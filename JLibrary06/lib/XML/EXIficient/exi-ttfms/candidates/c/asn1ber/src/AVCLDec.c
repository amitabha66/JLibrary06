/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 18-Oct-2006.
 */
#include "AVCL.h"
#include "rtxsrc/rtxCommon.h"

/**************************************************************/
/*                                                            */
/*  NonNegativeScalarType                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_NonNegativeScalarType (OSCTXT* pctxt, 
   NonNegativeScalarType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_real (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_NonNegativeScalarType (OSCTXT* pctxt, NonNegativeScalarType* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDouble (pctxt, pvalue, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AvclMessageType_transportStatus                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AvclMessageType_transportStatus (OSCTXT* pctxt, 
   AvclMessageType_transportStatus *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if(*pvalue < 0 || *pvalue > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   return (stat);
}

int XmlDec_AvclMessageType_transportStatus (OSCTXT* pctxt, 
   AvclMessageType_transportStatus* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = AvclMessageType_transportStatus_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MetaDataType                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_MetaDataType (OSCTXT* pctxt, MetaDataType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode content */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->content, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.contentPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_MetaDataType (OSCTXT* pctxt, MetaDataType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("content"), 7}, 0 },
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("name"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* content */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->content);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.contentPresent = TRUE;
            break;

         case 1: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 2: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "MetaDataType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "MetaDataType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PriorityType                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PriorityType (OSCTXT* pctxt, PriorityType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_uint8 (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_PriorityType (OSCTXT* pctxt, PriorityType* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecUInt8 (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PriorityElementType                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PriorityElementType (OSCTXT* pctxt, 
   PriorityElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PriorityType (pctxt, 
               &pvalue->value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PriorityElementType (OSCTXT* pctxt, PriorityElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 3: /* value */
            stat = XmlDec_PriorityType (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "PriorityElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "PriorityElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NonNegativeIntegerElementType                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_NonNegativeIntegerElementType (OSCTXT* pctxt, 
   NonNegativeIntegerElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_uint16 (pctxt, &pvalue->value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_NonNegativeIntegerElementType (OSCTXT* pctxt, 
   NonNegativeIntegerElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 3: /* value */
            stat = rtXmlpDecUInt16 (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "NonNegativeIntegerElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "NonNegativeIntegerElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AcknowledgeType                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AcknowledgeType (OSCTXT* pctxt, AcknowledgeType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if(*pvalue < 0 || *pvalue > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   return (stat);
}

int XmlDec_AcknowledgeType (OSCTXT* pctxt, AcknowledgeType* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = AcknowledgeType_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AcknowledgeElementType                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AcknowledgeElementType (OSCTXT* pctxt, 
   AcknowledgeElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AcknowledgeType (pctxt, 
               &pvalue->value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_AcknowledgeElementType (OSCTXT* pctxt, 
   AcknowledgeElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 3: /* value */
            stat = XmlDec_AcknowledgeType (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "AcknowledgeElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "AcknowledgeElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AvclMessageHeadType                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AvclMessageHeadType (OSCTXT* pctxt, 
   AvclMessageHeadType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode meta_list */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               MetaDataType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->meta_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, MetaDataType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_MetaDataType (pdata2);

                  stat = asn1D_MetaDataType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->meta_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode priority */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PriorityElementType (pctxt, 
               &pvalue->priority, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.priorityPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode sender */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeIntegerElementType (pctxt, 
               &pvalue->sender, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode recipient_list */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               NonNegativeIntegerElementType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->recipient_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, NonNegativeIntegerElementType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_NonNegativeIntegerElementType (pdata2);

                  stat = asn1D_NonNegativeIntegerElementType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->recipient_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode acknowledge */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AcknowledgeElementType (pctxt, 
               &pvalue->acknowledge, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.acknowledgePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_AvclMessageHeadType (OSCTXT* pctxt, AvclMessageHeadType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("meta"), 4}, 0}, 0 },
      {{{OSUTF8("Priority"), 8}, 0}, 1 },
      {{{OSUTF8("Sender"), 6}, 0}, 2 },
      {{{OSUTF8("Recipient"), 9}, 0}, 3 },
      {{{OSUTF8("Acknowledge"), 11}, 0}, 4 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}, {3, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 5; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         MetaDataType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, MetaDataType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MetaDataType (pdata1);

            stat = XmlDec_MetaDataType (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->meta_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 1: { /* Priority */
         stat = XmlDec_PriorityElementType (pctxt, &pvalue->priority);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.priorityPresent = TRUE;
         break;
      }
      case 2: { /* Sender */
         stat = XmlDec_NonNegativeIntegerElementType (pctxt, &pvalue->sender);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 3: {
         NonNegativeIntegerElementType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, NonNegativeIntegerElementType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NonNegativeIntegerElementType (pdata1);

            stat = XmlDec_NonNegativeIntegerElementType (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->recipient_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 3, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 3);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 4: { /* Acknowledge */
         stat = XmlDec_AcknowledgeElementType (pctxt, &pvalue->acknowledge);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.acknowledgePresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LatitudeType                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_LatitudeType (OSCTXT* pctxt, LatitudeType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_real (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_LatitudeType (OSCTXT* pctxt, LatitudeType* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDouble (pctxt, pvalue, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LongitudeType                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_LongitudeType (OSCTXT* pctxt, LongitudeType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_real (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_LongitudeType (OSCTXT* pctxt, LongitudeType* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDouble (pctxt, pvalue, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LatitudeLongitudeElementType                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_LatitudeLongitudeElementType (OSCTXT* pctxt, 
   LatitudeLongitudeElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode latitude */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_LatitudeType (pctxt, 
               &pvalue->latitude, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode longitude */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_LongitudeType (pctxt, 
               &pvalue->longitude, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_LatitudeLongitudeElementType (OSCTXT* pctxt, 
   LatitudeLongitudeElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("latitude"), 8}, 0 },
         { {OSUTF8("longitude"), 9}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* latitude */
            stat = XmlDec_LatitudeType (pctxt, &pvalue->latitude);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* longitude */
            stat = XmlDec_LongitudeType (pctxt, &pvalue->longitude);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "LatitudeLongitudeElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "LatitudeLongitudeElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositiveScalarType                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PositiveScalarType (OSCTXT* pctxt, 
   PositiveScalarType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_real (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_PositiveScalarType (OSCTXT* pctxt, PositiveScalarType* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDouble (pctxt, pvalue, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GeoOriginElementType                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_GeoOriginElementType (OSCTXT* pctxt, 
   GeoOriginElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode latitude */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_LatitudeType (pctxt, 
               &pvalue->latitude, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode longitude */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_LongitudeType (pctxt, 
               &pvalue->longitude, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode radiusOfInterest */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->radiusOfInterest, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.radiusOfInterestPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_GeoOriginElementType (OSCTXT* pctxt, GeoOriginElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("latitude"), 8}, 0 },
         { {OSUTF8("longitude"), 9}, 0 },
         { {OSUTF8("radiusOfInterest"), 16}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 6, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* latitude */
            stat = XmlDec_LatitudeType (pctxt, &pvalue->latitude);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* longitude */
            stat = XmlDec_LongitudeType (pctxt, &pvalue->longitude);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* radiusOfInterest */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->radiusOfInterest
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.radiusOfInterestPresent = TRUE;
            break;

         case 5: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "GeoOriginElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "GeoOriginElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LatitudeLongitudeElementType_derivations                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_LatitudeLongitudeElementType_derivations (OSCTXT* pctxt, 
   LatitudeLongitudeElementType_derivations *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.latitudeLongitudeElementType
             = rtxMemAllocType (pctxt, LatitudeLongitudeElementType);

         if (pvalue->u.latitudeLongitudeElementType == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_LatitudeLongitudeElementType (pvalue->u.latitudeLongitudeElementType);
         stat = asn1D_LatitudeLongitudeElementType (pctxt, 
            pvalue->u.latitudeLongitudeElementType, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.geoOriginElementType
             = rtxMemAllocType (pctxt, GeoOriginElementType);

         if (pvalue->u.geoOriginElementType == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_GeoOriginElementType (pvalue->u.geoOriginElementType);
         stat = asn1D_GeoOriginElementType (pctxt, 
            pvalue->u.geoOriginElementType, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_LatitudeLongitudeElementType_derivations (OSCTXT* pctxt, 
   LatitudeLongitudeElementType_derivations* pvalue)
{
   const OSUTF8CHAR* xsiType = 0;
   int stat = 0;

   /* decode xsi:type attribute */
   if (rtXmlpHasAttributes (pctxt)) {
      OSUINT32 i, nAttrs = 0;
      OSXMLNameFragments attrName;

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) == 0 &&
             rtXmlpDecXSITypeAttr (pctxt, &attrName, &xsiType) == 0) break;
      }
   }

   /* decode content */
   if (!OS_ISEMPTY (xsiType)) {
      xsiType = rtXmlDecQName (pctxt, xsiType, 0);
   }
   if (OS_ISEMPTY (xsiType)) {
      pvalue->t = 1;
      pvalue->u.latitudeLongitudeElementType
          = rtxMemAllocType (pctxt, LatitudeLongitudeElementType);

      if (pvalue->u.latitudeLongitudeElementType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_LatitudeLongitudeElementType (pvalue->
         u.latitudeLongitudeElementType);

      stat = XmlDec_LatitudeLongitudeElementType (pctxt, pvalue->
         u.latitudeLongitudeElementType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("LatitudeLongitudeElementType")))
   {
      pvalue->t = 1;
      pvalue->u.latitudeLongitudeElementType
          = rtxMemAllocType (pctxt, LatitudeLongitudeElementType);

      if (pvalue->u.latitudeLongitudeElementType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_LatitudeLongitudeElementType (pvalue->
         u.latitudeLongitudeElementType);

      stat = XmlDec_LatitudeLongitudeElementType (pctxt, pvalue->
         u.latitudeLongitudeElementType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("GeoOriginElementType")))
   {
      pvalue->t = 2;
      pvalue->u.geoOriginElementType
          = rtxMemAllocType (pctxt, GeoOriginElementType);

      if (pvalue->u.geoOriginElementType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_GeoOriginElementType (pvalue->u.geoOriginElementType);

      stat = XmlDec_GeoOriginElementType (pctxt, pvalue->u.geoOriginElementType
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  XyElementType                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_XyElementType (OSCTXT* pctxt, XyElementType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode x */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->x, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode y */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->y, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_XyElementType (OSCTXT* pctxt, XyElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("x"), 1}, 0 },
         { {OSUTF8("y"), 1}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 3: /* x */
            stat = rtXmlpDecDouble (pctxt, &pvalue->x, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* y */
            stat = rtXmlpDecDouble (pctxt, &pvalue->y, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "XyElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "XyElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PointListElements                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PointListElements (OSCTXT* pctxt, PointListElements *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.latitudeLongitude_list
             = rtxMemAllocType (pctxt, OSRTDList);

         if (pvalue->u.latitudeLongitude_list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         rtxDListFastInit (pvalue->u.latitudeLongitude_list);
         /* decode inline SEQUENCE OF type */
         {
            int stat = 0;
            LatitudeLongitudeElementType_derivations* pdata2;
            OSRTDListNode* pnode;
            ASN1CCB ccb;

            /* decode SEQUENCE OF or SET OF */

            rtxDListInit (pvalue->u.latitudeLongitude_list);

            ccb.len = length;
            ccb.ptr = OSRTBUFPTR(pctxt);

            while (!XD_CHKEND (pctxt, &ccb))
            {
               rtxDListAllocNodeAndData (pctxt, LatitudeLongitudeElementType_derivations, &pnode, &pdata2);

               if (pnode == NULL)
                  return LOG_RTERR (pctxt, RTERR_NOMEM);

               asn1Init_LatitudeLongitudeElementType_derivations (pdata2);

               stat = asn1D_LatitudeLongitudeElementType_derivations (pctxt, 
                  pdata2, ASN1EXPL, length);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               rtxDListAppendNode (pvalue->u.latitudeLongitude_list, pnode);
            }

            if (!(pvalue->u.latitudeLongitude_list->count >= 1U)) {
               rtxErrAddStrParm (pctxt, "PointListElements.u.latitudeLongitude_list.count");
               rtxErrAddIntParm (pctxt, (int)pvalue->u.latitudeLongitude_list->count);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

         }
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.xYPosition_list = rtxMemAllocType (pctxt, OSRTDList);

         if (pvalue->u.xYPosition_list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         rtxDListFastInit (pvalue->u.xYPosition_list);
         /* decode inline SEQUENCE OF type */
         {
            int stat = 0;
            XyElementType* pdata2;
            OSRTDListNode* pnode;
            ASN1CCB ccb;

            /* decode SEQUENCE OF or SET OF */

            rtxDListInit (pvalue->u.xYPosition_list);

            ccb.len = length;
            ccb.ptr = OSRTBUFPTR(pctxt);

            while (!XD_CHKEND (pctxt, &ccb))
            {
               rtxDListAllocNodeAndData (pctxt, XyElementType, &pnode, &pdata2);

               if (pnode == NULL)
                  return LOG_RTERR (pctxt, RTERR_NOMEM);

               asn1Init_XyElementType (pdata2);

               stat = asn1D_XyElementType (pctxt, 
                  pdata2, ASN1EXPL, length);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               rtxDListAppendNode (pvalue->u.xYPosition_list, pnode);
            }

            if (!(pvalue->u.xYPosition_list->count >= 1U)) {
               rtxErrAddStrParm (pctxt, "PointListElements.u.xYPosition_list.count");
               rtxErrAddIntParm (pctxt, (int)pvalue->u.xYPosition_list->count);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

         }
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_PointListElements (OSCTXT* pctxt, PointListElements* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("LatitudeLongitude"), 17}, 0}, 0 },
      {{{OSUTF8("XYPosition"), 10}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: {
      LatitudeLongitudeElementType_derivations* pdata1;

      pvalue->u.latitudeLongitude_list = rtxMemAllocType (pctxt, OSRTDList);
      rtxDListInit (pvalue->u.latitudeLongitude_list);

      do {
         pdata1
             = rtxMemAllocType (pctxt, LatitudeLongitudeElementType_derivations);

         if (pdata1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_LatitudeLongitudeElementType_derivations (pdata1);

         stat = XmlDec_LatitudeLongitudeElementType_derivations (pctxt, pdata1
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, pvalue->u.latitudeLongitude_list
            , (void*)pdata1);

         stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
         if (stat < 0 && stat != RTERR_UNEXPELEM)
            return LOG_RTERR (pctxt, stat);
      }
      while (stat == 0);

      rtXmlpMarkLastEventActive (pctxt);
      stat = 0;
      break;
   }
   case 1: {
      XyElementType* pdata1;

      pvalue->u.xYPosition_list = rtxMemAllocType (pctxt, OSRTDList);
      rtxDListInit (pvalue->u.xYPosition_list);

      do {
         pdata1 = rtxMemAllocType (pctxt, XyElementType);

         if (pdata1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_XyElementType (pdata1);

         stat = XmlDec_XyElementType (pctxt, pdata1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, pvalue->u.xYPosition_list, (void*)pdata1);

         stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 1, -1, FALSE);
         if (stat < 0 && stat != RTERR_UNEXPELEM)
            return LOG_RTERR (pctxt, stat);
      }
      while (stat == 1);

      rtXmlpMarkLastEventActive (pctxt);
      stat = 0;
      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  WaypointListType                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_WaypointListType (OSCTXT* pctxt, WaypointListType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PointListElements (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_WaypointListType (OSCTXT* pctxt, WaypointListType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "WaypointListType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "WaypointListType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("LatitudeLongitude"), 17}, 0}, 0 },
      {{{OSUTF8("XYPosition"), 10}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}, {2, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_PointListElements (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TurnDirectionType                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TurnDirectionType (OSCTXT* pctxt, TurnDirectionType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if(*pvalue < 0 || *pvalue > 3)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   return (stat);
}

int XmlDec_TurnDirectionType (OSCTXT* pctxt, TurnDirectionType* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = TurnDirectionType_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HeadingType                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_HeadingType (OSCTXT* pctxt, HeadingType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_real (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_HeadingType (OSCTXT* pctxt, HeadingType* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDouble (pctxt, pvalue, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositiveIntType                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PositiveIntType (OSCTXT* pctxt, PositiveIntType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_integer (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!(*pvalue >= 0)) {
      rtxErrAddStrParm (pctxt, "PositiveIntType");
      rtxErrAddIntParm (pctxt, *pvalue);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

int XmlDec_PositiveIntType (OSCTXT* pctxt, PositiveIntType* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecInt (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!(*pvalue >= 0)) {
      rtxErrAddStrParm (pctxt, "PositiveIntType");
      rtxErrAddIntParm (pctxt, *pvalue);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HorizontalPositionElements                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_HorizontalPositionElements (OSCTXT* pctxt, 
   HorizontalPositionElements *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.latitudeLongitude
             = rtxMemAllocType (pctxt, LatitudeLongitudeElementType_derivations);

         if (pvalue->u.latitudeLongitude == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_LatitudeLongitudeElementType_derivations (pvalue->u.latitudeLongitude);
         stat = asn1D_LatitudeLongitudeElementType_derivations (pctxt, 
            pvalue->u.latitudeLongitude, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.xYPosition = rtxMemAllocType (pctxt, XyElementType);

         if (pvalue->u.xYPosition == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_XyElementType (pvalue->u.xYPosition);
         stat = asn1D_XyElementType (pctxt, 
            pvalue->u.xYPosition, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.relativeXYPosition
             = rtxMemAllocType (pctxt, XyElementType);

         if (pvalue->u.relativeXYPosition == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_XyElementType (pvalue->u.relativeXYPosition);
         stat = asn1D_XyElementType (pctxt, 
            pvalue->u.relativeXYPosition, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_HorizontalPositionElements (OSCTXT* pctxt, 
   HorizontalPositionElements* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("LatitudeLongitude"), 17}, 0}, 0 },
      {{{OSUTF8("XYPosition"), 10}, 0}, 1 },
      {{{OSUTF8("RelativeXYPosition"), 18}, 0}, 2 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* LatitudeLongitude */
      pvalue->u.latitudeLongitude
          = rtxMemAllocType (pctxt, LatitudeLongitudeElementType_derivations);

      if (pvalue->u.latitudeLongitude == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_LatitudeLongitudeElementType_derivations (pvalue->
         u.latitudeLongitude);

      stat = XmlDec_LatitudeLongitudeElementType_derivations (pctxt, pvalue->
         u.latitudeLongitude);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* XYPosition */
      pvalue->u.xYPosition = rtxMemAllocType (pctxt, XyElementType);

      if (pvalue->u.xYPosition == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_XyElementType (pvalue->u.xYPosition);

      stat = XmlDec_XyElementType (pctxt, pvalue->u.xYPosition);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* RelativeXYPosition */
      pvalue->u.relativeXYPosition = rtxMemAllocType (pctxt, XyElementType);

      if (pvalue->u.relativeXYPosition == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_XyElementType (pvalue->u.relativeXYPosition);

      stat = XmlDec_XyElementType (pctxt, pvalue->u.relativeXYPosition);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HorizontalPositionElementType                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_HorizontalPositionElementType (OSCTXT* pctxt, 
   HorizontalPositionElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_HorizontalPositionElements (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_HorizontalPositionElementType (OSCTXT* pctxt, 
   HorizontalPositionElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "HorizontalPositionElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "HorizontalPositionElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("LatitudeLongitude"), 17}, 0}, 0 },
      {{{OSUTF8("XYPosition"), 10}, 0}, 0 },
      {{{OSUTF8("RelativeXYPosition"), 18}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}, {3, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_HorizontalPositionElements (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ParallelTrackType                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ParallelTrackType (OSCTXT* pctxt, ParallelTrackType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode firstTurn */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_TurnDirectionType (pctxt, 
               &pvalue->firstTurn, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode orientation */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_HeadingType (pctxt, 
               &pvalue->orientation, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode trackCount */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveIntType (pctxt, 
               &pvalue->trackCount, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode trackLength */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->trackLength, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode trackSpacing */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->trackSpacing, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 8:
         /* decode startPoint */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_HorizontalPositionElementType (pctxt, 
               &pvalue->startPoint, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|8):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 6) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_ParallelTrackType (OSCTXT* pctxt, ParallelTrackType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("firstTurn"), 9}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("orientation"), 11}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("trackCount"), 10}, 0 },
         { {OSUTF8("trackLength"), 11}, 0 },
         { {OSUTF8("trackSpacing"), 12}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 8, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* firstTurn */
            stat = XmlDec_TurnDirectionType (pctxt, &pvalue->firstTurn);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 3: /* orientation */
            stat = XmlDec_HeadingType (pctxt, &pvalue->orientation);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 5: /* trackCount */
            stat = XmlDec_PositiveIntType (pctxt, &pvalue->trackCount);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 6: /* trackLength */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->trackLength);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 7: /* trackSpacing */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->trackSpacing);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "ParallelTrackType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "ParallelTrackType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("StartPoint"), 10}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* StartPoint */
         stat = XmlDec_HorizontalPositionElementType (pctxt, &pvalue->
            startPoint);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SectorPatternType                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SectorPatternType (OSCTXT* pctxt, SectorPatternType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode firstTurn */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_TurnDirectionType (pctxt, 
               &pvalue->firstTurn, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode orientation */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_HeadingType (pctxt, 
               &pvalue->orientation, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode radius */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->radius, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode sectorCount */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveIntType (pctxt, 
               &pvalue->sectorCount, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode sectorSize */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->sectorSize, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode startPoint */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_HorizontalPositionElementType (pctxt, 
               &pvalue->startPoint, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|8):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 6) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SectorPatternType (OSCTXT* pctxt, SectorPatternType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("firstTurn"), 9}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("orientation"), 11}, 0 },
         { {OSUTF8("radius"), 6}, 0 },
         { {OSUTF8("sectorCount"), 11}, 0 },
         { {OSUTF8("sectorSize"), 10}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 8, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* firstTurn */
            stat = XmlDec_TurnDirectionType (pctxt, &pvalue->firstTurn);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 3: /* orientation */
            stat = XmlDec_HeadingType (pctxt, &pvalue->orientation);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* radius */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->radius);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* sectorCount */
            stat = XmlDec_PositiveIntType (pctxt, &pvalue->sectorCount);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 6: /* sectorSize */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->sectorSize);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 7: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SectorPatternType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SectorPatternType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("StartPoint"), 10}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* StartPoint */
         stat = XmlDec_HorizontalPositionElementType (pctxt, &pvalue->
            startPoint);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExpandingSquareType                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ExpandingSquareType (OSCTXT* pctxt, 
   ExpandingSquareType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode orientation */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_HeadingType (pctxt, 
               &pvalue->orientation, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode trackCount */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveIntType (pctxt, 
               &pvalue->trackCount, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode trackSpacing */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->trackSpacing, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode turnDirection */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_TurnDirectionType (pctxt, 
               &pvalue->turnDirection, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode startPoint */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_HorizontalPositionElementType (pctxt, 
               &pvalue->startPoint, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|7):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 5) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_ExpandingSquareType (OSCTXT* pctxt, ExpandingSquareType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("orientation"), 11}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("trackCount"), 10}, 0 },
         { {OSUTF8("trackSpacing"), 12}, 0 },
         { {OSUTF8("turnDirection"), 13}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 7, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* orientation */
            stat = XmlDec_HeadingType (pctxt, &pvalue->orientation);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 4: /* trackCount */
            stat = XmlDec_PositiveIntType (pctxt, &pvalue->trackCount);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* trackSpacing */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->trackSpacing);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 6: /* turnDirection */
            stat = XmlDec_TurnDirectionType (pctxt, &pvalue->turnDirection);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "ExpandingSquareType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "ExpandingSquareType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("StartPoint"), 10}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* StartPoint */
         stat = XmlDec_HorizontalPositionElementType (pctxt, &pvalue->
            startPoint);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CompositeWaypointElements                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CompositeWaypointElements (OSCTXT* pctxt, 
   CompositeWaypointElements *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.waypointList = rtxMemAllocType (pctxt, WaypointListType);

         if (pvalue->u.waypointList == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_WaypointListType (pvalue->u.waypointList);
         stat = asn1D_WaypointListType (pctxt, 
            pvalue->u.waypointList, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.parallelTrack = rtxMemAllocType (pctxt, ParallelTrackType);

         if (pvalue->u.parallelTrack == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ParallelTrackType (pvalue->u.parallelTrack);
         stat = asn1D_ParallelTrackType (pctxt, 
            pvalue->u.parallelTrack, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.sectorPattern = rtxMemAllocType (pctxt, SectorPatternType);

         if (pvalue->u.sectorPattern == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SectorPatternType (pvalue->u.sectorPattern);
         stat = asn1D_SectorPatternType (pctxt, 
            pvalue->u.sectorPattern, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.expandingSquare
             = rtxMemAllocType (pctxt, ExpandingSquareType);

         if (pvalue->u.expandingSquare == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ExpandingSquareType (pvalue->u.expandingSquare);
         stat = asn1D_ExpandingSquareType (pctxt, 
            pvalue->u.expandingSquare, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_CompositeWaypointElements (OSCTXT* pctxt, 
   CompositeWaypointElements* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("WaypointList"), 12}, 0}, 0 },
      {{{OSUTF8("ParallelTrack"), 13}, 0}, 1 },
      {{{OSUTF8("SectorPattern"), 13}, 0}, 2 },
      {{{OSUTF8("ExpandingSquare"), 15}, 0}, 3 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 4, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* WaypointList */
      pvalue->u.waypointList = rtxMemAllocType (pctxt, WaypointListType);

      if (pvalue->u.waypointList == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_WaypointListType (pvalue->u.waypointList);

      stat = XmlDec_WaypointListType (pctxt, pvalue->u.waypointList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* ParallelTrack */
      pvalue->u.parallelTrack = rtxMemAllocType (pctxt, ParallelTrackType);

      if (pvalue->u.parallelTrack == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ParallelTrackType (pvalue->u.parallelTrack);

      stat = XmlDec_ParallelTrackType (pctxt, pvalue->u.parallelTrack);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* SectorPattern */
      pvalue->u.sectorPattern = rtxMemAllocType (pctxt, SectorPatternType);

      if (pvalue->u.sectorPattern == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SectorPatternType (pvalue->u.sectorPattern);

      stat = XmlDec_SectorPatternType (pctxt, pvalue->u.sectorPattern);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* ExpandingSquare */
      pvalue->u.expandingSquare
          = rtxMemAllocType (pctxt, ExpandingSquareType);

      if (pvalue->u.expandingSquare == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ExpandingSquareType (pvalue->u.expandingSquare);

      stat = XmlDec_ExpandingSquareType (pctxt, pvalue->u.expandingSquare);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositiveScalarElementType                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PositiveScalarElementType (OSCTXT* pctxt, 
   PositiveScalarElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PositiveScalarElementType (OSCTXT* pctxt, 
   PositiveScalarElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 3: /* value */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "PositiveScalarElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "PositiveScalarElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SpeedElementType                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SpeedElementType (OSCTXT* pctxt, SpeedElementType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   pvalue->speedOverGround = FALSE;

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode speedOverGround */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->speedOverGround, ASN1IMPL, length);
            if (stat == 0) {
            }
         }
         break;

      case 3:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SpeedElementType (OSCTXT* pctxt, SpeedElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("speedOverGround"), 15}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* speedOverGround */
            stat = rtXmlpDecBool (pctxt, &pvalue->speedOverGround);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 4: /* value */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SpeedElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SpeedElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositiveScalarElementType_derivations                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PositiveScalarElementType_derivations (OSCTXT* pctxt, 
   PositiveScalarElementType_derivations *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.positiveScalarElementType
             = rtxMemAllocType (pctxt, PositiveScalarElementType);

         if (pvalue->u.positiveScalarElementType == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType (pvalue->u.positiveScalarElementType);
         stat = asn1D_PositiveScalarElementType (pctxt, 
            pvalue->u.positiveScalarElementType, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.speedElementType
             = rtxMemAllocType (pctxt, SpeedElementType);

         if (pvalue->u.speedElementType == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SpeedElementType (pvalue->u.speedElementType);
         stat = asn1D_SpeedElementType (pctxt, 
            pvalue->u.speedElementType, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_PositiveScalarElementType_derivations (OSCTXT* pctxt, 
   PositiveScalarElementType_derivations* pvalue)
{
   const OSUTF8CHAR* xsiType = 0;
   int stat = 0;

   /* decode xsi:type attribute */
   if (rtXmlpHasAttributes (pctxt)) {
      OSUINT32 i, nAttrs = 0;
      OSXMLNameFragments attrName;

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) == 0 &&
             rtXmlpDecXSITypeAttr (pctxt, &attrName, &xsiType) == 0) break;
      }
   }

   /* decode content */
   if (!OS_ISEMPTY (xsiType)) {
      xsiType = rtXmlDecQName (pctxt, xsiType, 0);
   }
   if (OS_ISEMPTY (xsiType)) {
      pvalue->t = 1;
      pvalue->u.positiveScalarElementType
          = rtxMemAllocType (pctxt, PositiveScalarElementType);

      if (pvalue->u.positiveScalarElementType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType (pvalue->u.positiveScalarElementType
         );

      stat = XmlDec_PositiveScalarElementType (pctxt, pvalue->
         u.positiveScalarElementType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("PositiveScalarElementType")))
   {
      pvalue->t = 1;
      pvalue->u.positiveScalarElementType
          = rtxMemAllocType (pctxt, PositiveScalarElementType);

      if (pvalue->u.positiveScalarElementType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType (pvalue->u.positiveScalarElementType
         );

      stat = XmlDec_PositiveScalarElementType (pctxt, pvalue->
         u.positiveScalarElementType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("SpeedElementType")))
   {
      pvalue->t = 2;
      pvalue->u.speedElementType = rtxMemAllocType (pctxt, SpeedElementType);

      if (pvalue->u.speedElementType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SpeedElementType (pvalue->u.speedElementType);

      stat = XmlDec_SpeedElementType (pctxt, pvalue->u.speedElementType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DepthTypeElements                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_DepthTypeElements (OSCTXT* pctxt, DepthTypeElements *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.depth
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.depth == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.depth);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.depth, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.altitude
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.altitude == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.altitude);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.altitude, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_DepthTypeElements (OSCTXT* pctxt, DepthTypeElements* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Depth"), 5}, 0}, 0 },
      {{{OSUTF8("Altitude"), 8}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* Depth */
      pvalue->u.depth
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.depth == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.depth);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.depth);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* Altitude */
      pvalue->u.altitude
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.altitude == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.altitude);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.altitude);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TrackModeType                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TrackModeType (OSCTXT* pctxt, TrackModeType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if(*pvalue < 0 || *pvalue > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   return (stat);
}

int XmlDec_TrackModeType (OSCTXT* pctxt, TrackModeType* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = TrackModeType_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TrackModeElementType                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TrackModeElementType (OSCTXT* pctxt, 
   TrackModeElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_TrackModeType (pctxt, 
               &pvalue->value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_TrackModeElementType (OSCTXT* pctxt, TrackModeElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 3: /* value */
            stat = XmlDec_TrackModeType (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "TrackModeElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "TrackModeElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SignedPercentType                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SignedPercentType (OSCTXT* pctxt, SignedPercentType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_real (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_SignedPercentType (OSCTXT* pctxt, SignedPercentType* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDouble (pctxt, pvalue, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SignedPercentElementType                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SignedPercentElementType (OSCTXT* pctxt, 
   SignedPercentElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SignedPercentType (pctxt, 
               &pvalue->value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SignedPercentElementType (OSCTXT* pctxt, 
   SignedPercentElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 3: /* value */
            stat = XmlDec_SignedPercentType (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SignedPercentElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SignedPercentElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SetPropellerCommandType_choice                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SetPropellerCommandType_choice (OSCTXT* pctxt, 
   SetPropellerCommandType_choice *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.portPropeller
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.portPropeller == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.portPropeller);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.portPropeller, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.starboardPropeller
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.starboardPropeller == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.starboardPropeller);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.starboardPropeller, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.centerlinePropeller
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.centerlinePropeller == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.centerlinePropeller);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.centerlinePropeller, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.allPropellers
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.allPropellers == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.allPropellers);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.allPropellers, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_SetPropellerCommandType_choice (OSCTXT* pctxt, 
   SetPropellerCommandType_choice* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("PortPropeller"), 13}, 0}, 0 },
      {{{OSUTF8("StarboardPropeller"), 18}, 0}, 1 },
      {{{OSUTF8("CenterlinePropeller"), 19}, 0}, 2 },
      {{{OSUTF8("AllPropellers"), 13}, 0}, 3 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 4, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* PortPropeller */
      pvalue->u.portPropeller
          = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.portPropeller == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.portPropeller);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->u.portPropeller);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* StarboardPropeller */
      pvalue->u.starboardPropeller
          = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.starboardPropeller == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.starboardPropeller);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->
         u.starboardPropeller);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* CenterlinePropeller */
      pvalue->u.centerlinePropeller
          = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.centerlinePropeller == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.centerlinePropeller);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->
         u.centerlinePropeller);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* AllPropellers */
      pvalue->u.allPropellers
          = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.allPropellers == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.allPropellers);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->u.allPropellers);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SetPropellerCommandType                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SetPropellerCommandType (OSCTXT* pctxt, 
   SetPropellerCommandType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SetPropellerCommandType_choice (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SetPropellerCommandType (OSCTXT* pctxt, 
   SetPropellerCommandType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SetPropellerCommandType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SetPropellerCommandType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("PortPropeller"), 13}, 0}, 0 },
      {{{OSUTF8("StarboardPropeller"), 18}, 0}, 0 },
      {{{OSUTF8("CenterlinePropeller"), 19}, 0}, 0 },
      {{{OSUTF8("AllPropellers"), 13}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}, {4, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_SetPropellerCommandType_choice (pctxt, &pvalue->choice
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UuvSpeedElements                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UuvSpeedElements (OSCTXT* pctxt, UuvSpeedElements *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.setPower
             = rtxMemAllocType (pctxt, SetPropellerCommandType);

         if (pvalue->u.setPower == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SetPropellerCommandType (pvalue->u.setPower);
         stat = asn1D_SetPropellerCommandType (pctxt, 
            pvalue->u.setPower, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.makeKnots = rtxMemAllocType (pctxt, SpeedElementType);

         if (pvalue->u.makeKnots == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SpeedElementType (pvalue->u.makeKnots);
         stat = asn1D_SpeedElementType (pctxt, 
            pvalue->u.makeKnots, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.makeSpeed = rtxMemAllocType (pctxt, SpeedElementType);

         if (pvalue->u.makeSpeed == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SpeedElementType (pvalue->u.makeSpeed);
         stat = asn1D_SpeedElementType (pctxt, 
            pvalue->u.makeSpeed, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_UuvSpeedElements (OSCTXT* pctxt, UuvSpeedElements* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("SetPower"), 8}, 0}, 0 },
      {{{OSUTF8("MakeKnots"), 9}, 0}, 1 },
      {{{OSUTF8("MakeSpeed"), 9}, 0}, 2 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* SetPower */
      pvalue->u.setPower = rtxMemAllocType (pctxt, SetPropellerCommandType);

      if (pvalue->u.setPower == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SetPropellerCommandType (pvalue->u.setPower);

      stat = XmlDec_SetPropellerCommandType (pctxt, pvalue->u.setPower);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* MakeKnots */
      pvalue->u.makeKnots = rtxMemAllocType (pctxt, SpeedElementType);

      if (pvalue->u.makeKnots == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SpeedElementType (pvalue->u.makeKnots);

      stat = XmlDec_SpeedElementType (pctxt, pvalue->u.makeKnots);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* MakeSpeed */
      pvalue->u.makeSpeed = rtxMemAllocType (pctxt, SpeedElementType);

      if (pvalue->u.makeSpeed == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SpeedElementType (pvalue->u.makeSpeed);

      stat = XmlDec_SpeedElementType (pctxt, pvalue->u.makeSpeed);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PositiveIntegerElementType                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PositiveIntegerElementType (OSCTXT* pctxt, 
   PositiveIntegerElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveIntType (pctxt, 
               &pvalue->value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PositiveIntegerElementType (OSCTXT* pctxt, 
   PositiveIntegerElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 3: /* value */
            stat = XmlDec_PositiveIntType (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "PositiveIntegerElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "PositiveIntegerElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UuvCompositeWaypointCommandType                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UuvCompositeWaypointCommandType (OSCTXT* pctxt, 
   UuvCompositeWaypointCommandType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CompositeWaypointElements (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode choice_1 */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_DepthTypeElements (pctxt, 
               &pvalue->choice_1, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode homingMode */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_TrackModeElementType (pctxt, 
               &pvalue->homingMode, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.homingModePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode choice_2 */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_UuvSpeedElements (pctxt, 
               &pvalue->choice_2, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choice_2Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode gpsFixes */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveIntegerElementType (pctxt, 
               &pvalue->gpsFixes, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.gpsFixesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode standoff */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->standoff, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.standoffPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode timeOut */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->timeOut, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeOutPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UuvCompositeWaypointCommandType (OSCTXT* pctxt, 
   UuvCompositeWaypointCommandType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UuvCompositeWaypointCommandType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UuvCompositeWaypointCommandType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("WaypointList"), 12}, 0}, 0 },
      {{{OSUTF8("ParallelTrack"), 13}, 0}, 0 },
      {{{OSUTF8("SectorPattern"), 13}, 0}, 0 },
      {{{OSUTF8("ExpandingSquare"), 15}, 0}, 0 },
      {{{OSUTF8("Depth"), 5}, 0}, 1 },
      {{{OSUTF8("Altitude"), 8}, 0}, 1 },
      {{{OSUTF8("HomingMode"), 10}, 0}, 2 },
      {{{OSUTF8("SetPower"), 8}, 0}, 3 },
      {{{OSUTF8("MakeKnots"), 9}, 0}, 3 },
      {{{OSUTF8("MakeSpeed"), 9}, 0}, 3 },
      {{{OSUTF8("GpsFixes"), 8}, 0}, 4 },
      {{{OSUTF8("Standoff"), 8}, 0}, 5 },
      {{{OSUTF8("TimeOut"), 7}, 0}, 6 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}, {4, 2, -1}, {6, 7, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 7; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_CompositeWaypointElements (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_DepthTypeElements (pctxt, &pvalue->choice_1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 2: { /* HomingMode */
         stat = XmlDec_TrackModeElementType (pctxt, &pvalue->homingMode);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.homingModePresent = TRUE;
         break;
      }
      case 3: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_UuvSpeedElements (pctxt, &pvalue->choice_2);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choice_2Present = TRUE;
         break;
      }
      case 4: { /* GpsFixes */
         stat = XmlDec_PositiveIntegerElementType (pctxt, &pvalue->gpsFixes);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.gpsFixesPresent = TRUE;
         break;
      }
      case 5: { /* Standoff */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            standoff);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.standoffPresent = TRUE;
         break;
      }
      case 6: { /* TimeOut */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            timeOut);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.timeOutPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  StringElementType                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_StringElementType (OSCTXT* pctxt, StringElementType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_StringElementType (OSCTXT* pctxt, StringElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 3: /* value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "StringElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "StringElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FollowBeaconCommandType                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_FollowBeaconCommandType (OSCTXT* pctxt, 
   FollowBeaconCommandType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode beacon */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_StringElementType (pctxt, 
               &pvalue->beacon, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.beaconPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode timeOut */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->timeOut, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeOutPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_FollowBeaconCommandType (OSCTXT* pctxt, 
   FollowBeaconCommandType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "FollowBeaconCommandType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "FollowBeaconCommandType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Beacon"), 6}, 0}, 0 },
      {{{OSUTF8("TimeOut"), 7}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* Beacon */
         stat = XmlDec_StringElementType (pctxt, &pvalue->beacon);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.beaconPresent = TRUE;
         break;
      }
      case 1: { /* TimeOut */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            timeOut);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.timeOutPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GpsFixCommandType                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_GpsFixCommandType (OSCTXT* pctxt, GpsFixCommandType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeOut */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->timeOut, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeOutPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_GpsFixCommandType (OSCTXT* pctxt, GpsFixCommandType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeOut"), 7}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeOut */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->timeOut);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeOutPresent = TRUE;
            break;

         case 3: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 4: /* value */
            stat = rtXmlpDecBool (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "GpsFixCommandType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "GpsFixCommandType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NoValueElementType                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_NoValueElementType (OSCTXT* pctxt, 
   NoValueElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_NoValueElementType (OSCTXT* pctxt, NoValueElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "NoValueElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "NoValueElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HeadingElementType                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_HeadingElementType (OSCTXT* pctxt, 
   HeadingElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_HeadingType (pctxt, 
               &pvalue->value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_HeadingElementType (OSCTXT* pctxt, HeadingElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 3: /* value */
            stat = XmlDec_HeadingType (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "HeadingElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "HeadingElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BooleanElementType                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_BooleanElementType (OSCTXT* pctxt, 
   BooleanElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_BooleanElementType (OSCTXT* pctxt, BooleanElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 3: /* value */
            stat = rtXmlpDecBool (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "BooleanElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "BooleanElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BooleanElementType_derivations                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_BooleanElementType_derivations (OSCTXT* pctxt, 
   BooleanElementType_derivations *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.booleanElementType
             = rtxMemAllocType (pctxt, BooleanElementType);

         if (pvalue->u.booleanElementType == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_BooleanElementType (pvalue->u.booleanElementType);
         stat = asn1D_BooleanElementType (pctxt, 
            pvalue->u.booleanElementType, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.gpsFixCommandType
             = rtxMemAllocType (pctxt, GpsFixCommandType);

         if (pvalue->u.gpsFixCommandType == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_GpsFixCommandType (pvalue->u.gpsFixCommandType);
         stat = asn1D_GpsFixCommandType (pctxt, 
            pvalue->u.gpsFixCommandType, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_BooleanElementType_derivations (OSCTXT* pctxt, 
   BooleanElementType_derivations* pvalue)
{
   const OSUTF8CHAR* xsiType = 0;
   int stat = 0;

   /* decode xsi:type attribute */
   if (rtXmlpHasAttributes (pctxt)) {
      OSUINT32 i, nAttrs = 0;
      OSXMLNameFragments attrName;

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) == 0 &&
             rtXmlpDecXSITypeAttr (pctxt, &attrName, &xsiType) == 0) break;
      }
   }

   /* decode content */
   if (!OS_ISEMPTY (xsiType)) {
      xsiType = rtXmlDecQName (pctxt, xsiType, 0);
   }
   if (OS_ISEMPTY (xsiType)) {
      pvalue->t = 1;
      pvalue->u.booleanElementType
          = rtxMemAllocType (pctxt, BooleanElementType);

      if (pvalue->u.booleanElementType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BooleanElementType (pvalue->u.booleanElementType);

      stat = XmlDec_BooleanElementType (pctxt, pvalue->u.booleanElementType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("BooleanElementType")))
   {
      pvalue->t = 1;
      pvalue->u.booleanElementType
          = rtxMemAllocType (pctxt, BooleanElementType);

      if (pvalue->u.booleanElementType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BooleanElementType (pvalue->u.booleanElementType);

      stat = XmlDec_BooleanElementType (pctxt, pvalue->u.booleanElementType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("GpsFixCommandType")))
   {
      pvalue->t = 2;
      pvalue->u.gpsFixCommandType
          = rtxMemAllocType (pctxt, GpsFixCommandType);

      if (pvalue->u.gpsFixCommandType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_GpsFixCommandType (pvalue->u.gpsFixCommandType);

      stat = XmlDec_GpsFixCommandType (pctxt, pvalue->u.gpsFixCommandType);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HoverCommandType                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_HoverCommandType (OSCTXT* pctxt, HoverCommandType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_HorizontalPositionElements (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choicePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode choice_1 */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_DepthTypeElements (pctxt, 
               &pvalue->choice_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choice_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode heading */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_HeadingElementType (pctxt, 
               &pvalue->heading, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.headingPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode obtainGps */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_BooleanElementType_derivations (pctxt, 
               &pvalue->obtainGps, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.obtainGpsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode standoff */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->standoff, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.standoffPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode timeOut */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->timeOut, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeOutPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_HoverCommandType (OSCTXT* pctxt, HoverCommandType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "HoverCommandType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "HoverCommandType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("LatitudeLongitude"), 17}, 0}, 0 },
      {{{OSUTF8("XYPosition"), 10}, 0}, 0 },
      {{{OSUTF8("RelativeXYPosition"), 18}, 0}, 0 },
      {{{OSUTF8("Depth"), 5}, 0}, 1 },
      {{{OSUTF8("Altitude"), 8}, 0}, 1 },
      {{{OSUTF8("Heading"), 7}, 0}, 2 },
      {{{OSUTF8("ObtainGps"), 9}, 0}, 3 },
      {{{OSUTF8("Standoff"), 8}, 0}, 4 },
      {{{OSUTF8("TimeOut"), 7}, 0}, 5 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 9, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 6; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_HorizontalPositionElements (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choicePresent = TRUE;
         break;
      }
      case 1: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_DepthTypeElements (pctxt, &pvalue->choice_1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choice_1Present = TRUE;
         break;
      }
      case 2: { /* Heading */
         stat = XmlDec_HeadingElementType (pctxt, &pvalue->heading);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.headingPresent = TRUE;
         break;
      }
      case 3: { /* ObtainGps */
         stat = XmlDec_BooleanElementType_derivations (pctxt, &pvalue->
            obtainGps);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.obtainGpsPresent = TRUE;
         break;
      }
      case 4: { /* Standoff */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            standoff);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.standoffPresent = TRUE;
         break;
      }
      case 5: { /* TimeOut */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            timeOut);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.timeOutPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UuvLoiterCommandType                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UuvLoiterCommandType (OSCTXT* pctxt, 
   UuvLoiterCommandType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_HorizontalPositionElements (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choicePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode choice_1 */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_DepthTypeElements (pctxt, 
               &pvalue->choice_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choice_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode choice_2 */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_UuvSpeedElements (pctxt, 
               &pvalue->choice_2, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choice_2Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode loiterDepth */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->loiterDepth, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode timeOut */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->timeOut, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeOutPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UuvLoiterCommandType (OSCTXT* pctxt, UuvLoiterCommandType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UuvLoiterCommandType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UuvLoiterCommandType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("LatitudeLongitude"), 17}, 0}, 0 },
      {{{OSUTF8("XYPosition"), 10}, 0}, 0 },
      {{{OSUTF8("RelativeXYPosition"), 18}, 0}, 0 },
      {{{OSUTF8("Depth"), 5}, 0}, 1 },
      {{{OSUTF8("Altitude"), 8}, 0}, 1 },
      {{{OSUTF8("SetPower"), 8}, 0}, 2 },
      {{{OSUTF8("MakeKnots"), 9}, 0}, 2 },
      {{{OSUTF8("MakeSpeed"), 9}, 0}, 2 },
      {{{OSUTF8("LoiterDepth"), 11}, 0}, 3 },
      {{{OSUTF8("TimeOut"), 7}, 0}, 4 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 9, -1}, {9, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 5; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_HorizontalPositionElements (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choicePresent = TRUE;
         break;
      }
      case 1: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_DepthTypeElements (pctxt, &pvalue->choice_1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choice_1Present = TRUE;
         break;
      }
      case 2: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_UuvSpeedElements (pctxt, &pvalue->choice_2);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choice_2Present = TRUE;
         break;
      }
      case 3: { /* LoiterDepth */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            loiterDepth);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 4: { /* TimeOut */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            timeOut);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.timeOutPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ExitModeElements                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ExitModeElements (OSCTXT* pctxt, ExitModeElements *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.normalExit = rtxMemAllocType (pctxt, NoValueElementType);

         if (pvalue->u.normalExit == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NoValueElementType (pvalue->u.normalExit);
         stat = asn1D_NoValueElementType (pctxt, 
            pvalue->u.normalExit, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.missionAbort = rtxMemAllocType (pctxt, NoValueElementType);

         if (pvalue->u.missionAbort == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NoValueElementType (pvalue->u.missionAbort);
         stat = asn1D_NoValueElementType (pctxt, 
            pvalue->u.missionAbort, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.systemAbort = rtxMemAllocType (pctxt, NoValueElementType);

         if (pvalue->u.systemAbort == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NoValueElementType (pvalue->u.systemAbort);
         stat = asn1D_NoValueElementType (pctxt, 
            pvalue->u.systemAbort, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.recallAbort = rtxMemAllocType (pctxt, NoValueElementType);

         if (pvalue->u.recallAbort == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NoValueElementType (pvalue->u.recallAbort);
         stat = asn1D_NoValueElementType (pctxt, 
            pvalue->u.recallAbort, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_ExitModeElements (OSCTXT* pctxt, ExitModeElements* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("NormalExit"), 10}, 0}, 0 },
      {{{OSUTF8("MissionAbort"), 12}, 0}, 1 },
      {{{OSUTF8("SystemAbort"), 11}, 0}, 2 },
      {{{OSUTF8("RecallAbort"), 11}, 0}, 3 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 4, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* NormalExit */
      pvalue->u.normalExit = rtxMemAllocType (pctxt, NoValueElementType);

      if (pvalue->u.normalExit == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NoValueElementType (pvalue->u.normalExit);

      stat = XmlDec_NoValueElementType (pctxt, pvalue->u.normalExit);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* MissionAbort */
      pvalue->u.missionAbort = rtxMemAllocType (pctxt, NoValueElementType);

      if (pvalue->u.missionAbort == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NoValueElementType (pvalue->u.missionAbort);

      stat = XmlDec_NoValueElementType (pctxt, pvalue->u.missionAbort);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* SystemAbort */
      pvalue->u.systemAbort = rtxMemAllocType (pctxt, NoValueElementType);

      if (pvalue->u.systemAbort == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NoValueElementType (pvalue->u.systemAbort);

      stat = XmlDec_NoValueElementType (pctxt, pvalue->u.systemAbort);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* RecallAbort */
      pvalue->u.recallAbort = rtxMemAllocType (pctxt, NoValueElementType);

      if (pvalue->u.recallAbort == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NoValueElementType (pvalue->u.recallAbort);

      stat = XmlDec_NoValueElementType (pctxt, pvalue->u.recallAbort);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuitCommandType                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_QuitCommandType (OSCTXT* pctxt, QuitCommandType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_ExitModeElements (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choicePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_QuitCommandType (OSCTXT* pctxt, QuitCommandType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "QuitCommandType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "QuitCommandType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("NormalExit"), 10}, 0}, 0 },
      {{{OSUTF8("MissionAbort"), 12}, 0}, 0 },
      {{{OSUTF8("SystemAbort"), 11}, 0}, 0 },
      {{{OSUTF8("RecallAbort"), 11}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_ExitModeElements (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choicePresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ScalarElementType                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ScalarElementType (OSCTXT* pctxt, ScalarElementType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_ScalarElementType (OSCTXT* pctxt, ScalarElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 3: /* value */
            stat = rtXmlpDecDouble (pctxt, &pvalue->value, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "ScalarElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "ScalarElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RecoverCommandType                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_RecoverCommandType (OSCTXT* pctxt, 
   RecoverCommandType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode range */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_ScalarElementType (pctxt, 
               &pvalue->range, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode heading */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_HeadingElementType (pctxt, 
               &pvalue->heading, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode timeOut */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->timeOut, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeOutPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_RecoverCommandType (OSCTXT* pctxt, RecoverCommandType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "RecoverCommandType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "RecoverCommandType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Range"), 5}, 0}, 0 },
      {{{OSUTF8("Heading"), 7}, 0}, 1 },
      {{{OSUTF8("TimeOut"), 7}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 1, -1}, {2, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* Range */
         stat = XmlDec_ScalarElementType (pctxt, &pvalue->range);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* Heading */
         stat = XmlDec_HeadingElementType (pctxt, &pvalue->heading);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 2: { /* TimeOut */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            timeOut);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.timeOutPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SendMessageCommandType_choice                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SendMessageCommandType_choice (OSCTXT* pctxt, 
   SendMessageCommandType_choice *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.aVCLMessage = rtxMemAllocType (pctxt, AvclMessageType);

         if (pvalue->u.aVCLMessage == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AvclMessageType ((AvclMessageType*)pvalue->u.aVCLMessage);
         stat = asn1D_AvclMessageType (pctxt, 
            (AvclMessageType*)pvalue->u.aVCLMessage, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_SendMessageCommandType_choice (OSCTXT* pctxt, 
   SendMessageCommandType_choice* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("AVCLMessage"), 11}, 0}, 0 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 1, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* AVCLMessage */
      pvalue->u.aVCLMessage = rtxMemAllocType (pctxt, AvclMessageType);

      if (pvalue->u.aVCLMessage == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AvclMessageType ((AvclMessageType*)pvalue->u.aVCLMessage);

      stat = XmlDec_AvclMessageType (pctxt, pvalue->u.aVCLMessage);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SendMessageCommandType                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SendMessageCommandType (OSCTXT* pctxt, 
   SendMessageCommandType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SendMessageCommandType_choice (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SendMessageCommandType (OSCTXT* pctxt, 
   SendMessageCommandType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SendMessageCommandType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SendMessageCommandType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("AVCLMessage"), 11}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_SendMessageCommandType_choice (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SetPlanesCommandType_choice                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SetPlanesCommandType_choice (OSCTXT* pctxt, 
   SetPlanesCommandType_choice *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.bowPlanes
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.bowPlanes == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.bowPlanes);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.bowPlanes, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.sternPlanes
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.sternPlanes == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.sternPlanes);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.sternPlanes, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.allPlanes
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.allPlanes == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.allPlanes);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.allPlanes, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_SetPlanesCommandType_choice (OSCTXT* pctxt, 
   SetPlanesCommandType_choice* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("BowPlanes"), 9}, 0}, 0 },
      {{{OSUTF8("SternPlanes"), 11}, 0}, 1 },
      {{{OSUTF8("AllPlanes"), 9}, 0}, 2 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* BowPlanes */
      pvalue->u.bowPlanes = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.bowPlanes == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.bowPlanes);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->u.bowPlanes);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* SternPlanes */
      pvalue->u.sternPlanes
          = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.sternPlanes == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.sternPlanes);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->u.sternPlanes);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* AllPlanes */
      pvalue->u.allPlanes = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.allPlanes == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.allPlanes);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->u.allPlanes);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SetPlanesCommandType                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SetPlanesCommandType (OSCTXT* pctxt, 
   SetPlanesCommandType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SetPlanesCommandType_choice (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SetPlanesCommandType (OSCTXT* pctxt, SetPlanesCommandType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SetPlanesCommandType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SetPlanesCommandType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("BowPlanes"), 9}, 0}, 0 },
      {{{OSUTF8("SternPlanes"), 11}, 0}, 0 },
      {{{OSUTF8("AllPlanes"), 9}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}, {3, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /*  */
         stat = XmlDec_SetPlanesCommandType_choice (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AbsoluteHorizontalPositionElements                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AbsoluteHorizontalPositionElements (OSCTXT* pctxt, 
   AbsoluteHorizontalPositionElements *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.latitudeLongitude
             = rtxMemAllocType (pctxt, LatitudeLongitudeElementType_derivations);

         if (pvalue->u.latitudeLongitude == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_LatitudeLongitudeElementType_derivations (pvalue->u.latitudeLongitude);
         stat = asn1D_LatitudeLongitudeElementType_derivations (pctxt, 
            pvalue->u.latitudeLongitude, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.xYPosition = rtxMemAllocType (pctxt, XyElementType);

         if (pvalue->u.xYPosition == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_XyElementType (pvalue->u.xYPosition);
         stat = asn1D_XyElementType (pctxt, 
            pvalue->u.xYPosition, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_AbsoluteHorizontalPositionElements (OSCTXT* pctxt, 
   AbsoluteHorizontalPositionElements* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("LatitudeLongitude"), 17}, 0}, 0 },
      {{{OSUTF8("XYPosition"), 10}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* LatitudeLongitude */
      pvalue->u.latitudeLongitude
          = rtxMemAllocType (pctxt, LatitudeLongitudeElementType_derivations);

      if (pvalue->u.latitudeLongitude == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_LatitudeLongitudeElementType_derivations (pvalue->
         u.latitudeLongitude);

      stat = XmlDec_LatitudeLongitudeElementType_derivations (pctxt, pvalue->
         u.latitudeLongitude);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* XYPosition */
      pvalue->u.xYPosition = rtxMemAllocType (pctxt, XyElementType);

      if (pvalue->u.xYPosition == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_XyElementType (pvalue->u.xYPosition);

      stat = XmlDec_XyElementType (pctxt, pvalue->u.xYPosition);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UuvPositionCommandType                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UuvPositionCommandType (OSCTXT* pctxt, 
   UuvPositionCommandType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AbsoluteHorizontalPositionElements (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode depth */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->depth, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.depthPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UuvPositionCommandType (OSCTXT* pctxt, 
   UuvPositionCommandType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UuvPositionCommandType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UuvPositionCommandType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("LatitudeLongitude"), 17}, 0}, 0 },
      {{{OSUTF8("XYPosition"), 10}, 0}, 0 },
      {{{OSUTF8("Depth"), 5}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}, {2, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_AbsoluteHorizontalPositionElements (pctxt, &pvalue->
            choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* Depth */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            depth);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.depthPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SetSonarCommandType_choice                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SetSonarCommandType_choice (OSCTXT* pctxt, 
   SetSonarCommandType_choice *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.manual = rtxMemAllocType (pctxt, NoValueElementType);

         if (pvalue->u.manual == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NoValueElementType (pvalue->u.manual);
         stat = asn1D_NoValueElementType (pctxt, 
            pvalue->u.manual, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.scan = rtxMemAllocType (pctxt, NoValueElementType);

         if (pvalue->u.scan == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NoValueElementType (pvalue->u.scan);
         stat = asn1D_NoValueElementType (pctxt, 
            pvalue->u.scan, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.track = rtxMemAllocType (pctxt, NoValueElementType);

         if (pvalue->u.track == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NoValueElementType (pvalue->u.track);
         stat = asn1D_NoValueElementType (pctxt, 
            pvalue->u.track, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_SetSonarCommandType_choice (OSCTXT* pctxt, 
   SetSonarCommandType_choice* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Manual"), 6}, 0}, 0 },
      {{{OSUTF8("Scan"), 4}, 0}, 1 },
      {{{OSUTF8("Track"), 5}, 0}, 2 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* Manual */
      pvalue->u.manual = rtxMemAllocType (pctxt, NoValueElementType);

      if (pvalue->u.manual == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NoValueElementType (pvalue->u.manual);

      stat = XmlDec_NoValueElementType (pctxt, pvalue->u.manual);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* Scan */
      pvalue->u.scan = rtxMemAllocType (pctxt, NoValueElementType);

      if (pvalue->u.scan == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NoValueElementType (pvalue->u.scan);

      stat = XmlDec_NoValueElementType (pctxt, pvalue->u.scan);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* Track */
      pvalue->u.track = rtxMemAllocType (pctxt, NoValueElementType);

      if (pvalue->u.track == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NoValueElementType (pvalue->u.track);

      stat = XmlDec_NoValueElementType (pctxt, pvalue->u.track);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BearingTypeElements                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_BearingTypeElements (OSCTXT* pctxt, 
   BearingTypeElements *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.relative = rtxMemAllocType (pctxt, NoValueElementType);

         if (pvalue->u.relative == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NoValueElementType (pvalue->u.relative);
         stat = asn1D_NoValueElementType (pctxt, 
            pvalue->u.relative, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.true_ = rtxMemAllocType (pctxt, NoValueElementType);

         if (pvalue->u.true_ == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NoValueElementType (pvalue->u.true_);
         stat = asn1D_NoValueElementType (pctxt, 
            pvalue->u.true_, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.magnetic = rtxMemAllocType (pctxt, NoValueElementType);

         if (pvalue->u.magnetic == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NoValueElementType (pvalue->u.magnetic);
         stat = asn1D_NoValueElementType (pctxt, 
            pvalue->u.magnetic, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_BearingTypeElements (OSCTXT* pctxt, BearingTypeElements* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Relative"), 8}, 0}, 0 },
      {{{OSUTF8("True"), 4}, 0}, 1 },
      {{{OSUTF8("Magnetic"), 8}, 0}, 2 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* Relative */
      pvalue->u.relative = rtxMemAllocType (pctxt, NoValueElementType);

      if (pvalue->u.relative == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NoValueElementType (pvalue->u.relative);

      stat = XmlDec_NoValueElementType (pctxt, pvalue->u.relative);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* True */
      pvalue->u.true_ = rtxMemAllocType (pctxt, NoValueElementType);

      if (pvalue->u.true_ == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NoValueElementType (pvalue->u.true_);

      stat = XmlDec_NoValueElementType (pctxt, pvalue->u.true_);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* Magnetic */
      pvalue->u.magnetic = rtxMemAllocType (pctxt, NoValueElementType);

      if (pvalue->u.magnetic == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NoValueElementType (pvalue->u.magnetic);

      stat = XmlDec_NoValueElementType (pctxt, pvalue->u.magnetic);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SetSonarCommandType                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SetSonarCommandType (OSCTXT* pctxt, 
   SetSonarCommandType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode model */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_StringElementType (pctxt, 
               &pvalue->model, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SetSonarCommandType_choice (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode bearing */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_ScalarElementType (pctxt, 
               &pvalue->bearing, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bearingPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode elevation */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_ScalarElementType (pctxt, 
               &pvalue->elevation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.elevationPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode choice_1 */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_BearingTypeElements (pctxt, 
               &pvalue->choice_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choice_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SetSonarCommandType (OSCTXT* pctxt, SetSonarCommandType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SetSonarCommandType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SetSonarCommandType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Model"), 5}, 0}, 0 },
      {{{OSUTF8("Manual"), 6}, 0}, 1 },
      {{{OSUTF8("Scan"), 4}, 0}, 1 },
      {{{OSUTF8("Track"), 5}, 0}, 1 },
      {{{OSUTF8("Bearing"), 7}, 0}, 2 },
      {{{OSUTF8("Elevation"), 9}, 0}, 3 },
      {{{OSUTF8("Relative"), 8}, 0}, 4 },
      {{{OSUTF8("True"), 4}, 0}, 4 },
      {{{OSUTF8("Magnetic"), 8}, 0}, 4 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 3, -1}, {4, 5, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 5; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* Model */
         stat = XmlDec_StringElementType (pctxt, &pvalue->model);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /*  */
         stat = XmlDec_SetSonarCommandType_choice (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 2: { /* Bearing */
         stat = XmlDec_ScalarElementType (pctxt, &pvalue->bearing);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.bearingPresent = TRUE;
         break;
      }
      case 3: { /* Elevation */
         stat = XmlDec_ScalarElementType (pctxt, &pvalue->elevation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.elevationPresent = TRUE;
         break;
      }
      case 4: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_BearingTypeElements (pctxt, &pvalue->choice_1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choice_1Present = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SetThrusterCommandType_choice                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SetThrusterCommandType_choice (OSCTXT* pctxt, 
   SetThrusterCommandType_choice *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.bowLateralThruster
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.bowLateralThruster == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.bowLateralThruster);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.bowLateralThruster, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.sternLateralThruster
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.sternLateralThruster == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.sternLateralThruster);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.sternLateralThruster, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.lateralThrusters
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.lateralThrusters == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.lateralThrusters);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.lateralThrusters, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.bowVerticalThruster
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.bowVerticalThruster == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.bowVerticalThruster);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.bowVerticalThruster, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.sternVerticalThruster
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.sternVerticalThruster == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.sternVerticalThruster);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.sternVerticalThruster, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.verticalThrusters
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.verticalThrusters == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.verticalThrusters);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.verticalThrusters, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_SetThrusterCommandType_choice (OSCTXT* pctxt, 
   SetThrusterCommandType_choice* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("BowLateralThruster"), 18}, 0}, 0 },
      {{{OSUTF8("SternLateralThruster"), 20}, 0}, 1 },
      {{{OSUTF8("LateralThrusters"), 16}, 0}, 2 },
      {{{OSUTF8("BowVerticalThruster"), 19}, 0}, 3 },
      {{{OSUTF8("SternVerticalThruster"), 21}, 0}, 4 },
      {{{OSUTF8("VerticalThrusters"), 17}, 0}, 5 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 6, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* BowLateralThruster */
      pvalue->u.bowLateralThruster
          = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.bowLateralThruster == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.bowLateralThruster);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->
         u.bowLateralThruster);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* SternLateralThruster */
      pvalue->u.sternLateralThruster
          = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.sternLateralThruster == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.sternLateralThruster);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->
         u.sternLateralThruster);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* LateralThrusters */
      pvalue->u.lateralThrusters
          = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.lateralThrusters == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.lateralThrusters);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->u.lateralThrusters
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* BowVerticalThruster */
      pvalue->u.bowVerticalThruster
          = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.bowVerticalThruster == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.bowVerticalThruster);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->
         u.bowVerticalThruster);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* SternVerticalThruster */
      pvalue->u.sternVerticalThruster
          = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.sternVerticalThruster == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.sternVerticalThruster);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->
         u.sternVerticalThruster);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* VerticalThrusters */
      pvalue->u.verticalThrusters
          = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.verticalThrusters == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.verticalThrusters);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->
         u.verticalThrusters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SetThrusterCommandType                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SetThrusterCommandType (OSCTXT* pctxt, 
   SetThrusterCommandType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SetThrusterCommandType_choice (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SetThrusterCommandType (OSCTXT* pctxt, 
   SetThrusterCommandType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SetThrusterCommandType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SetThrusterCommandType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("BowLateralThruster"), 18}, 0}, 0 },
      {{{OSUTF8("SternLateralThruster"), 20}, 0}, 0 },
      {{{OSUTF8("LateralThrusters"), 16}, 0}, 0 },
      {{{OSUTF8("BowVerticalThruster"), 19}, 0}, 0 },
      {{{OSUTF8("SternVerticalThruster"), 21}, 0}, 0 },
      {{{OSUTF8("VerticalThrusters"), 17}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 6, -1}, {6, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /*  */
         stat = XmlDec_SetThrusterCommandType_choice (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TakeStationCommandType_choice                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TakeStationCommandType_choice (OSCTXT* pctxt, 
   TakeStationCommandType_choice *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.targetSonarScan
             = rtxMemAllocType (pctxt, NoValueElementType);

         if (pvalue->u.targetSonarScan == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NoValueElementType (pvalue->u.targetSonarScan);
         stat = asn1D_NoValueElementType (pctxt, 
            pvalue->u.targetSonarScan, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.targetEdgeSonarScan
             = rtxMemAllocType (pctxt, NoValueElementType);

         if (pvalue->u.targetEdgeSonarScan == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NoValueElementType (pvalue->u.targetEdgeSonarScan);
         stat = asn1D_NoValueElementType (pctxt, 
            pvalue->u.targetEdgeSonarScan, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_TakeStationCommandType_choice (OSCTXT* pctxt, 
   TakeStationCommandType_choice* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("TargetSonarScan"), 15}, 0}, 0 },
      {{{OSUTF8("TargetEdgeSonarScan"), 19}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* TargetSonarScan */
      pvalue->u.targetSonarScan = rtxMemAllocType (pctxt, NoValueElementType);

      if (pvalue->u.targetSonarScan == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NoValueElementType (pvalue->u.targetSonarScan);

      stat = XmlDec_NoValueElementType (pctxt, pvalue->u.targetSonarScan);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* TargetEdgeSonarScan */
      pvalue->u.targetEdgeSonarScan
          = rtxMemAllocType (pctxt, NoValueElementType);

      if (pvalue->u.targetEdgeSonarScan == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NoValueElementType (pvalue->u.targetEdgeSonarScan);

      stat = XmlDec_NoValueElementType (pctxt, pvalue->u.targetEdgeSonarScan);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetElementType                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TargetElementType (OSCTXT* pctxt, TargetElementType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bearing */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->bearing, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode elevation */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->elevation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.elevationPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode range */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->range, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_TargetElementType (OSCTXT* pctxt, TargetElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bearing"), 7}, 0 },
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("elevation"), 9}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("range"), 5}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 6, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bearing */
            stat = rtXmlpDecDouble (pctxt, &pvalue->bearing, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 2: /* elevation */
            stat = rtXmlpDecDouble (pctxt, &pvalue->elevation, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.elevationPresent = TRUE;
            break;

         case 3: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 4: /* range */
            stat = rtXmlpDecDouble (pctxt, &pvalue->range, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "TargetElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "TargetElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TakeStationCommandType                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TakeStationCommandType (OSCTXT* pctxt, 
   TakeStationCommandType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_TakeStationCommandType_choice (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode targetLocation */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_TargetElementType (pctxt, 
               &pvalue->targetLocation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.targetLocationPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode commandedStation */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_TargetElementType (pctxt, 
               &pvalue->commandedStation, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode heading */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_HeadingElementType (pctxt, 
               &pvalue->heading, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.headingPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode timeOut */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->timeOut, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeOutPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_TakeStationCommandType (OSCTXT* pctxt, 
   TakeStationCommandType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "TakeStationCommandType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "TakeStationCommandType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("TargetSonarScan"), 15}, 0}, 0 },
      {{{OSUTF8("TargetEdgeSonarScan"), 19}, 0}, 0 },
      {{{OSUTF8("TargetLocation"), 14}, 0}, 1 },
      {{{OSUTF8("CommandedStation"), 16}, 0}, 2 },
      {{{OSUTF8("Heading"), 7}, 0}, 3 },
      {{{OSUTF8("TimeOut"), 7}, 0}, 4 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}, {2, 2, -1}, {4, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 5; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /*  */
         stat = XmlDec_TakeStationCommandType_choice (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* TargetLocation */
         stat = XmlDec_TargetElementType (pctxt, &pvalue->targetLocation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.targetLocationPresent = TRUE;
         break;
      }
      case 2: { /* CommandedStation */
         stat = XmlDec_TargetElementType (pctxt, &pvalue->commandedStation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 3: { /* Heading */
         stat = XmlDec_HeadingElementType (pctxt, &pvalue->heading);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.headingPresent = TRUE;
         break;
      }
      case 4: { /* TimeOut */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            timeOut);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.timeOutPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UuvWaypointCommandType                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UuvWaypointCommandType (OSCTXT* pctxt, 
   UuvWaypointCommandType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_HorizontalPositionElements (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode choice_1 */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_DepthTypeElements (pctxt, 
               &pvalue->choice_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choice_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode homingMode */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_TrackModeElementType (pctxt, 
               &pvalue->homingMode, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.homingModePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode choice_2 */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_UuvSpeedElements (pctxt, 
               &pvalue->choice_2, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choice_2Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode obtainGps */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_BooleanElementType_derivations (pctxt, 
               &pvalue->obtainGps, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.obtainGpsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode standoff */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->standoff, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.standoffPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode timeOut */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->timeOut, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeOutPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UuvWaypointCommandType (OSCTXT* pctxt, 
   UuvWaypointCommandType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UuvWaypointCommandType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UuvWaypointCommandType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("LatitudeLongitude"), 17}, 0}, 0 },
      {{{OSUTF8("XYPosition"), 10}, 0}, 0 },
      {{{OSUTF8("RelativeXYPosition"), 18}, 0}, 0 },
      {{{OSUTF8("Depth"), 5}, 0}, 1 },
      {{{OSUTF8("Altitude"), 8}, 0}, 1 },
      {{{OSUTF8("HomingMode"), 10}, 0}, 2 },
      {{{OSUTF8("SetPower"), 8}, 0}, 3 },
      {{{OSUTF8("MakeKnots"), 9}, 0}, 3 },
      {{{OSUTF8("MakeSpeed"), 9}, 0}, 3 },
      {{{OSUTF8("ObtainGps"), 9}, 0}, 4 },
      {{{OSUTF8("Standoff"), 8}, 0}, 5 },
      {{{OSUTF8("TimeOut"), 7}, 0}, 6 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}, {3, 9, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 7; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_HorizontalPositionElements (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_DepthTypeElements (pctxt, &pvalue->choice_1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choice_1Present = TRUE;
         break;
      }
      case 2: { /* HomingMode */
         stat = XmlDec_TrackModeElementType (pctxt, &pvalue->homingMode);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.homingModePresent = TRUE;
         break;
      }
      case 3: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_UuvSpeedElements (pctxt, &pvalue->choice_2);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choice_2Present = TRUE;
         break;
      }
      case 4: { /* ObtainGps */
         stat = XmlDec_BooleanElementType_derivations (pctxt, &pvalue->
            obtainGps);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.obtainGpsPresent = TRUE;
         break;
      }
      case 5: { /* Standoff */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            standoff);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.standoffPresent = TRUE;
         break;
      }
      case 6: { /* TimeOut */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            timeOut);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.timeOutPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UuvScriptCommandsType_element                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UuvScriptCommandsType_element (OSCTXT* pctxt, 
   UuvScriptCommandsType_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.compositeWaypoint
             = rtxMemAllocType (pctxt, UuvCompositeWaypointCommandType);

         if (pvalue->u.compositeWaypoint == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UuvCompositeWaypointCommandType (pvalue->u.compositeWaypoint);
         stat = asn1D_UuvCompositeWaypointCommandType (pctxt, 
            pvalue->u.compositeWaypoint, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.followBeacon
             = rtxMemAllocType (pctxt, FollowBeaconCommandType);

         if (pvalue->u.followBeacon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_FollowBeaconCommandType (pvalue->u.followBeacon);
         stat = asn1D_FollowBeaconCommandType (pctxt, 
            pvalue->u.followBeacon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.gpsFix = rtxMemAllocType (pctxt, GpsFixCommandType);

         if (pvalue->u.gpsFix == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_GpsFixCommandType (pvalue->u.gpsFix);
         stat = asn1D_GpsFixCommandType (pctxt, 
            pvalue->u.gpsFix, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.help = rtxMemAllocType (pctxt, NoValueElementType);

         if (pvalue->u.help == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NoValueElementType (pvalue->u.help);
         stat = asn1D_NoValueElementType (pctxt, 
            pvalue->u.help, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.hover = rtxMemAllocType (pctxt, HoverCommandType);

         if (pvalue->u.hover == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_HoverCommandType (pvalue->u.hover);
         stat = asn1D_HoverCommandType (pctxt, 
            pvalue->u.hover, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.loiter = rtxMemAllocType (pctxt, UuvLoiterCommandType);

         if (pvalue->u.loiter == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UuvLoiterCommandType (pvalue->u.loiter);
         stat = asn1D_UuvLoiterCommandType (pctxt, 
            pvalue->u.loiter, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.makeAltitude
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.makeAltitude == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeAltitude);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.makeAltitude, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.makeDepth
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.makeDepth == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeDepth);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.makeDepth, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.makeHeading = rtxMemAllocType (pctxt, HeadingElementType);

         if (pvalue->u.makeHeading == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_HeadingElementType (pvalue->u.makeHeading);
         stat = asn1D_HeadingElementType (pctxt, 
            pvalue->u.makeHeading, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.makeKnots = rtxMemAllocType (pctxt, SpeedElementType);

         if (pvalue->u.makeKnots == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SpeedElementType (pvalue->u.makeKnots);
         stat = asn1D_SpeedElementType (pctxt, 
            pvalue->u.makeKnots, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.makeSpeed = rtxMemAllocType (pctxt, SpeedElementType);

         if (pvalue->u.makeSpeed == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SpeedElementType (pvalue->u.makeSpeed);
         stat = asn1D_SpeedElementType (pctxt, 
            pvalue->u.makeSpeed, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.metaCommand = rtxMemAllocType (pctxt, MetaDataType);

         if (pvalue->u.metaCommand == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MetaDataType (pvalue->u.metaCommand);
         stat = asn1D_MetaDataType (pctxt, 
            pvalue->u.metaCommand, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.missionScript = rtxMemAllocType (pctxt, StringElementType);

         if (pvalue->u.missionScript == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_StringElementType (pvalue->u.missionScript);
         stat = asn1D_StringElementType (pctxt, 
            pvalue->u.missionScript, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.missionScriptInline
             = rtxMemAllocType (pctxt, StringElementType);

         if (pvalue->u.missionScriptInline == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_StringElementType (pvalue->u.missionScriptInline);
         stat = asn1D_StringElementType (pctxt, 
            pvalue->u.missionScriptInline, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.moveLateral
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.moveLateral == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.moveLateral);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.moveLateral, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.moveRotate
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.moveRotate == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.moveRotate);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.moveRotate, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.quit = rtxMemAllocType (pctxt, QuitCommandType);

         if (pvalue->u.quit == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_QuitCommandType (pvalue->u.quit);
         stat = asn1D_QuitCommandType (pctxt, 
            pvalue->u.quit, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      case (TM_CTXT|TM_CONS|17):
         pvalue->u.realtime
             = rtxMemAllocType (pctxt, BooleanElementType_derivations);

         if (pvalue->u.realtime == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_BooleanElementType_derivations (pvalue->u.realtime);
         stat = asn1D_BooleanElementType_derivations (pctxt, 
            pvalue->u.realtime, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 18;
         break;

      case (TM_CTXT|TM_CONS|18):
         pvalue->u.recover = rtxMemAllocType (pctxt, RecoverCommandType);

         if (pvalue->u.recover == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RecoverCommandType (pvalue->u.recover);
         stat = asn1D_RecoverCommandType (pctxt, 
            pvalue->u.recover, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 19;
         break;

      case (TM_CTXT|TM_CONS|19):
         pvalue->u.sendMessage
             = rtxMemAllocType (pctxt, SendMessageCommandType);

         if (pvalue->u.sendMessage == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SendMessageCommandType (pvalue->u.sendMessage);
         stat = asn1D_SendMessageCommandType (pctxt, 
            pvalue->u.sendMessage, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 20;
         break;

      case (TM_CTXT|TM_CONS|20):
         pvalue->u.setPlanes = rtxMemAllocType (pctxt, SetPlanesCommandType);

         if (pvalue->u.setPlanes == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SetPlanesCommandType (pvalue->u.setPlanes);
         stat = asn1D_SetPlanesCommandType (pctxt, 
            pvalue->u.setPlanes, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 21;
         break;

      case (TM_CTXT|TM_CONS|21):
         pvalue->u.setPosition
             = rtxMemAllocType (pctxt, UuvPositionCommandType);

         if (pvalue->u.setPosition == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UuvPositionCommandType (pvalue->u.setPosition);
         stat = asn1D_UuvPositionCommandType (pctxt, 
            pvalue->u.setPosition, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 22;
         break;

      case (TM_CTXT|TM_CONS|22):
         pvalue->u.setPower
             = rtxMemAllocType (pctxt, SetPropellerCommandType);

         if (pvalue->u.setPower == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SetPropellerCommandType (pvalue->u.setPower);
         stat = asn1D_SetPropellerCommandType (pctxt, 
            pvalue->u.setPower, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 23;
         break;

      case (TM_CTXT|TM_CONS|23):
         pvalue->u.setRudder
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.setRudder == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.setRudder);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.setRudder, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 24;
         break;

      case (TM_CTXT|TM_CONS|24):
         pvalue->u.setSonar = rtxMemAllocType (pctxt, SetSonarCommandType);

         if (pvalue->u.setSonar == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SetSonarCommandType (pvalue->u.setSonar);
         stat = asn1D_SetSonarCommandType (pctxt, 
            pvalue->u.setSonar, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 25;
         break;

      case (TM_CTXT|TM_CONS|25):
         pvalue->u.setStandoff
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.setStandoff == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.setStandoff);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.setStandoff, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 26;
         break;

      case (TM_CTXT|TM_CONS|26):
         pvalue->u.setThruster
             = rtxMemAllocType (pctxt, SetThrusterCommandType);

         if (pvalue->u.setThruster == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SetThrusterCommandType (pvalue->u.setThruster);
         stat = asn1D_SetThrusterCommandType (pctxt, 
            pvalue->u.setThruster, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 27;
         break;

      case (TM_CTXT|TM_CONS|27):
         pvalue->u.setTime = rtxMemAllocType (pctxt, ScalarElementType);

         if (pvalue->u.setTime == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ScalarElementType (pvalue->u.setTime);
         stat = asn1D_ScalarElementType (pctxt, 
            pvalue->u.setTime, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 28;
         break;

      case (TM_CTXT|TM_CONS|28):
         pvalue->u.setTimeStep
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.setTimeStep == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.setTimeStep);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.setTimeStep, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 29;
         break;

      case (TM_CTXT|TM_CONS|29):
         pvalue->u.takeStation
             = rtxMemAllocType (pctxt, TakeStationCommandType);

         if (pvalue->u.takeStation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TakeStationCommandType (pvalue->u.takeStation);
         stat = asn1D_TakeStationCommandType (pctxt, 
            pvalue->u.takeStation, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 30;
         break;

      case (TM_CTXT|TM_CONS|30):
         pvalue->u.thrusters
             = rtxMemAllocType (pctxt, BooleanElementType_derivations);

         if (pvalue->u.thrusters == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_BooleanElementType_derivations (pvalue->u.thrusters);
         stat = asn1D_BooleanElementType_derivations (pctxt, 
            pvalue->u.thrusters, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 31;
         break;

      case (TM_CTXT|TM_CONS|31):
         pvalue->u.trace
             = rtxMemAllocType (pctxt, BooleanElementType_derivations);

         if (pvalue->u.trace == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_BooleanElementType_derivations (pvalue->u.trace);
         stat = asn1D_BooleanElementType_derivations (pctxt, 
            pvalue->u.trace, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 32;
         break;

      case (TM_CTXT|TM_CONS|32):
         pvalue->u.wait
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.wait == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.wait);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.wait, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 33;
         break;

      case (TM_CTXT|TM_CONS|33):
         pvalue->u.waitUntilTime
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.waitUntilTime == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.waitUntilTime);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.waitUntilTime, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 34;
         break;

      case (TM_CTXT|TM_CONS|34):
         pvalue->u.waypoint = rtxMemAllocType (pctxt, UuvWaypointCommandType);

         if (pvalue->u.waypoint == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UuvWaypointCommandType (pvalue->u.waypoint);
         stat = asn1D_UuvWaypointCommandType (pctxt, 
            pvalue->u.waypoint, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 35;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_UuvScriptCommandsType_element (OSCTXT* pctxt, 
   UuvScriptCommandsType_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("CompositeWaypoint"), 17}, 0}, 0 },
      {{{OSUTF8("FollowBeacon"), 12}, 0}, 1 },
      {{{OSUTF8("GpsFix"), 6}, 0}, 2 },
      {{{OSUTF8("Help"), 4}, 0}, 3 },
      {{{OSUTF8("Hover"), 5}, 0}, 4 },
      {{{OSUTF8("Loiter"), 6}, 0}, 5 },
      {{{OSUTF8("MakeAltitude"), 12}, 0}, 6 },
      {{{OSUTF8("MakeDepth"), 9}, 0}, 7 },
      {{{OSUTF8("MakeHeading"), 11}, 0}, 8 },
      {{{OSUTF8("MakeKnots"), 9}, 0}, 9 },
      {{{OSUTF8("MakeSpeed"), 9}, 0}, 10 },
      {{{OSUTF8("MetaCommand"), 11}, 0}, 11 },
      {{{OSUTF8("MissionScript"), 13}, 0}, 12 },
      {{{OSUTF8("MissionScriptInline"), 19}, 0}, 13 },
      {{{OSUTF8("MoveLateral"), 11}, 0}, 14 },
      {{{OSUTF8("MoveRotate"), 10}, 0}, 15 },
      {{{OSUTF8("Quit"), 4}, 0}, 16 },
      {{{OSUTF8("Realtime"), 8}, 0}, 17 },
      {{{OSUTF8("Recover"), 7}, 0}, 18 },
      {{{OSUTF8("SendMessage"), 11}, 0}, 19 },
      {{{OSUTF8("SetPlanes"), 9}, 0}, 20 },
      {{{OSUTF8("SetPosition"), 11}, 0}, 21 },
      {{{OSUTF8("SetPower"), 8}, 0}, 22 },
      {{{OSUTF8("SetRudder"), 9}, 0}, 23 },
      {{{OSUTF8("SetSonar"), 8}, 0}, 24 },
      {{{OSUTF8("SetStandoff"), 11}, 0}, 25 },
      {{{OSUTF8("SetThruster"), 11}, 0}, 26 },
      {{{OSUTF8("SetTime"), 7}, 0}, 27 },
      {{{OSUTF8("SetTimeStep"), 11}, 0}, 28 },
      {{{OSUTF8("TakeStation"), 11}, 0}, 29 },
      {{{OSUTF8("Thrusters"), 9}, 0}, 30 },
      {{{OSUTF8("Trace"), 5}, 0}, 31 },
      {{{OSUTF8("Wait"), 4}, 0}, 32 },
      {{{OSUTF8("WaitUntilTime"), 13}, 0}, 33 },
      {{{OSUTF8("Waypoint"), 8}, 0}, 34 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 35, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* CompositeWaypoint */
      pvalue->u.compositeWaypoint
          = rtxMemAllocType (pctxt, UuvCompositeWaypointCommandType);

      if (pvalue->u.compositeWaypoint == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UuvCompositeWaypointCommandType (pvalue->u.compositeWaypoint);

      stat = XmlDec_UuvCompositeWaypointCommandType (pctxt, pvalue->
         u.compositeWaypoint);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* FollowBeacon */
      pvalue->u.followBeacon
          = rtxMemAllocType (pctxt, FollowBeaconCommandType);

      if (pvalue->u.followBeacon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_FollowBeaconCommandType (pvalue->u.followBeacon);

      stat = XmlDec_FollowBeaconCommandType (pctxt, pvalue->u.followBeacon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* GpsFix */
      pvalue->u.gpsFix = rtxMemAllocType (pctxt, GpsFixCommandType);

      if (pvalue->u.gpsFix == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_GpsFixCommandType (pvalue->u.gpsFix);

      stat = XmlDec_GpsFixCommandType (pctxt, pvalue->u.gpsFix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* Help */
      pvalue->u.help = rtxMemAllocType (pctxt, NoValueElementType);

      if (pvalue->u.help == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NoValueElementType (pvalue->u.help);

      stat = XmlDec_NoValueElementType (pctxt, pvalue->u.help);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* Hover */
      pvalue->u.hover = rtxMemAllocType (pctxt, HoverCommandType);

      if (pvalue->u.hover == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HoverCommandType (pvalue->u.hover);

      stat = XmlDec_HoverCommandType (pctxt, pvalue->u.hover);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* Loiter */
      pvalue->u.loiter = rtxMemAllocType (pctxt, UuvLoiterCommandType);

      if (pvalue->u.loiter == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UuvLoiterCommandType (pvalue->u.loiter);

      stat = XmlDec_UuvLoiterCommandType (pctxt, pvalue->u.loiter);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* MakeAltitude */
      pvalue->u.makeAltitude
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.makeAltitude == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeAltitude);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.makeAltitude);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* MakeDepth */
      pvalue->u.makeDepth
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.makeDepth == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeDepth);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.makeDepth);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* MakeHeading */
      pvalue->u.makeHeading = rtxMemAllocType (pctxt, HeadingElementType);

      if (pvalue->u.makeHeading == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HeadingElementType (pvalue->u.makeHeading);

      stat = XmlDec_HeadingElementType (pctxt, pvalue->u.makeHeading);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* MakeKnots */
      pvalue->u.makeKnots = rtxMemAllocType (pctxt, SpeedElementType);

      if (pvalue->u.makeKnots == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SpeedElementType (pvalue->u.makeKnots);

      stat = XmlDec_SpeedElementType (pctxt, pvalue->u.makeKnots);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* MakeSpeed */
      pvalue->u.makeSpeed = rtxMemAllocType (pctxt, SpeedElementType);

      if (pvalue->u.makeSpeed == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SpeedElementType (pvalue->u.makeSpeed);

      stat = XmlDec_SpeedElementType (pctxt, pvalue->u.makeSpeed);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* MetaCommand */
      pvalue->u.metaCommand = rtxMemAllocType (pctxt, MetaDataType);

      if (pvalue->u.metaCommand == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MetaDataType (pvalue->u.metaCommand);

      stat = XmlDec_MetaDataType (pctxt, pvalue->u.metaCommand);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* MissionScript */
      pvalue->u.missionScript = rtxMemAllocType (pctxt, StringElementType);

      if (pvalue->u.missionScript == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_StringElementType (pvalue->u.missionScript);

      stat = XmlDec_StringElementType (pctxt, pvalue->u.missionScript);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* MissionScriptInline */
      pvalue->u.missionScriptInline
          = rtxMemAllocType (pctxt, StringElementType);

      if (pvalue->u.missionScriptInline == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_StringElementType (pvalue->u.missionScriptInline);

      stat = XmlDec_StringElementType (pctxt, pvalue->u.missionScriptInline);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* MoveLateral */
      pvalue->u.moveLateral
          = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.moveLateral == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.moveLateral);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->u.moveLateral);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* MoveRotate */
      pvalue->u.moveRotate
          = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.moveRotate == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.moveRotate);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->u.moveRotate);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* Quit */
      pvalue->u.quit = rtxMemAllocType (pctxt, QuitCommandType);

      if (pvalue->u.quit == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QuitCommandType (pvalue->u.quit);

      stat = XmlDec_QuitCommandType (pctxt, pvalue->u.quit);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 17: { /* Realtime */
      pvalue->u.realtime
          = rtxMemAllocType (pctxt, BooleanElementType_derivations);

      if (pvalue->u.realtime == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BooleanElementType_derivations (pvalue->u.realtime);

      stat = XmlDec_BooleanElementType_derivations (pctxt, pvalue->u.realtime
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 18: { /* Recover */
      pvalue->u.recover = rtxMemAllocType (pctxt, RecoverCommandType);

      if (pvalue->u.recover == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RecoverCommandType (pvalue->u.recover);

      stat = XmlDec_RecoverCommandType (pctxt, pvalue->u.recover);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 19: { /* SendMessage */
      pvalue->u.sendMessage = rtxMemAllocType (pctxt, SendMessageCommandType);

      if (pvalue->u.sendMessage == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SendMessageCommandType (pvalue->u.sendMessage);

      stat = XmlDec_SendMessageCommandType (pctxt, pvalue->u.sendMessage);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 20: { /* SetPlanes */
      pvalue->u.setPlanes = rtxMemAllocType (pctxt, SetPlanesCommandType);

      if (pvalue->u.setPlanes == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SetPlanesCommandType (pvalue->u.setPlanes);

      stat = XmlDec_SetPlanesCommandType (pctxt, pvalue->u.setPlanes);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 21: { /* SetPosition */
      pvalue->u.setPosition = rtxMemAllocType (pctxt, UuvPositionCommandType);

      if (pvalue->u.setPosition == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UuvPositionCommandType (pvalue->u.setPosition);

      stat = XmlDec_UuvPositionCommandType (pctxt, pvalue->u.setPosition);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 22: { /* SetPower */
      pvalue->u.setPower = rtxMemAllocType (pctxt, SetPropellerCommandType);

      if (pvalue->u.setPower == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SetPropellerCommandType (pvalue->u.setPower);

      stat = XmlDec_SetPropellerCommandType (pctxt, pvalue->u.setPower);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 23: { /* SetRudder */
      pvalue->u.setRudder = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.setRudder == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.setRudder);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->u.setRudder);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 24: { /* SetSonar */
      pvalue->u.setSonar = rtxMemAllocType (pctxt, SetSonarCommandType);

      if (pvalue->u.setSonar == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SetSonarCommandType (pvalue->u.setSonar);

      stat = XmlDec_SetSonarCommandType (pctxt, pvalue->u.setSonar);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 25: { /* SetStandoff */
      pvalue->u.setStandoff
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.setStandoff == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.setStandoff);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.setStandoff);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 26: { /* SetThruster */
      pvalue->u.setThruster = rtxMemAllocType (pctxt, SetThrusterCommandType);

      if (pvalue->u.setThruster == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SetThrusterCommandType (pvalue->u.setThruster);

      stat = XmlDec_SetThrusterCommandType (pctxt, pvalue->u.setThruster);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 27: { /* SetTime */
      pvalue->u.setTime = rtxMemAllocType (pctxt, ScalarElementType);

      if (pvalue->u.setTime == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ScalarElementType (pvalue->u.setTime);

      stat = XmlDec_ScalarElementType (pctxt, pvalue->u.setTime);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 28: { /* SetTimeStep */
      pvalue->u.setTimeStep
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.setTimeStep == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.setTimeStep);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.setTimeStep);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 29: { /* TakeStation */
      pvalue->u.takeStation = rtxMemAllocType (pctxt, TakeStationCommandType);

      if (pvalue->u.takeStation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TakeStationCommandType (pvalue->u.takeStation);

      stat = XmlDec_TakeStationCommandType (pctxt, pvalue->u.takeStation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 30: { /* Thrusters */
      pvalue->u.thrusters
          = rtxMemAllocType (pctxt, BooleanElementType_derivations);

      if (pvalue->u.thrusters == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BooleanElementType_derivations (pvalue->u.thrusters);

      stat = XmlDec_BooleanElementType_derivations (pctxt, pvalue->u.thrusters
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 31: { /* Trace */
      pvalue->u.trace
          = rtxMemAllocType (pctxt, BooleanElementType_derivations);

      if (pvalue->u.trace == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BooleanElementType_derivations (pvalue->u.trace);

      stat = XmlDec_BooleanElementType_derivations (pctxt, pvalue->u.trace);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 32: { /* Wait */
      pvalue->u.wait
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.wait == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.wait);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.wait);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 33: { /* WaitUntilTime */
      pvalue->u.waitUntilTime
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.waitUntilTime == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.waitUntilTime
         );

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.waitUntilTime);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 34: { /* Waypoint */
      pvalue->u.waypoint = rtxMemAllocType (pctxt, UuvWaypointCommandType);

      if (pvalue->u.waypoint == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UuvWaypointCommandType (pvalue->u.waypoint);

      stat = XmlDec_UuvWaypointCommandType (pctxt, pvalue->u.waypoint);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UuvScriptCommandsType                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UuvScriptCommandsType (OSCTXT* pctxt, 
   UuvScriptCommandsType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               UuvScriptCommandsType_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, UuvScriptCommandsType_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_UuvScriptCommandsType_element (pdata2);

                  stat = asn1D_UuvScriptCommandsType_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

               if (!(pvalue->choice_list.count >= 1U)) {
                  rtxErrAddStrParm (pctxt, "UuvScriptCommandsType.choice_list.count");
                  rtxErrAddIntParm (pctxt, (int)pvalue->choice_list.count);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UuvScriptCommandsType (OSCTXT* pctxt, UuvScriptCommandsType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UuvScriptCommandsType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UuvScriptCommandsType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("CompositeWaypoint"), 17}, 0}, 0 },
      {{{OSUTF8("FollowBeacon"), 12}, 0}, 0 },
      {{{OSUTF8("GpsFix"), 6}, 0}, 0 },
      {{{OSUTF8("Help"), 4}, 0}, 0 },
      {{{OSUTF8("Hover"), 5}, 0}, 0 },
      {{{OSUTF8("Loiter"), 6}, 0}, 0 },
      {{{OSUTF8("MakeAltitude"), 12}, 0}, 0 },
      {{{OSUTF8("MakeDepth"), 9}, 0}, 0 },
      {{{OSUTF8("MakeHeading"), 11}, 0}, 0 },
      {{{OSUTF8("MakeKnots"), 9}, 0}, 0 },
      {{{OSUTF8("MakeSpeed"), 9}, 0}, 0 },
      {{{OSUTF8("MetaCommand"), 11}, 0}, 0 },
      {{{OSUTF8("MissionScript"), 13}, 0}, 0 },
      {{{OSUTF8("MissionScriptInline"), 19}, 0}, 0 },
      {{{OSUTF8("MoveLateral"), 11}, 0}, 0 },
      {{{OSUTF8("MoveRotate"), 10}, 0}, 0 },
      {{{OSUTF8("Quit"), 4}, 0}, 0 },
      {{{OSUTF8("Realtime"), 8}, 0}, 0 },
      {{{OSUTF8("Recover"), 7}, 0}, 0 },
      {{{OSUTF8("SendMessage"), 11}, 0}, 0 },
      {{{OSUTF8("SetPlanes"), 9}, 0}, 0 },
      {{{OSUTF8("SetPosition"), 11}, 0}, 0 },
      {{{OSUTF8("SetPower"), 8}, 0}, 0 },
      {{{OSUTF8("SetRudder"), 9}, 0}, 0 },
      {{{OSUTF8("SetSonar"), 8}, 0}, 0 },
      {{{OSUTF8("SetStandoff"), 11}, 0}, 0 },
      {{{OSUTF8("SetThruster"), 11}, 0}, 0 },
      {{{OSUTF8("SetTime"), 7}, 0}, 0 },
      {{{OSUTF8("SetTimeStep"), 11}, 0}, 0 },
      {{{OSUTF8("TakeStation"), 11}, 0}, 0 },
      {{{OSUTF8("Thrusters"), 9}, 0}, 0 },
      {{{OSUTF8("Trace"), 5}, 0}, 0 },
      {{{OSUTF8("Wait"), 4}, 0}, 0 },
      {{{OSUTF8("WaitUntilTime"), 13}, 0}, 0 },
      {{{OSUTF8("Waypoint"), 8}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 35, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         UuvScriptCommandsType_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, UuvScriptCommandsType_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UuvScriptCommandsType_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_UuvScriptCommandsType_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 35, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SpeedTypeElements                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SpeedTypeElements (OSCTXT* pctxt, SpeedTypeElements *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.speed
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.speed == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.speed);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.speed, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.knots
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.knots == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.knots);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.knots, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_SpeedTypeElements (OSCTXT* pctxt, SpeedTypeElements* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Speed"), 5}, 0}, 0 },
      {{{OSUTF8("Knots"), 5}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* Speed */
      pvalue->u.speed
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.speed == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.speed);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.speed);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* Knots */
      pvalue->u.knots
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.knots == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.knots);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.knots);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UsvCompositeWaypointCommandType                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UsvCompositeWaypointCommandType (OSCTXT* pctxt, 
   UsvCompositeWaypointCommandType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CompositeWaypointElements (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode homingMode */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_TrackModeElementType (pctxt, 
               &pvalue->homingMode, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.homingModePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode choice_1 */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SpeedTypeElements (pctxt, 
               &pvalue->choice_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choice_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode standoff */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->standoff, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.standoffPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode timeOut */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->timeOut, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeOutPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UsvCompositeWaypointCommandType (OSCTXT* pctxt, 
   UsvCompositeWaypointCommandType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UsvCompositeWaypointCommandType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UsvCompositeWaypointCommandType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("WaypointList"), 12}, 0}, 0 },
      {{{OSUTF8("ParallelTrack"), 13}, 0}, 0 },
      {{{OSUTF8("SectorPattern"), 13}, 0}, 0 },
      {{{OSUTF8("ExpandingSquare"), 15}, 0}, 0 },
      {{{OSUTF8("HomingMode"), 10}, 0}, 1 },
      {{{OSUTF8("Speed"), 5}, 0}, 2 },
      {{{OSUTF8("Knots"), 5}, 0}, 2 },
      {{{OSUTF8("Standoff"), 8}, 0}, 3 },
      {{{OSUTF8("TimeOut"), 7}, 0}, 4 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}, {4, 5, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 5; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_CompositeWaypointElements (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* HomingMode */
         stat = XmlDec_TrackModeElementType (pctxt, &pvalue->homingMode);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.homingModePresent = TRUE;
         break;
      }
      case 2: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_SpeedTypeElements (pctxt, &pvalue->choice_1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choice_1Present = TRUE;
         break;
      }
      case 3: { /* Standoff */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            standoff);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.standoffPresent = TRUE;
         break;
      }
      case 4: { /* TimeOut */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            timeOut);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.timeOutPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UsvLoiterCommandType                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UsvLoiterCommandType (OSCTXT* pctxt, 
   UsvLoiterCommandType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_HorizontalPositionElements (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choicePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode choice_1 */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SpeedTypeElements (pctxt, 
               &pvalue->choice_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choice_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode timeOut */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->timeOut, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeOutPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UsvLoiterCommandType (OSCTXT* pctxt, UsvLoiterCommandType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UsvLoiterCommandType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UsvLoiterCommandType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("LatitudeLongitude"), 17}, 0}, 0 },
      {{{OSUTF8("XYPosition"), 10}, 0}, 0 },
      {{{OSUTF8("RelativeXYPosition"), 18}, 0}, 0 },
      {{{OSUTF8("Speed"), 5}, 0}, 1 },
      {{{OSUTF8("Knots"), 5}, 0}, 1 },
      {{{OSUTF8("TimeOut"), 7}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 6, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_HorizontalPositionElements (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choicePresent = TRUE;
         break;
      }
      case 1: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_SpeedTypeElements (pctxt, &pvalue->choice_1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choice_1Present = TRUE;
         break;
      }
      case 2: { /* TimeOut */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            timeOut);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.timeOutPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UsvPositionCommandType                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UsvPositionCommandType (OSCTXT* pctxt, 
   UsvPositionCommandType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AbsoluteHorizontalPositionElements (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UsvPositionCommandType (OSCTXT* pctxt, 
   UsvPositionCommandType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UsvPositionCommandType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UsvPositionCommandType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("LatitudeLongitude"), 17}, 0}, 0 },
      {{{OSUTF8("XYPosition"), 10}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}, {2, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_AbsoluteHorizontalPositionElements (pctxt, &pvalue->
            choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UsvWaypointCommandType                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UsvWaypointCommandType (OSCTXT* pctxt, 
   UsvWaypointCommandType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_HorizontalPositionElements (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode homingMode */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_TrackModeElementType (pctxt, 
               &pvalue->homingMode, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.homingModePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode choice_1 */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SpeedTypeElements (pctxt, 
               &pvalue->choice_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choice_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode standoff */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->standoff, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.standoffPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode timeOut */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->timeOut, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeOutPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UsvWaypointCommandType (OSCTXT* pctxt, 
   UsvWaypointCommandType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UsvWaypointCommandType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UsvWaypointCommandType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("LatitudeLongitude"), 17}, 0}, 0 },
      {{{OSUTF8("XYPosition"), 10}, 0}, 0 },
      {{{OSUTF8("RelativeXYPosition"), 18}, 0}, 0 },
      {{{OSUTF8("HomingMode"), 10}, 0}, 1 },
      {{{OSUTF8("Speed"), 5}, 0}, 2 },
      {{{OSUTF8("Knots"), 5}, 0}, 2 },
      {{{OSUTF8("Standoff"), 8}, 0}, 3 },
      {{{OSUTF8("TimeOut"), 7}, 0}, 4 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}, {3, 5, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 5; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_HorizontalPositionElements (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* HomingMode */
         stat = XmlDec_TrackModeElementType (pctxt, &pvalue->homingMode);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.homingModePresent = TRUE;
         break;
      }
      case 2: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_SpeedTypeElements (pctxt, &pvalue->choice_1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choice_1Present = TRUE;
         break;
      }
      case 3: { /* Standoff */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            standoff);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.standoffPresent = TRUE;
         break;
      }
      case 4: { /* TimeOut */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            timeOut);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.timeOutPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UsvScriptCommandsType_element                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UsvScriptCommandsType_element (OSCTXT* pctxt, 
   UsvScriptCommandsType_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.compositeWaypoint
             = rtxMemAllocType (pctxt, UsvCompositeWaypointCommandType);

         if (pvalue->u.compositeWaypoint == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UsvCompositeWaypointCommandType (pvalue->u.compositeWaypoint);
         stat = asn1D_UsvCompositeWaypointCommandType (pctxt, 
            pvalue->u.compositeWaypoint, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.followBeacon
             = rtxMemAllocType (pctxt, FollowBeaconCommandType);

         if (pvalue->u.followBeacon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_FollowBeaconCommandType (pvalue->u.followBeacon);
         stat = asn1D_FollowBeaconCommandType (pctxt, 
            pvalue->u.followBeacon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.help = rtxMemAllocType (pctxt, NoValueElementType);

         if (pvalue->u.help == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NoValueElementType (pvalue->u.help);
         stat = asn1D_NoValueElementType (pctxt, 
            pvalue->u.help, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.loiter = rtxMemAllocType (pctxt, UsvLoiterCommandType);

         if (pvalue->u.loiter == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UsvLoiterCommandType (pvalue->u.loiter);
         stat = asn1D_UsvLoiterCommandType (pctxt, 
            pvalue->u.loiter, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.makeHeading = rtxMemAllocType (pctxt, HeadingElementType);

         if (pvalue->u.makeHeading == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_HeadingElementType (pvalue->u.makeHeading);
         stat = asn1D_HeadingElementType (pctxt, 
            pvalue->u.makeHeading, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.makeKnots = rtxMemAllocType (pctxt, SpeedElementType);

         if (pvalue->u.makeKnots == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SpeedElementType (pvalue->u.makeKnots);
         stat = asn1D_SpeedElementType (pctxt, 
            pvalue->u.makeKnots, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.makeSpeed = rtxMemAllocType (pctxt, SpeedElementType);

         if (pvalue->u.makeSpeed == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SpeedElementType (pvalue->u.makeSpeed);
         stat = asn1D_SpeedElementType (pctxt, 
            pvalue->u.makeSpeed, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.metaCommand = rtxMemAllocType (pctxt, MetaDataType);

         if (pvalue->u.metaCommand == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MetaDataType (pvalue->u.metaCommand);
         stat = asn1D_MetaDataType (pctxt, 
            pvalue->u.metaCommand, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.missionScript = rtxMemAllocType (pctxt, StringElementType);

         if (pvalue->u.missionScript == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_StringElementType (pvalue->u.missionScript);
         stat = asn1D_StringElementType (pctxt, 
            pvalue->u.missionScript, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.missionScriptInline
             = rtxMemAllocType (pctxt, StringElementType);

         if (pvalue->u.missionScriptInline == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_StringElementType (pvalue->u.missionScriptInline);
         stat = asn1D_StringElementType (pctxt, 
            pvalue->u.missionScriptInline, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.quit = rtxMemAllocType (pctxt, QuitCommandType);

         if (pvalue->u.quit == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_QuitCommandType (pvalue->u.quit);
         stat = asn1D_QuitCommandType (pctxt, 
            pvalue->u.quit, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.realtime
             = rtxMemAllocType (pctxt, BooleanElementType_derivations);

         if (pvalue->u.realtime == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_BooleanElementType_derivations (pvalue->u.realtime);
         stat = asn1D_BooleanElementType_derivations (pctxt, 
            pvalue->u.realtime, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.sendMessage
             = rtxMemAllocType (pctxt, SendMessageCommandType);

         if (pvalue->u.sendMessage == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SendMessageCommandType (pvalue->u.sendMessage);
         stat = asn1D_SendMessageCommandType (pctxt, 
            pvalue->u.sendMessage, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.setPosition
             = rtxMemAllocType (pctxt, UsvPositionCommandType);

         if (pvalue->u.setPosition == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UsvPositionCommandType (pvalue->u.setPosition);
         stat = asn1D_UsvPositionCommandType (pctxt, 
            pvalue->u.setPosition, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.setPower
             = rtxMemAllocType (pctxt, SetPropellerCommandType);

         if (pvalue->u.setPower == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SetPropellerCommandType (pvalue->u.setPower);
         stat = asn1D_SetPropellerCommandType (pctxt, 
            pvalue->u.setPower, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.setRudder
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.setRudder == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.setRudder);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.setRudder, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.setStandoff
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.setStandoff == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.setStandoff);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.setStandoff, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      case (TM_CTXT|TM_CONS|17):
         pvalue->u.setTime = rtxMemAllocType (pctxt, ScalarElementType);

         if (pvalue->u.setTime == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ScalarElementType (pvalue->u.setTime);
         stat = asn1D_ScalarElementType (pctxt, 
            pvalue->u.setTime, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 18;
         break;

      case (TM_CTXT|TM_CONS|18):
         pvalue->u.setTimeStep
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.setTimeStep == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.setTimeStep);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.setTimeStep, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 19;
         break;

      case (TM_CTXT|TM_CONS|19):
         pvalue->u.trace
             = rtxMemAllocType (pctxt, BooleanElementType_derivations);

         if (pvalue->u.trace == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_BooleanElementType_derivations (pvalue->u.trace);
         stat = asn1D_BooleanElementType_derivations (pctxt, 
            pvalue->u.trace, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 20;
         break;

      case (TM_CTXT|TM_CONS|20):
         pvalue->u.wait
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.wait == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.wait);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.wait, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 21;
         break;

      case (TM_CTXT|TM_CONS|21):
         pvalue->u.waitUntilTime
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.waitUntilTime == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.waitUntilTime);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.waitUntilTime, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 22;
         break;

      case (TM_CTXT|TM_CONS|22):
         pvalue->u.waypoint = rtxMemAllocType (pctxt, UsvWaypointCommandType);

         if (pvalue->u.waypoint == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UsvWaypointCommandType (pvalue->u.waypoint);
         stat = asn1D_UsvWaypointCommandType (pctxt, 
            pvalue->u.waypoint, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 23;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_UsvScriptCommandsType_element (OSCTXT* pctxt, 
   UsvScriptCommandsType_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("CompositeWaypoint"), 17}, 0}, 0 },
      {{{OSUTF8("FollowBeacon"), 12}, 0}, 1 },
      {{{OSUTF8("Help"), 4}, 0}, 2 },
      {{{OSUTF8("Loiter"), 6}, 0}, 3 },
      {{{OSUTF8("MakeHeading"), 11}, 0}, 4 },
      {{{OSUTF8("MakeKnots"), 9}, 0}, 5 },
      {{{OSUTF8("MakeSpeed"), 9}, 0}, 6 },
      {{{OSUTF8("MetaCommand"), 11}, 0}, 7 },
      {{{OSUTF8("MissionScript"), 13}, 0}, 8 },
      {{{OSUTF8("MissionScriptInline"), 19}, 0}, 9 },
      {{{OSUTF8("Quit"), 4}, 0}, 10 },
      {{{OSUTF8("Realtime"), 8}, 0}, 11 },
      {{{OSUTF8("SendMessage"), 11}, 0}, 12 },
      {{{OSUTF8("SetPosition"), 11}, 0}, 13 },
      {{{OSUTF8("SetPower"), 8}, 0}, 14 },
      {{{OSUTF8("SetRudder"), 9}, 0}, 15 },
      {{{OSUTF8("SetStandoff"), 11}, 0}, 16 },
      {{{OSUTF8("SetTime"), 7}, 0}, 17 },
      {{{OSUTF8("SetTimeStep"), 11}, 0}, 18 },
      {{{OSUTF8("Trace"), 5}, 0}, 19 },
      {{{OSUTF8("Wait"), 4}, 0}, 20 },
      {{{OSUTF8("WaitUntilTime"), 13}, 0}, 21 },
      {{{OSUTF8("Waypoint"), 8}, 0}, 22 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 23, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* CompositeWaypoint */
      pvalue->u.compositeWaypoint
          = rtxMemAllocType (pctxt, UsvCompositeWaypointCommandType);

      if (pvalue->u.compositeWaypoint == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UsvCompositeWaypointCommandType (pvalue->u.compositeWaypoint);

      stat = XmlDec_UsvCompositeWaypointCommandType (pctxt, pvalue->
         u.compositeWaypoint);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* FollowBeacon */
      pvalue->u.followBeacon
          = rtxMemAllocType (pctxt, FollowBeaconCommandType);

      if (pvalue->u.followBeacon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_FollowBeaconCommandType (pvalue->u.followBeacon);

      stat = XmlDec_FollowBeaconCommandType (pctxt, pvalue->u.followBeacon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* Help */
      pvalue->u.help = rtxMemAllocType (pctxt, NoValueElementType);

      if (pvalue->u.help == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NoValueElementType (pvalue->u.help);

      stat = XmlDec_NoValueElementType (pctxt, pvalue->u.help);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* Loiter */
      pvalue->u.loiter = rtxMemAllocType (pctxt, UsvLoiterCommandType);

      if (pvalue->u.loiter == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UsvLoiterCommandType (pvalue->u.loiter);

      stat = XmlDec_UsvLoiterCommandType (pctxt, pvalue->u.loiter);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* MakeHeading */
      pvalue->u.makeHeading = rtxMemAllocType (pctxt, HeadingElementType);

      if (pvalue->u.makeHeading == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HeadingElementType (pvalue->u.makeHeading);

      stat = XmlDec_HeadingElementType (pctxt, pvalue->u.makeHeading);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* MakeKnots */
      pvalue->u.makeKnots = rtxMemAllocType (pctxt, SpeedElementType);

      if (pvalue->u.makeKnots == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SpeedElementType (pvalue->u.makeKnots);

      stat = XmlDec_SpeedElementType (pctxt, pvalue->u.makeKnots);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* MakeSpeed */
      pvalue->u.makeSpeed = rtxMemAllocType (pctxt, SpeedElementType);

      if (pvalue->u.makeSpeed == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SpeedElementType (pvalue->u.makeSpeed);

      stat = XmlDec_SpeedElementType (pctxt, pvalue->u.makeSpeed);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* MetaCommand */
      pvalue->u.metaCommand = rtxMemAllocType (pctxt, MetaDataType);

      if (pvalue->u.metaCommand == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MetaDataType (pvalue->u.metaCommand);

      stat = XmlDec_MetaDataType (pctxt, pvalue->u.metaCommand);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* MissionScript */
      pvalue->u.missionScript = rtxMemAllocType (pctxt, StringElementType);

      if (pvalue->u.missionScript == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_StringElementType (pvalue->u.missionScript);

      stat = XmlDec_StringElementType (pctxt, pvalue->u.missionScript);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* MissionScriptInline */
      pvalue->u.missionScriptInline
          = rtxMemAllocType (pctxt, StringElementType);

      if (pvalue->u.missionScriptInline == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_StringElementType (pvalue->u.missionScriptInline);

      stat = XmlDec_StringElementType (pctxt, pvalue->u.missionScriptInline);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* Quit */
      pvalue->u.quit = rtxMemAllocType (pctxt, QuitCommandType);

      if (pvalue->u.quit == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QuitCommandType (pvalue->u.quit);

      stat = XmlDec_QuitCommandType (pctxt, pvalue->u.quit);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* Realtime */
      pvalue->u.realtime
          = rtxMemAllocType (pctxt, BooleanElementType_derivations);

      if (pvalue->u.realtime == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BooleanElementType_derivations (pvalue->u.realtime);

      stat = XmlDec_BooleanElementType_derivations (pctxt, pvalue->u.realtime
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* SendMessage */
      pvalue->u.sendMessage = rtxMemAllocType (pctxt, SendMessageCommandType);

      if (pvalue->u.sendMessage == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SendMessageCommandType (pvalue->u.sendMessage);

      stat = XmlDec_SendMessageCommandType (pctxt, pvalue->u.sendMessage);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* SetPosition */
      pvalue->u.setPosition = rtxMemAllocType (pctxt, UsvPositionCommandType);

      if (pvalue->u.setPosition == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UsvPositionCommandType (pvalue->u.setPosition);

      stat = XmlDec_UsvPositionCommandType (pctxt, pvalue->u.setPosition);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* SetPower */
      pvalue->u.setPower = rtxMemAllocType (pctxt, SetPropellerCommandType);

      if (pvalue->u.setPower == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SetPropellerCommandType (pvalue->u.setPower);

      stat = XmlDec_SetPropellerCommandType (pctxt, pvalue->u.setPower);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* SetRudder */
      pvalue->u.setRudder = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.setRudder == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.setRudder);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->u.setRudder);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* SetStandoff */
      pvalue->u.setStandoff
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.setStandoff == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.setStandoff);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.setStandoff);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 17: { /* SetTime */
      pvalue->u.setTime = rtxMemAllocType (pctxt, ScalarElementType);

      if (pvalue->u.setTime == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ScalarElementType (pvalue->u.setTime);

      stat = XmlDec_ScalarElementType (pctxt, pvalue->u.setTime);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 18: { /* SetTimeStep */
      pvalue->u.setTimeStep
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.setTimeStep == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.setTimeStep);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.setTimeStep);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 19: { /* Trace */
      pvalue->u.trace
          = rtxMemAllocType (pctxt, BooleanElementType_derivations);

      if (pvalue->u.trace == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BooleanElementType_derivations (pvalue->u.trace);

      stat = XmlDec_BooleanElementType_derivations (pctxt, pvalue->u.trace);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 20: { /* Wait */
      pvalue->u.wait
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.wait == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.wait);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.wait);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 21: { /* WaitUntilTime */
      pvalue->u.waitUntilTime
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.waitUntilTime == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.waitUntilTime
         );

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.waitUntilTime);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 22: { /* Waypoint */
      pvalue->u.waypoint = rtxMemAllocType (pctxt, UsvWaypointCommandType);

      if (pvalue->u.waypoint == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UsvWaypointCommandType (pvalue->u.waypoint);

      stat = XmlDec_UsvWaypointCommandType (pctxt, pvalue->u.waypoint);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UsvScriptCommandsType                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UsvScriptCommandsType (OSCTXT* pctxt, 
   UsvScriptCommandsType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               UsvScriptCommandsType_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, UsvScriptCommandsType_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_UsvScriptCommandsType_element (pdata2);

                  stat = asn1D_UsvScriptCommandsType_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

               if (!(pvalue->choice_list.count >= 1U)) {
                  rtxErrAddStrParm (pctxt, "UsvScriptCommandsType.choice_list.count");
                  rtxErrAddIntParm (pctxt, (int)pvalue->choice_list.count);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UsvScriptCommandsType (OSCTXT* pctxt, UsvScriptCommandsType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UsvScriptCommandsType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UsvScriptCommandsType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("CompositeWaypoint"), 17}, 0}, 0 },
      {{{OSUTF8("FollowBeacon"), 12}, 0}, 0 },
      {{{OSUTF8("Help"), 4}, 0}, 0 },
      {{{OSUTF8("Loiter"), 6}, 0}, 0 },
      {{{OSUTF8("MakeHeading"), 11}, 0}, 0 },
      {{{OSUTF8("MakeKnots"), 9}, 0}, 0 },
      {{{OSUTF8("MakeSpeed"), 9}, 0}, 0 },
      {{{OSUTF8("MetaCommand"), 11}, 0}, 0 },
      {{{OSUTF8("MissionScript"), 13}, 0}, 0 },
      {{{OSUTF8("MissionScriptInline"), 19}, 0}, 0 },
      {{{OSUTF8("Quit"), 4}, 0}, 0 },
      {{{OSUTF8("Realtime"), 8}, 0}, 0 },
      {{{OSUTF8("SendMessage"), 11}, 0}, 0 },
      {{{OSUTF8("SetPosition"), 11}, 0}, 0 },
      {{{OSUTF8("SetPower"), 8}, 0}, 0 },
      {{{OSUTF8("SetRudder"), 9}, 0}, 0 },
      {{{OSUTF8("SetStandoff"), 11}, 0}, 0 },
      {{{OSUTF8("SetTime"), 7}, 0}, 0 },
      {{{OSUTF8("SetTimeStep"), 11}, 0}, 0 },
      {{{OSUTF8("Trace"), 5}, 0}, 0 },
      {{{OSUTF8("Wait"), 4}, 0}, 0 },
      {{{OSUTF8("WaitUntilTime"), 13}, 0}, 0 },
      {{{OSUTF8("Waypoint"), 8}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 23, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         UsvScriptCommandsType_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, UsvScriptCommandsType_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UsvScriptCommandsType_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_UsvScriptCommandsType_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 23, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UgvCompositeWaypointCommandType                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UgvCompositeWaypointCommandType (OSCTXT* pctxt, 
   UgvCompositeWaypointCommandType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CompositeWaypointElements (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode homingMode */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_TrackModeElementType (pctxt, 
               &pvalue->homingMode, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.homingModePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode choice_1 */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SpeedTypeElements (pctxt, 
               &pvalue->choice_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choice_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode standoff */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->standoff, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.standoffPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode timeOut */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->timeOut, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeOutPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UgvCompositeWaypointCommandType (OSCTXT* pctxt, 
   UgvCompositeWaypointCommandType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UgvCompositeWaypointCommandType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UgvCompositeWaypointCommandType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("WaypointList"), 12}, 0}, 0 },
      {{{OSUTF8("ParallelTrack"), 13}, 0}, 0 },
      {{{OSUTF8("SectorPattern"), 13}, 0}, 0 },
      {{{OSUTF8("ExpandingSquare"), 15}, 0}, 0 },
      {{{OSUTF8("HomingMode"), 10}, 0}, 1 },
      {{{OSUTF8("Speed"), 5}, 0}, 2 },
      {{{OSUTF8("Knots"), 5}, 0}, 2 },
      {{{OSUTF8("Standoff"), 8}, 0}, 3 },
      {{{OSUTF8("TimeOut"), 7}, 0}, 4 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}, {4, 5, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 5; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_CompositeWaypointElements (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* HomingMode */
         stat = XmlDec_TrackModeElementType (pctxt, &pvalue->homingMode);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.homingModePresent = TRUE;
         break;
      }
      case 2: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_SpeedTypeElements (pctxt, &pvalue->choice_1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choice_1Present = TRUE;
         break;
      }
      case 3: { /* Standoff */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            standoff);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.standoffPresent = TRUE;
         break;
      }
      case 4: { /* TimeOut */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            timeOut);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.timeOutPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UgvLoiterCommandType                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UgvLoiterCommandType (OSCTXT* pctxt, 
   UgvLoiterCommandType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_HorizontalPositionElements (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choicePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode choice_1 */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SpeedTypeElements (pctxt, 
               &pvalue->choice_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choice_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode timeOut */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->timeOut, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeOutPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UgvLoiterCommandType (OSCTXT* pctxt, UgvLoiterCommandType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UgvLoiterCommandType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UgvLoiterCommandType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("LatitudeLongitude"), 17}, 0}, 0 },
      {{{OSUTF8("XYPosition"), 10}, 0}, 0 },
      {{{OSUTF8("RelativeXYPosition"), 18}, 0}, 0 },
      {{{OSUTF8("Speed"), 5}, 0}, 1 },
      {{{OSUTF8("Knots"), 5}, 0}, 1 },
      {{{OSUTF8("TimeOut"), 7}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 6, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_HorizontalPositionElements (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choicePresent = TRUE;
         break;
      }
      case 1: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_SpeedTypeElements (pctxt, &pvalue->choice_1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choice_1Present = TRUE;
         break;
      }
      case 2: { /* TimeOut */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            timeOut);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.timeOutPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UgvPositionCommandType                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UgvPositionCommandType (OSCTXT* pctxt, 
   UgvPositionCommandType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AbsoluteHorizontalPositionElements (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UgvPositionCommandType (OSCTXT* pctxt, 
   UgvPositionCommandType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UgvPositionCommandType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UgvPositionCommandType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("LatitudeLongitude"), 17}, 0}, 0 },
      {{{OSUTF8("XYPosition"), 10}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}, {2, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_AbsoluteHorizontalPositionElements (pctxt, &pvalue->
            choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UgvWaypointCommandType                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UgvWaypointCommandType (OSCTXT* pctxt, 
   UgvWaypointCommandType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_HorizontalPositionElements (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode choice_1 */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SpeedTypeElements (pctxt, 
               &pvalue->choice_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choice_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode homingMode */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_TrackModeElementType (pctxt, 
               &pvalue->homingMode, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.homingModePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode standoff */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->standoff, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.standoffPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode timeOut */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->timeOut, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeOutPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UgvWaypointCommandType (OSCTXT* pctxt, 
   UgvWaypointCommandType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UgvWaypointCommandType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UgvWaypointCommandType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("LatitudeLongitude"), 17}, 0}, 0 },
      {{{OSUTF8("XYPosition"), 10}, 0}, 0 },
      {{{OSUTF8("RelativeXYPosition"), 18}, 0}, 0 },
      {{{OSUTF8("Speed"), 5}, 0}, 1 },
      {{{OSUTF8("Knots"), 5}, 0}, 1 },
      {{{OSUTF8("HomingMode"), 10}, 0}, 2 },
      {{{OSUTF8("Standoff"), 8}, 0}, 3 },
      {{{OSUTF8("TimeOut"), 7}, 0}, 4 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}, {3, 5, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 5; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_HorizontalPositionElements (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_SpeedTypeElements (pctxt, &pvalue->choice_1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choice_1Present = TRUE;
         break;
      }
      case 2: { /* HomingMode */
         stat = XmlDec_TrackModeElementType (pctxt, &pvalue->homingMode);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.homingModePresent = TRUE;
         break;
      }
      case 3: { /* Standoff */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            standoff);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.standoffPresent = TRUE;
         break;
      }
      case 4: { /* TimeOut */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            timeOut);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.timeOutPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UgvScriptCommandsType_element                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UgvScriptCommandsType_element (OSCTXT* pctxt, 
   UgvScriptCommandsType_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.compositeWaypoint
             = rtxMemAllocType (pctxt, UgvCompositeWaypointCommandType);

         if (pvalue->u.compositeWaypoint == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UgvCompositeWaypointCommandType (pvalue->u.compositeWaypoint);
         stat = asn1D_UgvCompositeWaypointCommandType (pctxt, 
            pvalue->u.compositeWaypoint, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.followBeacon
             = rtxMemAllocType (pctxt, FollowBeaconCommandType);

         if (pvalue->u.followBeacon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_FollowBeaconCommandType (pvalue->u.followBeacon);
         stat = asn1D_FollowBeaconCommandType (pctxt, 
            pvalue->u.followBeacon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.help = rtxMemAllocType (pctxt, NoValueElementType);

         if (pvalue->u.help == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NoValueElementType (pvalue->u.help);
         stat = asn1D_NoValueElementType (pctxt, 
            pvalue->u.help, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.loiter = rtxMemAllocType (pctxt, UgvLoiterCommandType);

         if (pvalue->u.loiter == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UgvLoiterCommandType (pvalue->u.loiter);
         stat = asn1D_UgvLoiterCommandType (pctxt, 
            pvalue->u.loiter, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.makeHeading = rtxMemAllocType (pctxt, HeadingElementType);

         if (pvalue->u.makeHeading == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_HeadingElementType (pvalue->u.makeHeading);
         stat = asn1D_HeadingElementType (pctxt, 
            pvalue->u.makeHeading, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.makeKnots
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.makeKnots == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeKnots);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.makeKnots, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.makeSpeed
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.makeSpeed == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeSpeed);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.makeSpeed, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.metaCommand = rtxMemAllocType (pctxt, MetaDataType);

         if (pvalue->u.metaCommand == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MetaDataType (pvalue->u.metaCommand);
         stat = asn1D_MetaDataType (pctxt, 
            pvalue->u.metaCommand, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.missionScript = rtxMemAllocType (pctxt, StringElementType);

         if (pvalue->u.missionScript == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_StringElementType (pvalue->u.missionScript);
         stat = asn1D_StringElementType (pctxt, 
            pvalue->u.missionScript, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.missionScriptInline
             = rtxMemAllocType (pctxt, StringElementType);

         if (pvalue->u.missionScriptInline == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_StringElementType (pvalue->u.missionScriptInline);
         stat = asn1D_StringElementType (pctxt, 
            pvalue->u.missionScriptInline, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.quit = rtxMemAllocType (pctxt, QuitCommandType);

         if (pvalue->u.quit == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_QuitCommandType (pvalue->u.quit);
         stat = asn1D_QuitCommandType (pctxt, 
            pvalue->u.quit, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.realtime
             = rtxMemAllocType (pctxt, BooleanElementType_derivations);

         if (pvalue->u.realtime == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_BooleanElementType_derivations (pvalue->u.realtime);
         stat = asn1D_BooleanElementType_derivations (pctxt, 
            pvalue->u.realtime, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.sendMessage
             = rtxMemAllocType (pctxt, SendMessageCommandType);

         if (pvalue->u.sendMessage == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SendMessageCommandType (pvalue->u.sendMessage);
         stat = asn1D_SendMessageCommandType (pctxt, 
            pvalue->u.sendMessage, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.setPosition
             = rtxMemAllocType (pctxt, UgvPositionCommandType);

         if (pvalue->u.setPosition == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UgvPositionCommandType (pvalue->u.setPosition);
         stat = asn1D_UgvPositionCommandType (pctxt, 
            pvalue->u.setPosition, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.setStandoff
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.setStandoff == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.setStandoff);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.setStandoff, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.setTime = rtxMemAllocType (pctxt, ScalarElementType);

         if (pvalue->u.setTime == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ScalarElementType (pvalue->u.setTime);
         stat = asn1D_ScalarElementType (pctxt, 
            pvalue->u.setTime, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.setTimeStep
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.setTimeStep == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.setTimeStep);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.setTimeStep, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      case (TM_CTXT|TM_CONS|17):
         pvalue->u.trace
             = rtxMemAllocType (pctxt, BooleanElementType_derivations);

         if (pvalue->u.trace == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_BooleanElementType_derivations (pvalue->u.trace);
         stat = asn1D_BooleanElementType_derivations (pctxt, 
            pvalue->u.trace, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 18;
         break;

      case (TM_CTXT|TM_CONS|18):
         pvalue->u.wait
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.wait == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.wait);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.wait, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 19;
         break;

      case (TM_CTXT|TM_CONS|19):
         pvalue->u.waitUntilTime
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.waitUntilTime == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.waitUntilTime);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.waitUntilTime, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 20;
         break;

      case (TM_CTXT|TM_CONS|20):
         pvalue->u.waypoint = rtxMemAllocType (pctxt, UgvWaypointCommandType);

         if (pvalue->u.waypoint == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UgvWaypointCommandType (pvalue->u.waypoint);
         stat = asn1D_UgvWaypointCommandType (pctxt, 
            pvalue->u.waypoint, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 21;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_UgvScriptCommandsType_element (OSCTXT* pctxt, 
   UgvScriptCommandsType_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("CompositeWaypoint"), 17}, 0}, 0 },
      {{{OSUTF8("FollowBeacon"), 12}, 0}, 1 },
      {{{OSUTF8("Help"), 4}, 0}, 2 },
      {{{OSUTF8("Loiter"), 6}, 0}, 3 },
      {{{OSUTF8("MakeHeading"), 11}, 0}, 4 },
      {{{OSUTF8("MakeKnots"), 9}, 0}, 5 },
      {{{OSUTF8("MakeSpeed"), 9}, 0}, 6 },
      {{{OSUTF8("MetaCommand"), 11}, 0}, 7 },
      {{{OSUTF8("MissionScript"), 13}, 0}, 8 },
      {{{OSUTF8("MissionScriptInline"), 19}, 0}, 9 },
      {{{OSUTF8("Quit"), 4}, 0}, 10 },
      {{{OSUTF8("Realtime"), 8}, 0}, 11 },
      {{{OSUTF8("SendMessage"), 11}, 0}, 12 },
      {{{OSUTF8("SetPosition"), 11}, 0}, 13 },
      {{{OSUTF8("SetStandoff"), 11}, 0}, 14 },
      {{{OSUTF8("SetTime"), 7}, 0}, 15 },
      {{{OSUTF8("SetTimeStep"), 11}, 0}, 16 },
      {{{OSUTF8("Trace"), 5}, 0}, 17 },
      {{{OSUTF8("Wait"), 4}, 0}, 18 },
      {{{OSUTF8("WaitUntilTime"), 13}, 0}, 19 },
      {{{OSUTF8("Waypoint"), 8}, 0}, 20 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 21, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* CompositeWaypoint */
      pvalue->u.compositeWaypoint
          = rtxMemAllocType (pctxt, UgvCompositeWaypointCommandType);

      if (pvalue->u.compositeWaypoint == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UgvCompositeWaypointCommandType (pvalue->u.compositeWaypoint);

      stat = XmlDec_UgvCompositeWaypointCommandType (pctxt, pvalue->
         u.compositeWaypoint);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* FollowBeacon */
      pvalue->u.followBeacon
          = rtxMemAllocType (pctxt, FollowBeaconCommandType);

      if (pvalue->u.followBeacon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_FollowBeaconCommandType (pvalue->u.followBeacon);

      stat = XmlDec_FollowBeaconCommandType (pctxt, pvalue->u.followBeacon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* Help */
      pvalue->u.help = rtxMemAllocType (pctxt, NoValueElementType);

      if (pvalue->u.help == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NoValueElementType (pvalue->u.help);

      stat = XmlDec_NoValueElementType (pctxt, pvalue->u.help);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* Loiter */
      pvalue->u.loiter = rtxMemAllocType (pctxt, UgvLoiterCommandType);

      if (pvalue->u.loiter == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UgvLoiterCommandType (pvalue->u.loiter);

      stat = XmlDec_UgvLoiterCommandType (pctxt, pvalue->u.loiter);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* MakeHeading */
      pvalue->u.makeHeading = rtxMemAllocType (pctxt, HeadingElementType);

      if (pvalue->u.makeHeading == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HeadingElementType (pvalue->u.makeHeading);

      stat = XmlDec_HeadingElementType (pctxt, pvalue->u.makeHeading);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* MakeKnots */
      pvalue->u.makeKnots
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.makeKnots == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeKnots);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.makeKnots);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* MakeSpeed */
      pvalue->u.makeSpeed
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.makeSpeed == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeSpeed);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.makeSpeed);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* MetaCommand */
      pvalue->u.metaCommand = rtxMemAllocType (pctxt, MetaDataType);

      if (pvalue->u.metaCommand == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MetaDataType (pvalue->u.metaCommand);

      stat = XmlDec_MetaDataType (pctxt, pvalue->u.metaCommand);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* MissionScript */
      pvalue->u.missionScript = rtxMemAllocType (pctxt, StringElementType);

      if (pvalue->u.missionScript == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_StringElementType (pvalue->u.missionScript);

      stat = XmlDec_StringElementType (pctxt, pvalue->u.missionScript);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* MissionScriptInline */
      pvalue->u.missionScriptInline
          = rtxMemAllocType (pctxt, StringElementType);

      if (pvalue->u.missionScriptInline == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_StringElementType (pvalue->u.missionScriptInline);

      stat = XmlDec_StringElementType (pctxt, pvalue->u.missionScriptInline);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* Quit */
      pvalue->u.quit = rtxMemAllocType (pctxt, QuitCommandType);

      if (pvalue->u.quit == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QuitCommandType (pvalue->u.quit);

      stat = XmlDec_QuitCommandType (pctxt, pvalue->u.quit);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* Realtime */
      pvalue->u.realtime
          = rtxMemAllocType (pctxt, BooleanElementType_derivations);

      if (pvalue->u.realtime == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BooleanElementType_derivations (pvalue->u.realtime);

      stat = XmlDec_BooleanElementType_derivations (pctxt, pvalue->u.realtime
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* SendMessage */
      pvalue->u.sendMessage = rtxMemAllocType (pctxt, SendMessageCommandType);

      if (pvalue->u.sendMessage == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SendMessageCommandType (pvalue->u.sendMessage);

      stat = XmlDec_SendMessageCommandType (pctxt, pvalue->u.sendMessage);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* SetPosition */
      pvalue->u.setPosition = rtxMemAllocType (pctxt, UgvPositionCommandType);

      if (pvalue->u.setPosition == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UgvPositionCommandType (pvalue->u.setPosition);

      stat = XmlDec_UgvPositionCommandType (pctxt, pvalue->u.setPosition);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* SetStandoff */
      pvalue->u.setStandoff
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.setStandoff == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.setStandoff);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.setStandoff);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* SetTime */
      pvalue->u.setTime = rtxMemAllocType (pctxt, ScalarElementType);

      if (pvalue->u.setTime == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ScalarElementType (pvalue->u.setTime);

      stat = XmlDec_ScalarElementType (pctxt, pvalue->u.setTime);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* SetTimeStep */
      pvalue->u.setTimeStep
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.setTimeStep == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.setTimeStep);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.setTimeStep);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 17: { /* Trace */
      pvalue->u.trace
          = rtxMemAllocType (pctxt, BooleanElementType_derivations);

      if (pvalue->u.trace == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BooleanElementType_derivations (pvalue->u.trace);

      stat = XmlDec_BooleanElementType_derivations (pctxt, pvalue->u.trace);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 18: { /* Wait */
      pvalue->u.wait
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.wait == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.wait);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.wait);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 19: { /* WaitUntilTime */
      pvalue->u.waitUntilTime
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.waitUntilTime == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.waitUntilTime
         );

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.waitUntilTime);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 20: { /* Waypoint */
      pvalue->u.waypoint = rtxMemAllocType (pctxt, UgvWaypointCommandType);

      if (pvalue->u.waypoint == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UgvWaypointCommandType (pvalue->u.waypoint);

      stat = XmlDec_UgvWaypointCommandType (pctxt, pvalue->u.waypoint);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UgvScriptCommandsType                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UgvScriptCommandsType (OSCTXT* pctxt, 
   UgvScriptCommandsType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               UgvScriptCommandsType_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, UgvScriptCommandsType_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_UgvScriptCommandsType_element (pdata2);

                  stat = asn1D_UgvScriptCommandsType_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

               if (!(pvalue->choice_list.count >= 1U)) {
                  rtxErrAddStrParm (pctxt, "UgvScriptCommandsType.choice_list.count");
                  rtxErrAddIntParm (pctxt, (int)pvalue->choice_list.count);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UgvScriptCommandsType (OSCTXT* pctxt, UgvScriptCommandsType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UgvScriptCommandsType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UgvScriptCommandsType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("CompositeWaypoint"), 17}, 0}, 0 },
      {{{OSUTF8("FollowBeacon"), 12}, 0}, 0 },
      {{{OSUTF8("Help"), 4}, 0}, 0 },
      {{{OSUTF8("Loiter"), 6}, 0}, 0 },
      {{{OSUTF8("MakeHeading"), 11}, 0}, 0 },
      {{{OSUTF8("MakeKnots"), 9}, 0}, 0 },
      {{{OSUTF8("MakeSpeed"), 9}, 0}, 0 },
      {{{OSUTF8("MetaCommand"), 11}, 0}, 0 },
      {{{OSUTF8("MissionScript"), 13}, 0}, 0 },
      {{{OSUTF8("MissionScriptInline"), 19}, 0}, 0 },
      {{{OSUTF8("Quit"), 4}, 0}, 0 },
      {{{OSUTF8("Realtime"), 8}, 0}, 0 },
      {{{OSUTF8("SendMessage"), 11}, 0}, 0 },
      {{{OSUTF8("SetPosition"), 11}, 0}, 0 },
      {{{OSUTF8("SetStandoff"), 11}, 0}, 0 },
      {{{OSUTF8("SetTime"), 7}, 0}, 0 },
      {{{OSUTF8("SetTimeStep"), 11}, 0}, 0 },
      {{{OSUTF8("Trace"), 5}, 0}, 0 },
      {{{OSUTF8("Wait"), 4}, 0}, 0 },
      {{{OSUTF8("WaitUntilTime"), 13}, 0}, 0 },
      {{{OSUTF8("Waypoint"), 8}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 21, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         UgvScriptCommandsType_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, UgvScriptCommandsType_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UgvScriptCommandsType_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_UgvScriptCommandsType_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 21, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AltitudeTypeElements                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AltitudeTypeElements (OSCTXT* pctxt, 
   AltitudeTypeElements *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.aGLAltitude
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.aGLAltitude == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.aGLAltitude);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.aGLAltitude, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.mSLAltitude
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.mSLAltitude == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.mSLAltitude);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.mSLAltitude, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_AltitudeTypeElements (OSCTXT* pctxt, AltitudeTypeElements* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("AGLAltitude"), 11}, 0}, 0 },
      {{{OSUTF8("MSLAltitude"), 11}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* AGLAltitude */
      pvalue->u.aGLAltitude
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.aGLAltitude == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.aGLAltitude);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.aGLAltitude);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* MSLAltitude */
      pvalue->u.mSLAltitude
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.mSLAltitude == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.mSLAltitude);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.mSLAltitude);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UavCompositeWaypointCommandType                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UavCompositeWaypointCommandType (OSCTXT* pctxt, 
   UavCompositeWaypointCommandType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CompositeWaypointElements (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode choice_1 */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AltitudeTypeElements (pctxt, 
               &pvalue->choice_1, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode homingMode */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_TrackModeElementType (pctxt, 
               &pvalue->homingMode, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.homingModePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode choice_2 */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SpeedTypeElements (pctxt, 
               &pvalue->choice_2, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choice_2Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode standoff */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->standoff, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.standoffPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode timeOut */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->timeOut, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeOutPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UavCompositeWaypointCommandType (OSCTXT* pctxt, 
   UavCompositeWaypointCommandType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UavCompositeWaypointCommandType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UavCompositeWaypointCommandType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("WaypointList"), 12}, 0}, 0 },
      {{{OSUTF8("ParallelTrack"), 13}, 0}, 0 },
      {{{OSUTF8("SectorPattern"), 13}, 0}, 0 },
      {{{OSUTF8("ExpandingSquare"), 15}, 0}, 0 },
      {{{OSUTF8("AGLAltitude"), 11}, 0}, 1 },
      {{{OSUTF8("MSLAltitude"), 11}, 0}, 1 },
      {{{OSUTF8("HomingMode"), 10}, 0}, 2 },
      {{{OSUTF8("Speed"), 5}, 0}, 3 },
      {{{OSUTF8("Knots"), 5}, 0}, 3 },
      {{{OSUTF8("Standoff"), 8}, 0}, 4 },
      {{{OSUTF8("TimeOut"), 7}, 0}, 5 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}, {4, 2, -1}, {6, 5, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 6; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_CompositeWaypointElements (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_AltitudeTypeElements (pctxt, &pvalue->choice_1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 2: { /* HomingMode */
         stat = XmlDec_TrackModeElementType (pctxt, &pvalue->homingMode);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.homingModePresent = TRUE;
         break;
      }
      case 3: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_SpeedTypeElements (pctxt, &pvalue->choice_2);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choice_2Present = TRUE;
         break;
      }
      case 4: { /* Standoff */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            standoff);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.standoffPresent = TRUE;
         break;
      }
      case 5: { /* TimeOut */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            timeOut);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.timeOutPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UavLoiterCommandType                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UavLoiterCommandType (OSCTXT* pctxt, 
   UavLoiterCommandType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_HorizontalPositionElements (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choicePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode choice_1 */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SpeedTypeElements (pctxt, 
               &pvalue->choice_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choice_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode choice_2 */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AltitudeTypeElements (pctxt, 
               &pvalue->choice_2, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choice_2Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode loiterAltitude */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->loiterAltitude, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode timeOut */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->timeOut, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeOutPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UavLoiterCommandType (OSCTXT* pctxt, UavLoiterCommandType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UavLoiterCommandType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UavLoiterCommandType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("LatitudeLongitude"), 17}, 0}, 0 },
      {{{OSUTF8("XYPosition"), 10}, 0}, 0 },
      {{{OSUTF8("RelativeXYPosition"), 18}, 0}, 0 },
      {{{OSUTF8("Speed"), 5}, 0}, 1 },
      {{{OSUTF8("Knots"), 5}, 0}, 1 },
      {{{OSUTF8("AGLAltitude"), 11}, 0}, 2 },
      {{{OSUTF8("MSLAltitude"), 11}, 0}, 2 },
      {{{OSUTF8("LoiterAltitude"), 14}, 0}, 3 },
      {{{OSUTF8("TimeOut"), 7}, 0}, 4 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 8, -1}, {8, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 5; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_HorizontalPositionElements (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choicePresent = TRUE;
         break;
      }
      case 1: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_SpeedTypeElements (pctxt, &pvalue->choice_1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choice_1Present = TRUE;
         break;
      }
      case 2: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_AltitudeTypeElements (pctxt, &pvalue->choice_2);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choice_2Present = TRUE;
         break;
      }
      case 3: { /* LoiterAltitude */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            loiterAltitude);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 4: { /* TimeOut */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            timeOut);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.timeOutPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UavPositionCommandType                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UavPositionCommandType (OSCTXT* pctxt, 
   UavPositionCommandType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AbsoluteHorizontalPositionElements (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode mSLAltitude */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_ScalarElementType (pctxt, 
               &pvalue->mSLAltitude, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mSLAltitudePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UavPositionCommandType (OSCTXT* pctxt, 
   UavPositionCommandType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UavPositionCommandType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UavPositionCommandType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("LatitudeLongitude"), 17}, 0}, 0 },
      {{{OSUTF8("XYPosition"), 10}, 0}, 0 },
      {{{OSUTF8("MSLAltitude"), 11}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}, {2, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_AbsoluteHorizontalPositionElements (pctxt, &pvalue->
            choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* MSLAltitude */
         stat = XmlDec_ScalarElementType (pctxt, &pvalue->mSLAltitude);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.mSLAltitudePresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PercentType                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PercentType (OSCTXT* pctxt, PercentType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_real (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_PercentType (OSCTXT* pctxt, PercentType* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDouble (pctxt, pvalue, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PercentElementType                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PercentElementType (OSCTXT* pctxt, 
   PercentElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PercentType (pctxt, 
               &pvalue->value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PercentElementType (OSCTXT* pctxt, PercentElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 3: /* value */
            stat = XmlDec_PercentType (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "PercentElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "PercentElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UavWaypointCommandType                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UavWaypointCommandType (OSCTXT* pctxt, 
   UavWaypointCommandType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_HorizontalPositionElements (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode choice_1 */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AltitudeTypeElements (pctxt, 
               &pvalue->choice_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choice_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode homingMode */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_TrackModeElementType (pctxt, 
               &pvalue->homingMode, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.homingModePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode choice_2 */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SpeedTypeElements (pctxt, 
               &pvalue->choice_2, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choice_2Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode standoff */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->standoff, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.standoffPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode timeOut */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->timeOut, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeOutPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UavWaypointCommandType (OSCTXT* pctxt, 
   UavWaypointCommandType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UavWaypointCommandType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UavWaypointCommandType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("LatitudeLongitude"), 17}, 0}, 0 },
      {{{OSUTF8("XYPosition"), 10}, 0}, 0 },
      {{{OSUTF8("RelativeXYPosition"), 18}, 0}, 0 },
      {{{OSUTF8("AGLAltitude"), 11}, 0}, 1 },
      {{{OSUTF8("MSLAltitude"), 11}, 0}, 1 },
      {{{OSUTF8("HomingMode"), 10}, 0}, 2 },
      {{{OSUTF8("Speed"), 5}, 0}, 3 },
      {{{OSUTF8("Knots"), 5}, 0}, 3 },
      {{{OSUTF8("Standoff"), 8}, 0}, 4 },
      {{{OSUTF8("TimeOut"), 7}, 0}, 5 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}, {3, 7, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 6; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_HorizontalPositionElements (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_AltitudeTypeElements (pctxt, &pvalue->choice_1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choice_1Present = TRUE;
         break;
      }
      case 2: { /* HomingMode */
         stat = XmlDec_TrackModeElementType (pctxt, &pvalue->homingMode);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.homingModePresent = TRUE;
         break;
      }
      case 3: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_SpeedTypeElements (pctxt, &pvalue->choice_2);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choice_2Present = TRUE;
         break;
      }
      case 4: { /* Standoff */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            standoff);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.standoffPresent = TRUE;
         break;
      }
      case 5: { /* TimeOut */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            timeOut);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.timeOutPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UavScriptCommandsType_element                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UavScriptCommandsType_element (OSCTXT* pctxt, 
   UavScriptCommandsType_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.compositeWaypoint
             = rtxMemAllocType (pctxt, UavCompositeWaypointCommandType);

         if (pvalue->u.compositeWaypoint == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UavCompositeWaypointCommandType (pvalue->u.compositeWaypoint);
         stat = asn1D_UavCompositeWaypointCommandType (pctxt, 
            pvalue->u.compositeWaypoint, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.followBeacon
             = rtxMemAllocType (pctxt, FollowBeaconCommandType);

         if (pvalue->u.followBeacon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_FollowBeaconCommandType (pvalue->u.followBeacon);
         stat = asn1D_FollowBeaconCommandType (pctxt, 
            pvalue->u.followBeacon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.help = rtxMemAllocType (pctxt, NoValueElementType);

         if (pvalue->u.help == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NoValueElementType (pvalue->u.help);
         stat = asn1D_NoValueElementType (pctxt, 
            pvalue->u.help, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.loiter = rtxMemAllocType (pctxt, UavLoiterCommandType);

         if (pvalue->u.loiter == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UavLoiterCommandType (pvalue->u.loiter);
         stat = asn1D_UavLoiterCommandType (pctxt, 
            pvalue->u.loiter, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.makeAltitudeAGL
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.makeAltitudeAGL == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeAltitudeAGL);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.makeAltitudeAGL, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.makeAltitudeMSL
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.makeAltitudeMSL == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeAltitudeMSL);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.makeAltitudeMSL, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.makeClimbRate
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.makeClimbRate == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.makeClimbRate);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.makeClimbRate, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.makeHeading = rtxMemAllocType (pctxt, HeadingElementType);

         if (pvalue->u.makeHeading == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_HeadingElementType (pvalue->u.makeHeading);
         stat = asn1D_HeadingElementType (pctxt, 
            pvalue->u.makeHeading, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.makeKnots = rtxMemAllocType (pctxt, SpeedElementType);

         if (pvalue->u.makeKnots == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SpeedElementType (pvalue->u.makeKnots);
         stat = asn1D_SpeedElementType (pctxt, 
            pvalue->u.makeKnots, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.makeSpeed = rtxMemAllocType (pctxt, SpeedElementType);

         if (pvalue->u.makeSpeed == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SpeedElementType (pvalue->u.makeSpeed);
         stat = asn1D_SpeedElementType (pctxt, 
            pvalue->u.makeSpeed, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.makeTurnRate
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.makeTurnRate == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.makeTurnRate);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.makeTurnRate, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.metaCommand = rtxMemAllocType (pctxt, MetaDataType);

         if (pvalue->u.metaCommand == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MetaDataType (pvalue->u.metaCommand);
         stat = asn1D_MetaDataType (pctxt, 
            pvalue->u.metaCommand, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.missionScript = rtxMemAllocType (pctxt, StringElementType);

         if (pvalue->u.missionScript == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_StringElementType (pvalue->u.missionScript);
         stat = asn1D_StringElementType (pctxt, 
            pvalue->u.missionScript, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.missionScriptInline
             = rtxMemAllocType (pctxt, StringElementType);

         if (pvalue->u.missionScriptInline == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_StringElementType (pvalue->u.missionScriptInline);
         stat = asn1D_StringElementType (pctxt, 
            pvalue->u.missionScriptInline, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.quit = rtxMemAllocType (pctxt, QuitCommandType);

         if (pvalue->u.quit == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_QuitCommandType (pvalue->u.quit);
         stat = asn1D_QuitCommandType (pctxt, 
            pvalue->u.quit, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.realtime
             = rtxMemAllocType (pctxt, BooleanElementType_derivations);

         if (pvalue->u.realtime == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_BooleanElementType_derivations (pvalue->u.realtime);
         stat = asn1D_BooleanElementType_derivations (pctxt, 
            pvalue->u.realtime, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.sendMessage
             = rtxMemAllocType (pctxt, SendMessageCommandType);

         if (pvalue->u.sendMessage == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SendMessageCommandType (pvalue->u.sendMessage);
         stat = asn1D_SendMessageCommandType (pctxt, 
            pvalue->u.sendMessage, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      case (TM_CTXT|TM_CONS|17):
         pvalue->u.setAileron
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.setAileron == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.setAileron);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.setAileron, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 18;
         break;

      case (TM_CTXT|TM_CONS|18):
         pvalue->u.setElevator
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.setElevator == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.setElevator);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.setElevator, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 19;
         break;

      case (TM_CTXT|TM_CONS|19):
         pvalue->u.setPosition
             = rtxMemAllocType (pctxt, UavPositionCommandType);

         if (pvalue->u.setPosition == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UavPositionCommandType (pvalue->u.setPosition);
         stat = asn1D_UavPositionCommandType (pctxt, 
            pvalue->u.setPosition, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 20;
         break;

      case (TM_CTXT|TM_CONS|20):
         pvalue->u.setPower = rtxMemAllocType (pctxt, PercentElementType);

         if (pvalue->u.setPower == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PercentElementType (pvalue->u.setPower);
         stat = asn1D_PercentElementType (pctxt, 
            pvalue->u.setPower, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 21;
         break;

      case (TM_CTXT|TM_CONS|21):
         pvalue->u.setRudder
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.setRudder == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.setRudder);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.setRudder, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 22;
         break;

      case (TM_CTXT|TM_CONS|22):
         pvalue->u.setStandoff
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.setStandoff == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.setStandoff);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.setStandoff, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 23;
         break;

      case (TM_CTXT|TM_CONS|23):
         pvalue->u.setTime = rtxMemAllocType (pctxt, ScalarElementType);

         if (pvalue->u.setTime == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ScalarElementType (pvalue->u.setTime);
         stat = asn1D_ScalarElementType (pctxt, 
            pvalue->u.setTime, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 24;
         break;

      case (TM_CTXT|TM_CONS|24):
         pvalue->u.setTimeStep
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.setTimeStep == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.setTimeStep);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.setTimeStep, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 25;
         break;

      case (TM_CTXT|TM_CONS|25):
         pvalue->u.trace
             = rtxMemAllocType (pctxt, BooleanElementType_derivations);

         if (pvalue->u.trace == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_BooleanElementType_derivations (pvalue->u.trace);
         stat = asn1D_BooleanElementType_derivations (pctxt, 
            pvalue->u.trace, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 26;
         break;

      case (TM_CTXT|TM_CONS|26):
         pvalue->u.wait
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.wait == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.wait);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.wait, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 27;
         break;

      case (TM_CTXT|TM_CONS|27):
         pvalue->u.waitUntilTime
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.waitUntilTime == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.waitUntilTime);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.waitUntilTime, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 28;
         break;

      case (TM_CTXT|TM_CONS|28):
         pvalue->u.waypoint = rtxMemAllocType (pctxt, UavWaypointCommandType);

         if (pvalue->u.waypoint == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UavWaypointCommandType (pvalue->u.waypoint);
         stat = asn1D_UavWaypointCommandType (pctxt, 
            pvalue->u.waypoint, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 29;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_UavScriptCommandsType_element (OSCTXT* pctxt, 
   UavScriptCommandsType_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("CompositeWaypoint"), 17}, 0}, 0 },
      {{{OSUTF8("FollowBeacon"), 12}, 0}, 1 },
      {{{OSUTF8("Help"), 4}, 0}, 2 },
      {{{OSUTF8("Loiter"), 6}, 0}, 3 },
      {{{OSUTF8("MakeAltitudeAGL"), 15}, 0}, 4 },
      {{{OSUTF8("MakeAltitudeMSL"), 15}, 0}, 5 },
      {{{OSUTF8("MakeClimbRate"), 13}, 0}, 6 },
      {{{OSUTF8("MakeHeading"), 11}, 0}, 7 },
      {{{OSUTF8("MakeKnots"), 9}, 0}, 8 },
      {{{OSUTF8("MakeSpeed"), 9}, 0}, 9 },
      {{{OSUTF8("MakeTurnRate"), 12}, 0}, 10 },
      {{{OSUTF8("MetaCommand"), 11}, 0}, 11 },
      {{{OSUTF8("MissionScript"), 13}, 0}, 12 },
      {{{OSUTF8("MissionScriptInline"), 19}, 0}, 13 },
      {{{OSUTF8("Quit"), 4}, 0}, 14 },
      {{{OSUTF8("Realtime"), 8}, 0}, 15 },
      {{{OSUTF8("SendMessage"), 11}, 0}, 16 },
      {{{OSUTF8("SetAileron"), 10}, 0}, 17 },
      {{{OSUTF8("SetElevator"), 11}, 0}, 18 },
      {{{OSUTF8("SetPosition"), 11}, 0}, 19 },
      {{{OSUTF8("SetPower"), 8}, 0}, 20 },
      {{{OSUTF8("SetRudder"), 9}, 0}, 21 },
      {{{OSUTF8("SetStandoff"), 11}, 0}, 22 },
      {{{OSUTF8("SetTime"), 7}, 0}, 23 },
      {{{OSUTF8("SetTimeStep"), 11}, 0}, 24 },
      {{{OSUTF8("Trace"), 5}, 0}, 25 },
      {{{OSUTF8("Wait"), 4}, 0}, 26 },
      {{{OSUTF8("WaitUntilTime"), 13}, 0}, 27 },
      {{{OSUTF8("Waypoint"), 8}, 0}, 28 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 29, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* CompositeWaypoint */
      pvalue->u.compositeWaypoint
          = rtxMemAllocType (pctxt, UavCompositeWaypointCommandType);

      if (pvalue->u.compositeWaypoint == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UavCompositeWaypointCommandType (pvalue->u.compositeWaypoint);

      stat = XmlDec_UavCompositeWaypointCommandType (pctxt, pvalue->
         u.compositeWaypoint);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* FollowBeacon */
      pvalue->u.followBeacon
          = rtxMemAllocType (pctxt, FollowBeaconCommandType);

      if (pvalue->u.followBeacon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_FollowBeaconCommandType (pvalue->u.followBeacon);

      stat = XmlDec_FollowBeaconCommandType (pctxt, pvalue->u.followBeacon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* Help */
      pvalue->u.help = rtxMemAllocType (pctxt, NoValueElementType);

      if (pvalue->u.help == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NoValueElementType (pvalue->u.help);

      stat = XmlDec_NoValueElementType (pctxt, pvalue->u.help);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* Loiter */
      pvalue->u.loiter = rtxMemAllocType (pctxt, UavLoiterCommandType);

      if (pvalue->u.loiter == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UavLoiterCommandType (pvalue->u.loiter);

      stat = XmlDec_UavLoiterCommandType (pctxt, pvalue->u.loiter);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* MakeAltitudeAGL */
      pvalue->u.makeAltitudeAGL
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.makeAltitudeAGL == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeAltitudeAGL
         );

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.makeAltitudeAGL);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* MakeAltitudeMSL */
      pvalue->u.makeAltitudeMSL
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.makeAltitudeMSL == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeAltitudeMSL
         );

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.makeAltitudeMSL);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* MakeClimbRate */
      pvalue->u.makeClimbRate
          = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.makeClimbRate == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.makeClimbRate);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->u.makeClimbRate);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* MakeHeading */
      pvalue->u.makeHeading = rtxMemAllocType (pctxt, HeadingElementType);

      if (pvalue->u.makeHeading == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HeadingElementType (pvalue->u.makeHeading);

      stat = XmlDec_HeadingElementType (pctxt, pvalue->u.makeHeading);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* MakeKnots */
      pvalue->u.makeKnots = rtxMemAllocType (pctxt, SpeedElementType);

      if (pvalue->u.makeKnots == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SpeedElementType (pvalue->u.makeKnots);

      stat = XmlDec_SpeedElementType (pctxt, pvalue->u.makeKnots);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* MakeSpeed */
      pvalue->u.makeSpeed = rtxMemAllocType (pctxt, SpeedElementType);

      if (pvalue->u.makeSpeed == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SpeedElementType (pvalue->u.makeSpeed);

      stat = XmlDec_SpeedElementType (pctxt, pvalue->u.makeSpeed);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* MakeTurnRate */
      pvalue->u.makeTurnRate
          = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.makeTurnRate == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.makeTurnRate);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->u.makeTurnRate);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* MetaCommand */
      pvalue->u.metaCommand = rtxMemAllocType (pctxt, MetaDataType);

      if (pvalue->u.metaCommand == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MetaDataType (pvalue->u.metaCommand);

      stat = XmlDec_MetaDataType (pctxt, pvalue->u.metaCommand);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* MissionScript */
      pvalue->u.missionScript = rtxMemAllocType (pctxt, StringElementType);

      if (pvalue->u.missionScript == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_StringElementType (pvalue->u.missionScript);

      stat = XmlDec_StringElementType (pctxt, pvalue->u.missionScript);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* MissionScriptInline */
      pvalue->u.missionScriptInline
          = rtxMemAllocType (pctxt, StringElementType);

      if (pvalue->u.missionScriptInline == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_StringElementType (pvalue->u.missionScriptInline);

      stat = XmlDec_StringElementType (pctxt, pvalue->u.missionScriptInline);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* Quit */
      pvalue->u.quit = rtxMemAllocType (pctxt, QuitCommandType);

      if (pvalue->u.quit == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QuitCommandType (pvalue->u.quit);

      stat = XmlDec_QuitCommandType (pctxt, pvalue->u.quit);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* Realtime */
      pvalue->u.realtime
          = rtxMemAllocType (pctxt, BooleanElementType_derivations);

      if (pvalue->u.realtime == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BooleanElementType_derivations (pvalue->u.realtime);

      stat = XmlDec_BooleanElementType_derivations (pctxt, pvalue->u.realtime
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* SendMessage */
      pvalue->u.sendMessage = rtxMemAllocType (pctxt, SendMessageCommandType);

      if (pvalue->u.sendMessage == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SendMessageCommandType (pvalue->u.sendMessage);

      stat = XmlDec_SendMessageCommandType (pctxt, pvalue->u.sendMessage);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 17: { /* SetAileron */
      pvalue->u.setAileron
          = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.setAileron == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.setAileron);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->u.setAileron);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 18: { /* SetElevator */
      pvalue->u.setElevator
          = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.setElevator == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.setElevator);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->u.setElevator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 19: { /* SetPosition */
      pvalue->u.setPosition = rtxMemAllocType (pctxt, UavPositionCommandType);

      if (pvalue->u.setPosition == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UavPositionCommandType (pvalue->u.setPosition);

      stat = XmlDec_UavPositionCommandType (pctxt, pvalue->u.setPosition);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 20: { /* SetPower */
      pvalue->u.setPower = rtxMemAllocType (pctxt, PercentElementType);

      if (pvalue->u.setPower == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PercentElementType (pvalue->u.setPower);

      stat = XmlDec_PercentElementType (pctxt, pvalue->u.setPower);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 21: { /* SetRudder */
      pvalue->u.setRudder = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.setRudder == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.setRudder);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->u.setRudder);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 22: { /* SetStandoff */
      pvalue->u.setStandoff
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.setStandoff == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.setStandoff);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.setStandoff);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 23: { /* SetTime */
      pvalue->u.setTime = rtxMemAllocType (pctxt, ScalarElementType);

      if (pvalue->u.setTime == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ScalarElementType (pvalue->u.setTime);

      stat = XmlDec_ScalarElementType (pctxt, pvalue->u.setTime);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 24: { /* SetTimeStep */
      pvalue->u.setTimeStep
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.setTimeStep == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.setTimeStep);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.setTimeStep);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 25: { /* Trace */
      pvalue->u.trace
          = rtxMemAllocType (pctxt, BooleanElementType_derivations);

      if (pvalue->u.trace == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BooleanElementType_derivations (pvalue->u.trace);

      stat = XmlDec_BooleanElementType_derivations (pctxt, pvalue->u.trace);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 26: { /* Wait */
      pvalue->u.wait
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.wait == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.wait);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.wait);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 27: { /* WaitUntilTime */
      pvalue->u.waitUntilTime
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.waitUntilTime == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.waitUntilTime
         );

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.waitUntilTime);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 28: { /* Waypoint */
      pvalue->u.waypoint = rtxMemAllocType (pctxt, UavWaypointCommandType);

      if (pvalue->u.waypoint == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UavWaypointCommandType (pvalue->u.waypoint);

      stat = XmlDec_UavWaypointCommandType (pctxt, pvalue->u.waypoint);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UavScriptCommandsType                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UavScriptCommandsType (OSCTXT* pctxt, 
   UavScriptCommandsType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               UavScriptCommandsType_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, UavScriptCommandsType_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_UavScriptCommandsType_element (pdata2);

                  stat = asn1D_UavScriptCommandsType_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

               if (!(pvalue->choice_list.count >= 1U)) {
                  rtxErrAddStrParm (pctxt, "UavScriptCommandsType.choice_list.count");
                  rtxErrAddIntParm (pctxt, (int)pvalue->choice_list.count);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UavScriptCommandsType (OSCTXT* pctxt, UavScriptCommandsType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UavScriptCommandsType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UavScriptCommandsType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("CompositeWaypoint"), 17}, 0}, 0 },
      {{{OSUTF8("FollowBeacon"), 12}, 0}, 0 },
      {{{OSUTF8("Help"), 4}, 0}, 0 },
      {{{OSUTF8("Loiter"), 6}, 0}, 0 },
      {{{OSUTF8("MakeAltitudeAGL"), 15}, 0}, 0 },
      {{{OSUTF8("MakeAltitudeMSL"), 15}, 0}, 0 },
      {{{OSUTF8("MakeClimbRate"), 13}, 0}, 0 },
      {{{OSUTF8("MakeHeading"), 11}, 0}, 0 },
      {{{OSUTF8("MakeKnots"), 9}, 0}, 0 },
      {{{OSUTF8("MakeSpeed"), 9}, 0}, 0 },
      {{{OSUTF8("MakeTurnRate"), 12}, 0}, 0 },
      {{{OSUTF8("MetaCommand"), 11}, 0}, 0 },
      {{{OSUTF8("MissionScript"), 13}, 0}, 0 },
      {{{OSUTF8("MissionScriptInline"), 19}, 0}, 0 },
      {{{OSUTF8("Quit"), 4}, 0}, 0 },
      {{{OSUTF8("Realtime"), 8}, 0}, 0 },
      {{{OSUTF8("SendMessage"), 11}, 0}, 0 },
      {{{OSUTF8("SetAileron"), 10}, 0}, 0 },
      {{{OSUTF8("SetElevator"), 11}, 0}, 0 },
      {{{OSUTF8("SetPosition"), 11}, 0}, 0 },
      {{{OSUTF8("SetPower"), 8}, 0}, 0 },
      {{{OSUTF8("SetRudder"), 9}, 0}, 0 },
      {{{OSUTF8("SetStandoff"), 11}, 0}, 0 },
      {{{OSUTF8("SetTime"), 7}, 0}, 0 },
      {{{OSUTF8("SetTimeStep"), 11}, 0}, 0 },
      {{{OSUTF8("Trace"), 5}, 0}, 0 },
      {{{OSUTF8("Wait"), 4}, 0}, 0 },
      {{{OSUTF8("WaitUntilTime"), 13}, 0}, 0 },
      {{{OSUTF8("Waypoint"), 8}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 29, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         UavScriptCommandsType_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, UavScriptCommandsType_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UavScriptCommandsType_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_UavScriptCommandsType_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 29, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AbsoluteHorizontalPositionElementType                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AbsoluteHorizontalPositionElementType (OSCTXT* pctxt, 
   AbsoluteHorizontalPositionElementType *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AbsoluteHorizontalPositionElements (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_AbsoluteHorizontalPositionElementType (OSCTXT* pctxt, 
   AbsoluteHorizontalPositionElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "AbsoluteHorizontalPositionElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "AbsoluteHorizontalPositionElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("LatitudeLongitude"), 17}, 0}, 0 },
      {{{OSUTF8("XYPosition"), 10}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}, {2, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_AbsoluteHorizontalPositionElements (pctxt, &pvalue->
            choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  WeaponStatusType                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_WeaponStatusType (OSCTXT* pctxt, WeaponStatusType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if(*pvalue < 0 || *pvalue > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   return (stat);
}

int XmlDec_WeaponStatusType (OSCTXT* pctxt, WeaponStatusType* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = WeaponStatusType_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ActionObjectElementType                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ActionObjectElementType (OSCTXT* pctxt, 
   ActionObjectElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_ActionObjectElementType (OSCTXT* pctxt, 
   ActionObjectElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "ActionObjectElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "ActionObjectElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AttackElementType                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AttackElementType (OSCTXT* pctxt, AttackElementType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   pvalue->disableOnly = FALSE;
   pvalue->singleTarget = FALSE;

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode disableOnly */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->disableOnly, ASN1IMPL, length);
            if (stat == 0) {
            }
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode singleTarget */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->singleTarget, ASN1IMPL, length);
            if (stat == 0) {
            }
         }
         break;

      case 4:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode weaponStatus */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_WeaponStatusType (pctxt, 
               &pvalue->weaponStatus, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode target_list */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               ActionObjectElementType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->target_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, ActionObjectElementType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_ActionObjectElementType (pdata2);

                  stat = asn1D_ActionObjectElementType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->target_list, pnode);
               }

               if (!(pvalue->target_list.count >= 1U)) {
                  rtxErrAddStrParm (pctxt, "AttackElementType.target_list.count");
                  rtxErrAddIntParm (pctxt, (int)pvalue->target_list.count);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_AttackElementType (OSCTXT* pctxt, AttackElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("disableOnly"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("singleTarget"), 12}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("weaponStatus"), 12}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 6, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* disableOnly */
            stat = rtXmlpDecBool (pctxt, &pvalue->disableOnly);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 3: /* singleTarget */
            stat = rtXmlpDecBool (pctxt, &pvalue->singleTarget);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 5: /* weaponStatus */
            stat = XmlDec_WeaponStatusType (pctxt, &pvalue->weaponStatus);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "AttackElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "AttackElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Target"), 6}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         ActionObjectElementType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, ActionObjectElementType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ActionObjectElementType (pdata1);

            stat = XmlDec_ActionObjectElementType (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->target_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ContaminantType                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ContaminantType (OSCTXT* pctxt, ContaminantType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if(*pvalue < 0 || *pvalue > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   return (stat);
}

int XmlDec_ContaminantType (OSCTXT* pctxt, ContaminantType* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = ContaminantType_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ContaminantElementType                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ContaminantElementType (OSCTXT* pctxt, 
   ContaminantElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_ContaminantType (pctxt, 
               &pvalue->type, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_ContaminantElementType (OSCTXT* pctxt, 
   ContaminantElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("type"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 3: /* type */
            stat = XmlDec_ContaminantType (pctxt, &pvalue->type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "ContaminantElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "ContaminantElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DecontaminateElementType                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_DecontaminateElementType (OSCTXT* pctxt, 
   DecontaminateElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode contaminant_list */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               ContaminantElementType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->contaminant_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, ContaminantElementType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_ContaminantElementType (pdata2);

                  stat = asn1D_ContaminantElementType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->contaminant_list, pnode);
               }

               if (!(pvalue->contaminant_list.count >= 1U)) {
                  rtxErrAddStrParm (pctxt, "DecontaminateElementType.contaminant_list.count");
                  rtxErrAddIntParm (pctxt, (int)pvalue->contaminant_list.count);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_DecontaminateElementType (OSCTXT* pctxt, 
   DecontaminateElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "DecontaminateElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "DecontaminateElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Contaminant"), 11}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         ContaminantElementType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, ContaminantElementType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ContaminantElementType (pdata1);

            stat = XmlDec_ContaminantElementType (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->contaminant_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DemolishElementType                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_DemolishElementType (OSCTXT* pctxt, 
   DemolishElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   pvalue->permanentDisable = TRUE;
   pvalue->singleTarget = FALSE;

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode permanentDisable */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->permanentDisable, ASN1IMPL, length);
            if (stat == 0) {
            }
         }
         break;

      case 3:
         /* decode singleTarget */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->singleTarget, ASN1IMPL, length);
            if (stat == 0) {
            }
         }
         break;

      case 4:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode target_list */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               ActionObjectElementType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->target_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, ActionObjectElementType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_ActionObjectElementType (pdata2);

                  stat = asn1D_ActionObjectElementType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->target_list, pnode);
               }

               if (!(pvalue->target_list.count >= 1U)) {
                  rtxErrAddStrParm (pctxt, "DemolishElementType.target_list.count");
                  rtxErrAddIntParm (pctxt, (int)pvalue->target_list.count);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_DemolishElementType (OSCTXT* pctxt, DemolishElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("permanentDisable"), 16}, 0 },
         { {OSUTF8("singleTarget"), 12}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* permanentDisable */
            stat = rtXmlpDecBool (pctxt, &pvalue->permanentDisable);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* singleTarget */
            stat = rtXmlpDecBool (pctxt, &pvalue->singleTarget);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "DemolishElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "DemolishElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Target"), 6}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         ActionObjectElementType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, ActionObjectElementType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ActionObjectElementType (pdata1);

            stat = XmlDec_ActionObjectElementType (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->target_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IlluminatorType                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_IlluminatorType (OSCTXT* pctxt, IlluminatorType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if(*pvalue < 0 || *pvalue > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   return (stat);
}

int XmlDec_IlluminatorType (OSCTXT* pctxt, IlluminatorType* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = IlluminatorType_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IlluminatorElementType                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_IlluminatorElementType (OSCTXT* pctxt, 
   IlluminatorElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_IlluminatorType (pctxt, 
               &pvalue->type, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode illuminatorCharacteristic_list */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               StringElementType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->illuminatorCharacteristic_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, StringElementType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_StringElementType (pdata2);

                  stat = asn1D_StringElementType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->illuminatorCharacteristic_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_IlluminatorElementType (OSCTXT* pctxt, 
   IlluminatorElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("type"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 3: /* type */
            stat = XmlDec_IlluminatorType (pctxt, &pvalue->type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "IlluminatorElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "IlluminatorElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("IlluminatorCharacteristic"), 25}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         StringElementType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, StringElementType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_StringElementType (pdata1);

            stat = XmlDec_StringElementType (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->illuminatorCharacteristic_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IlluminateElementType                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_IlluminateElementType (OSCTXT* pctxt, 
   IlluminateElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode illuminator */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_IlluminatorElementType (pctxt, 
               &pvalue->illuminator, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_IlluminateElementType (OSCTXT* pctxt, IlluminateElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "IlluminateElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "IlluminateElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Illuminator"), 11}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* Illuminator */
         stat = XmlDec_IlluminatorElementType (pctxt, &pvalue->illuminator);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FrequencyRangeElementType                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_FrequencyRangeElementType (OSCTXT* pctxt, 
   FrequencyRangeElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode maxFrequency */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->maxFrequency, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode minFrequency */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->minFrequency, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_FrequencyRangeElementType (OSCTXT* pctxt, 
   FrequencyRangeElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("maxFrequency"), 12}, 0 },
         { {OSUTF8("minFrequency"), 12}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* maxFrequency */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->maxFrequency);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* minFrequency */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->minFrequency
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "FrequencyRangeElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "FrequencyRangeElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  JamElementType                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_JamElementType (OSCTXT* pctxt, JamElementType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode frequencyRange_list */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               FrequencyRangeElementType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->frequencyRange_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, FrequencyRangeElementType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_FrequencyRangeElementType (pdata2);

                  stat = asn1D_FrequencyRangeElementType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->frequencyRange_list, pnode);
               }

               if (!(pvalue->frequencyRange_list.count >= 1U)) {
                  rtxErrAddStrParm (pctxt, "JamElementType.frequencyRange_list.count");
                  rtxErrAddIntParm (pctxt, (int)pvalue->frequencyRange_list.count);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_JamElementType (OSCTXT* pctxt, JamElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "JamElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "JamElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("FrequencyRange"), 14}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         FrequencyRangeElementType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, FrequencyRangeElementType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FrequencyRangeElementType (pdata1);

            stat = XmlDec_FrequencyRangeElementType (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->frequencyRange_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MarkerType                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_MarkerType (OSCTXT* pctxt, MarkerType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if(*pvalue < 0 || *pvalue > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   return (stat);
}

int XmlDec_MarkerType (OSCTXT* pctxt, MarkerType* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = MarkerType_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MarkerElementType                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_MarkerElementType (OSCTXT* pctxt, MarkerElementType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_MarkerType (pctxt, 
               &pvalue->type, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode markerCharacteristic_list */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               StringElementType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->markerCharacteristic_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, StringElementType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_StringElementType (pdata2);

                  stat = asn1D_StringElementType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->markerCharacteristic_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_MarkerElementType (OSCTXT* pctxt, MarkerElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("type"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 3: /* type */
            stat = XmlDec_MarkerType (pctxt, &pvalue->type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "MarkerElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "MarkerElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("MarkerCharacteristic"), 20}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         StringElementType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, StringElementType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_StringElementType (pdata1);

            stat = XmlDec_StringElementType (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->markerCharacteristic_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MarkElementType                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_MarkElementType (OSCTXT* pctxt, MarkElementType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode marker */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_MarkerElementType (pctxt, 
               &pvalue->marker, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode target_list */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               ActionObjectElementType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->target_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, ActionObjectElementType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_ActionObjectElementType (pdata2);

                  stat = asn1D_ActionObjectElementType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->target_list, pnode);
               }

               if (!(pvalue->target_list.count >= 1U)) {
                  rtxErrAddStrParm (pctxt, "MarkElementType.target_list.count");
                  rtxErrAddIntParm (pctxt, (int)pvalue->target_list.count);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_MarkElementType (OSCTXT* pctxt, MarkElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "MarkElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "MarkElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Marker"), 6}, 0}, 0 },
      {{{OSUTF8("Target"), 6}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* Marker */
         stat = XmlDec_MarkerElementType (pctxt, &pvalue->marker);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: {
         ActionObjectElementType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, ActionObjectElementType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ActionObjectElementType (pdata1);

            stat = XmlDec_ActionObjectElementType (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->target_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MonitorTransmissionsElementType                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_MonitorTransmissionsElementType (OSCTXT* pctxt, 
   MonitorTransmissionsElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode frequencyRange_list */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               FrequencyRangeElementType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->frequencyRange_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, FrequencyRangeElementType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_FrequencyRangeElementType (pdata2);

                  stat = asn1D_FrequencyRangeElementType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->frequencyRange_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_MonitorTransmissionsElementType (OSCTXT* pctxt, 
   MonitorTransmissionsElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "MonitorTransmissionsElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "MonitorTransmissionsElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("FrequencyRange"), 14}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         FrequencyRangeElementType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, FrequencyRangeElementType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FrequencyRangeElementType (pdata1);

            stat = XmlDec_FrequencyRangeElementType (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->frequencyRange_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PatrolElementType                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PatrolElementType (OSCTXT* pctxt, PatrolElementType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode qualifier_list */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               StringElementType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->qualifier_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, StringElementType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_StringElementType (pdata2);

                  stat = asn1D_StringElementType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->qualifier_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PatrolElementType (OSCTXT* pctxt, PatrolElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "PatrolElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "PatrolElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Qualifier"), 9}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         StringElementType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, StringElementType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_StringElementType (pdata1);

            stat = XmlDec_StringElementType (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->qualifier_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RendezvousElementType                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_RendezvousElementType (OSCTXT* pctxt, 
   RendezvousElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode targetVehicleID */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->targetVehicleID, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode qualifier_list */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               StringElementType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->qualifier_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, StringElementType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_StringElementType (pdata2);

                  stat = asn1D_StringElementType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->qualifier_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_RendezvousElementType (OSCTXT* pctxt, RendezvousElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("targetVehicleID"), 15}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* targetVehicleID */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->targetVehicleID);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "RendezvousElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "RendezvousElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Qualifier"), 9}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         StringElementType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, StringElementType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_StringElementType (pdata1);

            stat = XmlDec_StringElementType (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->qualifier_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SampleEnvironmentElementType                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SampleEnvironmentElementType (OSCTXT* pctxt, 
   SampleEnvironmentElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode contaminant_list */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               ContaminantElementType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->contaminant_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, ContaminantElementType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_ContaminantElementType (pdata2);

                  stat = asn1D_ContaminantElementType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->contaminant_list, pnode);
               }

               if (!(pvalue->contaminant_list.count >= 1U)) {
                  rtxErrAddStrParm (pctxt, "SampleEnvironmentElementType.contaminant_list.count");
                  rtxErrAddIntParm (pctxt, (int)pvalue->contaminant_list.count);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SampleEnvironmentElementType (OSCTXT* pctxt, 
   SampleEnvironmentElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SampleEnvironmentElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SampleEnvironmentElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Contaminant"), 11}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         ContaminantElementType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, ContaminantElementType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ContaminantElementType (pdata1);

            stat = XmlDec_ContaminantElementType (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->contaminant_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DatumTypeType                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_DatumTypeType (OSCTXT* pctxt, DatumTypeType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if(*pvalue < 0 || *pvalue > 1)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   return (stat);
}

int XmlDec_DatumTypeType (OSCTXT* pctxt, DatumTypeType* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = DatumTypeType_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SearchElementType                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SearchElementType (OSCTXT* pctxt, SearchElementType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   pvalue->singleTarget = FALSE;

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode datumType */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_DatumTypeType (pctxt, 
               &pvalue->datumType, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode requiredPD */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PercentType (pctxt, 
               &pvalue->requiredPD, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode singleTarget */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->singleTarget, ASN1IMPL, length);
            if (stat == 0) {
            }
         }
         break;

      case 5:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode searchTarget_list */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               ActionObjectElementType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->searchTarget_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, ActionObjectElementType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_ActionObjectElementType (pdata2);

                  stat = asn1D_ActionObjectElementType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->searchTarget_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SearchElementType (OSCTXT* pctxt, SearchElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("datumType"), 9}, 0 },
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("requiredPD"), 10}, 0 },
         { {OSUTF8("singleTarget"), 12}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 6, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* datumType */
            stat = XmlDec_DatumTypeType (pctxt, &pvalue->datumType);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 2: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 3: /* requiredPD */
            stat = XmlDec_PercentType (pctxt, &pvalue->requiredPD);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* singleTarget */
            stat = rtXmlpDecBool (pctxt, &pvalue->singleTarget);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SearchElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SearchElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("SearchTarget"), 12}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         ActionObjectElementType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, ActionObjectElementType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ActionObjectElementType (pdata1);

            stat = XmlDec_ActionObjectElementType (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->searchTarget_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GoalElements                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_GoalElements (OSCTXT* pctxt, GoalElements *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.attack = rtxMemAllocType (pctxt, AttackElementType);

         if (pvalue->u.attack == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AttackElementType (pvalue->u.attack);
         stat = asn1D_AttackElementType (pctxt, 
            pvalue->u.attack, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.decontaminate
             = rtxMemAllocType (pctxt, DecontaminateElementType);

         if (pvalue->u.decontaminate == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_DecontaminateElementType (pvalue->u.decontaminate);
         stat = asn1D_DecontaminateElementType (pctxt, 
            pvalue->u.decontaminate, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.demolish = rtxMemAllocType (pctxt, DemolishElementType);

         if (pvalue->u.demolish == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_DemolishElementType (pvalue->u.demolish);
         stat = asn1D_DemolishElementType (pctxt, 
            pvalue->u.demolish, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.illuminateArea
             = rtxMemAllocType (pctxt, IlluminateElementType);

         if (pvalue->u.illuminateArea == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_IlluminateElementType (pvalue->u.illuminateArea);
         stat = asn1D_IlluminateElementType (pctxt, 
            pvalue->u.illuminateArea, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.jam = rtxMemAllocType (pctxt, JamElementType);

         if (pvalue->u.jam == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_JamElementType (pvalue->u.jam);
         stat = asn1D_JamElementType (pctxt, 
            pvalue->u.jam, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.markTarget = rtxMemAllocType (pctxt, MarkElementType);

         if (pvalue->u.markTarget == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MarkElementType (pvalue->u.markTarget);
         stat = asn1D_MarkElementType (pctxt, 
            pvalue->u.markTarget, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.monitorTransmissions
             = rtxMemAllocType (pctxt, MonitorTransmissionsElementType);

         if (pvalue->u.monitorTransmissions == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MonitorTransmissionsElementType (pvalue->u.monitorTransmissions);
         stat = asn1D_MonitorTransmissionsElementType (pctxt, 
            pvalue->u.monitorTransmissions, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.patrol = rtxMemAllocType (pctxt, PatrolElementType);

         if (pvalue->u.patrol == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PatrolElementType (pvalue->u.patrol);
         stat = asn1D_PatrolElementType (pctxt, 
            pvalue->u.patrol, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.rendezvous
             = rtxMemAllocType (pctxt, RendezvousElementType);

         if (pvalue->u.rendezvous == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RendezvousElementType (pvalue->u.rendezvous);
         stat = asn1D_RendezvousElementType (pctxt, 
            pvalue->u.rendezvous, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.reposition = rtxMemAllocType (pctxt, NoValueElementType);

         if (pvalue->u.reposition == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NoValueElementType (pvalue->u.reposition);
         stat = asn1D_NoValueElementType (pctxt, 
            pvalue->u.reposition, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.sampleEnvironment
             = rtxMemAllocType (pctxt, SampleEnvironmentElementType);

         if (pvalue->u.sampleEnvironment == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SampleEnvironmentElementType (pvalue->u.sampleEnvironment);
         stat = asn1D_SampleEnvironmentElementType (pctxt, 
            pvalue->u.sampleEnvironment, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.search = rtxMemAllocType (pctxt, SearchElementType);

         if (pvalue->u.search == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SearchElementType (pvalue->u.search);
         stat = asn1D_SearchElementType (pctxt, 
            pvalue->u.search, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_GoalElements (OSCTXT* pctxt, GoalElements* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Attack"), 6}, 0}, 0 },
      {{{OSUTF8("Decontaminate"), 13}, 0}, 1 },
      {{{OSUTF8("Demolish"), 8}, 0}, 2 },
      {{{OSUTF8("IlluminateArea"), 14}, 0}, 3 },
      {{{OSUTF8("Jam"), 3}, 0}, 4 },
      {{{OSUTF8("MarkTarget"), 10}, 0}, 5 },
      {{{OSUTF8("MonitorTransmissions"), 20}, 0}, 6 },
      {{{OSUTF8("Patrol"), 6}, 0}, 7 },
      {{{OSUTF8("Rendezvous"), 10}, 0}, 8 },
      {{{OSUTF8("Reposition"), 10}, 0}, 9 },
      {{{OSUTF8("SampleEnvironment"), 17}, 0}, 10 },
      {{{OSUTF8("Search"), 6}, 0}, 11 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 12, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* Attack */
      pvalue->u.attack = rtxMemAllocType (pctxt, AttackElementType);

      if (pvalue->u.attack == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AttackElementType (pvalue->u.attack);

      stat = XmlDec_AttackElementType (pctxt, pvalue->u.attack);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* Decontaminate */
      pvalue->u.decontaminate
          = rtxMemAllocType (pctxt, DecontaminateElementType);

      if (pvalue->u.decontaminate == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DecontaminateElementType (pvalue->u.decontaminate);

      stat = XmlDec_DecontaminateElementType (pctxt, pvalue->u.decontaminate);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* Demolish */
      pvalue->u.demolish = rtxMemAllocType (pctxt, DemolishElementType);

      if (pvalue->u.demolish == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DemolishElementType (pvalue->u.demolish);

      stat = XmlDec_DemolishElementType (pctxt, pvalue->u.demolish);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* IlluminateArea */
      pvalue->u.illuminateArea
          = rtxMemAllocType (pctxt, IlluminateElementType);

      if (pvalue->u.illuminateArea == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_IlluminateElementType (pvalue->u.illuminateArea);

      stat = XmlDec_IlluminateElementType (pctxt, pvalue->u.illuminateArea);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* Jam */
      pvalue->u.jam = rtxMemAllocType (pctxt, JamElementType);

      if (pvalue->u.jam == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_JamElementType (pvalue->u.jam);

      stat = XmlDec_JamElementType (pctxt, pvalue->u.jam);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* MarkTarget */
      pvalue->u.markTarget = rtxMemAllocType (pctxt, MarkElementType);

      if (pvalue->u.markTarget == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MarkElementType (pvalue->u.markTarget);

      stat = XmlDec_MarkElementType (pctxt, pvalue->u.markTarget);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* MonitorTransmissions */
      pvalue->u.monitorTransmissions
          = rtxMemAllocType (pctxt, MonitorTransmissionsElementType);

      if (pvalue->u.monitorTransmissions == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MonitorTransmissionsElementType (pvalue->u.monitorTransmissions
         );

      stat = XmlDec_MonitorTransmissionsElementType (pctxt, pvalue->
         u.monitorTransmissions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* Patrol */
      pvalue->u.patrol = rtxMemAllocType (pctxt, PatrolElementType);

      if (pvalue->u.patrol == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PatrolElementType (pvalue->u.patrol);

      stat = XmlDec_PatrolElementType (pctxt, pvalue->u.patrol);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* Rendezvous */
      pvalue->u.rendezvous = rtxMemAllocType (pctxt, RendezvousElementType);

      if (pvalue->u.rendezvous == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RendezvousElementType (pvalue->u.rendezvous);

      stat = XmlDec_RendezvousElementType (pctxt, pvalue->u.rendezvous);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* Reposition */
      pvalue->u.reposition = rtxMemAllocType (pctxt, NoValueElementType);

      if (pvalue->u.reposition == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NoValueElementType (pvalue->u.reposition);

      stat = XmlDec_NoValueElementType (pctxt, pvalue->u.reposition);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* SampleEnvironment */
      pvalue->u.sampleEnvironment
          = rtxMemAllocType (pctxt, SampleEnvironmentElementType);

      if (pvalue->u.sampleEnvironment == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SampleEnvironmentElementType (pvalue->u.sampleEnvironment);

      stat = XmlDec_SampleEnvironmentElementType (pctxt, pvalue->
         u.sampleEnvironment);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* Search */
      pvalue->u.search = rtxMemAllocType (pctxt, SearchElementType);

      if (pvalue->u.search == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SearchElementType (pvalue->u.search);

      stat = XmlDec_SearchElementType (pctxt, pvalue->u.search);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CircleElementType                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CircleElementType (OSCTXT* pctxt, CircleElementType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode center */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AbsoluteHorizontalPositionElementType (pctxt, 
               &pvalue->center, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode radius */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->radius, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CircleElementType (OSCTXT* pctxt, CircleElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "CircleElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "CircleElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Center"), 6}, 0}, 0 },
      {{{OSUTF8("Radius"), 6}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 1, -1}, {2, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* Center */
         stat = XmlDec_AbsoluteHorizontalPositionElementType (pctxt, &pvalue->
            center);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* Radius */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            radius);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AreaOrientationType                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AreaOrientationType (OSCTXT* pctxt, 
   AreaOrientationType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_real (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_AreaOrientationType (OSCTXT* pctxt, AreaOrientationType* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDouble (pctxt, pvalue, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AreaOrientationElementType                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AreaOrientationElementType (OSCTXT* pctxt, 
   AreaOrientationElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AreaOrientationType (pctxt, 
               &pvalue->value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_AreaOrientationElementType (OSCTXT* pctxt, 
   AreaOrientationElementType* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* value */
            stat = XmlDec_AreaOrientationType (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "AreaOrientationElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "AreaOrientationElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RectangleElementType                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_RectangleElementType (OSCTXT* pctxt, 
   RectangleElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode northwestCorner */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AbsoluteHorizontalPositionElementType (pctxt, 
               &pvalue->northwestCorner, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode width */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->width, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode height */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
               &pvalue->height, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode orientation */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AreaOrientationElementType (pctxt, 
               &pvalue->orientation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.orientationPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_RectangleElementType (OSCTXT* pctxt, RectangleElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "RectangleElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "RectangleElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("NorthwestCorner"), 15}, 0}, 0 },
      {{{OSUTF8("Width"), 5}, 0}, 1 },
      {{{OSUTF8("Height"), 6}, 0}, 2 },
      {{{OSUTF8("Orientation"), 11}, 0}, 3 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 1, -1}, {2, 1, -1}, {3, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 4; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* NorthwestCorner */
         stat = XmlDec_AbsoluteHorizontalPositionElementType (pctxt, &pvalue->
            northwestCorner);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* Width */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            width);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 2: { /* Height */
         stat = XmlDec_PositiveScalarElementType_derivations (pctxt, &pvalue->
            height);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 3: { /* Orientation */
         stat = XmlDec_AreaOrientationElementType (pctxt, &pvalue->orientation
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.orientationPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PolygonElementType                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PolygonElementType (OSCTXT* pctxt, 
   PolygonElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PointListElements (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PolygonElementType (OSCTXT* pctxt, PolygonElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "PolygonElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "PolygonElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("LatitudeLongitude"), 17}, 0}, 0 },
      {{{OSUTF8("XYPosition"), 10}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}, {2, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_PointListElements (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LimitingLineElementType                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_LimitingLineElementType (OSCTXT* pctxt, 
   LimitingLineElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PointListElements (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_LimitingLineElementType (OSCTXT* pctxt, 
   LimitingLineElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "LimitingLineElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "LimitingLineElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("LatitudeLongitude"), 17}, 0}, 0 },
      {{{OSUTF8("XYPosition"), 10}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}, {2, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_PointListElements (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AreaElements                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AreaElements (OSCTXT* pctxt, AreaElements *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.point
             = rtxMemAllocType (pctxt, AbsoluteHorizontalPositionElementType);

         if (pvalue->u.point == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AbsoluteHorizontalPositionElementType (pvalue->u.point);
         stat = asn1D_AbsoluteHorizontalPositionElementType (pctxt, 
            pvalue->u.point, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.circle = rtxMemAllocType (pctxt, CircleElementType);

         if (pvalue->u.circle == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CircleElementType (pvalue->u.circle);
         stat = asn1D_CircleElementType (pctxt, 
            pvalue->u.circle, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.rectangle = rtxMemAllocType (pctxt, RectangleElementType);

         if (pvalue->u.rectangle == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RectangleElementType (pvalue->u.rectangle);
         stat = asn1D_RectangleElementType (pctxt, 
            pvalue->u.rectangle, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.polygon = rtxMemAllocType (pctxt, PolygonElementType);

         if (pvalue->u.polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PolygonElementType (pvalue->u.polygon);
         stat = asn1D_PolygonElementType (pctxt, 
            pvalue->u.polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.limitingLine
             = rtxMemAllocType (pctxt, LimitingLineElementType);

         if (pvalue->u.limitingLine == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_LimitingLineElementType (pvalue->u.limitingLine);
         stat = asn1D_LimitingLineElementType (pctxt, 
            pvalue->u.limitingLine, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_AreaElements (OSCTXT* pctxt, AreaElements* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Point"), 5}, 0}, 0 },
      {{{OSUTF8("Circle"), 6}, 0}, 1 },
      {{{OSUTF8("Rectangle"), 9}, 0}, 2 },
      {{{OSUTF8("Polygon"), 7}, 0}, 3 },
      {{{OSUTF8("LimitingLine"), 12}, 0}, 4 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 5, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* Point */
      pvalue->u.point
          = rtxMemAllocType (pctxt, AbsoluteHorizontalPositionElementType);

      if (pvalue->u.point == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AbsoluteHorizontalPositionElementType (pvalue->u.point);

      stat = XmlDec_AbsoluteHorizontalPositionElementType (pctxt, pvalue->
         u.point);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* Circle */
      pvalue->u.circle = rtxMemAllocType (pctxt, CircleElementType);

      if (pvalue->u.circle == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CircleElementType (pvalue->u.circle);

      stat = XmlDec_CircleElementType (pctxt, pvalue->u.circle);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* Rectangle */
      pvalue->u.rectangle = rtxMemAllocType (pctxt, RectangleElementType);

      if (pvalue->u.rectangle == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RectangleElementType (pvalue->u.rectangle);

      stat = XmlDec_RectangleElementType (pctxt, pvalue->u.rectangle);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* Polygon */
      pvalue->u.polygon = rtxMemAllocType (pctxt, PolygonElementType);

      if (pvalue->u.polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PolygonElementType (pvalue->u.polygon);

      stat = XmlDec_PolygonElementType (pctxt, pvalue->u.polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* LimitingLine */
      pvalue->u.limitingLine
          = rtxMemAllocType (pctxt, LimitingLineElementType);

      if (pvalue->u.limitingLine == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_LimitingLineElementType (pvalue->u.limitingLine);

      stat = XmlDec_LimitingLineElementType (pctxt, pvalue->u.limitingLine);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NumericalBlockElementType                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_NumericalBlockElementType (OSCTXT* pctxt, 
   NumericalBlockElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode maximum */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->maximum, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode minimum */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->minimum, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_NumericalBlockElementType (OSCTXT* pctxt, 
   NumericalBlockElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("maximum"), 7}, 0 },
         { {OSUTF8("minimum"), 7}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* maximum */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->maximum);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* minimum */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->minimum);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "NumericalBlockElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "NumericalBlockElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DepthBlockElements                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_DepthBlockElements (OSCTXT* pctxt, 
   DepthBlockElements *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.depthBlock
             = rtxMemAllocType (pctxt, NumericalBlockElementType);

         if (pvalue->u.depthBlock == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NumericalBlockElementType (pvalue->u.depthBlock);
         stat = asn1D_NumericalBlockElementType (pctxt, 
            pvalue->u.depthBlock, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.altitudeBlock
             = rtxMemAllocType (pctxt, NumericalBlockElementType);

         if (pvalue->u.altitudeBlock == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NumericalBlockElementType (pvalue->u.altitudeBlock);
         stat = asn1D_NumericalBlockElementType (pctxt, 
            pvalue->u.altitudeBlock, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.depthAltitudeBlock
             = rtxMemAllocType (pctxt, NumericalBlockElementType);

         if (pvalue->u.depthAltitudeBlock == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NumericalBlockElementType (pvalue->u.depthAltitudeBlock);
         stat = asn1D_NumericalBlockElementType (pctxt, 
            pvalue->u.depthAltitudeBlock, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_DepthBlockElements (OSCTXT* pctxt, DepthBlockElements* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("DepthBlock"), 10}, 0}, 0 },
      {{{OSUTF8("AltitudeBlock"), 13}, 0}, 1 },
      {{{OSUTF8("DepthAltitudeBlock"), 18}, 0}, 2 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* DepthBlock */
      pvalue->u.depthBlock
          = rtxMemAllocType (pctxt, NumericalBlockElementType);

      if (pvalue->u.depthBlock == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NumericalBlockElementType (pvalue->u.depthBlock);

      stat = XmlDec_NumericalBlockElementType (pctxt, pvalue->u.depthBlock);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* AltitudeBlock */
      pvalue->u.altitudeBlock
          = rtxMemAllocType (pctxt, NumericalBlockElementType);

      if (pvalue->u.altitudeBlock == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NumericalBlockElementType (pvalue->u.altitudeBlock);

      stat = XmlDec_NumericalBlockElementType (pctxt, pvalue->u.altitudeBlock
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* DepthAltitudeBlock */
      pvalue->u.depthAltitudeBlock
          = rtxMemAllocType (pctxt, NumericalBlockElementType);

      if (pvalue->u.depthAltitudeBlock == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NumericalBlockElementType (pvalue->u.depthAltitudeBlock);

      stat = XmlDec_NumericalBlockElementType (pctxt, pvalue->
         u.depthAltitudeBlock);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AltitudeBlockElements                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AltitudeBlockElements (OSCTXT* pctxt, 
   AltitudeBlockElements *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.aGLAltitudeBlock
             = rtxMemAllocType (pctxt, NumericalBlockElementType);

         if (pvalue->u.aGLAltitudeBlock == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NumericalBlockElementType (pvalue->u.aGLAltitudeBlock);
         stat = asn1D_NumericalBlockElementType (pctxt, 
            pvalue->u.aGLAltitudeBlock, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.mSLAltitudeBlock
             = rtxMemAllocType (pctxt, NumericalBlockElementType);

         if (pvalue->u.mSLAltitudeBlock == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NumericalBlockElementType (pvalue->u.mSLAltitudeBlock);
         stat = asn1D_NumericalBlockElementType (pctxt, 
            pvalue->u.mSLAltitudeBlock, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.aGLMSLAltitudeBlock
             = rtxMemAllocType (pctxt, NumericalBlockElementType);

         if (pvalue->u.aGLMSLAltitudeBlock == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NumericalBlockElementType (pvalue->u.aGLMSLAltitudeBlock);
         stat = asn1D_NumericalBlockElementType (pctxt, 
            pvalue->u.aGLMSLAltitudeBlock, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_AltitudeBlockElements (OSCTXT* pctxt, AltitudeBlockElements* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("AGLAltitudeBlock"), 16}, 0}, 0 },
      {{{OSUTF8("MSLAltitudeBlock"), 16}, 0}, 1 },
      {{{OSUTF8("AGLMSLAltitudeBlock"), 19}, 0}, 2 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* AGLAltitudeBlock */
      pvalue->u.aGLAltitudeBlock
          = rtxMemAllocType (pctxt, NumericalBlockElementType);

      if (pvalue->u.aGLAltitudeBlock == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NumericalBlockElementType (pvalue->u.aGLAltitudeBlock);

      stat = XmlDec_NumericalBlockElementType (pctxt, pvalue->
         u.aGLAltitudeBlock);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* MSLAltitudeBlock */
      pvalue->u.mSLAltitudeBlock
          = rtxMemAllocType (pctxt, NumericalBlockElementType);

      if (pvalue->u.mSLAltitudeBlock == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NumericalBlockElementType (pvalue->u.mSLAltitudeBlock);

      stat = XmlDec_NumericalBlockElementType (pctxt, pvalue->
         u.mSLAltitudeBlock);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* AGLMSLAltitudeBlock */
      pvalue->u.aGLMSLAltitudeBlock
          = rtxMemAllocType (pctxt, NumericalBlockElementType);

      if (pvalue->u.aGLMSLAltitudeBlock == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NumericalBlockElementType (pvalue->u.aGLMSLAltitudeBlock);

      stat = XmlDec_NumericalBlockElementType (pctxt, pvalue->
         u.aGLMSLAltitudeBlock);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VerticalBlockElements                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_VerticalBlockElements (OSCTXT* pctxt, 
   VerticalBlockElements *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.choice = rtxMemAllocType (pctxt, DepthTypeElements);

         if (pvalue->u.choice == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_DepthTypeElements (pvalue->u.choice);
         stat = asn1D_DepthTypeElements (pctxt, 
            pvalue->u.choice, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.choice_1 = rtxMemAllocType (pctxt, AltitudeTypeElements);

         if (pvalue->u.choice_1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AltitudeTypeElements (pvalue->u.choice_1);
         stat = asn1D_AltitudeTypeElements (pctxt, 
            pvalue->u.choice_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.choice_2 = rtxMemAllocType (pctxt, DepthBlockElements);

         if (pvalue->u.choice_2 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_DepthBlockElements (pvalue->u.choice_2);
         stat = asn1D_DepthBlockElements (pctxt, 
            pvalue->u.choice_2, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.choice_3 = rtxMemAllocType (pctxt, AltitudeBlockElements);

         if (pvalue->u.choice_3 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AltitudeBlockElements (pvalue->u.choice_3);
         stat = asn1D_AltitudeBlockElements (pctxt, 
            pvalue->u.choice_3, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_VerticalBlockElements (OSCTXT* pctxt, VerticalBlockElements* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Depth"), 5}, 0}, 0 },
      {{{OSUTF8("Altitude"), 8}, 0}, 0 },
      {{{OSUTF8("AGLAltitude"), 11}, 0}, 1 },
      {{{OSUTF8("MSLAltitude"), 11}, 0}, 1 },
      {{{OSUTF8("DepthBlock"), 10}, 0}, 2 },
      {{{OSUTF8("AltitudeBlock"), 13}, 0}, 2 },
      {{{OSUTF8("DepthAltitudeBlock"), 18}, 0}, 2 },
      {{{OSUTF8("AGLAltitudeBlock"), 16}, 0}, 3 },
      {{{OSUTF8("MSLAltitudeBlock"), 16}, 0}, 3 },
      {{{OSUTF8("AGLMSLAltitudeBlock"), 19}, 0}, 3 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 10, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: {
      rtXmlpMarkLastEventActive (pctxt);

      pvalue->u.choice = rtxMemAllocType (pctxt, DepthTypeElements);

      if (pvalue->u.choice == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DepthTypeElements (pvalue->u.choice);

      stat = XmlDec_DepthTypeElements (pctxt, pvalue->u.choice);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: {
      rtXmlpMarkLastEventActive (pctxt);

      pvalue->u.choice_1 = rtxMemAllocType (pctxt, AltitudeTypeElements);

      if (pvalue->u.choice_1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AltitudeTypeElements (pvalue->u.choice_1);

      stat = XmlDec_AltitudeTypeElements (pctxt, pvalue->u.choice_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: {
      rtXmlpMarkLastEventActive (pctxt);

      pvalue->u.choice_2 = rtxMemAllocType (pctxt, DepthBlockElements);

      if (pvalue->u.choice_2 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DepthBlockElements (pvalue->u.choice_2);

      stat = XmlDec_DepthBlockElements (pctxt, pvalue->u.choice_2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: {
      rtXmlpMarkLastEventActive (pctxt);

      pvalue->u.choice_3 = rtxMemAllocType (pctxt, AltitudeBlockElements);

      if (pvalue->u.choice_3 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AltitudeBlockElements (pvalue->u.choice_3);

      stat = XmlDec_AltitudeBlockElements (pctxt, pvalue->u.choice_3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AreaElementType                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AreaElementType (OSCTXT* pctxt, AreaElementType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AreaElements (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choicePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode choice_1 */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_VerticalBlockElements (pctxt, 
               &pvalue->choice_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choice_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_AreaElementType (OSCTXT* pctxt, AreaElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "AreaElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "AreaElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Point"), 5}, 0}, 0 },
      {{{OSUTF8("Circle"), 6}, 0}, 0 },
      {{{OSUTF8("Rectangle"), 9}, 0}, 0 },
      {{{OSUTF8("Polygon"), 7}, 0}, 0 },
      {{{OSUTF8("LimitingLine"), 12}, 0}, 0 },
      {{{OSUTF8("Depth"), 5}, 0}, 1 },
      {{{OSUTF8("Altitude"), 8}, 0}, 1 },
      {{{OSUTF8("AGLAltitude"), 11}, 0}, 1 },
      {{{OSUTF8("MSLAltitude"), 11}, 0}, 1 },
      {{{OSUTF8("DepthBlock"), 10}, 0}, 1 },
      {{{OSUTF8("AltitudeBlock"), 13}, 0}, 1 },
      {{{OSUTF8("DepthAltitudeBlock"), 18}, 0}, 1 },
      {{{OSUTF8("AGLAltitudeBlock"), 16}, 0}, 1 },
      {{{OSUTF8("MSLAltitudeBlock"), 16}, 0}, 1 },
      {{{OSUTF8("AGLMSLAltitudeBlock"), 19}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 15, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_AreaElements (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choicePresent = TRUE;
         break;
      }
      case 1: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_VerticalBlockElements (pctxt, &pvalue->choice_1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choice_1Present = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AbsoluteTimingElementType                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AbsoluteTimingElementType (OSCTXT* pctxt, 
   AbsoluteTimingElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode start */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->start, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode stop */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->stop, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_AbsoluteTimingElementType (OSCTXT* pctxt, 
   AbsoluteTimingElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("start"), 5}, 0 },
         { {OSUTF8("stop"), 4}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* start */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->start);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* stop */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->stop);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "AbsoluteTimingElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "AbsoluteTimingElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimingTypeElements                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TimingTypeElements (OSCTXT* pctxt, 
   TimingTypeElements *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.duration
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.duration == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.duration);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.duration, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.timing
             = rtxMemAllocType (pctxt, AbsoluteTimingElementType);

         if (pvalue->u.timing == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AbsoluteTimingElementType (pvalue->u.timing);
         stat = asn1D_AbsoluteTimingElementType (pctxt, 
            pvalue->u.timing, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_TimingTypeElements (OSCTXT* pctxt, TimingTypeElements* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Duration"), 8}, 0}, 0 },
      {{{OSUTF8("Timing"), 6}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* Duration */
      pvalue->u.duration
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.duration == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.duration);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.duration);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* Timing */
      pvalue->u.timing = rtxMemAllocType (pctxt, AbsoluteTimingElementType);

      if (pvalue->u.timing == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AbsoluteTimingElementType (pvalue->u.timing);

      stat = XmlDec_AbsoluteTimingElementType (pctxt, pvalue->u.timing);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportingCriteriaType                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ReportingCriteriaType (OSCTXT* pctxt, 
   ReportingCriteriaType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if(*pvalue < 0 || *pvalue > 4)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   return (stat);
}

int XmlDec_ReportingCriteriaType (OSCTXT* pctxt, ReportingCriteriaType* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = ReportingCriteriaType_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReportingCriteriaElementType                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ReportingCriteriaElementType (OSCTXT* pctxt, 
   ReportingCriteriaElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode periodicity */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->periodicity, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.periodicityPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_ReportingCriteriaType (pctxt, 
               &pvalue->value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_ReportingCriteriaElementType (OSCTXT* pctxt, 
   ReportingCriteriaElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("periodicity"), 11}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* periodicity */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->periodicity);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.periodicityPresent = TRUE;
            break;

         case 3: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 4: /* value */
            stat = XmlDec_ReportingCriteriaType (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "ReportingCriteriaElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "ReportingCriteriaElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AgendaGoalElementType                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AgendaGoalElementType (OSCTXT* pctxt, 
   AgendaGoalElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   pvalue->alert = FALSE;

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode alert */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->alert, ASN1IMPL, length);
            if (stat == 0) {
            }
         }
         break;

      case 1:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode nextOnFail */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->nextOnFail, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.nextOnFailPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode nextOnSucceed */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->nextOnSucceed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.nextOnSucceedPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_GoalElements (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode operatingArea */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AreaElementType (pctxt, 
               &pvalue->operatingArea, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 8:
         /* decode choice_1 */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_TimingTypeElements (pctxt, 
               &pvalue->choice_1, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 9:
         /* decode reportingCriteria_list */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               ReportingCriteriaElementType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->reportingCriteria_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, ReportingCriteriaElementType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_ReportingCriteriaElementType (pdata2);

                  stat = asn1D_ReportingCriteriaElementType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->reportingCriteria_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 5) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_AgendaGoalElementType (OSCTXT* pctxt, AgendaGoalElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("alert"), 5}, 0 },
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("nextOnFail"), 10}, 0 },
         { {OSUTF8("nextOnSucceed"), 13}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 6, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* alert */
            stat = rtXmlpDecBool (pctxt, &pvalue->alert);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 2: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* nextOnFail */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->nextOnFail);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.nextOnFailPresent = TRUE;
            break;

         case 4: /* nextOnSucceed */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->nextOnSucceed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.nextOnSucceedPresent = TRUE;
            break;

         case 5: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "AgendaGoalElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "AgendaGoalElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Attack"), 6}, 0}, 0 },
      {{{OSUTF8("Decontaminate"), 13}, 0}, 0 },
      {{{OSUTF8("Demolish"), 8}, 0}, 0 },
      {{{OSUTF8("IlluminateArea"), 14}, 0}, 0 },
      {{{OSUTF8("Jam"), 3}, 0}, 0 },
      {{{OSUTF8("MarkTarget"), 10}, 0}, 0 },
      {{{OSUTF8("MonitorTransmissions"), 20}, 0}, 0 },
      {{{OSUTF8("Patrol"), 6}, 0}, 0 },
      {{{OSUTF8("Rendezvous"), 10}, 0}, 0 },
      {{{OSUTF8("Reposition"), 10}, 0}, 0 },
      {{{OSUTF8("SampleEnvironment"), 17}, 0}, 0 },
      {{{OSUTF8("Search"), 6}, 0}, 0 },
      {{{OSUTF8("OperatingArea"), 13}, 0}, 1 },
      {{{OSUTF8("Duration"), 8}, 0}, 2 },
      {{{OSUTF8("Timing"), 6}, 0}, 2 },
      {{{OSUTF8("ReportingCriteria"), 17}, 0}, 3 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 12, -1}, {12, 1, -1}, {13, 2, -1}, {15, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 4; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_GoalElements (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* OperatingArea */
         stat = XmlDec_AreaElementType (pctxt, &pvalue->operatingArea);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 2: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_TimingTypeElements (pctxt, &pvalue->choice_1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 3: {
         ReportingCriteriaElementType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, ReportingCriteriaElementType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ReportingCriteriaElementType (pdata1);

            stat = XmlDec_ReportingCriteriaElementType (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->reportingCriteria_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 15, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 3);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AgendaGoalListType                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AgendaGoalListType (OSCTXT* pctxt, 
   AgendaGoalListType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode goal_list */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               AgendaGoalElementType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->goal_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, AgendaGoalElementType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_AgendaGoalElementType (pdata2);

                  stat = asn1D_AgendaGoalElementType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->goal_list, pnode);
               }

               if (!(pvalue->goal_list.count >= 1U)) {
                  rtxErrAddStrParm (pctxt, "AgendaGoalListType.goal_list.count");
                  rtxErrAddIntParm (pctxt, (int)pvalue->goal_list.count);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_AgendaGoalListType (OSCTXT* pctxt, AgendaGoalListType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "AgendaGoalListType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "AgendaGoalListType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Goal"), 4}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         AgendaGoalElementType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, AgendaGoalElementType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AgendaGoalElementType (pdata1);

            stat = XmlDec_AgendaGoalElementType (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->goal_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RouteElementType                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_RouteElementType (OSCTXT* pctxt, RouteElementType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PointListElements (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choicePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode choice_1 */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_VerticalBlockElements (pctxt, 
               &pvalue->choice_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choice_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_RouteElementType (OSCTXT* pctxt, RouteElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "RouteElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "RouteElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("LatitudeLongitude"), 17}, 0}, 0 },
      {{{OSUTF8("XYPosition"), 10}, 0}, 0 },
      {{{OSUTF8("Depth"), 5}, 0}, 1 },
      {{{OSUTF8("Altitude"), 8}, 0}, 1 },
      {{{OSUTF8("AGLAltitude"), 11}, 0}, 1 },
      {{{OSUTF8("MSLAltitude"), 11}, 0}, 1 },
      {{{OSUTF8("DepthBlock"), 10}, 0}, 1 },
      {{{OSUTF8("AltitudeBlock"), 13}, 0}, 1 },
      {{{OSUTF8("DepthAltitudeBlock"), 18}, 0}, 1 },
      {{{OSUTF8("AGLAltitudeBlock"), 16}, 0}, 1 },
      {{{OSUTF8("MSLAltitudeBlock"), 16}, 0}, 1 },
      {{{OSUTF8("AGLMSLAltitudeBlock"), 19}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 12, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_PointListElements (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choicePresent = TRUE;
         break;
      }
      case 1: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_VerticalBlockElements (pctxt, &pvalue->choice_1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choice_1Present = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AgendaConstraintListType                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AgendaConstraintListType (OSCTXT* pctxt, 
   AgendaConstraintListType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode ingressRouting */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_RouteElementType (pctxt, 
               &pvalue->ingressRouting, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.ingressRoutingPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode avoidArea_list */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               AreaElementType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->avoidArea_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, AreaElementType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_AreaElementType (pdata2);

                  stat = asn1D_AreaElementType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->avoidArea_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode egressRouting */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_RouteElementType (pctxt, 
               &pvalue->egressRouting, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.egressRoutingPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_AgendaConstraintListType (OSCTXT* pctxt, 
   AgendaConstraintListType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "AgendaConstraintListType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "AgendaConstraintListType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("IngressRouting"), 14}, 0}, 0 },
      {{{OSUTF8("AvoidArea"), 9}, 0}, 1 },
      {{{OSUTF8("EgressRouting"), 13}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* IngressRouting */
         stat = XmlDec_RouteElementType (pctxt, &pvalue->ingressRouting);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.ingressRoutingPresent = TRUE;
         break;
      }
      case 1: {
         AreaElementType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, AreaElementType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AreaElementType (pdata1);

            stat = XmlDec_AreaElementType (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->avoidArea_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 2: { /* EgressRouting */
         stat = XmlDec_RouteElementType (pctxt, &pvalue->egressRouting);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.egressRoutingPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AgendaMissionElementType                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AgendaMissionElementType (OSCTXT* pctxt, 
   AgendaMissionElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode launchPosition */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AbsoluteHorizontalPositionElementType (pctxt, 
               &pvalue->launchPosition, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.launchPositionPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode recoveryPosition */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AbsoluteHorizontalPositionElementType (pctxt, 
               &pvalue->recoveryPosition, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.recoveryPositionPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode goalList */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AgendaGoalListType (pctxt, 
               &pvalue->goalList, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode constraintList */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AgendaConstraintListType (pctxt, 
               &pvalue->constraintList, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.constraintListPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_AgendaMissionElementType (OSCTXT* pctxt, 
   AgendaMissionElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "AgendaMissionElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "AgendaMissionElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("LaunchPosition"), 14}, 0}, 0 },
      {{{OSUTF8("RecoveryPosition"), 16}, 0}, 1 },
      {{{OSUTF8("GoalList"), 8}, 0}, 2 },
      {{{OSUTF8("ConstraintList"), 14}, 0}, 3 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}, {3, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 4; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* LaunchPosition */
         stat = XmlDec_AbsoluteHorizontalPositionElementType (pctxt, &pvalue->
            launchPosition);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.launchPositionPresent = TRUE;
         break;
      }
      case 1: { /* RecoveryPosition */
         stat = XmlDec_AbsoluteHorizontalPositionElementType (pctxt, &pvalue->
            recoveryPosition);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.recoveryPositionPresent = TRUE;
         break;
      }
      case 2: { /* GoalList */
         stat = XmlDec_AgendaGoalListType (pctxt, &pvalue->goalList);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 3: { /* ConstraintList */
         stat = XmlDec_AgendaConstraintListType (pctxt, &pvalue->constraintList
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.constraintListPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MissionSpecification                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_MissionSpecification (OSCTXT* pctxt, 
   MissionSpecification *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.uUVCommandScript
             = rtxMemAllocType (pctxt, UuvScriptCommandsType);

         if (pvalue->u.uUVCommandScript == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UuvScriptCommandsType (pvalue->u.uUVCommandScript);
         stat = asn1D_UuvScriptCommandsType (pctxt, 
            pvalue->u.uUVCommandScript, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.uSVCommandScript
             = rtxMemAllocType (pctxt, UsvScriptCommandsType);

         if (pvalue->u.uSVCommandScript == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UsvScriptCommandsType (pvalue->u.uSVCommandScript);
         stat = asn1D_UsvScriptCommandsType (pctxt, 
            pvalue->u.uSVCommandScript, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.uGVCommandScript
             = rtxMemAllocType (pctxt, UgvScriptCommandsType);

         if (pvalue->u.uGVCommandScript == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UgvScriptCommandsType (pvalue->u.uGVCommandScript);
         stat = asn1D_UgvScriptCommandsType (pctxt, 
            pvalue->u.uGVCommandScript, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.uAVCommandScript
             = rtxMemAllocType (pctxt, UavScriptCommandsType);

         if (pvalue->u.uAVCommandScript == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UavScriptCommandsType (pvalue->u.uAVCommandScript);
         stat = asn1D_UavScriptCommandsType (pctxt, 
            pvalue->u.uAVCommandScript, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.agendaMission
             = rtxMemAllocType (pctxt, AgendaMissionElementType);

         if (pvalue->u.agendaMission == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AgendaMissionElementType (pvalue->u.agendaMission);
         stat = asn1D_AgendaMissionElementType (pctxt, 
            pvalue->u.agendaMission, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_MissionSpecification (OSCTXT* pctxt, MissionSpecification* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("UUVCommandScript"), 16}, 0}, 0 },
      {{{OSUTF8("USVCommandScript"), 16}, 0}, 1 },
      {{{OSUTF8("UGVCommandScript"), 16}, 0}, 2 },
      {{{OSUTF8("UAVCommandScript"), 16}, 0}, 3 },
      {{{OSUTF8("AgendaMission"), 13}, 0}, 4 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 5, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* UUVCommandScript */
      pvalue->u.uUVCommandScript
          = rtxMemAllocType (pctxt, UuvScriptCommandsType);

      if (pvalue->u.uUVCommandScript == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UuvScriptCommandsType (pvalue->u.uUVCommandScript);

      stat = XmlDec_UuvScriptCommandsType (pctxt, pvalue->u.uUVCommandScript);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* USVCommandScript */
      pvalue->u.uSVCommandScript
          = rtxMemAllocType (pctxt, UsvScriptCommandsType);

      if (pvalue->u.uSVCommandScript == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UsvScriptCommandsType (pvalue->u.uSVCommandScript);

      stat = XmlDec_UsvScriptCommandsType (pctxt, pvalue->u.uSVCommandScript);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* UGVCommandScript */
      pvalue->u.uGVCommandScript
          = rtxMemAllocType (pctxt, UgvScriptCommandsType);

      if (pvalue->u.uGVCommandScript == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UgvScriptCommandsType (pvalue->u.uGVCommandScript);

      stat = XmlDec_UgvScriptCommandsType (pctxt, pvalue->u.uGVCommandScript);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* UAVCommandScript */
      pvalue->u.uAVCommandScript
          = rtxMemAllocType (pctxt, UavScriptCommandsType);

      if (pvalue->u.uAVCommandScript == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UavScriptCommandsType (pvalue->u.uAVCommandScript);

      stat = XmlDec_UavScriptCommandsType (pctxt, pvalue->u.uAVCommandScript);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* AgendaMission */
      pvalue->u.agendaMission
          = rtxMemAllocType (pctxt, AgendaMissionElementType);

      if (pvalue->u.agendaMission == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AgendaMissionElementType (pvalue->u.agendaMission);

      stat = XmlDec_AgendaMissionElementType (pctxt, pvalue->u.agendaMission);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationRequestType                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_InformationRequestType (OSCTXT* pctxt, 
   InformationRequestType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if(*pvalue < 0 || *pvalue > 8)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   return (stat);
}

int XmlDec_InformationRequestType (OSCTXT* pctxt, 
   InformationRequestType* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = InformationRequestType_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InformationRequestElementType                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_InformationRequestElementType (OSCTXT* pctxt, 
   InformationRequestElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode informationType */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_InformationRequestType (pctxt, 
               &pvalue->informationType, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_InformationRequestElementType (OSCTXT* pctxt, 
   InformationRequestElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("informationType"), 15}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* informationType */
            stat = XmlDec_InformationRequestType (pctxt, &pvalue->
               informationType);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "InformationRequestElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "InformationRequestElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VehicleGroupCompositionType                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_VehicleGroupCompositionType (OSCTXT* pctxt, 
   VehicleGroupCompositionType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if(*pvalue < 0 || *pvalue > 6)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   return (stat);
}

int XmlDec_VehicleGroupCompositionType (OSCTXT* pctxt, 
   VehicleGroupCompositionType* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = VehicleGroupCompositionType_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VehicleGroupCompositionElementType                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_VehicleGroupCompositionElementType (OSCTXT* pctxt, 
   VehicleGroupCompositionElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode request */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_VehicleGroupCompositionType (pctxt, 
               &pvalue->request, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_VehicleGroupCompositionElementType (OSCTXT* pctxt, 
   VehicleGroupCompositionElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("request"), 7}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* request */
            stat = XmlDec_VehicleGroupCompositionType (pctxt, &pvalue->request
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "VehicleGroupCompositionElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "VehicleGroupCompositionElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DimensionsElementType                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_DimensionsElementType (OSCTXT* pctxt, 
   DimensionsElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode height */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->height, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode length */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->length, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode mass */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->mass, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode width */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->width, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 4) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_DimensionsElementType (OSCTXT* pctxt, DimensionsElementType* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("height"), 6}, 0 },
         { {OSUTF8("length"), 6}, 0 },
         { {OSUTF8("mass"), 4}, 0 },
         { {OSUTF8("width"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* height */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->height);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* length */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* mass */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->mass);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* width */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->width);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "DimensionsElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "DimensionsElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UuvOperatingCharacteristicsElementType                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UuvOperatingCharacteristicsElementType (OSCTXT* pctxt, 
   UuvOperatingCharacteristicsElementType *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode cruiseSpeed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->cruiseSpeed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.cruiseSpeedPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode endurance */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->endurance, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.endurancePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode maxDepth */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->maxDepth, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.maxDepthPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode maxPitchRate */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->maxPitchRate, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.maxPitchRatePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode maxSpeed */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->maxSpeed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.maxSpeedPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode maxYawRate */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->maxYawRate, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.maxYawRatePresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode turnRadius */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->turnRadius, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.turnRadiusPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_PRIM|9):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UuvOperatingCharacteristicsElementType (OSCTXT* pctxt, 
   UuvOperatingCharacteristicsElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("cruiseSpeed"), 11}, 0 },
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("endurance"), 9}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("maxDepth"), 8}, 0 },
         { {OSUTF8("maxPitchRate"), 12}, 0 },
         { {OSUTF8("maxSpeed"), 8}, 0 },
         { {OSUTF8("maxYawRate"), 10}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("turnRadius"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 10, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* cruiseSpeed */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->cruiseSpeed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.cruiseSpeedPresent = TRUE;
            break;

         case 1: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 2: /* endurance */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->endurance);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.endurancePresent = TRUE;
            break;

         case 3: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 4: /* maxDepth */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->maxDepth);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.maxDepthPresent = TRUE;
            break;

         case 5: /* maxPitchRate */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->maxPitchRate);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.maxPitchRatePresent = TRUE;
            break;

         case 6: /* maxSpeed */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->maxSpeed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.maxSpeedPresent = TRUE;
            break;

         case 7: /* maxYawRate */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->maxYawRate);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.maxYawRatePresent = TRUE;
            break;

         case 8: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 9: /* turnRadius */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->turnRadius);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.turnRadiusPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UuvOperatingCharacteristicsElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UuvOperatingCharacteristicsElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DegreesOfControlElementType                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_DegreesOfControlElementType (OSCTXT* pctxt, 
   DegreesOfControlElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   pvalue->lateral = FALSE;
   pvalue->longitudinal = TRUE;
   pvalue->pitch = FALSE;
   pvalue->roll = FALSE;
   pvalue->vertical = FALSE;
   pvalue->yaw = TRUE;

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode lateral */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->lateral, ASN1IMPL, length);
            if (stat == 0) {
            }
         }
         break;

      case 3:
         /* decode longitudinal */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->longitudinal, ASN1IMPL, length);
            if (stat == 0) {
            }
         }
         break;

      case 4:
         /* decode pitch */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->pitch, ASN1IMPL, length);
            if (stat == 0) {
            }
         }
         break;

      case 5:
         /* decode roll */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->roll, ASN1IMPL, length);
            if (stat == 0) {
            }
         }
         break;

      case 6:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode vertical */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->vertical, ASN1IMPL, length);
            if (stat == 0) {
            }
         }
         break;

      case 8:
         /* decode yaw */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->yaw, ASN1IMPL, length);
            if (stat == 0) {
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_DegreesOfControlElementType (OSCTXT* pctxt, 
   DegreesOfControlElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("lateral"), 7}, 0 },
         { {OSUTF8("longitudinal"), 12}, 0 },
         { {OSUTF8("pitch"), 5}, 0 },
         { {OSUTF8("roll"), 4}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("vertical"), 8}, 0 },
         { {OSUTF8("yaw"), 3}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 9, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* lateral */
            stat = rtXmlpDecBool (pctxt, &pvalue->lateral);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* longitudinal */
            stat = rtXmlpDecBool (pctxt, &pvalue->longitudinal);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* pitch */
            stat = rtXmlpDecBool (pctxt, &pvalue->pitch);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* roll */
            stat = rtXmlpDecBool (pctxt, &pvalue->roll);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 6: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 7: /* vertical */
            stat = rtXmlpDecBool (pctxt, &pvalue->vertical);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 8: /* yaw */
            stat = rtXmlpDecBool (pctxt, &pvalue->yaw);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "DegreesOfControlElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "DegreesOfControlElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UuvCapabilityType                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UuvCapabilityType (OSCTXT* pctxt, UuvCapabilityType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if(*pvalue < 0 || *pvalue > 9)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   return (stat);
}

int XmlDec_UuvCapabilityType (OSCTXT* pctxt, UuvCapabilityType* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = UuvCapabilityType_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UuvCapabilityElementType                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UuvCapabilityElementType (OSCTXT* pctxt, 
   UuvCapabilityElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_UuvCapabilityType (pctxt, 
               &pvalue->value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UuvCapabilityElementType (OSCTXT* pctxt, 
   UuvCapabilityElementType* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* value */
            stat = XmlDec_UuvCapabilityType (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UuvCapabilityElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UuvCapabilityElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UuvCharacteristicsElementType                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UuvCharacteristicsElementType (OSCTXT* pctxt, 
   UuvCharacteristicsElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode dimensions */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_DimensionsElementType (pctxt, 
               &pvalue->dimensions, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dimensionsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode operatingCharacteristics */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_UuvOperatingCharacteristicsElementType (pctxt, 
               &pvalue->operatingCharacteristics, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.operatingCharacteristicsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode degreesOfControl */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_DegreesOfControlElementType (pctxt, 
               &pvalue->degreesOfControl, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.degreesOfControlPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode capability_list */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               UuvCapabilityElementType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->capability_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, UuvCapabilityElementType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_UuvCapabilityElementType (pdata2);

                  stat = asn1D_UuvCapabilityElementType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->capability_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UuvCharacteristicsElementType (OSCTXT* pctxt, 
   UuvCharacteristicsElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UuvCharacteristicsElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UuvCharacteristicsElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Dimensions"), 10}, 0}, 0 },
      {{{OSUTF8("OperatingCharacteristics"), 24}, 0}, 1 },
      {{{OSUTF8("DegreesOfControl"), 16}, 0}, 2 },
      {{{OSUTF8("Capability"), 10}, 0}, 3 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 4; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* Dimensions */
         stat = XmlDec_DimensionsElementType (pctxt, &pvalue->dimensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.dimensionsPresent = TRUE;
         break;
      }
      case 1: { /* OperatingCharacteristics */
         stat = XmlDec_UuvOperatingCharacteristicsElementType (pctxt, &pvalue->
            operatingCharacteristics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.operatingCharacteristicsPresent = TRUE;
         break;
      }
      case 2: { /* DegreesOfControl */
         stat = XmlDec_DegreesOfControlElementType (pctxt, &pvalue->
            degreesOfControl);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.degreesOfControlPresent = TRUE;
         break;
      }
      case 3: {
         UuvCapabilityElementType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, UuvCapabilityElementType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UuvCapabilityElementType (pdata1);

            stat = XmlDec_UuvCapabilityElementType (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->capability_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 3, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 3);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UgvOperatingCharacteristicsElementType                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UgvOperatingCharacteristicsElementType (OSCTXT* pctxt, 
   UgvOperatingCharacteristicsElementType *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode cruiseSpeed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->cruiseSpeed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.cruiseSpeedPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode endurance */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->endurance, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.endurancePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode maxSpeed */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->maxSpeed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.maxSpeedPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode maxYawRate */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->maxYawRate, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.maxYawRatePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode staticPitchover */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->staticPitchover, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.staticPitchoverPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode staticRollover */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->staticRollover, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.staticRolloverPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode trackWidth */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->trackWidth, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.trackWidthPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode turnRadius */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->turnRadius, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.turnRadiusPresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode wheelBase */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->wheelBase, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.wheelBasePresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_PRIM|11):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UgvOperatingCharacteristicsElementType (OSCTXT* pctxt, 
   UgvOperatingCharacteristicsElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("cruiseSpeed"), 11}, 0 },
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("endurance"), 9}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("maxSpeed"), 8}, 0 },
         { {OSUTF8("maxYawRate"), 10}, 0 },
         { {OSUTF8("staticPitchover"), 15}, 0 },
         { {OSUTF8("staticRollover"), 14}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("trackWidth"), 10}, 0 },
         { {OSUTF8("turnRadius"), 10}, 0 },
         { {OSUTF8("wheelBase"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 12, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* cruiseSpeed */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->cruiseSpeed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.cruiseSpeedPresent = TRUE;
            break;

         case 1: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 2: /* endurance */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->endurance);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.endurancePresent = TRUE;
            break;

         case 3: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 4: /* maxSpeed */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->maxSpeed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.maxSpeedPresent = TRUE;
            break;

         case 5: /* maxYawRate */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->maxYawRate);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.maxYawRatePresent = TRUE;
            break;

         case 6: /* staticPitchover */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->staticPitchover
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.staticPitchoverPresent = TRUE;
            break;

         case 7: /* staticRollover */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->staticRollover);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.staticRolloverPresent = TRUE;
            break;

         case 8: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 9: /* trackWidth */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->trackWidth);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.trackWidthPresent = TRUE;
            break;

         case 10: /* turnRadius */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->turnRadius);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.turnRadiusPresent = TRUE;
            break;

         case 11: /* wheelBase */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->wheelBase);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.wheelBasePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UgvOperatingCharacteristicsElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UgvOperatingCharacteristicsElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UgvCapabilityType                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UgvCapabilityType (OSCTXT* pctxt, UgvCapabilityType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if(*pvalue < 0 || *pvalue > 3)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   return (stat);
}

int XmlDec_UgvCapabilityType (OSCTXT* pctxt, UgvCapabilityType* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = UgvCapabilityType_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UgvCapabilityElementType                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UgvCapabilityElementType (OSCTXT* pctxt, 
   UgvCapabilityElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_UgvCapabilityType (pctxt, 
               &pvalue->value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UgvCapabilityElementType (OSCTXT* pctxt, 
   UgvCapabilityElementType* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* value */
            stat = XmlDec_UgvCapabilityType (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UgvCapabilityElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UgvCapabilityElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UgvCharacteristicsElementType                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UgvCharacteristicsElementType (OSCTXT* pctxt, 
   UgvCharacteristicsElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode dimensions */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_DimensionsElementType (pctxt, 
               &pvalue->dimensions, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dimensionsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode operatingCharacteristics */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_UgvOperatingCharacteristicsElementType (pctxt, 
               &pvalue->operatingCharacteristics, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.operatingCharacteristicsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode degreesOfControl */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_DegreesOfControlElementType (pctxt, 
               &pvalue->degreesOfControl, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.degreesOfControlPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode capability_list */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               UgvCapabilityElementType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->capability_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, UgvCapabilityElementType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_UgvCapabilityElementType (pdata2);

                  stat = asn1D_UgvCapabilityElementType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->capability_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UgvCharacteristicsElementType (OSCTXT* pctxt, 
   UgvCharacteristicsElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UgvCharacteristicsElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UgvCharacteristicsElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Dimensions"), 10}, 0}, 0 },
      {{{OSUTF8("OperatingCharacteristics"), 24}, 0}, 1 },
      {{{OSUTF8("DegreesOfControl"), 16}, 0}, 2 },
      {{{OSUTF8("Capability"), 10}, 0}, 3 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 4; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* Dimensions */
         stat = XmlDec_DimensionsElementType (pctxt, &pvalue->dimensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.dimensionsPresent = TRUE;
         break;
      }
      case 1: { /* OperatingCharacteristics */
         stat = XmlDec_UgvOperatingCharacteristicsElementType (pctxt, &pvalue->
            operatingCharacteristics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.operatingCharacteristicsPresent = TRUE;
         break;
      }
      case 2: { /* DegreesOfControl */
         stat = XmlDec_DegreesOfControlElementType (pctxt, &pvalue->
            degreesOfControl);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.degreesOfControlPresent = TRUE;
         break;
      }
      case 3: {
         UgvCapabilityElementType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, UgvCapabilityElementType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UgvCapabilityElementType (pdata1);

            stat = XmlDec_UgvCapabilityElementType (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->capability_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 3, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 3);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UsvOperatingCharacteristicsElementType                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UsvOperatingCharacteristicsElementType (OSCTXT* pctxt, 
   UsvOperatingCharacteristicsElementType *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode cruiseSpeed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->cruiseSpeed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.cruiseSpeedPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode endurance */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->endurance, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.endurancePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode maxSpeed */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->maxSpeed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.maxSpeedPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode maxYawRate */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->maxYawRate, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.maxYawRatePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode turnRadius */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->turnRadius, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.turnRadiusPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UsvOperatingCharacteristicsElementType (OSCTXT* pctxt, 
   UsvOperatingCharacteristicsElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("cruiseSpeed"), 11}, 0 },
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("endurance"), 9}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("maxSpeed"), 8}, 0 },
         { {OSUTF8("maxYawRate"), 10}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("turnRadius"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 8, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* cruiseSpeed */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->cruiseSpeed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.cruiseSpeedPresent = TRUE;
            break;

         case 1: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 2: /* endurance */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->endurance);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.endurancePresent = TRUE;
            break;

         case 3: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 4: /* maxSpeed */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->maxSpeed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.maxSpeedPresent = TRUE;
            break;

         case 5: /* maxYawRate */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->maxYawRate);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.maxYawRatePresent = TRUE;
            break;

         case 6: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 7: /* turnRadius */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->turnRadius);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.turnRadiusPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UsvOperatingCharacteristicsElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UsvOperatingCharacteristicsElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UsvCapabilityType                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UsvCapabilityType (OSCTXT* pctxt, UsvCapabilityType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if(*pvalue < 0 || *pvalue > 3)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   return (stat);
}

int XmlDec_UsvCapabilityType (OSCTXT* pctxt, UsvCapabilityType* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = UsvCapabilityType_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UsvCapabilityElementType                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UsvCapabilityElementType (OSCTXT* pctxt, 
   UsvCapabilityElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_UsvCapabilityType (pctxt, 
               &pvalue->value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UsvCapabilityElementType (OSCTXT* pctxt, 
   UsvCapabilityElementType* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* value */
            stat = XmlDec_UsvCapabilityType (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UsvCapabilityElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UsvCapabilityElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UsvCharacteristicsElementType                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UsvCharacteristicsElementType (OSCTXT* pctxt, 
   UsvCharacteristicsElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode dimensions */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_DimensionsElementType (pctxt, 
               &pvalue->dimensions, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dimensionsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode operatingCharacteristics */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_UsvOperatingCharacteristicsElementType (pctxt, 
               &pvalue->operatingCharacteristics, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.operatingCharacteristicsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode degreesOfControl */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_DegreesOfControlElementType (pctxt, 
               &pvalue->degreesOfControl, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.degreesOfControlPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode capability_list */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               UsvCapabilityElementType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->capability_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, UsvCapabilityElementType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_UsvCapabilityElementType (pdata2);

                  stat = asn1D_UsvCapabilityElementType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->capability_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UsvCharacteristicsElementType (OSCTXT* pctxt, 
   UsvCharacteristicsElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UsvCharacteristicsElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UsvCharacteristicsElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Dimensions"), 10}, 0}, 0 },
      {{{OSUTF8("OperatingCharacteristics"), 24}, 0}, 1 },
      {{{OSUTF8("DegreesOfControl"), 16}, 0}, 2 },
      {{{OSUTF8("Capability"), 10}, 0}, 3 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 4; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* Dimensions */
         stat = XmlDec_DimensionsElementType (pctxt, &pvalue->dimensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.dimensionsPresent = TRUE;
         break;
      }
      case 1: { /* OperatingCharacteristics */
         stat = XmlDec_UsvOperatingCharacteristicsElementType (pctxt, &pvalue->
            operatingCharacteristics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.operatingCharacteristicsPresent = TRUE;
         break;
      }
      case 2: { /* DegreesOfControl */
         stat = XmlDec_DegreesOfControlElementType (pctxt, &pvalue->
            degreesOfControl);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.degreesOfControlPresent = TRUE;
         break;
      }
      case 3: {
         UsvCapabilityElementType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, UsvCapabilityElementType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UsvCapabilityElementType (pdata1);

            stat = XmlDec_UsvCapabilityElementType (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->capability_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 3, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 3);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UavOperatingCharacteristicsElementType                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UavOperatingCharacteristicsElementType (OSCTXT* pctxt, 
   UavOperatingCharacteristicsElementType *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode cruiseSpeed */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->cruiseSpeed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.cruiseSpeedPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode endurance */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->endurance, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.endurancePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode maxAltitude */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->maxAltitude, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.maxAltitudePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode maxPitchRate */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->maxPitchRate, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.maxPitchRatePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode maxRollRate */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->maxRollRate, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.maxRollRatePresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode maxSpeed */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->maxSpeed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.maxSpeedPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode maxYawRate */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->maxYawRate, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.maxYawRatePresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_PRIM|9):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UavOperatingCharacteristicsElementType (OSCTXT* pctxt, 
   UavOperatingCharacteristicsElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("cruiseSpeed"), 11}, 0 },
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("endurance"), 9}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("maxAltitude"), 11}, 0 },
         { {OSUTF8("maxPitchRate"), 12}, 0 },
         { {OSUTF8("maxRollRate"), 11}, 0 },
         { {OSUTF8("maxSpeed"), 8}, 0 },
         { {OSUTF8("maxYawRate"), 10}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 10, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* cruiseSpeed */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->cruiseSpeed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.cruiseSpeedPresent = TRUE;
            break;

         case 1: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 2: /* endurance */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->endurance);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.endurancePresent = TRUE;
            break;

         case 3: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 4: /* maxAltitude */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->maxAltitude);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.maxAltitudePresent = TRUE;
            break;

         case 5: /* maxPitchRate */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->maxPitchRate);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.maxPitchRatePresent = TRUE;
            break;

         case 6: /* maxRollRate */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->maxRollRate);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.maxRollRatePresent = TRUE;
            break;

         case 7: /* maxSpeed */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->maxSpeed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.maxSpeedPresent = TRUE;
            break;

         case 8: /* maxYawRate */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->maxYawRate);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.maxYawRatePresent = TRUE;
            break;

         case 9: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UavOperatingCharacteristicsElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UavOperatingCharacteristicsElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UavCapabilityType                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UavCapabilityType (OSCTXT* pctxt, UavCapabilityType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if(*pvalue < 0 || *pvalue > 5)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   return (stat);
}

int XmlDec_UavCapabilityType (OSCTXT* pctxt, UavCapabilityType* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = UavCapabilityType_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UavCapabilityElementType                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UavCapabilityElementType (OSCTXT* pctxt, 
   UavCapabilityElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_UavCapabilityType (pctxt, 
               &pvalue->value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UavCapabilityElementType (OSCTXT* pctxt, 
   UavCapabilityElementType* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* value */
            stat = XmlDec_UavCapabilityType (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UavCapabilityElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UavCapabilityElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UavCharacteristicsElementType                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UavCharacteristicsElementType (OSCTXT* pctxt, 
   UavCharacteristicsElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode dimensions */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_DimensionsElementType (pctxt, 
               &pvalue->dimensions, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dimensionsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode operatingCharacteristics */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_UavOperatingCharacteristicsElementType (pctxt, 
               &pvalue->operatingCharacteristics, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.operatingCharacteristicsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode degreesOfControl */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_DegreesOfControlElementType (pctxt, 
               &pvalue->degreesOfControl, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.degreesOfControlPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode capability_list */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               UavCapabilityElementType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->capability_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, UavCapabilityElementType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_UavCapabilityElementType (pdata2);

                  stat = asn1D_UavCapabilityElementType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->capability_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UavCharacteristicsElementType (OSCTXT* pctxt, 
   UavCharacteristicsElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UavCharacteristicsElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UavCharacteristicsElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Dimensions"), 10}, 0}, 0 },
      {{{OSUTF8("OperatingCharacteristics"), 24}, 0}, 1 },
      {{{OSUTF8("DegreesOfControl"), 16}, 0}, 2 },
      {{{OSUTF8("Capability"), 10}, 0}, 3 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 4; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* Dimensions */
         stat = XmlDec_DimensionsElementType (pctxt, &pvalue->dimensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.dimensionsPresent = TRUE;
         break;
      }
      case 1: { /* OperatingCharacteristics */
         stat = XmlDec_UavOperatingCharacteristicsElementType (pctxt, &pvalue->
            operatingCharacteristics);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.operatingCharacteristicsPresent = TRUE;
         break;
      }
      case 2: { /* DegreesOfControl */
         stat = XmlDec_DegreesOfControlElementType (pctxt, &pvalue->
            degreesOfControl);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.degreesOfControlPresent = TRUE;
         break;
      }
      case 3: {
         UavCapabilityElementType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, UavCapabilityElementType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UavCapabilityElementType (pdata1);

            stat = XmlDec_UavCapabilityElementType (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->capability_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 3, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 3);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VehicleCharacteristicsGroup                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_VehicleCharacteristicsGroup (OSCTXT* pctxt, 
   VehicleCharacteristicsGroup *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.uUVCharacteristics
             = rtxMemAllocType (pctxt, UuvCharacteristicsElementType);

         if (pvalue->u.uUVCharacteristics == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UuvCharacteristicsElementType (pvalue->u.uUVCharacteristics);
         stat = asn1D_UuvCharacteristicsElementType (pctxt, 
            pvalue->u.uUVCharacteristics, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.uGVCharacteristics
             = rtxMemAllocType (pctxt, UgvCharacteristicsElementType);

         if (pvalue->u.uGVCharacteristics == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UgvCharacteristicsElementType (pvalue->u.uGVCharacteristics);
         stat = asn1D_UgvCharacteristicsElementType (pctxt, 
            pvalue->u.uGVCharacteristics, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.uSVCharacteristics
             = rtxMemAllocType (pctxt, UsvCharacteristicsElementType);

         if (pvalue->u.uSVCharacteristics == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UsvCharacteristicsElementType (pvalue->u.uSVCharacteristics);
         stat = asn1D_UsvCharacteristicsElementType (pctxt, 
            pvalue->u.uSVCharacteristics, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.uAVCharacteristics
             = rtxMemAllocType (pctxt, UavCharacteristicsElementType);

         if (pvalue->u.uAVCharacteristics == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UavCharacteristicsElementType (pvalue->u.uAVCharacteristics);
         stat = asn1D_UavCharacteristicsElementType (pctxt, 
            pvalue->u.uAVCharacteristics, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_VehicleCharacteristicsGroup (OSCTXT* pctxt, 
   VehicleCharacteristicsGroup* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("UUVCharacteristics"), 18}, 0}, 0 },
      {{{OSUTF8("UGVCharacteristics"), 18}, 0}, 1 },
      {{{OSUTF8("USVCharacteristics"), 18}, 0}, 2 },
      {{{OSUTF8("UAVCharacteristics"), 18}, 0}, 3 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 4, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* UUVCharacteristics */
      pvalue->u.uUVCharacteristics
          = rtxMemAllocType (pctxt, UuvCharacteristicsElementType);

      if (pvalue->u.uUVCharacteristics == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UuvCharacteristicsElementType (pvalue->u.uUVCharacteristics);

      stat = XmlDec_UuvCharacteristicsElementType (pctxt, pvalue->
         u.uUVCharacteristics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* UGVCharacteristics */
      pvalue->u.uGVCharacteristics
          = rtxMemAllocType (pctxt, UgvCharacteristicsElementType);

      if (pvalue->u.uGVCharacteristics == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UgvCharacteristicsElementType (pvalue->u.uGVCharacteristics);

      stat = XmlDec_UgvCharacteristicsElementType (pctxt, pvalue->
         u.uGVCharacteristics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* USVCharacteristics */
      pvalue->u.uSVCharacteristics
          = rtxMemAllocType (pctxt, UsvCharacteristicsElementType);

      if (pvalue->u.uSVCharacteristics == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UsvCharacteristicsElementType (pvalue->u.uSVCharacteristics);

      stat = XmlDec_UsvCharacteristicsElementType (pctxt, pvalue->
         u.uSVCharacteristics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* UAVCharacteristics */
      pvalue->u.uAVCharacteristics
          = rtxMemAllocType (pctxt, UavCharacteristicsElementType);

      if (pvalue->u.uAVCharacteristics == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UavCharacteristicsElementType (pvalue->u.uAVCharacteristics);

      stat = XmlDec_UavCharacteristicsElementType (pctxt, pvalue->
         u.uAVCharacteristics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UuvVerticalPositionElementType                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UuvVerticalPositionElementType (OSCTXT* pctxt, 
   UuvVerticalPositionElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode altitude */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->altitude, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.altitudePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode depth */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->depth, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UuvVerticalPositionElementType (OSCTXT* pctxt, 
   UuvVerticalPositionElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("altitude"), 8}, 0 },
         { {OSUTF8("depth"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* altitude */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->altitude);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.altitudePresent = TRUE;
            break;

         case 1: /* depth */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->depth);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UuvVerticalPositionElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UuvVerticalPositionElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  OrientationType                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_OrientationType (OSCTXT* pctxt, OrientationType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_real (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_OrientationType (OSCTXT* pctxt, OrientationType* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDouble (pctxt, pvalue, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  OrientationElementType                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_OrientationElementType (OSCTXT* pctxt, 
   OrientationElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode phi */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_OrientationType (pctxt, 
               &pvalue->phi, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.phiPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode psi */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_OrientationType (pctxt, 
               &pvalue->psi, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.psiPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode theta */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_OrientationType (pctxt, 
               &pvalue->theta, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.thetaPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_OrientationElementType (OSCTXT* pctxt, 
   OrientationElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("phi"), 3}, 0 },
         { {OSUTF8("psi"), 3}, 0 },
         { {OSUTF8("theta"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* phi */
            stat = XmlDec_OrientationType (pctxt, &pvalue->phi);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.phiPresent = TRUE;
            break;

         case 1: /* psi */
            stat = XmlDec_OrientationType (pctxt, &pvalue->psi);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.psiPresent = TRUE;
            break;

         case 2: /* theta */
            stat = XmlDec_OrientationType (pctxt, &pvalue->theta);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.thetaPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "OrientationElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "OrientationElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  WorldCoordinateVelocityElementType                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_WorldCoordinateVelocityElementType (OSCTXT* pctxt, 
   WorldCoordinateVelocityElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode phiDot */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->phiDot, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.phiDotPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode psiDot */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->psiDot, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.psiDotPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode thetaDot */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->thetaDot, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.thetaDotPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode xDot */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->xDot, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.xDotPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode yDot */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->yDot, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.yDotPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode zDot */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->zDot, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.zDotPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_WorldCoordinateVelocityElementType (OSCTXT* pctxt, 
   WorldCoordinateVelocityElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("phiDot"), 6}, 0 },
         { {OSUTF8("psiDot"), 6}, 0 },
         { {OSUTF8("thetaDot"), 8}, 0 },
         { {OSUTF8("xDot"), 4}, 0 },
         { {OSUTF8("yDot"), 4}, 0 },
         { {OSUTF8("zDot"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 6, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* phiDot */
            stat = rtXmlpDecDouble (pctxt, &pvalue->phiDot, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.phiDotPresent = TRUE;
            break;

         case 1: /* psiDot */
            stat = rtXmlpDecDouble (pctxt, &pvalue->psiDot, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.psiDotPresent = TRUE;
            break;

         case 2: /* thetaDot */
            stat = rtXmlpDecDouble (pctxt, &pvalue->thetaDot, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.thetaDotPresent = TRUE;
            break;

         case 3: /* xDot */
            stat = rtXmlpDecDouble (pctxt, &pvalue->xDot, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.xDotPresent = TRUE;
            break;

         case 4: /* yDot */
            stat = rtXmlpDecDouble (pctxt, &pvalue->yDot, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.yDotPresent = TRUE;
            break;

         case 5: /* zDot */
            stat = rtXmlpDecDouble (pctxt, &pvalue->zDot, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.zDotPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "WorldCoordinateVelocityElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "WorldCoordinateVelocityElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  BodyCoordinateVelocityElementType                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_BodyCoordinateVelocityElementType (OSCTXT* pctxt, 
   BodyCoordinateVelocityElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode p */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->p, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.pPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode q */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->q, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.qPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode r */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->r, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.rPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode u */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->u, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode v */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->v, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.vPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode w */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->w, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.wPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_BodyCoordinateVelocityElementType (OSCTXT* pctxt, 
   BodyCoordinateVelocityElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("p"), 1}, 0 },
         { {OSUTF8("q"), 1}, 0 },
         { {OSUTF8("r"), 1}, 0 },
         { {OSUTF8("u"), 1}, 0 },
         { {OSUTF8("v"), 1}, 0 },
         { {OSUTF8("w"), 1}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 6, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* p */
            stat = rtXmlpDecDouble (pctxt, &pvalue->p, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.pPresent = TRUE;
            break;

         case 1: /* q */
            stat = rtXmlpDecDouble (pctxt, &pvalue->q, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.qPresent = TRUE;
            break;

         case 2: /* r */
            stat = rtXmlpDecDouble (pctxt, &pvalue->r, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.rPresent = TRUE;
            break;

         case 3: /* u */
            stat = rtXmlpDecDouble (pctxt, &pvalue->u, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uPresent = TRUE;
            break;

         case 4: /* v */
            stat = rtXmlpDecDouble (pctxt, &pvalue->v, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.vPresent = TRUE;
            break;

         case 5: /* w */
            stat = rtXmlpDecDouble (pctxt, &pvalue->w, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.wPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "BodyCoordinateVelocityElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "BodyCoordinateVelocityElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DopplerVelocityElementType                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_DopplerVelocityElementType (OSCTXT* pctxt, 
   DopplerVelocityElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode speedOverGroundU */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->speedOverGroundU, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.speedOverGroundUPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode speedOverGroundV */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->speedOverGroundV, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.speedOverGroundVPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode speedThroughMediumU */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->speedThroughMediumU, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.speedThroughMediumUPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode speedThroughMediumV */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->speedThroughMediumV, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.speedThroughMediumVPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_DopplerVelocityElementType (OSCTXT* pctxt, 
   DopplerVelocityElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("speedOverGroundU"), 16}, 0 },
         { {OSUTF8("speedOverGroundV"), 16}, 0 },
         { {OSUTF8("speedThroughMediumU"), 19}, 0 },
         { {OSUTF8("speedThroughMediumV"), 19}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* speedOverGroundU */
            stat = rtXmlpDecDouble (pctxt, &pvalue->speedOverGroundU, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.speedOverGroundUPresent = TRUE;
            break;

         case 1: /* speedOverGroundV */
            stat = rtXmlpDecDouble (pctxt, &pvalue->speedOverGroundV, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.speedOverGroundVPresent = TRUE;
            break;

         case 2: /* speedThroughMediumU */
            stat = rtXmlpDecDouble (pctxt, &pvalue->speedThroughMediumU
               , -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.speedThroughMediumUPresent = TRUE;
            break;

         case 3: /* speedThroughMediumV */
            stat = rtXmlpDecDouble (pctxt, &pvalue->speedThroughMediumV
               , -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.speedThroughMediumVPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "DopplerVelocityElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "DopplerVelocityElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UuvTelemetryElementType                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UuvTelemetryElementType (OSCTXT* pctxt, 
   UuvTelemetryElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode _order */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               int xx2;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               xx2 = 0;
               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  if (xx2 >= 7) return LOG_RTERR (pctxt, RTERR_SEQOVFLW);

                  { int length;
                  if (XD_PEEKTAG (pctxt, 0xa)) {
                     stat = xd_Tag1AndLen (pctxt, &length);
                     if (stat != 0) return LOG_RTERR (pctxt, stat);
                  }
                  else return LOG_RTERR (pctxt,
                     berErrUnexpTag(pctxt, TM_UNIV|TM_PRIM|10));

                  stat = xd_uint8 (pctxt, &pvalue->_order.elem[xx2], ASN1IMPL, length);
                  if (stat == 0) {
                     if (!((pvalue->_order.elem[xx2] <= OSUINTCONST(6)))) {
                        rtxErrAddStrParm (pctxt, "UuvTelemetryElementType._order.elem[xx2]");
                        rtxErrAddIntParm (pctxt, (int)pvalue->_order.elem[xx2]);
                        return LOG_RTERR (pctxt, RTERR_CONSVIO);
                     }

                  }
                  else return LOG_RTERR (pctxt, stat);

                  }
                  xx2++;
               }
               pvalue->_order.n = xx2;

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode geographicPosition */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AbsoluteHorizontalPositionElementType (pctxt, 
               &pvalue->geographicPosition, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.geographicPositionPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode verticalPosition */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_UuvVerticalPositionElementType (pctxt, 
               &pvalue->verticalPosition, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.verticalPositionPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode orientation */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_OrientationElementType (pctxt, 
               &pvalue->orientation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.orientationPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode worldCoordinateVelocity */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_WorldCoordinateVelocityElementType (pctxt, 
               &pvalue->worldCoordinateVelocity, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.worldCoordinateVelocityPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode bodyCoordinateVelocity */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_BodyCoordinateVelocityElementType (pctxt, 
               &pvalue->bodyCoordinateVelocity, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bodyCoordinateVelocityPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode dopplerVelocity */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_DopplerVelocityElementType (pctxt, 
               &pvalue->dopplerVelocity, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dopplerVelocityPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 10:
         /* decode remainingPower */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PercentElementType (pctxt, 
               &pvalue->remainingPower, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.remainingPowerPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UuvTelemetryElementType (OSCTXT* pctxt, 
   UuvTelemetryElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UuvTelemetryElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UuvTelemetryElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("GeographicPosition"), 18}, 0}, 0 },
      {{{OSUTF8("VerticalPosition"), 16}, 0}, 1 },
      {{{OSUTF8("Orientation"), 11}, 0}, 2 },
      {{{OSUTF8("WorldCoordinateVelocity"), 23}, 0}, 3 },
      {{{OSUTF8("BodyCoordinateVelocity"), 22}, 0}, 4 },
      {{{OSUTF8("DopplerVelocity"), 15}, 0}, 5 },
      {{{OSUTF8("RemainingPower"), 14}, 0}, 6 }
   } ;
   pvalue->_order.n = 0;

   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 7, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: { /* GeographicPosition */
         stat = XmlDec_AbsoluteHorizontalPositionElementType (pctxt, &pvalue->
            geographicPosition);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.geographicPositionPresent = TRUE;
         break;
      }
      case 1: { /* VerticalPosition */
         stat = XmlDec_UuvVerticalPositionElementType (pctxt, &pvalue->
            verticalPosition);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.verticalPositionPresent = TRUE;
         break;
      }
      case 2: { /* Orientation */
         stat = XmlDec_OrientationElementType (pctxt, &pvalue->orientation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.orientationPresent = TRUE;
         break;
      }
      case 3: { /* WorldCoordinateVelocity */
         stat = XmlDec_WorldCoordinateVelocityElementType (pctxt, &pvalue->
            worldCoordinateVelocity);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.worldCoordinateVelocityPresent = TRUE;
         break;
      }
      case 4: { /* BodyCoordinateVelocity */
         stat = XmlDec_BodyCoordinateVelocityElementType (pctxt, &pvalue->
            bodyCoordinateVelocity);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.bodyCoordinateVelocityPresent = TRUE;
         break;
      }
      case 5: { /* DopplerVelocity */
         stat = XmlDec_DopplerVelocityElementType (pctxt, &pvalue->
            dopplerVelocity);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.dopplerVelocityPresent = TRUE;
         break;
      }
      case 6: { /* RemainingPower */
         stat = XmlDec_PercentElementType (pctxt, &pvalue->remainingPower);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.remainingPowerPresent = TRUE;
         break;
      }
      }
      pvalue->_order.elem[pvalue->_order.n++] = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UsvTelemetryElementType                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UsvTelemetryElementType (OSCTXT* pctxt, 
   UsvTelemetryElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode _order */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               int xx2;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               xx2 = 0;
               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  if (xx2 >= 6) return LOG_RTERR (pctxt, RTERR_SEQOVFLW);

                  { int length;
                  if (XD_PEEKTAG (pctxt, 0xa)) {
                     stat = xd_Tag1AndLen (pctxt, &length);
                     if (stat != 0) return LOG_RTERR (pctxt, stat);
                  }
                  else return LOG_RTERR (pctxt,
                     berErrUnexpTag(pctxt, TM_UNIV|TM_PRIM|10));

                  stat = xd_uint8 (pctxt, &pvalue->_order.elem[xx2], ASN1IMPL, length);
                  if (stat == 0) {
                     if (!((pvalue->_order.elem[xx2] <= OSUINTCONST(5)))) {
                        rtxErrAddStrParm (pctxt, "UsvTelemetryElementType._order.elem[xx2]");
                        rtxErrAddIntParm (pctxt, (int)pvalue->_order.elem[xx2]);
                        return LOG_RTERR (pctxt, RTERR_CONSVIO);
                     }

                  }
                  else return LOG_RTERR (pctxt, stat);

                  }
                  xx2++;
               }
               pvalue->_order.n = xx2;

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode geographicPosition */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AbsoluteHorizontalPositionElementType (pctxt, 
               &pvalue->geographicPosition, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.geographicPositionPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode orientation */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_OrientationElementType (pctxt, 
               &pvalue->orientation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.orientationPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode worldCoordinateVelocity */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_WorldCoordinateVelocityElementType (pctxt, 
               &pvalue->worldCoordinateVelocity, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.worldCoordinateVelocityPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode bodyCoordinateVelocity */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_BodyCoordinateVelocityElementType (pctxt, 
               &pvalue->bodyCoordinateVelocity, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bodyCoordinateVelocityPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode dopplerVelocity */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_DopplerVelocityElementType (pctxt, 
               &pvalue->dopplerVelocity, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dopplerVelocityPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode remainingPower */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PercentElementType (pctxt, 
               &pvalue->remainingPower, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.remainingPowerPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UsvTelemetryElementType (OSCTXT* pctxt, 
   UsvTelemetryElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UsvTelemetryElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UsvTelemetryElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("GeographicPosition"), 18}, 0}, 0 },
      {{{OSUTF8("Orientation"), 11}, 0}, 1 },
      {{{OSUTF8("WorldCoordinateVelocity"), 23}, 0}, 2 },
      {{{OSUTF8("BodyCoordinateVelocity"), 22}, 0}, 3 },
      {{{OSUTF8("DopplerVelocity"), 15}, 0}, 4 },
      {{{OSUTF8("RemainingPower"), 14}, 0}, 5 }
   } ;
   pvalue->_order.n = 0;

   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 6, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: { /* GeographicPosition */
         stat = XmlDec_AbsoluteHorizontalPositionElementType (pctxt, &pvalue->
            geographicPosition);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.geographicPositionPresent = TRUE;
         break;
      }
      case 1: { /* Orientation */
         stat = XmlDec_OrientationElementType (pctxt, &pvalue->orientation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.orientationPresent = TRUE;
         break;
      }
      case 2: { /* WorldCoordinateVelocity */
         stat = XmlDec_WorldCoordinateVelocityElementType (pctxt, &pvalue->
            worldCoordinateVelocity);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.worldCoordinateVelocityPresent = TRUE;
         break;
      }
      case 3: { /* BodyCoordinateVelocity */
         stat = XmlDec_BodyCoordinateVelocityElementType (pctxt, &pvalue->
            bodyCoordinateVelocity);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.bodyCoordinateVelocityPresent = TRUE;
         break;
      }
      case 4: { /* DopplerVelocity */
         stat = XmlDec_DopplerVelocityElementType (pctxt, &pvalue->
            dopplerVelocity);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.dopplerVelocityPresent = TRUE;
         break;
      }
      case 5: { /* RemainingPower */
         stat = XmlDec_PercentElementType (pctxt, &pvalue->remainingPower);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.remainingPowerPresent = TRUE;
         break;
      }
      }
      pvalue->_order.elem[pvalue->_order.n++] = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UgvVerticalPositionElementType                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UgvVerticalPositionElementType (OSCTXT* pctxt, 
   UgvVerticalPositionElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode altitudeMSL */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->altitudeMSL, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UgvVerticalPositionElementType (OSCTXT* pctxt, 
   UgvVerticalPositionElementType* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("altitudeMSL"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* altitudeMSL */
            stat = rtXmlpDecDouble (pctxt, &pvalue->altitudeMSL, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UgvVerticalPositionElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UgvVerticalPositionElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UgvTelemetryElementType                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UgvTelemetryElementType (OSCTXT* pctxt, 
   UgvTelemetryElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode _order */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               int xx2;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               xx2 = 0;
               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  if (xx2 >= 7) return LOG_RTERR (pctxt, RTERR_SEQOVFLW);

                  { int length;
                  if (XD_PEEKTAG (pctxt, 0xa)) {
                     stat = xd_Tag1AndLen (pctxt, &length);
                     if (stat != 0) return LOG_RTERR (pctxt, stat);
                  }
                  else return LOG_RTERR (pctxt,
                     berErrUnexpTag(pctxt, TM_UNIV|TM_PRIM|10));

                  stat = xd_uint8 (pctxt, &pvalue->_order.elem[xx2], ASN1IMPL, length);
                  if (stat == 0) {
                     if (!((pvalue->_order.elem[xx2] <= OSUINTCONST(6)))) {
                        rtxErrAddStrParm (pctxt, "UgvTelemetryElementType._order.elem[xx2]");
                        rtxErrAddIntParm (pctxt, (int)pvalue->_order.elem[xx2]);
                        return LOG_RTERR (pctxt, RTERR_CONSVIO);
                     }

                  }
                  else return LOG_RTERR (pctxt, stat);

                  }
                  xx2++;
               }
               pvalue->_order.n = xx2;

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode geographicPosition */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AbsoluteHorizontalPositionElementType (pctxt, 
               &pvalue->geographicPosition, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.geographicPositionPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode altitude */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_UgvVerticalPositionElementType (pctxt, 
               &pvalue->altitude, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.altitudePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode orientation */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_OrientationElementType (pctxt, 
               &pvalue->orientation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.orientationPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode worldCoordinateVelocity */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_WorldCoordinateVelocityElementType (pctxt, 
               &pvalue->worldCoordinateVelocity, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.worldCoordinateVelocityPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode bodyCoordinateVelocity */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_BodyCoordinateVelocityElementType (pctxt, 
               &pvalue->bodyCoordinateVelocity, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bodyCoordinateVelocityPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode dopplerVelocity */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_DopplerVelocityElementType (pctxt, 
               &pvalue->dopplerVelocity, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dopplerVelocityPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 10:
         /* decode remainingPower */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PercentElementType (pctxt, 
               &pvalue->remainingPower, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.remainingPowerPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UgvTelemetryElementType (OSCTXT* pctxt, 
   UgvTelemetryElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UgvTelemetryElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UgvTelemetryElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("GeographicPosition"), 18}, 0}, 0 },
      {{{OSUTF8("Altitude"), 8}, 0}, 1 },
      {{{OSUTF8("Orientation"), 11}, 0}, 2 },
      {{{OSUTF8("WorldCoordinateVelocity"), 23}, 0}, 3 },
      {{{OSUTF8("BodyCoordinateVelocity"), 22}, 0}, 4 },
      {{{OSUTF8("DopplerVelocity"), 15}, 0}, 5 },
      {{{OSUTF8("RemainingPower"), 14}, 0}, 6 }
   } ;
   pvalue->_order.n = 0;

   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 7, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: { /* GeographicPosition */
         stat = XmlDec_AbsoluteHorizontalPositionElementType (pctxt, &pvalue->
            geographicPosition);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.geographicPositionPresent = TRUE;
         break;
      }
      case 1: { /* Altitude */
         stat = XmlDec_UgvVerticalPositionElementType (pctxt, &pvalue->altitude
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.altitudePresent = TRUE;
         break;
      }
      case 2: { /* Orientation */
         stat = XmlDec_OrientationElementType (pctxt, &pvalue->orientation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.orientationPresent = TRUE;
         break;
      }
      case 3: { /* WorldCoordinateVelocity */
         stat = XmlDec_WorldCoordinateVelocityElementType (pctxt, &pvalue->
            worldCoordinateVelocity);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.worldCoordinateVelocityPresent = TRUE;
         break;
      }
      case 4: { /* BodyCoordinateVelocity */
         stat = XmlDec_BodyCoordinateVelocityElementType (pctxt, &pvalue->
            bodyCoordinateVelocity);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.bodyCoordinateVelocityPresent = TRUE;
         break;
      }
      case 5: { /* DopplerVelocity */
         stat = XmlDec_DopplerVelocityElementType (pctxt, &pvalue->
            dopplerVelocity);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.dopplerVelocityPresent = TRUE;
         break;
      }
      case 6: { /* RemainingPower */
         stat = XmlDec_PercentElementType (pctxt, &pvalue->remainingPower);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.remainingPowerPresent = TRUE;
         break;
      }
      }
      pvalue->_order.elem[pvalue->_order.n++] = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UavVerticalPositionElementType                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UavVerticalPositionElementType (OSCTXT* pctxt, 
   UavVerticalPositionElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode altitudeAGL */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveScalarType (pctxt, 
               &pvalue->altitudeAGL, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.altitudeAGLPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode altitudeMSL */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->altitudeMSL, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UavVerticalPositionElementType (OSCTXT* pctxt, 
   UavVerticalPositionElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("altitudeAGL"), 11}, 0 },
         { {OSUTF8("altitudeMSL"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* altitudeAGL */
            stat = XmlDec_PositiveScalarType (pctxt, &pvalue->altitudeAGL);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.altitudeAGLPresent = TRUE;
            break;

         case 1: /* altitudeMSL */
            stat = rtXmlpDecDouble (pctxt, &pvalue->altitudeMSL, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UavVerticalPositionElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UavVerticalPositionElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UavTelemetryElementType                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UavTelemetryElementType (OSCTXT* pctxt, 
   UavTelemetryElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode _order */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               int xx2;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               xx2 = 0;
               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  if (xx2 >= 7) return LOG_RTERR (pctxt, RTERR_SEQOVFLW);

                  { int length;
                  if (XD_PEEKTAG (pctxt, 0xa)) {
                     stat = xd_Tag1AndLen (pctxt, &length);
                     if (stat != 0) return LOG_RTERR (pctxt, stat);
                  }
                  else return LOG_RTERR (pctxt,
                     berErrUnexpTag(pctxt, TM_UNIV|TM_PRIM|10));

                  stat = xd_uint8 (pctxt, &pvalue->_order.elem[xx2], ASN1IMPL, length);
                  if (stat == 0) {
                     if (!((pvalue->_order.elem[xx2] <= OSUINTCONST(6)))) {
                        rtxErrAddStrParm (pctxt, "UavTelemetryElementType._order.elem[xx2]");
                        rtxErrAddIntParm (pctxt, (int)pvalue->_order.elem[xx2]);
                        return LOG_RTERR (pctxt, RTERR_CONSVIO);
                     }

                  }
                  else return LOG_RTERR (pctxt, stat);

                  }
                  xx2++;
               }
               pvalue->_order.n = xx2;

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode geographicPosition */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AbsoluteHorizontalPositionElementType (pctxt, 
               &pvalue->geographicPosition, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.geographicPositionPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode verticalPosition */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_UavVerticalPositionElementType (pctxt, 
               &pvalue->verticalPosition, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.verticalPositionPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode orientation */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_OrientationElementType (pctxt, 
               &pvalue->orientation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.orientationPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode worldCoordinateVelocity */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_WorldCoordinateVelocityElementType (pctxt, 
               &pvalue->worldCoordinateVelocity, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.worldCoordinateVelocityPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode bodyCoordinateVelocity */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_BodyCoordinateVelocityElementType (pctxt, 
               &pvalue->bodyCoordinateVelocity, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bodyCoordinateVelocityPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode dopplerVelocity */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_DopplerVelocityElementType (pctxt, 
               &pvalue->dopplerVelocity, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dopplerVelocityPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 10:
         /* decode remainingPower */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PercentElementType (pctxt, 
               &pvalue->remainingPower, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.remainingPowerPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UavTelemetryElementType (OSCTXT* pctxt, 
   UavTelemetryElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UavTelemetryElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UavTelemetryElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("GeographicPosition"), 18}, 0}, 0 },
      {{{OSUTF8("VerticalPosition"), 16}, 0}, 1 },
      {{{OSUTF8("Orientation"), 11}, 0}, 2 },
      {{{OSUTF8("WorldCoordinateVelocity"), 23}, 0}, 3 },
      {{{OSUTF8("BodyCoordinateVelocity"), 22}, 0}, 4 },
      {{{OSUTF8("DopplerVelocity"), 15}, 0}, 5 },
      {{{OSUTF8("RemainingPower"), 14}, 0}, 6 }
   } ;
   pvalue->_order.n = 0;

   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 7, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: { /* GeographicPosition */
         stat = XmlDec_AbsoluteHorizontalPositionElementType (pctxt, &pvalue->
            geographicPosition);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.geographicPositionPresent = TRUE;
         break;
      }
      case 1: { /* VerticalPosition */
         stat = XmlDec_UavVerticalPositionElementType (pctxt, &pvalue->
            verticalPosition);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.verticalPositionPresent = TRUE;
         break;
      }
      case 2: { /* Orientation */
         stat = XmlDec_OrientationElementType (pctxt, &pvalue->orientation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.orientationPresent = TRUE;
         break;
      }
      case 3: { /* WorldCoordinateVelocity */
         stat = XmlDec_WorldCoordinateVelocityElementType (pctxt, &pvalue->
            worldCoordinateVelocity);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.worldCoordinateVelocityPresent = TRUE;
         break;
      }
      case 4: { /* BodyCoordinateVelocity */
         stat = XmlDec_BodyCoordinateVelocityElementType (pctxt, &pvalue->
            bodyCoordinateVelocity);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.bodyCoordinateVelocityPresent = TRUE;
         break;
      }
      case 5: { /* DopplerVelocity */
         stat = XmlDec_DopplerVelocityElementType (pctxt, &pvalue->
            dopplerVelocity);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.dopplerVelocityPresent = TRUE;
         break;
      }
      case 6: { /* RemainingPower */
         stat = XmlDec_PercentElementType (pctxt, &pvalue->remainingPower);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.remainingPowerPresent = TRUE;
         break;
      }
      }
      pvalue->_order.elem[pvalue->_order.n++] = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DiscreteTimeResultsElementType_choice                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_DiscreteTimeResultsElementType_choice (OSCTXT* pctxt, 
   DiscreteTimeResultsElementType_choice *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.uUVTelemetry
             = rtxMemAllocType (pctxt, UuvTelemetryElementType);

         if (pvalue->u.uUVTelemetry == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UuvTelemetryElementType (pvalue->u.uUVTelemetry);
         stat = asn1D_UuvTelemetryElementType (pctxt, 
            pvalue->u.uUVTelemetry, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.uSVTelemetry
             = rtxMemAllocType (pctxt, UsvTelemetryElementType);

         if (pvalue->u.uSVTelemetry == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UsvTelemetryElementType (pvalue->u.uSVTelemetry);
         stat = asn1D_UsvTelemetryElementType (pctxt, 
            pvalue->u.uSVTelemetry, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.uGVTelemetry
             = rtxMemAllocType (pctxt, UgvTelemetryElementType);

         if (pvalue->u.uGVTelemetry == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UgvTelemetryElementType (pvalue->u.uGVTelemetry);
         stat = asn1D_UgvTelemetryElementType (pctxt, 
            pvalue->u.uGVTelemetry, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.uAVTelemetry
             = rtxMemAllocType (pctxt, UavTelemetryElementType);

         if (pvalue->u.uAVTelemetry == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UavTelemetryElementType (pvalue->u.uAVTelemetry);
         stat = asn1D_UavTelemetryElementType (pctxt, 
            pvalue->u.uAVTelemetry, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_DiscreteTimeResultsElementType_choice (OSCTXT* pctxt, 
   DiscreteTimeResultsElementType_choice* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("UUVTelemetry"), 12}, 0}, 0 },
      {{{OSUTF8("USVTelemetry"), 12}, 0}, 1 },
      {{{OSUTF8("UGVTelemetry"), 12}, 0}, 2 },
      {{{OSUTF8("UAVTelemetry"), 12}, 0}, 3 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 4, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* UUVTelemetry */
      pvalue->u.uUVTelemetry
          = rtxMemAllocType (pctxt, UuvTelemetryElementType);

      if (pvalue->u.uUVTelemetry == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UuvTelemetryElementType (pvalue->u.uUVTelemetry);

      stat = XmlDec_UuvTelemetryElementType (pctxt, pvalue->u.uUVTelemetry);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* USVTelemetry */
      pvalue->u.uSVTelemetry
          = rtxMemAllocType (pctxt, UsvTelemetryElementType);

      if (pvalue->u.uSVTelemetry == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UsvTelemetryElementType (pvalue->u.uSVTelemetry);

      stat = XmlDec_UsvTelemetryElementType (pctxt, pvalue->u.uSVTelemetry);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* UGVTelemetry */
      pvalue->u.uGVTelemetry
          = rtxMemAllocType (pctxt, UgvTelemetryElementType);

      if (pvalue->u.uGVTelemetry == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UgvTelemetryElementType (pvalue->u.uGVTelemetry);

      stat = XmlDec_UgvTelemetryElementType (pctxt, pvalue->u.uGVTelemetry);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* UAVTelemetry */
      pvalue->u.uAVTelemetry
          = rtxMemAllocType (pctxt, UavTelemetryElementType);

      if (pvalue->u.uAVTelemetry == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UavTelemetryElementType (pvalue->u.uAVTelemetry);

      stat = XmlDec_UavTelemetryElementType (pctxt, pvalue->u.uAVTelemetry);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UuvPropellersOrderElementType                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UuvPropellersOrderElementType (OSCTXT* pctxt, 
   UuvPropellersOrderElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode all */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SignedPercentType (pctxt, 
               &pvalue->all, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.allPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode centerline */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SignedPercentType (pctxt, 
               &pvalue->centerline, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.centerlinePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode port */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SignedPercentType (pctxt, 
               &pvalue->port, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.portPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode starboard */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SignedPercentType (pctxt, 
               &pvalue->starboard, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.starboardPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UuvPropellersOrderElementType (OSCTXT* pctxt, 
   UuvPropellersOrderElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("all"), 3}, 0 },
         { {OSUTF8("centerline"), 10}, 0 },
         { {OSUTF8("port"), 4}, 0 },
         { {OSUTF8("starboard"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* all */
            stat = XmlDec_SignedPercentType (pctxt, &pvalue->all);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.allPresent = TRUE;
            break;

         case 1: /* centerline */
            stat = XmlDec_SignedPercentType (pctxt, &pvalue->centerline);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.centerlinePresent = TRUE;
            break;

         case 2: /* port */
            stat = XmlDec_SignedPercentType (pctxt, &pvalue->port);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.portPresent = TRUE;
            break;

         case 3: /* starboard */
            stat = XmlDec_SignedPercentType (pctxt, &pvalue->starboard);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.starboardPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UuvPropellersOrderElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UuvPropellersOrderElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UuvPlanesOrderElementType                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UuvPlanesOrderElementType (OSCTXT* pctxt, 
   UuvPlanesOrderElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bow */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SignedPercentType (pctxt, 
               &pvalue->bow, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bowPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode stern */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SignedPercentType (pctxt, 
               &pvalue->stern, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sternPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UuvPlanesOrderElementType (OSCTXT* pctxt, 
   UuvPlanesOrderElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bow"), 3}, 0 },
         { {OSUTF8("stern"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bow */
            stat = XmlDec_SignedPercentType (pctxt, &pvalue->bow);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bowPresent = TRUE;
            break;

         case 1: /* stern */
            stat = XmlDec_SignedPercentType (pctxt, &pvalue->stern);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.sternPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UuvPlanesOrderElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UuvPlanesOrderElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UuvBodyThrustersOrderElementType                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UuvBodyThrustersOrderElementType (OSCTXT* pctxt, 
   UuvBodyThrustersOrderElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bowLateral */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SignedPercentType (pctxt, 
               &pvalue->bowLateral, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bowLateralPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode bowVertical */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SignedPercentType (pctxt, 
               &pvalue->bowVertical, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bowVerticalPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode sternLateral */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SignedPercentType (pctxt, 
               &pvalue->sternLateral, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sternLateralPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode sternVertical */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SignedPercentType (pctxt, 
               &pvalue->sternVertical, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sternVerticalPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UuvBodyThrustersOrderElementType (OSCTXT* pctxt, 
   UuvBodyThrustersOrderElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bowLateral"), 10}, 0 },
         { {OSUTF8("bowVertical"), 11}, 0 },
         { {OSUTF8("sternLateral"), 12}, 0 },
         { {OSUTF8("sternVertical"), 13}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bowLateral */
            stat = XmlDec_SignedPercentType (pctxt, &pvalue->bowLateral);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bowLateralPresent = TRUE;
            break;

         case 1: /* bowVertical */
            stat = XmlDec_SignedPercentType (pctxt, &pvalue->bowVertical);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bowVerticalPresent = TRUE;
            break;

         case 2: /* sternLateral */
            stat = XmlDec_SignedPercentType (pctxt, &pvalue->sternLateral);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.sternLateralPresent = TRUE;
            break;

         case 3: /* sternVertical */
            stat = XmlDec_SignedPercentType (pctxt, &pvalue->sternVertical);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.sternVerticalPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UuvBodyThrustersOrderElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UuvBodyThrustersOrderElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UuvControlOrdersElementType                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UuvControlOrdersElementType (OSCTXT* pctxt, 
   UuvControlOrdersElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode _order */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               int xx2;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               xx2 = 0;
               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  if (xx2 >= 4) return LOG_RTERR (pctxt, RTERR_SEQOVFLW);

                  { int length;
                  if (XD_PEEKTAG (pctxt, 0xa)) {
                     stat = xd_Tag1AndLen (pctxt, &length);
                     if (stat != 0) return LOG_RTERR (pctxt, stat);
                  }
                  else return LOG_RTERR (pctxt,
                     berErrUnexpTag(pctxt, TM_UNIV|TM_PRIM|10));

                  stat = xd_uint8 (pctxt, &pvalue->_order.elem[xx2], ASN1IMPL, length);
                  if (stat == 0) {
                     if (!((pvalue->_order.elem[xx2] <= OSUINTCONST(3)))) {
                        rtxErrAddStrParm (pctxt, "UuvControlOrdersElementType._order.elem[xx2]");
                        rtxErrAddIntParm (pctxt, (int)pvalue->_order.elem[xx2]);
                        return LOG_RTERR (pctxt, RTERR_CONSVIO);
                     }

                  }
                  else return LOG_RTERR (pctxt, stat);

                  }
                  xx2++;
               }
               pvalue->_order.n = xx2;

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode propellers */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_UuvPropellersOrderElementType (pctxt, 
               &pvalue->propellers, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.propellersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode rudder */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_ScalarElementType (pctxt, 
               &pvalue->rudder, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.rudderPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode planes */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_UuvPlanesOrderElementType (pctxt, 
               &pvalue->planes, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.planesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode bodyThrusters */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_UuvBodyThrustersOrderElementType (pctxt, 
               &pvalue->bodyThrusters, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bodyThrustersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UuvControlOrdersElementType (OSCTXT* pctxt, 
   UuvControlOrdersElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UuvControlOrdersElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UuvControlOrdersElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Propellers"), 10}, 0}, 0 },
      {{{OSUTF8("Rudder"), 6}, 0}, 1 },
      {{{OSUTF8("Planes"), 6}, 0}, 2 },
      {{{OSUTF8("BodyThrusters"), 13}, 0}, 3 }
   } ;
   pvalue->_order.n = 0;

   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 4, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: { /* Propellers */
         stat = XmlDec_UuvPropellersOrderElementType (pctxt, &pvalue->
            propellers);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.propellersPresent = TRUE;
         break;
      }
      case 1: { /* Rudder */
         stat = XmlDec_ScalarElementType (pctxt, &pvalue->rudder);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.rudderPresent = TRUE;
         break;
      }
      case 2: { /* Planes */
         stat = XmlDec_UuvPlanesOrderElementType (pctxt, &pvalue->planes);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.planesPresent = TRUE;
         break;
      }
      case 3: { /* BodyThrusters */
         stat = XmlDec_UuvBodyThrustersOrderElementType (pctxt, &pvalue->
            bodyThrusters);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.bodyThrustersPresent = TRUE;
         break;
      }
      }
      pvalue->_order.elem[pvalue->_order.n++] = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UsvPropellersOrderElementType                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UsvPropellersOrderElementType (OSCTXT* pctxt, 
   UsvPropellersOrderElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode all */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SignedPercentType (pctxt, 
               &pvalue->all, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.allPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode centerline */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SignedPercentType (pctxt, 
               &pvalue->centerline, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.centerlinePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode port */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SignedPercentType (pctxt, 
               &pvalue->port, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.portPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode starboard */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SignedPercentType (pctxt, 
               &pvalue->starboard, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.starboardPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UsvPropellersOrderElementType (OSCTXT* pctxt, 
   UsvPropellersOrderElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("all"), 3}, 0 },
         { {OSUTF8("centerline"), 10}, 0 },
         { {OSUTF8("port"), 4}, 0 },
         { {OSUTF8("starboard"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* all */
            stat = XmlDec_SignedPercentType (pctxt, &pvalue->all);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.allPresent = TRUE;
            break;

         case 1: /* centerline */
            stat = XmlDec_SignedPercentType (pctxt, &pvalue->centerline);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.centerlinePresent = TRUE;
            break;

         case 2: /* port */
            stat = XmlDec_SignedPercentType (pctxt, &pvalue->port);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.portPresent = TRUE;
            break;

         case 3: /* starboard */
            stat = XmlDec_SignedPercentType (pctxt, &pvalue->starboard);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.starboardPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UsvPropellersOrderElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UsvPropellersOrderElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UsvControlOrdersElementType                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UsvControlOrdersElementType (OSCTXT* pctxt, 
   UsvControlOrdersElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode _order */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               int xx2;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               xx2 = 0;
               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  if (xx2 >= 2) return LOG_RTERR (pctxt, RTERR_SEQOVFLW);

                  { int length;
                  if (XD_PEEKTAG (pctxt, 0xa)) {
                     stat = xd_Tag1AndLen (pctxt, &length);
                     if (stat != 0) return LOG_RTERR (pctxt, stat);
                  }
                  else return LOG_RTERR (pctxt,
                     berErrUnexpTag(pctxt, TM_UNIV|TM_PRIM|10));

                  stat = xd_uint8 (pctxt, &pvalue->_order.elem[xx2], ASN1IMPL, length);
                  if (stat == 0) {
                     if (!((pvalue->_order.elem[xx2] <= OSUINTCONST(1)))) {
                        rtxErrAddStrParm (pctxt, "UsvControlOrdersElementType._order.elem[xx2]");
                        rtxErrAddIntParm (pctxt, (int)pvalue->_order.elem[xx2]);
                        return LOG_RTERR (pctxt, RTERR_CONSVIO);
                     }

                  }
                  else return LOG_RTERR (pctxt, stat);

                  }
                  xx2++;
               }
               pvalue->_order.n = xx2;

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode propellers */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_UsvPropellersOrderElementType (pctxt, 
               &pvalue->propellers, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.propellersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode rudder */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SignedPercentElementType (pctxt, 
               &pvalue->rudder, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.rudderPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UsvControlOrdersElementType (OSCTXT* pctxt, 
   UsvControlOrdersElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UsvControlOrdersElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UsvControlOrdersElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Propellers"), 10}, 0}, 0 },
      {{{OSUTF8("Rudder"), 6}, 0}, 1 }
   } ;
   pvalue->_order.n = 0;

   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: { /* Propellers */
         stat = XmlDec_UsvPropellersOrderElementType (pctxt, &pvalue->
            propellers);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.propellersPresent = TRUE;
         break;
      }
      case 1: { /* Rudder */
         stat = XmlDec_SignedPercentElementType (pctxt, &pvalue->rudder);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.rudderPresent = TRUE;
         break;
      }
      }
      pvalue->_order.elem[pvalue->_order.n++] = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UgvControlOrdersElementType                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UgvControlOrdersElementType (OSCTXT* pctxt, 
   UgvControlOrdersElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode _order */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               int xx2;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               xx2 = 0;
               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  if (xx2 >= 1) return LOG_RTERR (pctxt, RTERR_SEQOVFLW);

                  { int length;
                  if (XD_PEEKTAG (pctxt, 0xa)) {
                     stat = xd_Tag1AndLen (pctxt, &length);
                     if (stat != 0) return LOG_RTERR (pctxt, stat);
                  }
                  else return LOG_RTERR (pctxt,
                     berErrUnexpTag(pctxt, TM_UNIV|TM_PRIM|10));

                  stat = xd_uint8 (pctxt, &pvalue->_order.elem[xx2], ASN1IMPL, length);
                  if (stat == 0) {
                     if (!((pvalue->_order.elem[xx2] <= OSUINTCONST(0)))) {
                        rtxErrAddStrParm (pctxt, "UgvControlOrdersElementType._order.elem[xx2]");
                        rtxErrAddIntParm (pctxt, (int)pvalue->_order.elem[xx2]);
                        return LOG_RTERR (pctxt, RTERR_CONSVIO);
                     }

                  }
                  else return LOG_RTERR (pctxt, stat);

                  }
                  xx2++;
               }
               pvalue->_order.n = xx2;

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode placeHolder */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NoValueElementType (pctxt, 
               &pvalue->placeHolder, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.placeHolderPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UgvControlOrdersElementType (OSCTXT* pctxt, 
   UgvControlOrdersElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UgvControlOrdersElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UgvControlOrdersElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("PlaceHolder"), 11}, 0}, 0 }
   } ;
   pvalue->_order.n = 0;

   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 1, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: { /* PlaceHolder */
         stat = XmlDec_NoValueElementType (pctxt, &pvalue->placeHolder);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.placeHolderPresent = TRUE;
         break;
      }
      }
      pvalue->_order.elem[pvalue->_order.n++] = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UavEnginesOrdersElementType                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UavEnginesOrdersElementType (OSCTXT* pctxt, 
   UavEnginesOrdersElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode engine1 */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SignedPercentType (pctxt, 
               &pvalue->engine1, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode engine2 */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SignedPercentType (pctxt, 
               &pvalue->engine2, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.engine2Present = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UavEnginesOrdersElementType (OSCTXT* pctxt, 
   UavEnginesOrdersElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("engine1"), 7}, 0 },
         { {OSUTF8("engine2"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* engine1 */
            stat = XmlDec_SignedPercentType (pctxt, &pvalue->engine1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* engine2 */
            stat = XmlDec_SignedPercentType (pctxt, &pvalue->engine2);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.engine2Present = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UavEnginesOrdersElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UavEnginesOrdersElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UavStabilatorOrderElementType                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UavStabilatorOrderElementType (OSCTXT* pctxt, 
   UavStabilatorOrderElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode port */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SignedPercentType (pctxt, 
               &pvalue->port, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode starboard */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SignedPercentType (pctxt, 
               &pvalue->starboard, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UavStabilatorOrderElementType (OSCTXT* pctxt, 
   UavStabilatorOrderElementType* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("port"), 4}, 0 },
         { {OSUTF8("starboard"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* port */
            stat = XmlDec_SignedPercentType (pctxt, &pvalue->port);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* starboard */
            stat = XmlDec_SignedPercentType (pctxt, &pvalue->starboard);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UavStabilatorOrderElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UavStabilatorOrderElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FixedWingUAVControlOrders                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_FixedWingUAVControlOrders (OSCTXT* pctxt, 
   FixedWingUAVControlOrders *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode engines */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_UavEnginesOrdersElementType (pctxt, 
               &pvalue->engines, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.enginesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode aileron */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SignedPercentElementType (pctxt, 
               &pvalue->aileron, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.aileronPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode rudder */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SignedPercentElementType (pctxt, 
               &pvalue->rudder, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.rudderPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode elevator */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_UavStabilatorOrderElementType (pctxt, 
               &pvalue->elevator, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.elevatorPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_FixedWingUAVControlOrders (OSCTXT* pctxt, 
   FixedWingUAVControlOrders* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Engines"), 7}, 0}, 0 },
      {{{OSUTF8("Aileron"), 7}, 0}, 1 },
      {{{OSUTF8("Rudder"), 6}, 0}, 2 },
      {{{OSUTF8("Elevator"), 8}, 0}, 3 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 4; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* Engines */
         stat = XmlDec_UavEnginesOrdersElementType (pctxt, &pvalue->engines);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.enginesPresent = TRUE;
         break;
      }
      case 1: { /* Aileron */
         stat = XmlDec_SignedPercentElementType (pctxt, &pvalue->aileron);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.aileronPresent = TRUE;
         break;
      }
      case 2: { /* Rudder */
         stat = XmlDec_SignedPercentElementType (pctxt, &pvalue->rudder);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.rudderPresent = TRUE;
         break;
      }
      case 3: { /* Elevator */
         stat = XmlDec_UavStabilatorOrderElementType (pctxt, &pvalue->elevator
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.elevatorPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UavCyclicOrderElementType                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UavCyclicOrderElementType (OSCTXT* pctxt, 
   UavCyclicOrderElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode foreAft */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SignedPercentType (pctxt, 
               &pvalue->foreAft, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode lateral */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SignedPercentType (pctxt, 
               &pvalue->lateral, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UavCyclicOrderElementType (OSCTXT* pctxt, 
   UavCyclicOrderElementType* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("foreAft"), 7}, 0 },
         { {OSUTF8("lateral"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* foreAft */
            stat = XmlDec_SignedPercentType (pctxt, &pvalue->foreAft);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* lateral */
            stat = XmlDec_SignedPercentType (pctxt, &pvalue->lateral);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UavCyclicOrderElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UavCyclicOrderElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RotaryWingUAVControlOrders                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_RotaryWingUAVControlOrders (OSCTXT* pctxt, 
   RotaryWingUAVControlOrders *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode collective */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SignedPercentElementType (pctxt, 
               &pvalue->collective, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.collectivePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode cyclic */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_UavCyclicOrderElementType (pctxt, 
               &pvalue->cyclic, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.cyclicPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode pedals */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SignedPercentElementType (pctxt, 
               &pvalue->pedals, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.pedalsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_RotaryWingUAVControlOrders (OSCTXT* pctxt, 
   RotaryWingUAVControlOrders* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Collective"), 10}, 0}, 0 },
      {{{OSUTF8("Cyclic"), 6}, 0}, 1 },
      {{{OSUTF8("Pedals"), 6}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* Collective */
         stat = XmlDec_SignedPercentElementType (pctxt, &pvalue->collective);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.collectivePresent = TRUE;
         break;
      }
      case 1: { /* Cyclic */
         stat = XmlDec_UavCyclicOrderElementType (pctxt, &pvalue->cyclic);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.cyclicPresent = TRUE;
         break;
      }
      case 2: { /* Pedals */
         stat = XmlDec_SignedPercentElementType (pctxt, &pvalue->pedals);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.pedalsPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UavControlOrdersElementType_choice                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UavControlOrdersElementType_choice (OSCTXT* pctxt, 
   UavControlOrdersElementType_choice *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.fixedWingUAVControlOrders
             = rtxMemAllocType (pctxt, FixedWingUAVControlOrders);

         if (pvalue->u.fixedWingUAVControlOrders == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_FixedWingUAVControlOrders (pvalue->u.fixedWingUAVControlOrders);
         stat = asn1D_FixedWingUAVControlOrders (pctxt, 
            pvalue->u.fixedWingUAVControlOrders, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.rotaryWingUAVControlOrders
             = rtxMemAllocType (pctxt, RotaryWingUAVControlOrders);

         if (pvalue->u.rotaryWingUAVControlOrders == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RotaryWingUAVControlOrders (pvalue->u.rotaryWingUAVControlOrders);
         stat = asn1D_RotaryWingUAVControlOrders (pctxt, 
            pvalue->u.rotaryWingUAVControlOrders, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_UavControlOrdersElementType_choice (OSCTXT* pctxt, 
   UavControlOrdersElementType_choice* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Engines"), 7}, 0}, 0 },
      {{{OSUTF8("Aileron"), 7}, 0}, 0 },
      {{{OSUTF8("Rudder"), 6}, 0}, 0 },
      {{{OSUTF8("Elevator"), 8}, 0}, 0 },
      {{{OSUTF8("Collective"), 10}, 0}, 1 },
      {{{OSUTF8("Cyclic"), 6}, 0}, 1 },
      {{{OSUTF8("Pedals"), 6}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 7, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: {
      rtXmlpMarkLastEventActive (pctxt);

      pvalue->u.fixedWingUAVControlOrders
          = rtxMemAllocType (pctxt, FixedWingUAVControlOrders);

      if (pvalue->u.fixedWingUAVControlOrders == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_FixedWingUAVControlOrders (pvalue->u.fixedWingUAVControlOrders
         );

      stat = XmlDec_FixedWingUAVControlOrders (pctxt, pvalue->
         u.fixedWingUAVControlOrders);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: {
      rtXmlpMarkLastEventActive (pctxt);

      pvalue->u.rotaryWingUAVControlOrders
          = rtxMemAllocType (pctxt, RotaryWingUAVControlOrders);

      if (pvalue->u.rotaryWingUAVControlOrders == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RotaryWingUAVControlOrders (pvalue->u.rotaryWingUAVControlOrders
         );

      stat = XmlDec_RotaryWingUAVControlOrders (pctxt, pvalue->
         u.rotaryWingUAVControlOrders);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UavControlOrdersElementType                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UavControlOrdersElementType (OSCTXT* pctxt, 
   UavControlOrdersElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_UavControlOrdersElementType_choice (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UavControlOrdersElementType (OSCTXT* pctxt, 
   UavControlOrdersElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UavControlOrdersElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UavControlOrdersElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Engines"), 7}, 0}, 0 },
      {{{OSUTF8("Aileron"), 7}, 0}, 0 },
      {{{OSUTF8("Rudder"), 6}, 0}, 0 },
      {{{OSUTF8("Elevator"), 8}, 0}, 0 },
      {{{OSUTF8("Collective"), 10}, 0}, 0 },
      {{{OSUTF8("Cyclic"), 6}, 0}, 0 },
      {{{OSUTF8("Pedals"), 6}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 7, -1}, {7, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_UavControlOrdersElementType_choice (pctxt, &pvalue->
            choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DiscreteTimeResultsElementType_choice_1                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_DiscreteTimeResultsElementType_choice_1 (OSCTXT* pctxt, 
   DiscreteTimeResultsElementType_choice_1 *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.uUVControlOrder
             = rtxMemAllocType (pctxt, UuvControlOrdersElementType);

         if (pvalue->u.uUVControlOrder == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UuvControlOrdersElementType (pvalue->u.uUVControlOrder);
         stat = asn1D_UuvControlOrdersElementType (pctxt, 
            pvalue->u.uUVControlOrder, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.uSVControlOrder
             = rtxMemAllocType (pctxt, UsvControlOrdersElementType);

         if (pvalue->u.uSVControlOrder == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UsvControlOrdersElementType (pvalue->u.uSVControlOrder);
         stat = asn1D_UsvControlOrdersElementType (pctxt, 
            pvalue->u.uSVControlOrder, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.uGVControlOrder
             = rtxMemAllocType (pctxt, UgvControlOrdersElementType);

         if (pvalue->u.uGVControlOrder == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UgvControlOrdersElementType (pvalue->u.uGVControlOrder);
         stat = asn1D_UgvControlOrdersElementType (pctxt, 
            pvalue->u.uGVControlOrder, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.uAVControlOrder
             = rtxMemAllocType (pctxt, UavControlOrdersElementType);

         if (pvalue->u.uAVControlOrder == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UavControlOrdersElementType (pvalue->u.uAVControlOrder);
         stat = asn1D_UavControlOrdersElementType (pctxt, 
            pvalue->u.uAVControlOrder, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_DiscreteTimeResultsElementType_choice_1 (OSCTXT* pctxt, 
   DiscreteTimeResultsElementType_choice_1* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("UUVControlOrder"), 15}, 0}, 0 },
      {{{OSUTF8("USVControlOrder"), 15}, 0}, 1 },
      {{{OSUTF8("UGVControlOrder"), 15}, 0}, 2 },
      {{{OSUTF8("UAVControlOrder"), 15}, 0}, 3 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 4, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* UUVControlOrder */
      pvalue->u.uUVControlOrder
          = rtxMemAllocType (pctxt, UuvControlOrdersElementType);

      if (pvalue->u.uUVControlOrder == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UuvControlOrdersElementType (pvalue->u.uUVControlOrder);

      stat = XmlDec_UuvControlOrdersElementType (pctxt, pvalue->
         u.uUVControlOrder);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* USVControlOrder */
      pvalue->u.uSVControlOrder
          = rtxMemAllocType (pctxt, UsvControlOrdersElementType);

      if (pvalue->u.uSVControlOrder == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UsvControlOrdersElementType (pvalue->u.uSVControlOrder);

      stat = XmlDec_UsvControlOrdersElementType (pctxt, pvalue->
         u.uSVControlOrder);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* UGVControlOrder */
      pvalue->u.uGVControlOrder
          = rtxMemAllocType (pctxt, UgvControlOrdersElementType);

      if (pvalue->u.uGVControlOrder == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UgvControlOrdersElementType (pvalue->u.uGVControlOrder);

      stat = XmlDec_UgvControlOrdersElementType (pctxt, pvalue->
         u.uGVControlOrder);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* UAVControlOrder */
      pvalue->u.uAVControlOrder
          = rtxMemAllocType (pctxt, UavControlOrdersElementType);

      if (pvalue->u.uAVControlOrder == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UavControlOrdersElementType (pvalue->u.uAVControlOrder);

      stat = XmlDec_UavControlOrdersElementType (pctxt, pvalue->
         u.uAVControlOrder);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SensorElements_activeSonar                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SensorElements_activeSonar (OSCTXT* pctxt, 
   SensorElements_activeSonar *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bearing */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->bearing, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode elevation */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->elevation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.elevationPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode model */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->model, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode range */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->range, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode strength */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->strength, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.strengthPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SensorElements_activeSonar (OSCTXT* pctxt, 
   SensorElements_activeSonar* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bearing"), 7}, 0 },
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("elevation"), 9}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("model"), 5}, 0 },
         { {OSUTF8("range"), 5}, 0 },
         { {OSUTF8("strength"), 8}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 8, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bearing */
            stat = rtXmlpDecDouble (pctxt, &pvalue->bearing, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 2: /* elevation */
            stat = rtXmlpDecDouble (pctxt, &pvalue->elevation, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.elevationPresent = TRUE;
            break;

         case 3: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 4: /* model */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->model);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* range */
            stat = rtXmlpDecDouble (pctxt, &pvalue->range, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 6: /* strength */
            stat = rtXmlpDecDouble (pctxt, &pvalue->strength, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.strengthPresent = TRUE;
            break;

         case 7: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SensorElements_activeSonar");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SensorElements_activeSonar");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SensorElements_imagingSonar                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SensorElements_imagingSonar (OSCTXT* pctxt, 
   SensorElements_imagingSonar *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode model */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->model, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SensorElements_imagingSonar (OSCTXT* pctxt, 
   SensorElements_imagingSonar* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("model"), 5}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* model */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->model);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SensorElements_imagingSonar");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SensorElements_imagingSonar");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SensorElements_blazedArraySonar                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SensorElements_blazedArraySonar (OSCTXT* pctxt, 
   SensorElements_blazedArraySonar *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode model */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->model, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SensorElements_blazedArraySonar (OSCTXT* pctxt, 
   SensorElements_blazedArraySonar* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("model"), 5}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* model */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->model);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SensorElements_blazedArraySonar");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SensorElements_blazedArraySonar");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SensorElements_syntheticApertureSonar                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SensorElements_syntheticApertureSonar (OSCTXT* pctxt, 
   SensorElements_syntheticApertureSonar *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode model */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->model, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SensorElements_syntheticApertureSonar (OSCTXT* pctxt, 
   SensorElements_syntheticApertureSonar* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("model"), 5}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* model */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->model);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SensorElements_syntheticApertureSonar");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SensorElements_syntheticApertureSonar");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SensorElements_passiveSonar                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SensorElements_passiveSonar (OSCTXT* pctxt, 
   SensorElements_passiveSonar *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bearing */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->bearing, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bearingPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode frequency */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->frequency, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode model */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->model, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode strength */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->strength, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.strengthPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SensorElements_passiveSonar (OSCTXT* pctxt, 
   SensorElements_passiveSonar* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bearing"), 7}, 0 },
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("frequency"), 9}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("model"), 5}, 0 },
         { {OSUTF8("strength"), 8}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 7, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bearing */
            stat = rtXmlpDecDouble (pctxt, &pvalue->bearing, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bearingPresent = TRUE;
            break;

         case 1: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 2: /* frequency */
            stat = rtXmlpDecDouble (pctxt, &pvalue->frequency, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 4: /* model */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->model);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* strength */
            stat = rtXmlpDecDouble (pctxt, &pvalue->strength, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.strengthPresent = TRUE;
            break;

         case 6: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SensorElements_passiveSonar");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SensorElements_passiveSonar");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SensorElements_radar                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SensorElements_radar (OSCTXT* pctxt, 
   SensorElements_radar *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode altitude */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->altitude, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.altitudePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode bearing */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->bearing, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bearingPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode elevation */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->elevation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.elevationPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode heading */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->heading, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.headingPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode mode1 */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->mode1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode1Present = TRUE;
            }
         }
         break;

      case 7:
         /* decode mode2 */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->mode2, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode2Present = TRUE;
            }
         }
         break;

      case 8:
         /* decode mode3 */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->mode3, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode3Present = TRUE;
            }
         }
         break;

      case 9:
         /* decode mode4 */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->mode4, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode4Present = TRUE;
            }
         }
         break;

      case 10:
         /* decode modeC */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->modeC, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.modeCPresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode model */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->model, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 12:
         /* decode range */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->range, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.rangePresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode velocity */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->velocity, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.velocityPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_PRIM|14):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SensorElements_radar (OSCTXT* pctxt, SensorElements_radar* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("altitude"), 8}, 0 },
         { {OSUTF8("bearing"), 7}, 0 },
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("elevation"), 9}, 0 },
         { {OSUTF8("heading"), 7}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("mode1"), 5}, 0 },
         { {OSUTF8("mode2"), 5}, 0 },
         { {OSUTF8("mode3"), 5}, 0 },
         { {OSUTF8("mode4"), 5}, 0 },
         { {OSUTF8("modeC"), 5}, 0 },
         { {OSUTF8("model"), 5}, 0 },
         { {OSUTF8("range"), 5}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("velocity"), 8}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 15, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* altitude */
            stat = rtXmlpDecDouble (pctxt, &pvalue->altitude, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.altitudePresent = TRUE;
            break;

         case 1: /* bearing */
            stat = rtXmlpDecDouble (pctxt, &pvalue->bearing, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bearingPresent = TRUE;
            break;

         case 2: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 3: /* elevation */
            stat = rtXmlpDecDouble (pctxt, &pvalue->elevation, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.elevationPresent = TRUE;
            break;

         case 4: /* heading */
            stat = rtXmlpDecDouble (pctxt, &pvalue->heading, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.headingPresent = TRUE;
            break;

         case 5: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 6: /* mode1 */
            stat = rtXmlpDecInt (pctxt, &pvalue->mode1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode1Present = TRUE;
            break;

         case 7: /* mode2 */
            stat = rtXmlpDecInt (pctxt, &pvalue->mode2);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode2Present = TRUE;
            break;

         case 8: /* mode3 */
            stat = rtXmlpDecInt (pctxt, &pvalue->mode3);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode3Present = TRUE;
            break;

         case 9: /* mode4 */
            stat = rtXmlpDecBool (pctxt, &pvalue->mode4);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode4Present = TRUE;
            break;

         case 10: /* modeC */
            stat = rtXmlpDecInt (pctxt, &pvalue->modeC);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.modeCPresent = TRUE;
            break;

         case 11: /* model */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->model);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 12: /* range */
            stat = rtXmlpDecDouble (pctxt, &pvalue->range, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.rangePresent = TRUE;
            break;

         case 13: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 14: /* velocity */
            stat = rtXmlpDecDouble (pctxt, &pvalue->velocity, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.velocityPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SensorElements_radar");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SensorElements_radar");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SensorElements_dopplerRadar                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SensorElements_dopplerRadar (OSCTXT* pctxt, 
   SensorElements_dopplerRadar *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode altitude */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->altitude, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.altitudePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode bearing */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->bearing, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bearingPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode elevation */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->elevation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.elevationPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode heading */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->heading, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.headingPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode mode1 */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->mode1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode1Present = TRUE;
            }
         }
         break;

      case 7:
         /* decode mode2 */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->mode2, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode2Present = TRUE;
            }
         }
         break;

      case 8:
         /* decode mode3 */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->mode3, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode3Present = TRUE;
            }
         }
         break;

      case 9:
         /* decode mode4 */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->mode4, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode4Present = TRUE;
            }
         }
         break;

      case 10:
         /* decode modeC */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->modeC, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.modeCPresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode model */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->model, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.modelPresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode range */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->range, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.rangePresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode velocity */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->velocity, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.velocityPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_PRIM|14):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SensorElements_dopplerRadar (OSCTXT* pctxt, 
   SensorElements_dopplerRadar* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("altitude"), 8}, 0 },
         { {OSUTF8("bearing"), 7}, 0 },
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("elevation"), 9}, 0 },
         { {OSUTF8("heading"), 7}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("mode1"), 5}, 0 },
         { {OSUTF8("mode2"), 5}, 0 },
         { {OSUTF8("mode3"), 5}, 0 },
         { {OSUTF8("mode4"), 5}, 0 },
         { {OSUTF8("modeC"), 5}, 0 },
         { {OSUTF8("model"), 5}, 0 },
         { {OSUTF8("range"), 5}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("velocity"), 8}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 15, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* altitude */
            stat = rtXmlpDecDouble (pctxt, &pvalue->altitude, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.altitudePresent = TRUE;
            break;

         case 1: /* bearing */
            stat = rtXmlpDecDouble (pctxt, &pvalue->bearing, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bearingPresent = TRUE;
            break;

         case 2: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 3: /* elevation */
            stat = rtXmlpDecDouble (pctxt, &pvalue->elevation, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.elevationPresent = TRUE;
            break;

         case 4: /* heading */
            stat = rtXmlpDecDouble (pctxt, &pvalue->heading, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.headingPresent = TRUE;
            break;

         case 5: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 6: /* mode1 */
            stat = rtXmlpDecInt (pctxt, &pvalue->mode1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode1Present = TRUE;
            break;

         case 7: /* mode2 */
            stat = rtXmlpDecInt (pctxt, &pvalue->mode2);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode2Present = TRUE;
            break;

         case 8: /* mode3 */
            stat = rtXmlpDecInt (pctxt, &pvalue->mode3);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode3Present = TRUE;
            break;

         case 9: /* mode4 */
            stat = rtXmlpDecBool (pctxt, &pvalue->mode4);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode4Present = TRUE;
            break;

         case 10: /* modeC */
            stat = rtXmlpDecInt (pctxt, &pvalue->modeC);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.modeCPresent = TRUE;
            break;

         case 11: /* model */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->model);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.modelPresent = TRUE;
            break;

         case 12: /* range */
            stat = rtXmlpDecDouble (pctxt, &pvalue->range, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.rangePresent = TRUE;
            break;

         case 13: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 14: /* velocity */
            stat = rtXmlpDecDouble (pctxt, &pvalue->velocity, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.velocityPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SensorElements_dopplerRadar");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SensorElements_dopplerRadar");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SensorElements_syntheticApertureRadar                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SensorElements_syntheticApertureRadar (OSCTXT* pctxt, 
   SensorElements_syntheticApertureRadar *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode altitude */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->altitude, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.altitudePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode bearing */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->bearing, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bearingPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode elevation */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->elevation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.elevationPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode heading */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->heading, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.headingPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode mode1 */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->mode1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode1Present = TRUE;
            }
         }
         break;

      case 7:
         /* decode mode2 */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->mode2, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode2Present = TRUE;
            }
         }
         break;

      case 8:
         /* decode mode3 */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->mode3, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode3Present = TRUE;
            }
         }
         break;

      case 9:
         /* decode mode4 */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->mode4, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode4Present = TRUE;
            }
         }
         break;

      case 10:
         /* decode modeC */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->modeC, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.modeCPresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode model */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->model, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 12:
         /* decode range */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->range, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.rangePresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode velocity */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->velocity, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.velocityPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_PRIM|14):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SensorElements_syntheticApertureRadar (OSCTXT* pctxt, 
   SensorElements_syntheticApertureRadar* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("altitude"), 8}, 0 },
         { {OSUTF8("bearing"), 7}, 0 },
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("elevation"), 9}, 0 },
         { {OSUTF8("heading"), 7}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("mode1"), 5}, 0 },
         { {OSUTF8("mode2"), 5}, 0 },
         { {OSUTF8("mode3"), 5}, 0 },
         { {OSUTF8("mode4"), 5}, 0 },
         { {OSUTF8("modeC"), 5}, 0 },
         { {OSUTF8("model"), 5}, 0 },
         { {OSUTF8("range"), 5}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("velocity"), 8}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 15, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* altitude */
            stat = rtXmlpDecDouble (pctxt, &pvalue->altitude, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.altitudePresent = TRUE;
            break;

         case 1: /* bearing */
            stat = rtXmlpDecDouble (pctxt, &pvalue->bearing, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bearingPresent = TRUE;
            break;

         case 2: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 3: /* elevation */
            stat = rtXmlpDecDouble (pctxt, &pvalue->elevation, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.elevationPresent = TRUE;
            break;

         case 4: /* heading */
            stat = rtXmlpDecDouble (pctxt, &pvalue->heading, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.headingPresent = TRUE;
            break;

         case 5: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 6: /* mode1 */
            stat = rtXmlpDecInt (pctxt, &pvalue->mode1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode1Present = TRUE;
            break;

         case 7: /* mode2 */
            stat = rtXmlpDecInt (pctxt, &pvalue->mode2);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode2Present = TRUE;
            break;

         case 8: /* mode3 */
            stat = rtXmlpDecInt (pctxt, &pvalue->mode3);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode3Present = TRUE;
            break;

         case 9: /* mode4 */
            stat = rtXmlpDecBool (pctxt, &pvalue->mode4);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode4Present = TRUE;
            break;

         case 10: /* modeC */
            stat = rtXmlpDecInt (pctxt, &pvalue->modeC);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.modeCPresent = TRUE;
            break;

         case 11: /* model */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->model);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 12: /* range */
            stat = rtXmlpDecDouble (pctxt, &pvalue->range, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.rangePresent = TRUE;
            break;

         case 13: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 14: /* velocity */
            stat = rtXmlpDecDouble (pctxt, &pvalue->velocity, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.velocityPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SensorElements_syntheticApertureRadar");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SensorElements_syntheticApertureRadar");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SensorElements_trackWhileScanRadar_track                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SensorElements_trackWhileScanRadar_track (OSCTXT* pctxt, 
   SensorElements_trackWhileScanRadar_track *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode altitude */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->altitude, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.altitudePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode bearing */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->bearing, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode heading */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->heading, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode mode1 */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->mode1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode1Present = TRUE;
            }
         }
         break;

      case 4:
         /* decode mode2 */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->mode2, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode2Present = TRUE;
            }
         }
         break;

      case 5:
         /* decode mode3 */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->mode3, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode3Present = TRUE;
            }
         }
         break;

      case 6:
         /* decode mode4 */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->mode4, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode4Present = TRUE;
            }
         }
         break;

      case 7:
         /* decode modeC */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->modeC, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.modeCPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode range */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->range, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 9:
         /* decode trackID */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->trackID, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 10:
         /* decode velocity */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->velocity, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_PRIM|10):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 5) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SensorElements_trackWhileScanRadar_track (OSCTXT* pctxt, 
   SensorElements_trackWhileScanRadar_track* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("altitude"), 8}, 0 },
         { {OSUTF8("bearing"), 7}, 0 },
         { {OSUTF8("heading"), 7}, 0 },
         { {OSUTF8("mode1"), 5}, 0 },
         { {OSUTF8("mode2"), 5}, 0 },
         { {OSUTF8("mode3"), 5}, 0 },
         { {OSUTF8("mode4"), 5}, 0 },
         { {OSUTF8("modeC"), 5}, 0 },
         { {OSUTF8("range"), 5}, 0 },
         { {OSUTF8("trackID"), 7}, 0 },
         { {OSUTF8("velocity"), 8}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 11, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* altitude */
            stat = rtXmlpDecDouble (pctxt, &pvalue->altitude, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.altitudePresent = TRUE;
            break;

         case 1: /* bearing */
            stat = rtXmlpDecDouble (pctxt, &pvalue->bearing, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* heading */
            stat = rtXmlpDecDouble (pctxt, &pvalue->heading, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* mode1 */
            stat = rtXmlpDecInt (pctxt, &pvalue->mode1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode1Present = TRUE;
            break;

         case 4: /* mode2 */
            stat = rtXmlpDecInt (pctxt, &pvalue->mode2);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode2Present = TRUE;
            break;

         case 5: /* mode3 */
            stat = rtXmlpDecInt (pctxt, &pvalue->mode3);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode3Present = TRUE;
            break;

         case 6: /* mode4 */
            stat = rtXmlpDecBool (pctxt, &pvalue->mode4);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode4Present = TRUE;
            break;

         case 7: /* modeC */
            stat = rtXmlpDecInt (pctxt, &pvalue->modeC);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.modeCPresent = TRUE;
            break;

         case 8: /* range */
            stat = rtXmlpDecDouble (pctxt, &pvalue->range, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 9: /* trackID */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->trackID);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 10: /* velocity */
            stat = rtXmlpDecDouble (pctxt, &pvalue->velocity, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SensorElements_trackWhileScanRadar_track");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SensorElements_trackWhileScanRadar_track");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SensorElements_trackWhileScanRadar                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SensorElements_trackWhileScanRadar (OSCTXT* pctxt, 
   SensorElements_trackWhileScanRadar *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode model */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->model, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode track_list */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               SensorElements_trackWhileScanRadar_track* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->track_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, SensorElements_trackWhileScanRadar_track, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_SensorElements_trackWhileScanRadar_track (pdata2);

                  stat = asn1D_SensorElements_trackWhileScanRadar_track (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->track_list, pnode);
               }

               if (!(pvalue->track_list.count >= 1U)) {
                  rtxErrAddStrParm (pctxt, "SensorElements_trackWhileScanRadar.track_list.count");
                  rtxErrAddIntParm (pctxt, (int)pvalue->track_list.count);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SensorElements_trackWhileScanRadar (OSCTXT* pctxt, 
   SensorElements_trackWhileScanRadar* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("model"), 5}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* model */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->model);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SensorElements_trackWhileScanRadar");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SensorElements_trackWhileScanRadar");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Track"), 5}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         SensorElements_trackWhileScanRadar_track* pdata1;
         do {
            pdata1
                = rtxMemAllocType (pctxt, SensorElements_trackWhileScanRadar_track);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SensorElements_trackWhileScanRadar_track (pdata1);

            stat = XmlDec_SensorElements_trackWhileScanRadar_track (pctxt, 
               pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->track_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SensorElements_earlyWarningRadar                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SensorElements_earlyWarningRadar (OSCTXT* pctxt, 
   SensorElements_earlyWarningRadar *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode altitude */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->altitude, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.altitudePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode bearing */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->bearing, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode heading */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->heading, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.headingPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode mode1 */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->mode1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode1Present = TRUE;
            }
         }
         break;

      case 6:
         /* decode mode2 */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->mode2, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode2Present = TRUE;
            }
         }
         break;

      case 7:
         /* decode mode3 */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->mode3, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode3Present = TRUE;
            }
         }
         break;

      case 8:
         /* decode mode4 */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->mode4, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode4Present = TRUE;
            }
         }
         break;

      case 9:
         /* decode modeC */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->modeC, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.modeCPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode model */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->model, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 11:
         /* decode range */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->range, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 12:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode velocity */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->velocity, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.velocityPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_PRIM|13):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SensorElements_earlyWarningRadar (OSCTXT* pctxt, 
   SensorElements_earlyWarningRadar* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("altitude"), 8}, 0 },
         { {OSUTF8("bearing"), 7}, 0 },
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("heading"), 7}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("mode1"), 5}, 0 },
         { {OSUTF8("mode2"), 5}, 0 },
         { {OSUTF8("mode3"), 5}, 0 },
         { {OSUTF8("mode4"), 5}, 0 },
         { {OSUTF8("modeC"), 5}, 0 },
         { {OSUTF8("model"), 5}, 0 },
         { {OSUTF8("range"), 5}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("velocity"), 8}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 14, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* altitude */
            stat = rtXmlpDecDouble (pctxt, &pvalue->altitude, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.altitudePresent = TRUE;
            break;

         case 1: /* bearing */
            stat = rtXmlpDecDouble (pctxt, &pvalue->bearing, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 3: /* heading */
            stat = rtXmlpDecDouble (pctxt, &pvalue->heading, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.headingPresent = TRUE;
            break;

         case 4: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 5: /* mode1 */
            stat = rtXmlpDecInt (pctxt, &pvalue->mode1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode1Present = TRUE;
            break;

         case 6: /* mode2 */
            stat = rtXmlpDecInt (pctxt, &pvalue->mode2);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode2Present = TRUE;
            break;

         case 7: /* mode3 */
            stat = rtXmlpDecInt (pctxt, &pvalue->mode3);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode3Present = TRUE;
            break;

         case 8: /* mode4 */
            stat = rtXmlpDecBool (pctxt, &pvalue->mode4);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode4Present = TRUE;
            break;

         case 9: /* modeC */
            stat = rtXmlpDecInt (pctxt, &pvalue->modeC);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.modeCPresent = TRUE;
            break;

         case 10: /* model */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->model);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 11: /* range */
            stat = rtXmlpDecDouble (pctxt, &pvalue->range, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 12: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 13: /* velocity */
            stat = rtXmlpDecDouble (pctxt, &pvalue->velocity, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.velocityPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SensorElements_earlyWarningRadar");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SensorElements_earlyWarningRadar");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SensorElements_acquisitionRadar                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SensorElements_acquisitionRadar (OSCTXT* pctxt, 
   SensorElements_acquisitionRadar *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode altitude */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->altitude, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.altitudePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode bearing */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->bearing, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode heading */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->heading, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.headingPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode mode1 */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->mode1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode1Present = TRUE;
            }
         }
         break;

      case 6:
         /* decode mode2 */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->mode2, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode2Present = TRUE;
            }
         }
         break;

      case 7:
         /* decode mode3 */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->mode3, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode3Present = TRUE;
            }
         }
         break;

      case 8:
         /* decode mode4 */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->mode4, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode4Present = TRUE;
            }
         }
         break;

      case 9:
         /* decode modeC */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->modeC, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.modeCPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode model */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->model, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 11:
         /* decode range */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->range, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 12:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode velocity */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->velocity, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.velocityPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_PRIM|13):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SensorElements_acquisitionRadar (OSCTXT* pctxt, 
   SensorElements_acquisitionRadar* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("altitude"), 8}, 0 },
         { {OSUTF8("bearing"), 7}, 0 },
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("heading"), 7}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("mode1"), 5}, 0 },
         { {OSUTF8("mode2"), 5}, 0 },
         { {OSUTF8("mode3"), 5}, 0 },
         { {OSUTF8("mode4"), 5}, 0 },
         { {OSUTF8("modeC"), 5}, 0 },
         { {OSUTF8("model"), 5}, 0 },
         { {OSUTF8("range"), 5}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("velocity"), 8}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 14, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* altitude */
            stat = rtXmlpDecDouble (pctxt, &pvalue->altitude, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.altitudePresent = TRUE;
            break;

         case 1: /* bearing */
            stat = rtXmlpDecDouble (pctxt, &pvalue->bearing, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 3: /* heading */
            stat = rtXmlpDecDouble (pctxt, &pvalue->heading, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.headingPresent = TRUE;
            break;

         case 4: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 5: /* mode1 */
            stat = rtXmlpDecInt (pctxt, &pvalue->mode1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode1Present = TRUE;
            break;

         case 6: /* mode2 */
            stat = rtXmlpDecInt (pctxt, &pvalue->mode2);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode2Present = TRUE;
            break;

         case 7: /* mode3 */
            stat = rtXmlpDecInt (pctxt, &pvalue->mode3);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode3Present = TRUE;
            break;

         case 8: /* mode4 */
            stat = rtXmlpDecBool (pctxt, &pvalue->mode4);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode4Present = TRUE;
            break;

         case 9: /* modeC */
            stat = rtXmlpDecInt (pctxt, &pvalue->modeC);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.modeCPresent = TRUE;
            break;

         case 10: /* model */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->model);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 11: /* range */
            stat = rtXmlpDecDouble (pctxt, &pvalue->range, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 12: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 13: /* velocity */
            stat = rtXmlpDecDouble (pctxt, &pvalue->velocity, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.velocityPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SensorElements_acquisitionRadar");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SensorElements_acquisitionRadar");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SensorElements_trackingRadar                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SensorElements_trackingRadar (OSCTXT* pctxt, 
   SensorElements_trackingRadar *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode altitude */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->altitude, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode bearing */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->bearing, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode heading */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->heading, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode mode1 */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->mode1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode1Present = TRUE;
            }
         }
         break;

      case 6:
         /* decode mode2 */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->mode2, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode2Present = TRUE;
            }
         }
         break;

      case 7:
         /* decode mode3 */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->mode3, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode3Present = TRUE;
            }
         }
         break;

      case 8:
         /* decode mode4 */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->mode4, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode4Present = TRUE;
            }
         }
         break;

      case 9:
         /* decode modeC */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->modeC, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.modeCPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode model */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->model, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 11:
         /* decode range */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->range, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 12:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode velocity */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->velocity, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_PRIM|13):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 6) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SensorElements_trackingRadar (OSCTXT* pctxt, 
   SensorElements_trackingRadar* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("altitude"), 8}, 0 },
         { {OSUTF8("bearing"), 7}, 0 },
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("heading"), 7}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("mode1"), 5}, 0 },
         { {OSUTF8("mode2"), 5}, 0 },
         { {OSUTF8("mode3"), 5}, 0 },
         { {OSUTF8("mode4"), 5}, 0 },
         { {OSUTF8("modeC"), 5}, 0 },
         { {OSUTF8("model"), 5}, 0 },
         { {OSUTF8("range"), 5}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("velocity"), 8}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 14, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* altitude */
            stat = rtXmlpDecDouble (pctxt, &pvalue->altitude, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* bearing */
            stat = rtXmlpDecDouble (pctxt, &pvalue->bearing, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 3: /* heading */
            stat = rtXmlpDecDouble (pctxt, &pvalue->heading, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 5: /* mode1 */
            stat = rtXmlpDecInt (pctxt, &pvalue->mode1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode1Present = TRUE;
            break;

         case 6: /* mode2 */
            stat = rtXmlpDecInt (pctxt, &pvalue->mode2);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode2Present = TRUE;
            break;

         case 7: /* mode3 */
            stat = rtXmlpDecInt (pctxt, &pvalue->mode3);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode3Present = TRUE;
            break;

         case 8: /* mode4 */
            stat = rtXmlpDecBool (pctxt, &pvalue->mode4);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode4Present = TRUE;
            break;

         case 9: /* modeC */
            stat = rtXmlpDecInt (pctxt, &pvalue->modeC);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.modeCPresent = TRUE;
            break;

         case 10: /* model */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->model);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 11: /* range */
            stat = rtXmlpDecDouble (pctxt, &pvalue->range, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 12: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 13: /* velocity */
            stat = rtXmlpDecDouble (pctxt, &pvalue->velocity, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SensorElements_trackingRadar");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SensorElements_trackingRadar");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SensorElements_fireControlRadar                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SensorElements_fireControlRadar (OSCTXT* pctxt, 
   SensorElements_fireControlRadar *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode altitude */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->altitude, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode bearing */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->bearing, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode heading */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->heading, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode mode1 */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->mode1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode1Present = TRUE;
            }
         }
         break;

      case 6:
         /* decode mode2 */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->mode2, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode2Present = TRUE;
            }
         }
         break;

      case 7:
         /* decode mode3 */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->mode3, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode3Present = TRUE;
            }
         }
         break;

      case 8:
         /* decode mode4 */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->mode4, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode4Present = TRUE;
            }
         }
         break;

      case 9:
         /* decode modeC */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->modeC, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.modeCPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode model */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->model, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 11:
         /* decode range */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->range, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 12:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode velocity */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->velocity, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_PRIM|13):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 6) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SensorElements_fireControlRadar (OSCTXT* pctxt, 
   SensorElements_fireControlRadar* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("altitude"), 8}, 0 },
         { {OSUTF8("bearing"), 7}, 0 },
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("heading"), 7}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("mode1"), 5}, 0 },
         { {OSUTF8("mode2"), 5}, 0 },
         { {OSUTF8("mode3"), 5}, 0 },
         { {OSUTF8("mode4"), 5}, 0 },
         { {OSUTF8("modeC"), 5}, 0 },
         { {OSUTF8("model"), 5}, 0 },
         { {OSUTF8("range"), 5}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("velocity"), 8}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 14, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* altitude */
            stat = rtXmlpDecDouble (pctxt, &pvalue->altitude, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* bearing */
            stat = rtXmlpDecDouble (pctxt, &pvalue->bearing, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 3: /* heading */
            stat = rtXmlpDecDouble (pctxt, &pvalue->heading, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 5: /* mode1 */
            stat = rtXmlpDecInt (pctxt, &pvalue->mode1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode1Present = TRUE;
            break;

         case 6: /* mode2 */
            stat = rtXmlpDecInt (pctxt, &pvalue->mode2);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode2Present = TRUE;
            break;

         case 7: /* mode3 */
            stat = rtXmlpDecInt (pctxt, &pvalue->mode3);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode3Present = TRUE;
            break;

         case 8: /* mode4 */
            stat = rtXmlpDecBool (pctxt, &pvalue->mode4);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode4Present = TRUE;
            break;

         case 9: /* modeC */
            stat = rtXmlpDecInt (pctxt, &pvalue->modeC);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.modeCPresent = TRUE;
            break;

         case 10: /* model */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->model);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 11: /* range */
            stat = rtXmlpDecDouble (pctxt, &pvalue->range, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 12: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 13: /* velocity */
            stat = rtXmlpDecDouble (pctxt, &pvalue->velocity, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SensorElements_fireControlRadar");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SensorElements_fireControlRadar");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SensorElements_surfaceSearchRadar                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SensorElements_surfaceSearchRadar (OSCTXT* pctxt, 
   SensorElements_surfaceSearchRadar *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bearing */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->bearing, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode heading */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->heading, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode mode1 */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->mode1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode1Present = TRUE;
            }
         }
         break;

      case 5:
         /* decode mode2 */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->mode2, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode2Present = TRUE;
            }
         }
         break;

      case 6:
         /* decode mode3 */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->mode3, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode3Present = TRUE;
            }
         }
         break;

      case 7:
         /* decode mode4 */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->mode4, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mode4Present = TRUE;
            }
         }
         break;

      case 8:
         /* decode modeC */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->modeC, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.modeCPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode model */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->model, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 10:
         /* decode range */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->range, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 11:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode velocity */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->velocity, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_PRIM|12):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 5) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SensorElements_surfaceSearchRadar (OSCTXT* pctxt, 
   SensorElements_surfaceSearchRadar* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bearing"), 7}, 0 },
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("heading"), 7}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("mode1"), 5}, 0 },
         { {OSUTF8("mode2"), 5}, 0 },
         { {OSUTF8("mode3"), 5}, 0 },
         { {OSUTF8("mode4"), 5}, 0 },
         { {OSUTF8("modeC"), 5}, 0 },
         { {OSUTF8("model"), 5}, 0 },
         { {OSUTF8("range"), 5}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("velocity"), 8}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 13, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bearing */
            stat = rtXmlpDecDouble (pctxt, &pvalue->bearing, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 2: /* heading */
            stat = rtXmlpDecDouble (pctxt, &pvalue->heading, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 4: /* mode1 */
            stat = rtXmlpDecInt (pctxt, &pvalue->mode1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode1Present = TRUE;
            break;

         case 5: /* mode2 */
            stat = rtXmlpDecInt (pctxt, &pvalue->mode2);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode2Present = TRUE;
            break;

         case 6: /* mode3 */
            stat = rtXmlpDecInt (pctxt, &pvalue->mode3);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode3Present = TRUE;
            break;

         case 7: /* mode4 */
            stat = rtXmlpDecBool (pctxt, &pvalue->mode4);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mode4Present = TRUE;
            break;

         case 8: /* modeC */
            stat = rtXmlpDecInt (pctxt, &pvalue->modeC);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.modeCPresent = TRUE;
            break;

         case 9: /* model */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->model);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 10: /* range */
            stat = rtXmlpDecDouble (pctxt, &pvalue->range, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 11: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 12: /* velocity */
            stat = rtXmlpDecDouble (pctxt, &pvalue->velocity, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SensorElements_surfaceSearchRadar");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SensorElements_surfaceSearchRadar");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SensorElements_eSM                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SensorElements_eSM (OSCTXT* pctxt, 
   SensorElements_eSM *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bearing */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->bearing, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bearingPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode frequency */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->frequency, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode model */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->model, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode strength */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->strength, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.strengthPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SensorElements_eSM (OSCTXT* pctxt, SensorElements_eSM* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bearing"), 7}, 0 },
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("frequency"), 9}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("model"), 5}, 0 },
         { {OSUTF8("strength"), 8}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 7, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bearing */
            stat = rtXmlpDecDouble (pctxt, &pvalue->bearing, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bearingPresent = TRUE;
            break;

         case 1: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 2: /* frequency */
            stat = rtXmlpDecDouble (pctxt, &pvalue->frequency, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 4: /* model */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->model);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* strength */
            stat = rtXmlpDecDouble (pctxt, &pvalue->strength, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.strengthPresent = TRUE;
            break;

         case 6: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SensorElements_eSM");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SensorElements_eSM");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SensorElements_passiveSoundDetection                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SensorElements_passiveSoundDetection (OSCTXT* pctxt, 
   SensorElements_passiveSoundDetection *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bearing */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->bearing, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bearingPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode frequency */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->frequency, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode model */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->model, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode strength */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->strength, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.strengthPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SensorElements_passiveSoundDetection (OSCTXT* pctxt, 
   SensorElements_passiveSoundDetection* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bearing"), 7}, 0 },
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("frequency"), 9}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("model"), 5}, 0 },
         { {OSUTF8("strength"), 8}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 7, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bearing */
            stat = rtXmlpDecDouble (pctxt, &pvalue->bearing, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bearingPresent = TRUE;
            break;

         case 1: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 2: /* frequency */
            stat = rtXmlpDecDouble (pctxt, &pvalue->frequency, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 4: /* model */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->model);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* strength */
            stat = rtXmlpDecDouble (pctxt, &pvalue->strength, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.strengthPresent = TRUE;
            break;

         case 6: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SensorElements_passiveSoundDetection");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SensorElements_passiveSoundDetection");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SensorElements_chemicalBiologicalRadiologicalDetection    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SensorElements_chemicalBiologicalRadiologicalDetection (
   OSCTXT* pctxt, 
   SensorElements_chemicalBiologicalRadiologicalDetection *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode magnitude */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->magnitude, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.magnitudePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode model */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->model, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode substance */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->substance, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SensorElements_chemicalBiologicalRadiologicalDetection 
   (OSCTXT* pctxt, 
   SensorElements_chemicalBiologicalRadiologicalDetection* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("magnitude"), 9}, 0 },
         { {OSUTF8("model"), 5}, 0 },
         { {OSUTF8("substance"), 9}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 6, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* magnitude */
            stat = rtXmlpDecDouble (pctxt, &pvalue->magnitude, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.magnitudePresent = TRUE;
            break;

         case 3: /* model */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->model);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* substance */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->substance);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SensorElements_chemicalBiologicalRadiologicalDetection");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SensorElements_chemicalBiologicalRadiologicalDetection");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SensorElements_video                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SensorElements_video (OSCTXT* pctxt, 
   SensorElements_video *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode model */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->model, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SensorElements_video (OSCTXT* pctxt, SensorElements_video* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("model"), 5}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* model */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->model);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SensorElements_video");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SensorElements_video");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SensorElements_fLIR                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SensorElements_fLIR (OSCTXT* pctxt, 
   SensorElements_fLIR *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode model */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->model, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SensorElements_fLIR (OSCTXT* pctxt, SensorElements_fLIR* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("model"), 5}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* model */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->model);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SensorElements_fLIR");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SensorElements_fLIR");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SensorElements_motionSensor                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SensorElements_motionSensor (OSCTXT* pctxt, 
   SensorElements_motionSensor *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode model */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->model, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SensorElements_motionSensor (OSCTXT* pctxt, 
   SensorElements_motionSensor* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("model"), 5}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* model */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->model);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SensorElements_motionSensor");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SensorElements_motionSensor");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SensorElements                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SensorElements (OSCTXT* pctxt, SensorElements *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.activeSonar
             = rtxMemAllocType (pctxt, SensorElements_activeSonar);

         if (pvalue->u.activeSonar == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SensorElements_activeSonar (pvalue->u.activeSonar);
         stat = asn1D_SensorElements_activeSonar (pctxt, 
            pvalue->u.activeSonar, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.imagingSonar
             = rtxMemAllocType (pctxt, SensorElements_imagingSonar);

         if (pvalue->u.imagingSonar == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SensorElements_imagingSonar (pvalue->u.imagingSonar);
         stat = asn1D_SensorElements_imagingSonar (pctxt, 
            pvalue->u.imagingSonar, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.blazedArraySonar
             = rtxMemAllocType (pctxt, SensorElements_blazedArraySonar);

         if (pvalue->u.blazedArraySonar == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SensorElements_blazedArraySonar (pvalue->u.blazedArraySonar);
         stat = asn1D_SensorElements_blazedArraySonar (pctxt, 
            pvalue->u.blazedArraySonar, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.syntheticApertureSonar
             = rtxMemAllocType (pctxt, SensorElements_syntheticApertureSonar);

         if (pvalue->u.syntheticApertureSonar == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SensorElements_syntheticApertureSonar (pvalue->u.syntheticApertureSonar);
         stat = asn1D_SensorElements_syntheticApertureSonar (pctxt, 
            pvalue->u.syntheticApertureSonar, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.passiveSonar
             = rtxMemAllocType (pctxt, SensorElements_passiveSonar);

         if (pvalue->u.passiveSonar == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SensorElements_passiveSonar (pvalue->u.passiveSonar);
         stat = asn1D_SensorElements_passiveSonar (pctxt, 
            pvalue->u.passiveSonar, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.radar = rtxMemAllocType (pctxt, SensorElements_radar);

         if (pvalue->u.radar == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SensorElements_radar (pvalue->u.radar);
         stat = asn1D_SensorElements_radar (pctxt, 
            pvalue->u.radar, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.dopplerRadar
             = rtxMemAllocType (pctxt, SensorElements_dopplerRadar);

         if (pvalue->u.dopplerRadar == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SensorElements_dopplerRadar (pvalue->u.dopplerRadar);
         stat = asn1D_SensorElements_dopplerRadar (pctxt, 
            pvalue->u.dopplerRadar, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.syntheticApertureRadar
             = rtxMemAllocType (pctxt, SensorElements_syntheticApertureRadar);

         if (pvalue->u.syntheticApertureRadar == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SensorElements_syntheticApertureRadar (pvalue->u.syntheticApertureRadar);
         stat = asn1D_SensorElements_syntheticApertureRadar (pctxt, 
            pvalue->u.syntheticApertureRadar, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.trackWhileScanRadar
             = rtxMemAllocType (pctxt, SensorElements_trackWhileScanRadar);

         if (pvalue->u.trackWhileScanRadar == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SensorElements_trackWhileScanRadar (pvalue->u.trackWhileScanRadar);
         stat = asn1D_SensorElements_trackWhileScanRadar (pctxt, 
            pvalue->u.trackWhileScanRadar, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.earlyWarningRadar
             = rtxMemAllocType (pctxt, SensorElements_earlyWarningRadar);

         if (pvalue->u.earlyWarningRadar == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SensorElements_earlyWarningRadar (pvalue->u.earlyWarningRadar);
         stat = asn1D_SensorElements_earlyWarningRadar (pctxt, 
            pvalue->u.earlyWarningRadar, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.acquisitionRadar
             = rtxMemAllocType (pctxt, SensorElements_acquisitionRadar);

         if (pvalue->u.acquisitionRadar == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SensorElements_acquisitionRadar (pvalue->u.acquisitionRadar);
         stat = asn1D_SensorElements_acquisitionRadar (pctxt, 
            pvalue->u.acquisitionRadar, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.trackingRadar
             = rtxMemAllocType (pctxt, SensorElements_trackingRadar);

         if (pvalue->u.trackingRadar == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SensorElements_trackingRadar (pvalue->u.trackingRadar);
         stat = asn1D_SensorElements_trackingRadar (pctxt, 
            pvalue->u.trackingRadar, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.fireControlRadar
             = rtxMemAllocType (pctxt, SensorElements_fireControlRadar);

         if (pvalue->u.fireControlRadar == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SensorElements_fireControlRadar (pvalue->u.fireControlRadar);
         stat = asn1D_SensorElements_fireControlRadar (pctxt, 
            pvalue->u.fireControlRadar, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.surfaceSearchRadar
             = rtxMemAllocType (pctxt, SensorElements_surfaceSearchRadar);

         if (pvalue->u.surfaceSearchRadar == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SensorElements_surfaceSearchRadar (pvalue->u.surfaceSearchRadar);
         stat = asn1D_SensorElements_surfaceSearchRadar (pctxt, 
            pvalue->u.surfaceSearchRadar, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.eSM = rtxMemAllocType (pctxt, SensorElements_eSM);

         if (pvalue->u.eSM == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SensorElements_eSM (pvalue->u.eSM);
         stat = asn1D_SensorElements_eSM (pctxt, 
            pvalue->u.eSM, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.passiveSoundDetection
             = rtxMemAllocType (pctxt, SensorElements_passiveSoundDetection);

         if (pvalue->u.passiveSoundDetection == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SensorElements_passiveSoundDetection (pvalue->u.passiveSoundDetection);
         stat = asn1D_SensorElements_passiveSoundDetection (pctxt, 
            pvalue->u.passiveSoundDetection, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.chemicalBiologicalRadiologicalDetection
             = rtxMemAllocType (pctxt, SensorElements_chemicalBiologicalRadiologicalDetection);

         if (pvalue->u.chemicalBiologicalRadiologicalDetection == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SensorElements_chemicalBiologicalRadiologicalDetection (pvalue->u.chemicalBiologicalRadiologicalDetection);
         stat = asn1D_SensorElements_chemicalBiologicalRadiologicalDetection (pctxt, 
            pvalue->u.chemicalBiologicalRadiologicalDetection, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      case (TM_CTXT|TM_CONS|17):
         pvalue->u.video = rtxMemAllocType (pctxt, SensorElements_video);

         if (pvalue->u.video == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SensorElements_video (pvalue->u.video);
         stat = asn1D_SensorElements_video (pctxt, 
            pvalue->u.video, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 18;
         break;

      case (TM_CTXT|TM_CONS|18):
         pvalue->u.fLIR = rtxMemAllocType (pctxt, SensorElements_fLIR);

         if (pvalue->u.fLIR == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SensorElements_fLIR (pvalue->u.fLIR);
         stat = asn1D_SensorElements_fLIR (pctxt, 
            pvalue->u.fLIR, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 19;
         break;

      case (TM_CTXT|TM_CONS|19):
         pvalue->u.motionSensor
             = rtxMemAllocType (pctxt, SensorElements_motionSensor);

         if (pvalue->u.motionSensor == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SensorElements_motionSensor (pvalue->u.motionSensor);
         stat = asn1D_SensorElements_motionSensor (pctxt, 
            pvalue->u.motionSensor, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 20;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_SensorElements (OSCTXT* pctxt, SensorElements* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("ActiveSonar"), 11}, 0}, 0 },
      {{{OSUTF8("ImagingSonar"), 12}, 0}, 1 },
      {{{OSUTF8("BlazedArraySonar"), 16}, 0}, 2 },
      {{{OSUTF8("SyntheticApertureSonar"), 22}, 0}, 3 },
      {{{OSUTF8("PassiveSonar"), 12}, 0}, 4 },
      {{{OSUTF8("Radar"), 5}, 0}, 5 },
      {{{OSUTF8("DopplerRadar"), 12}, 0}, 6 },
      {{{OSUTF8("SyntheticApertureRadar"), 22}, 0}, 7 },
      {{{OSUTF8("TrackWhileScanRadar"), 19}, 0}, 8 },
      {{{OSUTF8("EarlyWarningRadar"), 17}, 0}, 9 },
      {{{OSUTF8("AcquisitionRadar"), 16}, 0}, 10 },
      {{{OSUTF8("TrackingRadar"), 13}, 0}, 11 },
      {{{OSUTF8("FireControlRadar"), 16}, 0}, 12 },
      {{{OSUTF8("SurfaceSearchRadar"), 18}, 0}, 13 },
      {{{OSUTF8("ESM"), 3}, 0}, 14 },
      {{{OSUTF8("PassiveSoundDetection"), 21}, 0}, 15 },
      {{{OSUTF8("ChemicalBiologicalRadiologicalDetection"), 39}, 0}, 16 },
      {{{OSUTF8("Video"), 5}, 0}, 17 },
      {{{OSUTF8("FLIR"), 4}, 0}, 18 },
      {{{OSUTF8("MotionSensor"), 12}, 0}, 19 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 20, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* ActiveSonar */
      pvalue->u.activeSonar
          = rtxMemAllocType (pctxt, SensorElements_activeSonar);

      if (pvalue->u.activeSonar == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SensorElements_activeSonar (pvalue->u.activeSonar);

      stat = XmlDec_SensorElements_activeSonar (pctxt, pvalue->u.activeSonar);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* ImagingSonar */
      pvalue->u.imagingSonar
          = rtxMemAllocType (pctxt, SensorElements_imagingSonar);

      if (pvalue->u.imagingSonar == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SensorElements_imagingSonar (pvalue->u.imagingSonar);

      stat = XmlDec_SensorElements_imagingSonar (pctxt, pvalue->u.imagingSonar
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* BlazedArraySonar */
      pvalue->u.blazedArraySonar
          = rtxMemAllocType (pctxt, SensorElements_blazedArraySonar);

      if (pvalue->u.blazedArraySonar == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SensorElements_blazedArraySonar (pvalue->u.blazedArraySonar);

      stat = XmlDec_SensorElements_blazedArraySonar (pctxt, pvalue->
         u.blazedArraySonar);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* SyntheticApertureSonar */
      pvalue->u.syntheticApertureSonar
          = rtxMemAllocType (pctxt, SensorElements_syntheticApertureSonar);

      if (pvalue->u.syntheticApertureSonar == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SensorElements_syntheticApertureSonar (pvalue->
         u.syntheticApertureSonar);

      stat = XmlDec_SensorElements_syntheticApertureSonar (pctxt, pvalue->
         u.syntheticApertureSonar);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* PassiveSonar */
      pvalue->u.passiveSonar
          = rtxMemAllocType (pctxt, SensorElements_passiveSonar);

      if (pvalue->u.passiveSonar == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SensorElements_passiveSonar (pvalue->u.passiveSonar);

      stat = XmlDec_SensorElements_passiveSonar (pctxt, pvalue->u.passiveSonar
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* Radar */
      pvalue->u.radar = rtxMemAllocType (pctxt, SensorElements_radar);

      if (pvalue->u.radar == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SensorElements_radar (pvalue->u.radar);

      stat = XmlDec_SensorElements_radar (pctxt, pvalue->u.radar);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* DopplerRadar */
      pvalue->u.dopplerRadar
          = rtxMemAllocType (pctxt, SensorElements_dopplerRadar);

      if (pvalue->u.dopplerRadar == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SensorElements_dopplerRadar (pvalue->u.dopplerRadar);

      stat = XmlDec_SensorElements_dopplerRadar (pctxt, pvalue->u.dopplerRadar
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* SyntheticApertureRadar */
      pvalue->u.syntheticApertureRadar
          = rtxMemAllocType (pctxt, SensorElements_syntheticApertureRadar);

      if (pvalue->u.syntheticApertureRadar == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SensorElements_syntheticApertureRadar (pvalue->
         u.syntheticApertureRadar);

      stat = XmlDec_SensorElements_syntheticApertureRadar (pctxt, pvalue->
         u.syntheticApertureRadar);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* TrackWhileScanRadar */
      pvalue->u.trackWhileScanRadar
          = rtxMemAllocType (pctxt, SensorElements_trackWhileScanRadar);

      if (pvalue->u.trackWhileScanRadar == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SensorElements_trackWhileScanRadar (pvalue->
         u.trackWhileScanRadar);

      stat = XmlDec_SensorElements_trackWhileScanRadar (pctxt, pvalue->
         u.trackWhileScanRadar);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* EarlyWarningRadar */
      pvalue->u.earlyWarningRadar
          = rtxMemAllocType (pctxt, SensorElements_earlyWarningRadar);

      if (pvalue->u.earlyWarningRadar == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SensorElements_earlyWarningRadar (pvalue->u.earlyWarningRadar);

      stat = XmlDec_SensorElements_earlyWarningRadar (pctxt, pvalue->
         u.earlyWarningRadar);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* AcquisitionRadar */
      pvalue->u.acquisitionRadar
          = rtxMemAllocType (pctxt, SensorElements_acquisitionRadar);

      if (pvalue->u.acquisitionRadar == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SensorElements_acquisitionRadar (pvalue->u.acquisitionRadar);

      stat = XmlDec_SensorElements_acquisitionRadar (pctxt, pvalue->
         u.acquisitionRadar);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* TrackingRadar */
      pvalue->u.trackingRadar
          = rtxMemAllocType (pctxt, SensorElements_trackingRadar);

      if (pvalue->u.trackingRadar == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SensorElements_trackingRadar (pvalue->u.trackingRadar);

      stat = XmlDec_SensorElements_trackingRadar (pctxt, pvalue->
         u.trackingRadar);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* FireControlRadar */
      pvalue->u.fireControlRadar
          = rtxMemAllocType (pctxt, SensorElements_fireControlRadar);

      if (pvalue->u.fireControlRadar == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SensorElements_fireControlRadar (pvalue->u.fireControlRadar);

      stat = XmlDec_SensorElements_fireControlRadar (pctxt, pvalue->
         u.fireControlRadar);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* SurfaceSearchRadar */
      pvalue->u.surfaceSearchRadar
          = rtxMemAllocType (pctxt, SensorElements_surfaceSearchRadar);

      if (pvalue->u.surfaceSearchRadar == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SensorElements_surfaceSearchRadar (pvalue->u.surfaceSearchRadar
         );

      stat = XmlDec_SensorElements_surfaceSearchRadar (pctxt, pvalue->
         u.surfaceSearchRadar);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* ESM */
      pvalue->u.eSM = rtxMemAllocType (pctxt, SensorElements_eSM);

      if (pvalue->u.eSM == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SensorElements_eSM (pvalue->u.eSM);

      stat = XmlDec_SensorElements_eSM (pctxt, pvalue->u.eSM);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* PassiveSoundDetection */
      pvalue->u.passiveSoundDetection
          = rtxMemAllocType (pctxt, SensorElements_passiveSoundDetection);

      if (pvalue->u.passiveSoundDetection == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SensorElements_passiveSoundDetection (pvalue->
         u.passiveSoundDetection);

      stat = XmlDec_SensorElements_passiveSoundDetection (pctxt, pvalue->
         u.passiveSoundDetection);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* ChemicalBiologicalRadiologicalDetection */
      pvalue->u.chemicalBiologicalRadiologicalDetection
          = rtxMemAllocType (pctxt, SensorElements_chemicalBiologicalRadiologicalDetection);

      if (pvalue->u.chemicalBiologicalRadiologicalDetection == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SensorElements_chemicalBiologicalRadiologicalDetection (pvalue->
         u.chemicalBiologicalRadiologicalDetection);

      stat = XmlDec_SensorElements_chemicalBiologicalRadiologicalDetection 
         (pctxt, pvalue->u.chemicalBiologicalRadiologicalDetection);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 17: { /* Video */
      pvalue->u.video = rtxMemAllocType (pctxt, SensorElements_video);

      if (pvalue->u.video == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SensorElements_video (pvalue->u.video);

      stat = XmlDec_SensorElements_video (pctxt, pvalue->u.video);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 18: { /* FLIR */
      pvalue->u.fLIR = rtxMemAllocType (pctxt, SensorElements_fLIR);

      if (pvalue->u.fLIR == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SensorElements_fLIR (pvalue->u.fLIR);

      stat = XmlDec_SensorElements_fLIR (pctxt, pvalue->u.fLIR);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 19: { /* MotionSensor */
      pvalue->u.motionSensor
          = rtxMemAllocType (pctxt, SensorElements_motionSensor);

      if (pvalue->u.motionSensor == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SensorElements_motionSensor (pvalue->u.motionSensor);

      stat = XmlDec_SensorElements_motionSensor (pctxt, pvalue->u.motionSensor
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SensorElementType                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_SensorElementType (OSCTXT* pctxt, SensorElementType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               SensorElements* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, SensorElements, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_SensorElements (pdata2);

                  stat = asn1D_SensorElements (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

               if (!(pvalue->choice_list.count >= 1U)) {
                  rtxErrAddStrParm (pctxt, "SensorElementType.choice_list.count");
                  rtxErrAddIntParm (pctxt, (int)pvalue->choice_list.count);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_SensorElementType (OSCTXT* pctxt, SensorElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "SensorElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "SensorElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("ActiveSonar"), 11}, 0}, 0 },
      {{{OSUTF8("ImagingSonar"), 12}, 0}, 0 },
      {{{OSUTF8("BlazedArraySonar"), 16}, 0}, 0 },
      {{{OSUTF8("SyntheticApertureSonar"), 22}, 0}, 0 },
      {{{OSUTF8("PassiveSonar"), 12}, 0}, 0 },
      {{{OSUTF8("Radar"), 5}, 0}, 0 },
      {{{OSUTF8("DopplerRadar"), 12}, 0}, 0 },
      {{{OSUTF8("SyntheticApertureRadar"), 22}, 0}, 0 },
      {{{OSUTF8("TrackWhileScanRadar"), 19}, 0}, 0 },
      {{{OSUTF8("EarlyWarningRadar"), 17}, 0}, 0 },
      {{{OSUTF8("AcquisitionRadar"), 16}, 0}, 0 },
      {{{OSUTF8("TrackingRadar"), 13}, 0}, 0 },
      {{{OSUTF8("FireControlRadar"), 16}, 0}, 0 },
      {{{OSUTF8("SurfaceSearchRadar"), 18}, 0}, 0 },
      {{{OSUTF8("ESM"), 3}, 0}, 0 },
      {{{OSUTF8("PassiveSoundDetection"), 21}, 0}, 0 },
      {{{OSUTF8("ChemicalBiologicalRadiologicalDetection"), 39}, 0}, 0 },
      {{{OSUTF8("Video"), 5}, 0}, 0 },
      {{{OSUTF8("FLIR"), 4}, 0}, 0 },
      {{{OSUTF8("MotionSensor"), 12}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 20, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         SensorElements* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, SensorElements);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SensorElements (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_SensorElements (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 20, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  WeaponElementType                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_WeaponElementType (OSCTXT* pctxt, WeaponElementType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_WeaponElementType (OSCTXT* pctxt, WeaponElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "WeaponElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "WeaponElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DiscreteTimeResultsElementType                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_DiscreteTimeResultsElementType (OSCTXT* pctxt, 
   DiscreteTimeResultsElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_DiscreteTimeResultsElementType_choice (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choicePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode choice_1 */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_DiscreteTimeResultsElementType_choice_1 (pctxt, 
               &pvalue->choice_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choice_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode sensor */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_SensorElementType (pctxt, 
               &pvalue->sensor, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sensorPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode weapon */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_WeaponElementType (pctxt, 
               &pvalue->weapon, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.weaponPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_DiscreteTimeResultsElementType (OSCTXT* pctxt, 
   DiscreteTimeResultsElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "DiscreteTimeResultsElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "DiscreteTimeResultsElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("UUVTelemetry"), 12}, 0}, 0 },
      {{{OSUTF8("USVTelemetry"), 12}, 0}, 0 },
      {{{OSUTF8("UGVTelemetry"), 12}, 0}, 0 },
      {{{OSUTF8("UAVTelemetry"), 12}, 0}, 0 },
      {{{OSUTF8("UUVControlOrder"), 15}, 0}, 1 },
      {{{OSUTF8("USVControlOrder"), 15}, 0}, 1 },
      {{{OSUTF8("UGVControlOrder"), 15}, 0}, 1 },
      {{{OSUTF8("UAVControlOrder"), 15}, 0}, 1 },
      {{{OSUTF8("Sensor"), 6}, 0}, 2 },
      {{{OSUTF8("Weapon"), 6}, 0}, 3 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 10, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 4; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /*  */
         stat = XmlDec_DiscreteTimeResultsElementType_choice (pctxt, &pvalue->
            choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choicePresent = TRUE;
         break;
      }
      case 1: { /*  */
         stat = XmlDec_DiscreteTimeResultsElementType_choice_1 (pctxt, &pvalue
            ->choice_1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choice_1Present = TRUE;
         break;
      }
      case 2: { /* Sensor */
         stat = XmlDec_SensorElementType (pctxt, &pvalue->sensor);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.sensorPresent = TRUE;
         break;
      }
      case 3: { /* Weapon */
         stat = XmlDec_WeaponElementType (pctxt, &pvalue->weapon);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.weaponPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UuvLoggableEventType_element                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UuvLoggableEventType_element (OSCTXT* pctxt, 
   UuvLoggableEventType_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.compositeWaypoint
             = rtxMemAllocType (pctxt, UuvCompositeWaypointCommandType);

         if (pvalue->u.compositeWaypoint == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UuvCompositeWaypointCommandType (pvalue->u.compositeWaypoint);
         stat = asn1D_UuvCompositeWaypointCommandType (pctxt, 
            pvalue->u.compositeWaypoint, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.followBeacon
             = rtxMemAllocType (pctxt, FollowBeaconCommandType);

         if (pvalue->u.followBeacon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_FollowBeaconCommandType (pvalue->u.followBeacon);
         stat = asn1D_FollowBeaconCommandType (pctxt, 
            pvalue->u.followBeacon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.gpsFix = rtxMemAllocType (pctxt, GpsFixCommandType);

         if (pvalue->u.gpsFix == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_GpsFixCommandType (pvalue->u.gpsFix);
         stat = asn1D_GpsFixCommandType (pctxt, 
            pvalue->u.gpsFix, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.help = rtxMemAllocType (pctxt, NoValueElementType);

         if (pvalue->u.help == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NoValueElementType (pvalue->u.help);
         stat = asn1D_NoValueElementType (pctxt, 
            pvalue->u.help, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.hover = rtxMemAllocType (pctxt, HoverCommandType);

         if (pvalue->u.hover == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_HoverCommandType (pvalue->u.hover);
         stat = asn1D_HoverCommandType (pctxt, 
            pvalue->u.hover, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.loiter = rtxMemAllocType (pctxt, UuvLoiterCommandType);

         if (pvalue->u.loiter == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UuvLoiterCommandType (pvalue->u.loiter);
         stat = asn1D_UuvLoiterCommandType (pctxt, 
            pvalue->u.loiter, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.makeAltitude
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.makeAltitude == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeAltitude);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.makeAltitude, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.makeDepth
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.makeDepth == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeDepth);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.makeDepth, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.makeHeading = rtxMemAllocType (pctxt, HeadingElementType);

         if (pvalue->u.makeHeading == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_HeadingElementType (pvalue->u.makeHeading);
         stat = asn1D_HeadingElementType (pctxt, 
            pvalue->u.makeHeading, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.makeKnots = rtxMemAllocType (pctxt, SpeedElementType);

         if (pvalue->u.makeKnots == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SpeedElementType (pvalue->u.makeKnots);
         stat = asn1D_SpeedElementType (pctxt, 
            pvalue->u.makeKnots, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.makeSpeed = rtxMemAllocType (pctxt, SpeedElementType);

         if (pvalue->u.makeSpeed == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SpeedElementType (pvalue->u.makeSpeed);
         stat = asn1D_SpeedElementType (pctxt, 
            pvalue->u.makeSpeed, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.metaCommand = rtxMemAllocType (pctxt, MetaDataType);

         if (pvalue->u.metaCommand == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MetaDataType (pvalue->u.metaCommand);
         stat = asn1D_MetaDataType (pctxt, 
            pvalue->u.metaCommand, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.missionScript = rtxMemAllocType (pctxt, StringElementType);

         if (pvalue->u.missionScript == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_StringElementType (pvalue->u.missionScript);
         stat = asn1D_StringElementType (pctxt, 
            pvalue->u.missionScript, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.missionScriptInline
             = rtxMemAllocType (pctxt, StringElementType);

         if (pvalue->u.missionScriptInline == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_StringElementType (pvalue->u.missionScriptInline);
         stat = asn1D_StringElementType (pctxt, 
            pvalue->u.missionScriptInline, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.moveLateral = rtxMemAllocType (pctxt, ScalarElementType);

         if (pvalue->u.moveLateral == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ScalarElementType (pvalue->u.moveLateral);
         stat = asn1D_ScalarElementType (pctxt, 
            pvalue->u.moveLateral, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.moveRotate = rtxMemAllocType (pctxt, ScalarElementType);

         if (pvalue->u.moveRotate == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ScalarElementType (pvalue->u.moveRotate);
         stat = asn1D_ScalarElementType (pctxt, 
            pvalue->u.moveRotate, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.quit = rtxMemAllocType (pctxt, QuitCommandType);

         if (pvalue->u.quit == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_QuitCommandType (pvalue->u.quit);
         stat = asn1D_QuitCommandType (pctxt, 
            pvalue->u.quit, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      case (TM_CTXT|TM_CONS|17):
         pvalue->u.realtime
             = rtxMemAllocType (pctxt, BooleanElementType_derivations);

         if (pvalue->u.realtime == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_BooleanElementType_derivations (pvalue->u.realtime);
         stat = asn1D_BooleanElementType_derivations (pctxt, 
            pvalue->u.realtime, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 18;
         break;

      case (TM_CTXT|TM_CONS|18):
         pvalue->u.recover = rtxMemAllocType (pctxt, RecoverCommandType);

         if (pvalue->u.recover == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_RecoverCommandType (pvalue->u.recover);
         stat = asn1D_RecoverCommandType (pctxt, 
            pvalue->u.recover, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 19;
         break;

      case (TM_CTXT|TM_CONS|19):
         pvalue->u.sendMessage
             = rtxMemAllocType (pctxt, SendMessageCommandType);

         if (pvalue->u.sendMessage == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SendMessageCommandType (pvalue->u.sendMessage);
         stat = asn1D_SendMessageCommandType (pctxt, 
            pvalue->u.sendMessage, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 20;
         break;

      case (TM_CTXT|TM_CONS|20):
         pvalue->u.setPlanes = rtxMemAllocType (pctxt, SetPlanesCommandType);

         if (pvalue->u.setPlanes == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SetPlanesCommandType (pvalue->u.setPlanes);
         stat = asn1D_SetPlanesCommandType (pctxt, 
            pvalue->u.setPlanes, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 21;
         break;

      case (TM_CTXT|TM_CONS|21):
         pvalue->u.setPosition
             = rtxMemAllocType (pctxt, UuvPositionCommandType);

         if (pvalue->u.setPosition == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UuvPositionCommandType (pvalue->u.setPosition);
         stat = asn1D_UuvPositionCommandType (pctxt, 
            pvalue->u.setPosition, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 22;
         break;

      case (TM_CTXT|TM_CONS|22):
         pvalue->u.setPower
             = rtxMemAllocType (pctxt, SetPropellerCommandType);

         if (pvalue->u.setPower == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SetPropellerCommandType (pvalue->u.setPower);
         stat = asn1D_SetPropellerCommandType (pctxt, 
            pvalue->u.setPower, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 23;
         break;

      case (TM_CTXT|TM_CONS|23):
         pvalue->u.setRudder
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.setRudder == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.setRudder);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.setRudder, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 24;
         break;

      case (TM_CTXT|TM_CONS|24):
         pvalue->u.setSonar = rtxMemAllocType (pctxt, SetSonarCommandType);

         if (pvalue->u.setSonar == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SetSonarCommandType (pvalue->u.setSonar);
         stat = asn1D_SetSonarCommandType (pctxt, 
            pvalue->u.setSonar, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 25;
         break;

      case (TM_CTXT|TM_CONS|25):
         pvalue->u.setStandoff
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.setStandoff == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.setStandoff);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.setStandoff, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 26;
         break;

      case (TM_CTXT|TM_CONS|26):
         pvalue->u.setThruster
             = rtxMemAllocType (pctxt, SetThrusterCommandType);

         if (pvalue->u.setThruster == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SetThrusterCommandType (pvalue->u.setThruster);
         stat = asn1D_SetThrusterCommandType (pctxt, 
            pvalue->u.setThruster, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 27;
         break;

      case (TM_CTXT|TM_CONS|27):
         pvalue->u.setTime = rtxMemAllocType (pctxt, ScalarElementType);

         if (pvalue->u.setTime == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ScalarElementType (pvalue->u.setTime);
         stat = asn1D_ScalarElementType (pctxt, 
            pvalue->u.setTime, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 28;
         break;

      case (TM_CTXT|TM_CONS|28):
         pvalue->u.setTimeStep
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.setTimeStep == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.setTimeStep);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.setTimeStep, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 29;
         break;

      case (TM_CTXT|TM_CONS|29):
         pvalue->u.takeStation
             = rtxMemAllocType (pctxt, TakeStationCommandType);

         if (pvalue->u.takeStation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TakeStationCommandType (pvalue->u.takeStation);
         stat = asn1D_TakeStationCommandType (pctxt, 
            pvalue->u.takeStation, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 30;
         break;

      case (TM_CTXT|TM_CONS|30):
         pvalue->u.thrusters
             = rtxMemAllocType (pctxt, BooleanElementType_derivations);

         if (pvalue->u.thrusters == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_BooleanElementType_derivations (pvalue->u.thrusters);
         stat = asn1D_BooleanElementType_derivations (pctxt, 
            pvalue->u.thrusters, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 31;
         break;

      case (TM_CTXT|TM_CONS|31):
         pvalue->u.trace
             = rtxMemAllocType (pctxt, BooleanElementType_derivations);

         if (pvalue->u.trace == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_BooleanElementType_derivations (pvalue->u.trace);
         stat = asn1D_BooleanElementType_derivations (pctxt, 
            pvalue->u.trace, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 32;
         break;

      case (TM_CTXT|TM_CONS|32):
         pvalue->u.wait
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.wait == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.wait);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.wait, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 33;
         break;

      case (TM_CTXT|TM_CONS|33):
         pvalue->u.waitUntilTime
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.waitUntilTime == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.waitUntilTime);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.waitUntilTime, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 34;
         break;

      case (TM_CTXT|TM_CONS|34):
         pvalue->u.waypoint = rtxMemAllocType (pctxt, UuvWaypointCommandType);

         if (pvalue->u.waypoint == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UuvWaypointCommandType (pvalue->u.waypoint);
         stat = asn1D_UuvWaypointCommandType (pctxt, 
            pvalue->u.waypoint, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 35;
         break;

      case (TM_CTXT|TM_CONS|35):
         pvalue->u.aVCLMessage = rtxMemAllocType (pctxt, AvclMessageType);

         if (pvalue->u.aVCLMessage == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AvclMessageType ((AvclMessageType*)pvalue->u.aVCLMessage);
         stat = asn1D_AvclMessageType (pctxt, 
            (AvclMessageType*)pvalue->u.aVCLMessage, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 36;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_UuvLoggableEventType_element (OSCTXT* pctxt, 
   UuvLoggableEventType_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("CompositeWaypoint"), 17}, 0}, 0 },
      {{{OSUTF8("FollowBeacon"), 12}, 0}, 1 },
      {{{OSUTF8("GpsFix"), 6}, 0}, 2 },
      {{{OSUTF8("Help"), 4}, 0}, 3 },
      {{{OSUTF8("Hover"), 5}, 0}, 4 },
      {{{OSUTF8("Loiter"), 6}, 0}, 5 },
      {{{OSUTF8("MakeAltitude"), 12}, 0}, 6 },
      {{{OSUTF8("MakeDepth"), 9}, 0}, 7 },
      {{{OSUTF8("MakeHeading"), 11}, 0}, 8 },
      {{{OSUTF8("MakeKnots"), 9}, 0}, 9 },
      {{{OSUTF8("MakeSpeed"), 9}, 0}, 10 },
      {{{OSUTF8("MetaCommand"), 11}, 0}, 11 },
      {{{OSUTF8("MissionScript"), 13}, 0}, 12 },
      {{{OSUTF8("MissionScriptInline"), 19}, 0}, 13 },
      {{{OSUTF8("MoveLateral"), 11}, 0}, 14 },
      {{{OSUTF8("MoveRotate"), 10}, 0}, 15 },
      {{{OSUTF8("Quit"), 4}, 0}, 16 },
      {{{OSUTF8("Realtime"), 8}, 0}, 17 },
      {{{OSUTF8("Recover"), 7}, 0}, 18 },
      {{{OSUTF8("SendMessage"), 11}, 0}, 19 },
      {{{OSUTF8("SetPlanes"), 9}, 0}, 20 },
      {{{OSUTF8("SetPosition"), 11}, 0}, 21 },
      {{{OSUTF8("SetPower"), 8}, 0}, 22 },
      {{{OSUTF8("SetRudder"), 9}, 0}, 23 },
      {{{OSUTF8("SetSonar"), 8}, 0}, 24 },
      {{{OSUTF8("SetStandoff"), 11}, 0}, 25 },
      {{{OSUTF8("SetThruster"), 11}, 0}, 26 },
      {{{OSUTF8("SetTime"), 7}, 0}, 27 },
      {{{OSUTF8("SetTimeStep"), 11}, 0}, 28 },
      {{{OSUTF8("TakeStation"), 11}, 0}, 29 },
      {{{OSUTF8("Thrusters"), 9}, 0}, 30 },
      {{{OSUTF8("Trace"), 5}, 0}, 31 },
      {{{OSUTF8("Wait"), 4}, 0}, 32 },
      {{{OSUTF8("WaitUntilTime"), 13}, 0}, 33 },
      {{{OSUTF8("Waypoint"), 8}, 0}, 34 },
      {{{OSUTF8("AVCLMessage"), 11}, 0}, 35 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 36, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* CompositeWaypoint */
      pvalue->u.compositeWaypoint
          = rtxMemAllocType (pctxt, UuvCompositeWaypointCommandType);

      if (pvalue->u.compositeWaypoint == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UuvCompositeWaypointCommandType (pvalue->u.compositeWaypoint);

      stat = XmlDec_UuvCompositeWaypointCommandType (pctxt, pvalue->
         u.compositeWaypoint);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* FollowBeacon */
      pvalue->u.followBeacon
          = rtxMemAllocType (pctxt, FollowBeaconCommandType);

      if (pvalue->u.followBeacon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_FollowBeaconCommandType (pvalue->u.followBeacon);

      stat = XmlDec_FollowBeaconCommandType (pctxt, pvalue->u.followBeacon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* GpsFix */
      pvalue->u.gpsFix = rtxMemAllocType (pctxt, GpsFixCommandType);

      if (pvalue->u.gpsFix == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_GpsFixCommandType (pvalue->u.gpsFix);

      stat = XmlDec_GpsFixCommandType (pctxt, pvalue->u.gpsFix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* Help */
      pvalue->u.help = rtxMemAllocType (pctxt, NoValueElementType);

      if (pvalue->u.help == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NoValueElementType (pvalue->u.help);

      stat = XmlDec_NoValueElementType (pctxt, pvalue->u.help);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* Hover */
      pvalue->u.hover = rtxMemAllocType (pctxt, HoverCommandType);

      if (pvalue->u.hover == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HoverCommandType (pvalue->u.hover);

      stat = XmlDec_HoverCommandType (pctxt, pvalue->u.hover);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* Loiter */
      pvalue->u.loiter = rtxMemAllocType (pctxt, UuvLoiterCommandType);

      if (pvalue->u.loiter == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UuvLoiterCommandType (pvalue->u.loiter);

      stat = XmlDec_UuvLoiterCommandType (pctxt, pvalue->u.loiter);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* MakeAltitude */
      pvalue->u.makeAltitude
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.makeAltitude == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeAltitude);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.makeAltitude);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* MakeDepth */
      pvalue->u.makeDepth
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.makeDepth == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeDepth);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.makeDepth);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* MakeHeading */
      pvalue->u.makeHeading = rtxMemAllocType (pctxt, HeadingElementType);

      if (pvalue->u.makeHeading == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HeadingElementType (pvalue->u.makeHeading);

      stat = XmlDec_HeadingElementType (pctxt, pvalue->u.makeHeading);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* MakeKnots */
      pvalue->u.makeKnots = rtxMemAllocType (pctxt, SpeedElementType);

      if (pvalue->u.makeKnots == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SpeedElementType (pvalue->u.makeKnots);

      stat = XmlDec_SpeedElementType (pctxt, pvalue->u.makeKnots);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* MakeSpeed */
      pvalue->u.makeSpeed = rtxMemAllocType (pctxt, SpeedElementType);

      if (pvalue->u.makeSpeed == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SpeedElementType (pvalue->u.makeSpeed);

      stat = XmlDec_SpeedElementType (pctxt, pvalue->u.makeSpeed);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* MetaCommand */
      pvalue->u.metaCommand = rtxMemAllocType (pctxt, MetaDataType);

      if (pvalue->u.metaCommand == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MetaDataType (pvalue->u.metaCommand);

      stat = XmlDec_MetaDataType (pctxt, pvalue->u.metaCommand);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* MissionScript */
      pvalue->u.missionScript = rtxMemAllocType (pctxt, StringElementType);

      if (pvalue->u.missionScript == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_StringElementType (pvalue->u.missionScript);

      stat = XmlDec_StringElementType (pctxt, pvalue->u.missionScript);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* MissionScriptInline */
      pvalue->u.missionScriptInline
          = rtxMemAllocType (pctxt, StringElementType);

      if (pvalue->u.missionScriptInline == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_StringElementType (pvalue->u.missionScriptInline);

      stat = XmlDec_StringElementType (pctxt, pvalue->u.missionScriptInline);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* MoveLateral */
      pvalue->u.moveLateral = rtxMemAllocType (pctxt, ScalarElementType);

      if (pvalue->u.moveLateral == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ScalarElementType (pvalue->u.moveLateral);

      stat = XmlDec_ScalarElementType (pctxt, pvalue->u.moveLateral);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* MoveRotate */
      pvalue->u.moveRotate = rtxMemAllocType (pctxt, ScalarElementType);

      if (pvalue->u.moveRotate == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ScalarElementType (pvalue->u.moveRotate);

      stat = XmlDec_ScalarElementType (pctxt, pvalue->u.moveRotate);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* Quit */
      pvalue->u.quit = rtxMemAllocType (pctxt, QuitCommandType);

      if (pvalue->u.quit == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QuitCommandType (pvalue->u.quit);

      stat = XmlDec_QuitCommandType (pctxt, pvalue->u.quit);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 17: { /* Realtime */
      pvalue->u.realtime
          = rtxMemAllocType (pctxt, BooleanElementType_derivations);

      if (pvalue->u.realtime == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BooleanElementType_derivations (pvalue->u.realtime);

      stat = XmlDec_BooleanElementType_derivations (pctxt, pvalue->u.realtime
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 18: { /* Recover */
      pvalue->u.recover = rtxMemAllocType (pctxt, RecoverCommandType);

      if (pvalue->u.recover == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RecoverCommandType (pvalue->u.recover);

      stat = XmlDec_RecoverCommandType (pctxt, pvalue->u.recover);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 19: { /* SendMessage */
      pvalue->u.sendMessage = rtxMemAllocType (pctxt, SendMessageCommandType);

      if (pvalue->u.sendMessage == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SendMessageCommandType (pvalue->u.sendMessage);

      stat = XmlDec_SendMessageCommandType (pctxt, pvalue->u.sendMessage);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 20: { /* SetPlanes */
      pvalue->u.setPlanes = rtxMemAllocType (pctxt, SetPlanesCommandType);

      if (pvalue->u.setPlanes == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SetPlanesCommandType (pvalue->u.setPlanes);

      stat = XmlDec_SetPlanesCommandType (pctxt, pvalue->u.setPlanes);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 21: { /* SetPosition */
      pvalue->u.setPosition = rtxMemAllocType (pctxt, UuvPositionCommandType);

      if (pvalue->u.setPosition == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UuvPositionCommandType (pvalue->u.setPosition);

      stat = XmlDec_UuvPositionCommandType (pctxt, pvalue->u.setPosition);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 22: { /* SetPower */
      pvalue->u.setPower = rtxMemAllocType (pctxt, SetPropellerCommandType);

      if (pvalue->u.setPower == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SetPropellerCommandType (pvalue->u.setPower);

      stat = XmlDec_SetPropellerCommandType (pctxt, pvalue->u.setPower);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 23: { /* SetRudder */
      pvalue->u.setRudder = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.setRudder == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.setRudder);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->u.setRudder);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 24: { /* SetSonar */
      pvalue->u.setSonar = rtxMemAllocType (pctxt, SetSonarCommandType);

      if (pvalue->u.setSonar == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SetSonarCommandType (pvalue->u.setSonar);

      stat = XmlDec_SetSonarCommandType (pctxt, pvalue->u.setSonar);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 25: { /* SetStandoff */
      pvalue->u.setStandoff
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.setStandoff == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.setStandoff);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.setStandoff);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 26: { /* SetThruster */
      pvalue->u.setThruster = rtxMemAllocType (pctxt, SetThrusterCommandType);

      if (pvalue->u.setThruster == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SetThrusterCommandType (pvalue->u.setThruster);

      stat = XmlDec_SetThrusterCommandType (pctxt, pvalue->u.setThruster);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 27: { /* SetTime */
      pvalue->u.setTime = rtxMemAllocType (pctxt, ScalarElementType);

      if (pvalue->u.setTime == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ScalarElementType (pvalue->u.setTime);

      stat = XmlDec_ScalarElementType (pctxt, pvalue->u.setTime);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 28: { /* SetTimeStep */
      pvalue->u.setTimeStep
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.setTimeStep == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.setTimeStep);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.setTimeStep);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 29: { /* TakeStation */
      pvalue->u.takeStation = rtxMemAllocType (pctxt, TakeStationCommandType);

      if (pvalue->u.takeStation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TakeStationCommandType (pvalue->u.takeStation);

      stat = XmlDec_TakeStationCommandType (pctxt, pvalue->u.takeStation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 30: { /* Thrusters */
      pvalue->u.thrusters
          = rtxMemAllocType (pctxt, BooleanElementType_derivations);

      if (pvalue->u.thrusters == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BooleanElementType_derivations (pvalue->u.thrusters);

      stat = XmlDec_BooleanElementType_derivations (pctxt, pvalue->u.thrusters
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 31: { /* Trace */
      pvalue->u.trace
          = rtxMemAllocType (pctxt, BooleanElementType_derivations);

      if (pvalue->u.trace == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BooleanElementType_derivations (pvalue->u.trace);

      stat = XmlDec_BooleanElementType_derivations (pctxt, pvalue->u.trace);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 32: { /* Wait */
      pvalue->u.wait
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.wait == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.wait);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.wait);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 33: { /* WaitUntilTime */
      pvalue->u.waitUntilTime
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.waitUntilTime == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.waitUntilTime
         );

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.waitUntilTime);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 34: { /* Waypoint */
      pvalue->u.waypoint = rtxMemAllocType (pctxt, UuvWaypointCommandType);

      if (pvalue->u.waypoint == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UuvWaypointCommandType (pvalue->u.waypoint);

      stat = XmlDec_UuvWaypointCommandType (pctxt, pvalue->u.waypoint);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 35: { /* AVCLMessage */
      pvalue->u.aVCLMessage = rtxMemAllocType (pctxt, AvclMessageType);

      if (pvalue->u.aVCLMessage == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AvclMessageType ((AvclMessageType*)pvalue->u.aVCLMessage);

      stat = XmlDec_AvclMessageType (pctxt, pvalue->u.aVCLMessage);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UuvLoggableEventType                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UuvLoggableEventType (OSCTXT* pctxt, 
   UuvLoggableEventType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               UuvLoggableEventType_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, UuvLoggableEventType_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_UuvLoggableEventType_element (pdata2);

                  stat = asn1D_UuvLoggableEventType_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

               if (!(pvalue->choice_list.count >= 1U)) {
                  rtxErrAddStrParm (pctxt, "UuvLoggableEventType.choice_list.count");
                  rtxErrAddIntParm (pctxt, (int)pvalue->choice_list.count);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UuvLoggableEventType (OSCTXT* pctxt, UuvLoggableEventType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UuvLoggableEventType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UuvLoggableEventType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("CompositeWaypoint"), 17}, 0}, 0 },
      {{{OSUTF8("FollowBeacon"), 12}, 0}, 0 },
      {{{OSUTF8("GpsFix"), 6}, 0}, 0 },
      {{{OSUTF8("Help"), 4}, 0}, 0 },
      {{{OSUTF8("Hover"), 5}, 0}, 0 },
      {{{OSUTF8("Loiter"), 6}, 0}, 0 },
      {{{OSUTF8("MakeAltitude"), 12}, 0}, 0 },
      {{{OSUTF8("MakeDepth"), 9}, 0}, 0 },
      {{{OSUTF8("MakeHeading"), 11}, 0}, 0 },
      {{{OSUTF8("MakeKnots"), 9}, 0}, 0 },
      {{{OSUTF8("MakeSpeed"), 9}, 0}, 0 },
      {{{OSUTF8("MetaCommand"), 11}, 0}, 0 },
      {{{OSUTF8("MissionScript"), 13}, 0}, 0 },
      {{{OSUTF8("MissionScriptInline"), 19}, 0}, 0 },
      {{{OSUTF8("MoveLateral"), 11}, 0}, 0 },
      {{{OSUTF8("MoveRotate"), 10}, 0}, 0 },
      {{{OSUTF8("Quit"), 4}, 0}, 0 },
      {{{OSUTF8("Realtime"), 8}, 0}, 0 },
      {{{OSUTF8("Recover"), 7}, 0}, 0 },
      {{{OSUTF8("SendMessage"), 11}, 0}, 0 },
      {{{OSUTF8("SetPlanes"), 9}, 0}, 0 },
      {{{OSUTF8("SetPosition"), 11}, 0}, 0 },
      {{{OSUTF8("SetPower"), 8}, 0}, 0 },
      {{{OSUTF8("SetRudder"), 9}, 0}, 0 },
      {{{OSUTF8("SetSonar"), 8}, 0}, 0 },
      {{{OSUTF8("SetStandoff"), 11}, 0}, 0 },
      {{{OSUTF8("SetThruster"), 11}, 0}, 0 },
      {{{OSUTF8("SetTime"), 7}, 0}, 0 },
      {{{OSUTF8("SetTimeStep"), 11}, 0}, 0 },
      {{{OSUTF8("TakeStation"), 11}, 0}, 0 },
      {{{OSUTF8("Thrusters"), 9}, 0}, 0 },
      {{{OSUTF8("Trace"), 5}, 0}, 0 },
      {{{OSUTF8("Wait"), 4}, 0}, 0 },
      {{{OSUTF8("WaitUntilTime"), 13}, 0}, 0 },
      {{{OSUTF8("Waypoint"), 8}, 0}, 0 },
      {{{OSUTF8("AVCLMessage"), 11}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 36, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         UuvLoggableEventType_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, UuvLoggableEventType_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UuvLoggableEventType_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_UuvLoggableEventType_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 36, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UgvLoggableEventType_element                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UgvLoggableEventType_element (OSCTXT* pctxt, 
   UgvLoggableEventType_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.compositeWaypoint
             = rtxMemAllocType (pctxt, UgvCompositeWaypointCommandType);

         if (pvalue->u.compositeWaypoint == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UgvCompositeWaypointCommandType (pvalue->u.compositeWaypoint);
         stat = asn1D_UgvCompositeWaypointCommandType (pctxt, 
            pvalue->u.compositeWaypoint, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.help = rtxMemAllocType (pctxt, NoValueElementType);

         if (pvalue->u.help == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NoValueElementType (pvalue->u.help);
         stat = asn1D_NoValueElementType (pctxt, 
            pvalue->u.help, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.loiter = rtxMemAllocType (pctxt, UgvLoiterCommandType);

         if (pvalue->u.loiter == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UgvLoiterCommandType (pvalue->u.loiter);
         stat = asn1D_UgvLoiterCommandType (pctxt, 
            pvalue->u.loiter, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.makeHeading = rtxMemAllocType (pctxt, HeadingElementType);

         if (pvalue->u.makeHeading == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_HeadingElementType (pvalue->u.makeHeading);
         stat = asn1D_HeadingElementType (pctxt, 
            pvalue->u.makeHeading, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.makeSpeed
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.makeSpeed == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeSpeed);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.makeSpeed, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.metaCommand = rtxMemAllocType (pctxt, MetaDataType);

         if (pvalue->u.metaCommand == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MetaDataType (pvalue->u.metaCommand);
         stat = asn1D_MetaDataType (pctxt, 
            pvalue->u.metaCommand, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.missionScript = rtxMemAllocType (pctxt, StringElementType);

         if (pvalue->u.missionScript == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_StringElementType (pvalue->u.missionScript);
         stat = asn1D_StringElementType (pctxt, 
            pvalue->u.missionScript, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.missionScriptInline
             = rtxMemAllocType (pctxt, StringElementType);

         if (pvalue->u.missionScriptInline == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_StringElementType (pvalue->u.missionScriptInline);
         stat = asn1D_StringElementType (pctxt, 
            pvalue->u.missionScriptInline, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.quit = rtxMemAllocType (pctxt, QuitCommandType);

         if (pvalue->u.quit == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_QuitCommandType (pvalue->u.quit);
         stat = asn1D_QuitCommandType (pctxt, 
            pvalue->u.quit, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.realtime
             = rtxMemAllocType (pctxt, BooleanElementType_derivations);

         if (pvalue->u.realtime == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_BooleanElementType_derivations (pvalue->u.realtime);
         stat = asn1D_BooleanElementType_derivations (pctxt, 
            pvalue->u.realtime, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.sendMessage
             = rtxMemAllocType (pctxt, SendMessageCommandType);

         if (pvalue->u.sendMessage == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SendMessageCommandType (pvalue->u.sendMessage);
         stat = asn1D_SendMessageCommandType (pctxt, 
            pvalue->u.sendMessage, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.setPosition
             = rtxMemAllocType (pctxt, UgvPositionCommandType);

         if (pvalue->u.setPosition == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UgvPositionCommandType (pvalue->u.setPosition);
         stat = asn1D_UgvPositionCommandType (pctxt, 
            pvalue->u.setPosition, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.setStandoff
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.setStandoff == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.setStandoff);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.setStandoff, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.setTime = rtxMemAllocType (pctxt, ScalarElementType);

         if (pvalue->u.setTime == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ScalarElementType (pvalue->u.setTime);
         stat = asn1D_ScalarElementType (pctxt, 
            pvalue->u.setTime, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.setTimeStep
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.setTimeStep == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.setTimeStep);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.setTimeStep, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.trace
             = rtxMemAllocType (pctxt, BooleanElementType_derivations);

         if (pvalue->u.trace == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_BooleanElementType_derivations (pvalue->u.trace);
         stat = asn1D_BooleanElementType_derivations (pctxt, 
            pvalue->u.trace, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.wait
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.wait == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.wait);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.wait, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      case (TM_CTXT|TM_CONS|17):
         pvalue->u.waitUntilTime
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.waitUntilTime == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.waitUntilTime);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.waitUntilTime, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 18;
         break;

      case (TM_CTXT|TM_CONS|18):
         pvalue->u.waypoint = rtxMemAllocType (pctxt, UgvWaypointCommandType);

         if (pvalue->u.waypoint == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UgvWaypointCommandType (pvalue->u.waypoint);
         stat = asn1D_UgvWaypointCommandType (pctxt, 
            pvalue->u.waypoint, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 19;
         break;

      case (TM_CTXT|TM_CONS|19):
         pvalue->u.aVCLMessage = rtxMemAllocType (pctxt, AvclMessageType);

         if (pvalue->u.aVCLMessage == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AvclMessageType ((AvclMessageType*)pvalue->u.aVCLMessage);
         stat = asn1D_AvclMessageType (pctxt, 
            (AvclMessageType*)pvalue->u.aVCLMessage, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 20;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_UgvLoggableEventType_element (OSCTXT* pctxt, 
   UgvLoggableEventType_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("CompositeWaypoint"), 17}, 0}, 0 },
      {{{OSUTF8("Help"), 4}, 0}, 1 },
      {{{OSUTF8("Loiter"), 6}, 0}, 2 },
      {{{OSUTF8("MakeHeading"), 11}, 0}, 3 },
      {{{OSUTF8("MakeSpeed"), 9}, 0}, 4 },
      {{{OSUTF8("MetaCommand"), 11}, 0}, 5 },
      {{{OSUTF8("MissionScript"), 13}, 0}, 6 },
      {{{OSUTF8("MissionScriptInline"), 19}, 0}, 7 },
      {{{OSUTF8("Quit"), 4}, 0}, 8 },
      {{{OSUTF8("Realtime"), 8}, 0}, 9 },
      {{{OSUTF8("SendMessage"), 11}, 0}, 10 },
      {{{OSUTF8("SetPosition"), 11}, 0}, 11 },
      {{{OSUTF8("SetStandoff"), 11}, 0}, 12 },
      {{{OSUTF8("SetTime"), 7}, 0}, 13 },
      {{{OSUTF8("SetTimeStep"), 11}, 0}, 14 },
      {{{OSUTF8("Trace"), 5}, 0}, 15 },
      {{{OSUTF8("Wait"), 4}, 0}, 16 },
      {{{OSUTF8("WaitUntilTime"), 13}, 0}, 17 },
      {{{OSUTF8("Waypoint"), 8}, 0}, 18 },
      {{{OSUTF8("AVCLMessage"), 11}, 0}, 19 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 20, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* CompositeWaypoint */
      pvalue->u.compositeWaypoint
          = rtxMemAllocType (pctxt, UgvCompositeWaypointCommandType);

      if (pvalue->u.compositeWaypoint == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UgvCompositeWaypointCommandType (pvalue->u.compositeWaypoint);

      stat = XmlDec_UgvCompositeWaypointCommandType (pctxt, pvalue->
         u.compositeWaypoint);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* Help */
      pvalue->u.help = rtxMemAllocType (pctxt, NoValueElementType);

      if (pvalue->u.help == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NoValueElementType (pvalue->u.help);

      stat = XmlDec_NoValueElementType (pctxt, pvalue->u.help);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* Loiter */
      pvalue->u.loiter = rtxMemAllocType (pctxt, UgvLoiterCommandType);

      if (pvalue->u.loiter == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UgvLoiterCommandType (pvalue->u.loiter);

      stat = XmlDec_UgvLoiterCommandType (pctxt, pvalue->u.loiter);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* MakeHeading */
      pvalue->u.makeHeading = rtxMemAllocType (pctxt, HeadingElementType);

      if (pvalue->u.makeHeading == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HeadingElementType (pvalue->u.makeHeading);

      stat = XmlDec_HeadingElementType (pctxt, pvalue->u.makeHeading);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* MakeSpeed */
      pvalue->u.makeSpeed
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.makeSpeed == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeSpeed);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.makeSpeed);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* MetaCommand */
      pvalue->u.metaCommand = rtxMemAllocType (pctxt, MetaDataType);

      if (pvalue->u.metaCommand == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MetaDataType (pvalue->u.metaCommand);

      stat = XmlDec_MetaDataType (pctxt, pvalue->u.metaCommand);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* MissionScript */
      pvalue->u.missionScript = rtxMemAllocType (pctxt, StringElementType);

      if (pvalue->u.missionScript == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_StringElementType (pvalue->u.missionScript);

      stat = XmlDec_StringElementType (pctxt, pvalue->u.missionScript);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* MissionScriptInline */
      pvalue->u.missionScriptInline
          = rtxMemAllocType (pctxt, StringElementType);

      if (pvalue->u.missionScriptInline == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_StringElementType (pvalue->u.missionScriptInline);

      stat = XmlDec_StringElementType (pctxt, pvalue->u.missionScriptInline);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* Quit */
      pvalue->u.quit = rtxMemAllocType (pctxt, QuitCommandType);

      if (pvalue->u.quit == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QuitCommandType (pvalue->u.quit);

      stat = XmlDec_QuitCommandType (pctxt, pvalue->u.quit);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* Realtime */
      pvalue->u.realtime
          = rtxMemAllocType (pctxt, BooleanElementType_derivations);

      if (pvalue->u.realtime == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BooleanElementType_derivations (pvalue->u.realtime);

      stat = XmlDec_BooleanElementType_derivations (pctxt, pvalue->u.realtime
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* SendMessage */
      pvalue->u.sendMessage = rtxMemAllocType (pctxt, SendMessageCommandType);

      if (pvalue->u.sendMessage == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SendMessageCommandType (pvalue->u.sendMessage);

      stat = XmlDec_SendMessageCommandType (pctxt, pvalue->u.sendMessage);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* SetPosition */
      pvalue->u.setPosition = rtxMemAllocType (pctxt, UgvPositionCommandType);

      if (pvalue->u.setPosition == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UgvPositionCommandType (pvalue->u.setPosition);

      stat = XmlDec_UgvPositionCommandType (pctxt, pvalue->u.setPosition);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* SetStandoff */
      pvalue->u.setStandoff
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.setStandoff == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.setStandoff);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.setStandoff);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* SetTime */
      pvalue->u.setTime = rtxMemAllocType (pctxt, ScalarElementType);

      if (pvalue->u.setTime == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ScalarElementType (pvalue->u.setTime);

      stat = XmlDec_ScalarElementType (pctxt, pvalue->u.setTime);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* SetTimeStep */
      pvalue->u.setTimeStep
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.setTimeStep == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.setTimeStep);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.setTimeStep);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* Trace */
      pvalue->u.trace
          = rtxMemAllocType (pctxt, BooleanElementType_derivations);

      if (pvalue->u.trace == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BooleanElementType_derivations (pvalue->u.trace);

      stat = XmlDec_BooleanElementType_derivations (pctxt, pvalue->u.trace);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* Wait */
      pvalue->u.wait
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.wait == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.wait);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.wait);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 17: { /* WaitUntilTime */
      pvalue->u.waitUntilTime
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.waitUntilTime == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.waitUntilTime
         );

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.waitUntilTime);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 18: { /* Waypoint */
      pvalue->u.waypoint = rtxMemAllocType (pctxt, UgvWaypointCommandType);

      if (pvalue->u.waypoint == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UgvWaypointCommandType (pvalue->u.waypoint);

      stat = XmlDec_UgvWaypointCommandType (pctxt, pvalue->u.waypoint);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 19: { /* AVCLMessage */
      pvalue->u.aVCLMessage = rtxMemAllocType (pctxt, AvclMessageType);

      if (pvalue->u.aVCLMessage == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AvclMessageType ((AvclMessageType*)pvalue->u.aVCLMessage);

      stat = XmlDec_AvclMessageType (pctxt, pvalue->u.aVCLMessage);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UgvLoggableEventType                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UgvLoggableEventType (OSCTXT* pctxt, 
   UgvLoggableEventType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               UgvLoggableEventType_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, UgvLoggableEventType_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_UgvLoggableEventType_element (pdata2);

                  stat = asn1D_UgvLoggableEventType_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

               if (!(pvalue->choice_list.count >= 1U)) {
                  rtxErrAddStrParm (pctxt, "UgvLoggableEventType.choice_list.count");
                  rtxErrAddIntParm (pctxt, (int)pvalue->choice_list.count);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UgvLoggableEventType (OSCTXT* pctxt, UgvLoggableEventType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UgvLoggableEventType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UgvLoggableEventType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("CompositeWaypoint"), 17}, 0}, 0 },
      {{{OSUTF8("Help"), 4}, 0}, 0 },
      {{{OSUTF8("Loiter"), 6}, 0}, 0 },
      {{{OSUTF8("MakeHeading"), 11}, 0}, 0 },
      {{{OSUTF8("MakeSpeed"), 9}, 0}, 0 },
      {{{OSUTF8("MetaCommand"), 11}, 0}, 0 },
      {{{OSUTF8("MissionScript"), 13}, 0}, 0 },
      {{{OSUTF8("MissionScriptInline"), 19}, 0}, 0 },
      {{{OSUTF8("Quit"), 4}, 0}, 0 },
      {{{OSUTF8("Realtime"), 8}, 0}, 0 },
      {{{OSUTF8("SendMessage"), 11}, 0}, 0 },
      {{{OSUTF8("SetPosition"), 11}, 0}, 0 },
      {{{OSUTF8("SetStandoff"), 11}, 0}, 0 },
      {{{OSUTF8("SetTime"), 7}, 0}, 0 },
      {{{OSUTF8("SetTimeStep"), 11}, 0}, 0 },
      {{{OSUTF8("Trace"), 5}, 0}, 0 },
      {{{OSUTF8("Wait"), 4}, 0}, 0 },
      {{{OSUTF8("WaitUntilTime"), 13}, 0}, 0 },
      {{{OSUTF8("Waypoint"), 8}, 0}, 0 },
      {{{OSUTF8("AVCLMessage"), 11}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 20, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         UgvLoggableEventType_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, UgvLoggableEventType_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UgvLoggableEventType_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_UgvLoggableEventType_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 20, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UsvLoggableEventType_element                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UsvLoggableEventType_element (OSCTXT* pctxt, 
   UsvLoggableEventType_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.compositeWaypoint
             = rtxMemAllocType (pctxt, UsvCompositeWaypointCommandType);

         if (pvalue->u.compositeWaypoint == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UsvCompositeWaypointCommandType (pvalue->u.compositeWaypoint);
         stat = asn1D_UsvCompositeWaypointCommandType (pctxt, 
            pvalue->u.compositeWaypoint, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.help = rtxMemAllocType (pctxt, NoValueElementType);

         if (pvalue->u.help == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NoValueElementType (pvalue->u.help);
         stat = asn1D_NoValueElementType (pctxt, 
            pvalue->u.help, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.loiter = rtxMemAllocType (pctxt, UsvLoiterCommandType);

         if (pvalue->u.loiter == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UsvLoiterCommandType (pvalue->u.loiter);
         stat = asn1D_UsvLoiterCommandType (pctxt, 
            pvalue->u.loiter, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.makeHeading = rtxMemAllocType (pctxt, HeadingElementType);

         if (pvalue->u.makeHeading == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_HeadingElementType (pvalue->u.makeHeading);
         stat = asn1D_HeadingElementType (pctxt, 
            pvalue->u.makeHeading, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.makeKnots = rtxMemAllocType (pctxt, SpeedElementType);

         if (pvalue->u.makeKnots == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SpeedElementType (pvalue->u.makeKnots);
         stat = asn1D_SpeedElementType (pctxt, 
            pvalue->u.makeKnots, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.makeSpeed = rtxMemAllocType (pctxt, SpeedElementType);

         if (pvalue->u.makeSpeed == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SpeedElementType (pvalue->u.makeSpeed);
         stat = asn1D_SpeedElementType (pctxt, 
            pvalue->u.makeSpeed, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.metaCommand = rtxMemAllocType (pctxt, MetaDataType);

         if (pvalue->u.metaCommand == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MetaDataType (pvalue->u.metaCommand);
         stat = asn1D_MetaDataType (pctxt, 
            pvalue->u.metaCommand, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.missionScript = rtxMemAllocType (pctxt, StringElementType);

         if (pvalue->u.missionScript == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_StringElementType (pvalue->u.missionScript);
         stat = asn1D_StringElementType (pctxt, 
            pvalue->u.missionScript, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.missionScriptInline
             = rtxMemAllocType (pctxt, StringElementType);

         if (pvalue->u.missionScriptInline == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_StringElementType (pvalue->u.missionScriptInline);
         stat = asn1D_StringElementType (pctxt, 
            pvalue->u.missionScriptInline, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.quit = rtxMemAllocType (pctxt, QuitCommandType);

         if (pvalue->u.quit == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_QuitCommandType (pvalue->u.quit);
         stat = asn1D_QuitCommandType (pctxt, 
            pvalue->u.quit, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.realtime
             = rtxMemAllocType (pctxt, BooleanElementType_derivations);

         if (pvalue->u.realtime == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_BooleanElementType_derivations (pvalue->u.realtime);
         stat = asn1D_BooleanElementType_derivations (pctxt, 
            pvalue->u.realtime, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.sendMessage
             = rtxMemAllocType (pctxt, SendMessageCommandType);

         if (pvalue->u.sendMessage == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SendMessageCommandType (pvalue->u.sendMessage);
         stat = asn1D_SendMessageCommandType (pctxt, 
            pvalue->u.sendMessage, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.setPosition
             = rtxMemAllocType (pctxt, UsvPositionCommandType);

         if (pvalue->u.setPosition == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UsvPositionCommandType (pvalue->u.setPosition);
         stat = asn1D_UsvPositionCommandType (pctxt, 
            pvalue->u.setPosition, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.setPower
             = rtxMemAllocType (pctxt, SetPropellerCommandType);

         if (pvalue->u.setPower == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SetPropellerCommandType (pvalue->u.setPower);
         stat = asn1D_SetPropellerCommandType (pctxt, 
            pvalue->u.setPower, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.setRudder
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.setRudder == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.setRudder);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.setRudder, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.setStandoff
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.setStandoff == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.setStandoff);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.setStandoff, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.setTime = rtxMemAllocType (pctxt, ScalarElementType);

         if (pvalue->u.setTime == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ScalarElementType (pvalue->u.setTime);
         stat = asn1D_ScalarElementType (pctxt, 
            pvalue->u.setTime, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      case (TM_CTXT|TM_CONS|17):
         pvalue->u.setTimeStep
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.setTimeStep == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.setTimeStep);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.setTimeStep, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 18;
         break;

      case (TM_CTXT|TM_CONS|18):
         pvalue->u.trace
             = rtxMemAllocType (pctxt, BooleanElementType_derivations);

         if (pvalue->u.trace == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_BooleanElementType_derivations (pvalue->u.trace);
         stat = asn1D_BooleanElementType_derivations (pctxt, 
            pvalue->u.trace, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 19;
         break;

      case (TM_CTXT|TM_CONS|19):
         pvalue->u.wait
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.wait == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.wait);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.wait, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 20;
         break;

      case (TM_CTXT|TM_CONS|20):
         pvalue->u.waitUntilTime
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.waitUntilTime == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.waitUntilTime);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.waitUntilTime, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 21;
         break;

      case (TM_CTXT|TM_CONS|21):
         pvalue->u.waypoint = rtxMemAllocType (pctxt, UsvWaypointCommandType);

         if (pvalue->u.waypoint == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UsvWaypointCommandType (pvalue->u.waypoint);
         stat = asn1D_UsvWaypointCommandType (pctxt, 
            pvalue->u.waypoint, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 22;
         break;

      case (TM_CTXT|TM_CONS|22):
         pvalue->u.aVCLMessage = rtxMemAllocType (pctxt, AvclMessageType);

         if (pvalue->u.aVCLMessage == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AvclMessageType ((AvclMessageType*)pvalue->u.aVCLMessage);
         stat = asn1D_AvclMessageType (pctxt, 
            (AvclMessageType*)pvalue->u.aVCLMessage, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 23;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_UsvLoggableEventType_element (OSCTXT* pctxt, 
   UsvLoggableEventType_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("CompositeWaypoint"), 17}, 0}, 0 },
      {{{OSUTF8("Help"), 4}, 0}, 1 },
      {{{OSUTF8("Loiter"), 6}, 0}, 2 },
      {{{OSUTF8("MakeHeading"), 11}, 0}, 3 },
      {{{OSUTF8("MakeKnots"), 9}, 0}, 4 },
      {{{OSUTF8("MakeSpeed"), 9}, 0}, 5 },
      {{{OSUTF8("MetaCommand"), 11}, 0}, 6 },
      {{{OSUTF8("MissionScript"), 13}, 0}, 7 },
      {{{OSUTF8("MissionScriptInline"), 19}, 0}, 8 },
      {{{OSUTF8("Quit"), 4}, 0}, 9 },
      {{{OSUTF8("Realtime"), 8}, 0}, 10 },
      {{{OSUTF8("SendMessage"), 11}, 0}, 11 },
      {{{OSUTF8("SetPosition"), 11}, 0}, 12 },
      {{{OSUTF8("SetPower"), 8}, 0}, 13 },
      {{{OSUTF8("SetRudder"), 9}, 0}, 14 },
      {{{OSUTF8("SetStandoff"), 11}, 0}, 15 },
      {{{OSUTF8("SetTime"), 7}, 0}, 16 },
      {{{OSUTF8("SetTimeStep"), 11}, 0}, 17 },
      {{{OSUTF8("Trace"), 5}, 0}, 18 },
      {{{OSUTF8("Wait"), 4}, 0}, 19 },
      {{{OSUTF8("WaitUntilTime"), 13}, 0}, 20 },
      {{{OSUTF8("Waypoint"), 8}, 0}, 21 },
      {{{OSUTF8("AVCLMessage"), 11}, 0}, 22 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 23, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* CompositeWaypoint */
      pvalue->u.compositeWaypoint
          = rtxMemAllocType (pctxt, UsvCompositeWaypointCommandType);

      if (pvalue->u.compositeWaypoint == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UsvCompositeWaypointCommandType (pvalue->u.compositeWaypoint);

      stat = XmlDec_UsvCompositeWaypointCommandType (pctxt, pvalue->
         u.compositeWaypoint);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* Help */
      pvalue->u.help = rtxMemAllocType (pctxt, NoValueElementType);

      if (pvalue->u.help == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NoValueElementType (pvalue->u.help);

      stat = XmlDec_NoValueElementType (pctxt, pvalue->u.help);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* Loiter */
      pvalue->u.loiter = rtxMemAllocType (pctxt, UsvLoiterCommandType);

      if (pvalue->u.loiter == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UsvLoiterCommandType (pvalue->u.loiter);

      stat = XmlDec_UsvLoiterCommandType (pctxt, pvalue->u.loiter);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* MakeHeading */
      pvalue->u.makeHeading = rtxMemAllocType (pctxt, HeadingElementType);

      if (pvalue->u.makeHeading == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HeadingElementType (pvalue->u.makeHeading);

      stat = XmlDec_HeadingElementType (pctxt, pvalue->u.makeHeading);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* MakeKnots */
      pvalue->u.makeKnots = rtxMemAllocType (pctxt, SpeedElementType);

      if (pvalue->u.makeKnots == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SpeedElementType (pvalue->u.makeKnots);

      stat = XmlDec_SpeedElementType (pctxt, pvalue->u.makeKnots);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* MakeSpeed */
      pvalue->u.makeSpeed = rtxMemAllocType (pctxt, SpeedElementType);

      if (pvalue->u.makeSpeed == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SpeedElementType (pvalue->u.makeSpeed);

      stat = XmlDec_SpeedElementType (pctxt, pvalue->u.makeSpeed);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* MetaCommand */
      pvalue->u.metaCommand = rtxMemAllocType (pctxt, MetaDataType);

      if (pvalue->u.metaCommand == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MetaDataType (pvalue->u.metaCommand);

      stat = XmlDec_MetaDataType (pctxt, pvalue->u.metaCommand);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* MissionScript */
      pvalue->u.missionScript = rtxMemAllocType (pctxt, StringElementType);

      if (pvalue->u.missionScript == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_StringElementType (pvalue->u.missionScript);

      stat = XmlDec_StringElementType (pctxt, pvalue->u.missionScript);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* MissionScriptInline */
      pvalue->u.missionScriptInline
          = rtxMemAllocType (pctxt, StringElementType);

      if (pvalue->u.missionScriptInline == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_StringElementType (pvalue->u.missionScriptInline);

      stat = XmlDec_StringElementType (pctxt, pvalue->u.missionScriptInline);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* Quit */
      pvalue->u.quit = rtxMemAllocType (pctxt, QuitCommandType);

      if (pvalue->u.quit == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QuitCommandType (pvalue->u.quit);

      stat = XmlDec_QuitCommandType (pctxt, pvalue->u.quit);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* Realtime */
      pvalue->u.realtime
          = rtxMemAllocType (pctxt, BooleanElementType_derivations);

      if (pvalue->u.realtime == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BooleanElementType_derivations (pvalue->u.realtime);

      stat = XmlDec_BooleanElementType_derivations (pctxt, pvalue->u.realtime
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* SendMessage */
      pvalue->u.sendMessage = rtxMemAllocType (pctxt, SendMessageCommandType);

      if (pvalue->u.sendMessage == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SendMessageCommandType (pvalue->u.sendMessage);

      stat = XmlDec_SendMessageCommandType (pctxt, pvalue->u.sendMessage);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* SetPosition */
      pvalue->u.setPosition = rtxMemAllocType (pctxt, UsvPositionCommandType);

      if (pvalue->u.setPosition == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UsvPositionCommandType (pvalue->u.setPosition);

      stat = XmlDec_UsvPositionCommandType (pctxt, pvalue->u.setPosition);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* SetPower */
      pvalue->u.setPower = rtxMemAllocType (pctxt, SetPropellerCommandType);

      if (pvalue->u.setPower == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SetPropellerCommandType (pvalue->u.setPower);

      stat = XmlDec_SetPropellerCommandType (pctxt, pvalue->u.setPower);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* SetRudder */
      pvalue->u.setRudder = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.setRudder == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.setRudder);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->u.setRudder);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* SetStandoff */
      pvalue->u.setStandoff
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.setStandoff == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.setStandoff);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.setStandoff);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* SetTime */
      pvalue->u.setTime = rtxMemAllocType (pctxt, ScalarElementType);

      if (pvalue->u.setTime == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ScalarElementType (pvalue->u.setTime);

      stat = XmlDec_ScalarElementType (pctxt, pvalue->u.setTime);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 17: { /* SetTimeStep */
      pvalue->u.setTimeStep
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.setTimeStep == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.setTimeStep);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.setTimeStep);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 18: { /* Trace */
      pvalue->u.trace
          = rtxMemAllocType (pctxt, BooleanElementType_derivations);

      if (pvalue->u.trace == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BooleanElementType_derivations (pvalue->u.trace);

      stat = XmlDec_BooleanElementType_derivations (pctxt, pvalue->u.trace);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 19: { /* Wait */
      pvalue->u.wait
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.wait == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.wait);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.wait);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 20: { /* WaitUntilTime */
      pvalue->u.waitUntilTime
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.waitUntilTime == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.waitUntilTime
         );

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.waitUntilTime);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 21: { /* Waypoint */
      pvalue->u.waypoint = rtxMemAllocType (pctxt, UsvWaypointCommandType);

      if (pvalue->u.waypoint == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UsvWaypointCommandType (pvalue->u.waypoint);

      stat = XmlDec_UsvWaypointCommandType (pctxt, pvalue->u.waypoint);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 22: { /* AVCLMessage */
      pvalue->u.aVCLMessage = rtxMemAllocType (pctxt, AvclMessageType);

      if (pvalue->u.aVCLMessage == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AvclMessageType ((AvclMessageType*)pvalue->u.aVCLMessage);

      stat = XmlDec_AvclMessageType (pctxt, pvalue->u.aVCLMessage);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UsvLoggableEventType                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UsvLoggableEventType (OSCTXT* pctxt, 
   UsvLoggableEventType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               UsvLoggableEventType_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, UsvLoggableEventType_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_UsvLoggableEventType_element (pdata2);

                  stat = asn1D_UsvLoggableEventType_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

               if (!(pvalue->choice_list.count >= 1U)) {
                  rtxErrAddStrParm (pctxt, "UsvLoggableEventType.choice_list.count");
                  rtxErrAddIntParm (pctxt, (int)pvalue->choice_list.count);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UsvLoggableEventType (OSCTXT* pctxt, UsvLoggableEventType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UsvLoggableEventType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UsvLoggableEventType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("CompositeWaypoint"), 17}, 0}, 0 },
      {{{OSUTF8("Help"), 4}, 0}, 0 },
      {{{OSUTF8("Loiter"), 6}, 0}, 0 },
      {{{OSUTF8("MakeHeading"), 11}, 0}, 0 },
      {{{OSUTF8("MakeKnots"), 9}, 0}, 0 },
      {{{OSUTF8("MakeSpeed"), 9}, 0}, 0 },
      {{{OSUTF8("MetaCommand"), 11}, 0}, 0 },
      {{{OSUTF8("MissionScript"), 13}, 0}, 0 },
      {{{OSUTF8("MissionScriptInline"), 19}, 0}, 0 },
      {{{OSUTF8("Quit"), 4}, 0}, 0 },
      {{{OSUTF8("Realtime"), 8}, 0}, 0 },
      {{{OSUTF8("SendMessage"), 11}, 0}, 0 },
      {{{OSUTF8("SetPosition"), 11}, 0}, 0 },
      {{{OSUTF8("SetPower"), 8}, 0}, 0 },
      {{{OSUTF8("SetRudder"), 9}, 0}, 0 },
      {{{OSUTF8("SetStandoff"), 11}, 0}, 0 },
      {{{OSUTF8("SetTime"), 7}, 0}, 0 },
      {{{OSUTF8("SetTimeStep"), 11}, 0}, 0 },
      {{{OSUTF8("Trace"), 5}, 0}, 0 },
      {{{OSUTF8("Wait"), 4}, 0}, 0 },
      {{{OSUTF8("WaitUntilTime"), 13}, 0}, 0 },
      {{{OSUTF8("Waypoint"), 8}, 0}, 0 },
      {{{OSUTF8("AVCLMessage"), 11}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 23, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         UsvLoggableEventType_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, UsvLoggableEventType_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UsvLoggableEventType_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_UsvLoggableEventType_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 23, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UavLoggableEventType_element                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UavLoggableEventType_element (OSCTXT* pctxt, 
   UavLoggableEventType_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.compositeWaypoint
             = rtxMemAllocType (pctxt, UavCompositeWaypointCommandType);

         if (pvalue->u.compositeWaypoint == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UavCompositeWaypointCommandType (pvalue->u.compositeWaypoint);
         stat = asn1D_UavCompositeWaypointCommandType (pctxt, 
            pvalue->u.compositeWaypoint, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.help = rtxMemAllocType (pctxt, NoValueElementType);

         if (pvalue->u.help == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_NoValueElementType (pvalue->u.help);
         stat = asn1D_NoValueElementType (pctxt, 
            pvalue->u.help, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.loiter = rtxMemAllocType (pctxt, UavLoiterCommandType);

         if (pvalue->u.loiter == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UavLoiterCommandType (pvalue->u.loiter);
         stat = asn1D_UavLoiterCommandType (pctxt, 
            pvalue->u.loiter, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.makeAltitudeAGL
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.makeAltitudeAGL == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeAltitudeAGL);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.makeAltitudeAGL, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.makeAltitudeMSL
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.makeAltitudeMSL == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeAltitudeMSL);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.makeAltitudeMSL, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.makeClimbRate
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.makeClimbRate == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.makeClimbRate);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.makeClimbRate, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.makeHeading = rtxMemAllocType (pctxt, HeadingElementType);

         if (pvalue->u.makeHeading == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_HeadingElementType (pvalue->u.makeHeading);
         stat = asn1D_HeadingElementType (pctxt, 
            pvalue->u.makeHeading, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.makeKnots = rtxMemAllocType (pctxt, SpeedElementType);

         if (pvalue->u.makeKnots == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SpeedElementType (pvalue->u.makeKnots);
         stat = asn1D_SpeedElementType (pctxt, 
            pvalue->u.makeKnots, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.makeSpeed = rtxMemAllocType (pctxt, SpeedElementType);

         if (pvalue->u.makeSpeed == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SpeedElementType (pvalue->u.makeSpeed);
         stat = asn1D_SpeedElementType (pctxt, 
            pvalue->u.makeSpeed, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.makeTurnRate
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.makeTurnRate == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.makeTurnRate);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.makeTurnRate, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.metaCommand = rtxMemAllocType (pctxt, MetaDataType);

         if (pvalue->u.metaCommand == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MetaDataType (pvalue->u.metaCommand);
         stat = asn1D_MetaDataType (pctxt, 
            pvalue->u.metaCommand, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.missionScript = rtxMemAllocType (pctxt, StringElementType);

         if (pvalue->u.missionScript == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_StringElementType (pvalue->u.missionScript);
         stat = asn1D_StringElementType (pctxt, 
            pvalue->u.missionScript, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.missionScriptInline
             = rtxMemAllocType (pctxt, StringElementType);

         if (pvalue->u.missionScriptInline == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_StringElementType (pvalue->u.missionScriptInline);
         stat = asn1D_StringElementType (pctxt, 
            pvalue->u.missionScriptInline, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.quit = rtxMemAllocType (pctxt, QuitCommandType);

         if (pvalue->u.quit == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_QuitCommandType (pvalue->u.quit);
         stat = asn1D_QuitCommandType (pctxt, 
            pvalue->u.quit, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.realtime
             = rtxMemAllocType (pctxt, BooleanElementType_derivations);

         if (pvalue->u.realtime == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_BooleanElementType_derivations (pvalue->u.realtime);
         stat = asn1D_BooleanElementType_derivations (pctxt, 
            pvalue->u.realtime, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.sendMessage
             = rtxMemAllocType (pctxt, SendMessageCommandType);

         if (pvalue->u.sendMessage == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SendMessageCommandType (pvalue->u.sendMessage);
         stat = asn1D_SendMessageCommandType (pctxt, 
            pvalue->u.sendMessage, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.setAileron
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.setAileron == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.setAileron);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.setAileron, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      case (TM_CTXT|TM_CONS|17):
         pvalue->u.setElevator
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.setElevator == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.setElevator);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.setElevator, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 18;
         break;

      case (TM_CTXT|TM_CONS|18):
         pvalue->u.setPosition
             = rtxMemAllocType (pctxt, UavPositionCommandType);

         if (pvalue->u.setPosition == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UavPositionCommandType (pvalue->u.setPosition);
         stat = asn1D_UavPositionCommandType (pctxt, 
            pvalue->u.setPosition, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 19;
         break;

      case (TM_CTXT|TM_CONS|19):
         pvalue->u.setPower = rtxMemAllocType (pctxt, PercentElementType);

         if (pvalue->u.setPower == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PercentElementType (pvalue->u.setPower);
         stat = asn1D_PercentElementType (pctxt, 
            pvalue->u.setPower, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 20;
         break;

      case (TM_CTXT|TM_CONS|20):
         pvalue->u.setRudder
             = rtxMemAllocType (pctxt, SignedPercentElementType);

         if (pvalue->u.setRudder == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignedPercentElementType (pvalue->u.setRudder);
         stat = asn1D_SignedPercentElementType (pctxt, 
            pvalue->u.setRudder, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 21;
         break;

      case (TM_CTXT|TM_CONS|21):
         pvalue->u.setStandoff
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.setStandoff == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.setStandoff);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.setStandoff, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 22;
         break;

      case (TM_CTXT|TM_CONS|22):
         pvalue->u.setTime = rtxMemAllocType (pctxt, ScalarElementType);

         if (pvalue->u.setTime == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ScalarElementType (pvalue->u.setTime);
         stat = asn1D_ScalarElementType (pctxt, 
            pvalue->u.setTime, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 23;
         break;

      case (TM_CTXT|TM_CONS|23):
         pvalue->u.setTimeStep
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.setTimeStep == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.setTimeStep);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.setTimeStep, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 24;
         break;

      case (TM_CTXT|TM_CONS|24):
         pvalue->u.trace
             = rtxMemAllocType (pctxt, BooleanElementType_derivations);

         if (pvalue->u.trace == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_BooleanElementType_derivations (pvalue->u.trace);
         stat = asn1D_BooleanElementType_derivations (pctxt, 
            pvalue->u.trace, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 25;
         break;

      case (TM_CTXT|TM_CONS|25):
         pvalue->u.wait
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.wait == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.wait);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.wait, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 26;
         break;

      case (TM_CTXT|TM_CONS|26):
         pvalue->u.waitUntilTime
             = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

         if (pvalue->u.waitUntilTime == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PositiveScalarElementType_derivations (pvalue->u.waitUntilTime);
         stat = asn1D_PositiveScalarElementType_derivations (pctxt, 
            pvalue->u.waitUntilTime, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 27;
         break;

      case (TM_CTXT|TM_CONS|27):
         pvalue->u.waypoint = rtxMemAllocType (pctxt, UavWaypointCommandType);

         if (pvalue->u.waypoint == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UavWaypointCommandType (pvalue->u.waypoint);
         stat = asn1D_UavWaypointCommandType (pctxt, 
            pvalue->u.waypoint, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 28;
         break;

      case (TM_CTXT|TM_CONS|28):
         pvalue->u.aVCLMessage = rtxMemAllocType (pctxt, AvclMessageType);

         if (pvalue->u.aVCLMessage == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AvclMessageType ((AvclMessageType*)pvalue->u.aVCLMessage);
         stat = asn1D_AvclMessageType (pctxt, 
            (AvclMessageType*)pvalue->u.aVCLMessage, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 29;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_UavLoggableEventType_element (OSCTXT* pctxt, 
   UavLoggableEventType_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("CompositeWaypoint"), 17}, 0}, 0 },
      {{{OSUTF8("Help"), 4}, 0}, 1 },
      {{{OSUTF8("Loiter"), 6}, 0}, 2 },
      {{{OSUTF8("MakeAltitudeAGL"), 15}, 0}, 3 },
      {{{OSUTF8("MakeAltitudeMSL"), 15}, 0}, 4 },
      {{{OSUTF8("MakeClimbRate"), 13}, 0}, 5 },
      {{{OSUTF8("MakeHeading"), 11}, 0}, 6 },
      {{{OSUTF8("MakeKnots"), 9}, 0}, 7 },
      {{{OSUTF8("MakeSpeed"), 9}, 0}, 8 },
      {{{OSUTF8("MakeTurnRate"), 12}, 0}, 9 },
      {{{OSUTF8("MetaCommand"), 11}, 0}, 10 },
      {{{OSUTF8("MissionScript"), 13}, 0}, 11 },
      {{{OSUTF8("MissionScriptInline"), 19}, 0}, 12 },
      {{{OSUTF8("Quit"), 4}, 0}, 13 },
      {{{OSUTF8("Realtime"), 8}, 0}, 14 },
      {{{OSUTF8("SendMessage"), 11}, 0}, 15 },
      {{{OSUTF8("SetAileron"), 10}, 0}, 16 },
      {{{OSUTF8("SetElevator"), 11}, 0}, 17 },
      {{{OSUTF8("SetPosition"), 11}, 0}, 18 },
      {{{OSUTF8("SetPower"), 8}, 0}, 19 },
      {{{OSUTF8("SetRudder"), 9}, 0}, 20 },
      {{{OSUTF8("SetStandoff"), 11}, 0}, 21 },
      {{{OSUTF8("SetTime"), 7}, 0}, 22 },
      {{{OSUTF8("SetTimeStep"), 11}, 0}, 23 },
      {{{OSUTF8("Trace"), 5}, 0}, 24 },
      {{{OSUTF8("Wait"), 4}, 0}, 25 },
      {{{OSUTF8("WaitUntilTime"), 13}, 0}, 26 },
      {{{OSUTF8("Waypoint"), 8}, 0}, 27 },
      {{{OSUTF8("AVCLMessage"), 11}, 0}, 28 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 29, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* CompositeWaypoint */
      pvalue->u.compositeWaypoint
          = rtxMemAllocType (pctxt, UavCompositeWaypointCommandType);

      if (pvalue->u.compositeWaypoint == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UavCompositeWaypointCommandType (pvalue->u.compositeWaypoint);

      stat = XmlDec_UavCompositeWaypointCommandType (pctxt, pvalue->
         u.compositeWaypoint);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* Help */
      pvalue->u.help = rtxMemAllocType (pctxt, NoValueElementType);

      if (pvalue->u.help == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NoValueElementType (pvalue->u.help);

      stat = XmlDec_NoValueElementType (pctxt, pvalue->u.help);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* Loiter */
      pvalue->u.loiter = rtxMemAllocType (pctxt, UavLoiterCommandType);

      if (pvalue->u.loiter == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UavLoiterCommandType (pvalue->u.loiter);

      stat = XmlDec_UavLoiterCommandType (pctxt, pvalue->u.loiter);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* MakeAltitudeAGL */
      pvalue->u.makeAltitudeAGL
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.makeAltitudeAGL == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeAltitudeAGL
         );

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.makeAltitudeAGL);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* MakeAltitudeMSL */
      pvalue->u.makeAltitudeMSL
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.makeAltitudeMSL == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.makeAltitudeMSL
         );

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.makeAltitudeMSL);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* MakeClimbRate */
      pvalue->u.makeClimbRate
          = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.makeClimbRate == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.makeClimbRate);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->u.makeClimbRate);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* MakeHeading */
      pvalue->u.makeHeading = rtxMemAllocType (pctxt, HeadingElementType);

      if (pvalue->u.makeHeading == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HeadingElementType (pvalue->u.makeHeading);

      stat = XmlDec_HeadingElementType (pctxt, pvalue->u.makeHeading);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* MakeKnots */
      pvalue->u.makeKnots = rtxMemAllocType (pctxt, SpeedElementType);

      if (pvalue->u.makeKnots == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SpeedElementType (pvalue->u.makeKnots);

      stat = XmlDec_SpeedElementType (pctxt, pvalue->u.makeKnots);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* MakeSpeed */
      pvalue->u.makeSpeed = rtxMemAllocType (pctxt, SpeedElementType);

      if (pvalue->u.makeSpeed == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SpeedElementType (pvalue->u.makeSpeed);

      stat = XmlDec_SpeedElementType (pctxt, pvalue->u.makeSpeed);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* MakeTurnRate */
      pvalue->u.makeTurnRate
          = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.makeTurnRate == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.makeTurnRate);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->u.makeTurnRate);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* MetaCommand */
      pvalue->u.metaCommand = rtxMemAllocType (pctxt, MetaDataType);

      if (pvalue->u.metaCommand == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MetaDataType (pvalue->u.metaCommand);

      stat = XmlDec_MetaDataType (pctxt, pvalue->u.metaCommand);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* MissionScript */
      pvalue->u.missionScript = rtxMemAllocType (pctxt, StringElementType);

      if (pvalue->u.missionScript == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_StringElementType (pvalue->u.missionScript);

      stat = XmlDec_StringElementType (pctxt, pvalue->u.missionScript);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* MissionScriptInline */
      pvalue->u.missionScriptInline
          = rtxMemAllocType (pctxt, StringElementType);

      if (pvalue->u.missionScriptInline == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_StringElementType (pvalue->u.missionScriptInline);

      stat = XmlDec_StringElementType (pctxt, pvalue->u.missionScriptInline);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* Quit */
      pvalue->u.quit = rtxMemAllocType (pctxt, QuitCommandType);

      if (pvalue->u.quit == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QuitCommandType (pvalue->u.quit);

      stat = XmlDec_QuitCommandType (pctxt, pvalue->u.quit);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* Realtime */
      pvalue->u.realtime
          = rtxMemAllocType (pctxt, BooleanElementType_derivations);

      if (pvalue->u.realtime == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BooleanElementType_derivations (pvalue->u.realtime);

      stat = XmlDec_BooleanElementType_derivations (pctxt, pvalue->u.realtime
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* SendMessage */
      pvalue->u.sendMessage = rtxMemAllocType (pctxt, SendMessageCommandType);

      if (pvalue->u.sendMessage == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SendMessageCommandType (pvalue->u.sendMessage);

      stat = XmlDec_SendMessageCommandType (pctxt, pvalue->u.sendMessage);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* SetAileron */
      pvalue->u.setAileron
          = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.setAileron == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.setAileron);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->u.setAileron);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 17: { /* SetElevator */
      pvalue->u.setElevator
          = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.setElevator == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.setElevator);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->u.setElevator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 18: { /* SetPosition */
      pvalue->u.setPosition = rtxMemAllocType (pctxt, UavPositionCommandType);

      if (pvalue->u.setPosition == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UavPositionCommandType (pvalue->u.setPosition);

      stat = XmlDec_UavPositionCommandType (pctxt, pvalue->u.setPosition);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 19: { /* SetPower */
      pvalue->u.setPower = rtxMemAllocType (pctxt, PercentElementType);

      if (pvalue->u.setPower == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PercentElementType (pvalue->u.setPower);

      stat = XmlDec_PercentElementType (pctxt, pvalue->u.setPower);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 20: { /* SetRudder */
      pvalue->u.setRudder = rtxMemAllocType (pctxt, SignedPercentElementType);

      if (pvalue->u.setRudder == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SignedPercentElementType (pvalue->u.setRudder);

      stat = XmlDec_SignedPercentElementType (pctxt, pvalue->u.setRudder);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 21: { /* SetStandoff */
      pvalue->u.setStandoff
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.setStandoff == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.setStandoff);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.setStandoff);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 22: { /* SetTime */
      pvalue->u.setTime = rtxMemAllocType (pctxt, ScalarElementType);

      if (pvalue->u.setTime == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ScalarElementType (pvalue->u.setTime);

      stat = XmlDec_ScalarElementType (pctxt, pvalue->u.setTime);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 23: { /* SetTimeStep */
      pvalue->u.setTimeStep
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.setTimeStep == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.setTimeStep);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.setTimeStep);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 24: { /* Trace */
      pvalue->u.trace
          = rtxMemAllocType (pctxt, BooleanElementType_derivations);

      if (pvalue->u.trace == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BooleanElementType_derivations (pvalue->u.trace);

      stat = XmlDec_BooleanElementType_derivations (pctxt, pvalue->u.trace);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 25: { /* Wait */
      pvalue->u.wait
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.wait == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.wait);

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.wait);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 26: { /* WaitUntilTime */
      pvalue->u.waitUntilTime
          = rtxMemAllocType (pctxt, PositiveScalarElementType_derivations);

      if (pvalue->u.waitUntilTime == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PositiveScalarElementType_derivations (pvalue->u.waitUntilTime
         );

      stat = XmlDec_PositiveScalarElementType_derivations (pctxt, pvalue->
         u.waitUntilTime);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 27: { /* Waypoint */
      pvalue->u.waypoint = rtxMemAllocType (pctxt, UavWaypointCommandType);

      if (pvalue->u.waypoint == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UavWaypointCommandType (pvalue->u.waypoint);

      stat = XmlDec_UavWaypointCommandType (pctxt, pvalue->u.waypoint);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 28: { /* AVCLMessage */
      pvalue->u.aVCLMessage = rtxMemAllocType (pctxt, AvclMessageType);

      if (pvalue->u.aVCLMessage == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AvclMessageType ((AvclMessageType*)pvalue->u.aVCLMessage);

      stat = XmlDec_AvclMessageType (pctxt, pvalue->u.aVCLMessage);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UavLoggableEventType                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UavLoggableEventType (OSCTXT* pctxt, 
   UavLoggableEventType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               UavLoggableEventType_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, UavLoggableEventType_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_UavLoggableEventType_element (pdata2);

                  stat = asn1D_UavLoggableEventType_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

               if (!(pvalue->choice_list.count >= 1U)) {
                  rtxErrAddStrParm (pctxt, "UavLoggableEventType.choice_list.count");
                  rtxErrAddIntParm (pctxt, (int)pvalue->choice_list.count);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UavLoggableEventType (OSCTXT* pctxt, UavLoggableEventType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UavLoggableEventType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UavLoggableEventType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("CompositeWaypoint"), 17}, 0}, 0 },
      {{{OSUTF8("Help"), 4}, 0}, 0 },
      {{{OSUTF8("Loiter"), 6}, 0}, 0 },
      {{{OSUTF8("MakeAltitudeAGL"), 15}, 0}, 0 },
      {{{OSUTF8("MakeAltitudeMSL"), 15}, 0}, 0 },
      {{{OSUTF8("MakeClimbRate"), 13}, 0}, 0 },
      {{{OSUTF8("MakeHeading"), 11}, 0}, 0 },
      {{{OSUTF8("MakeKnots"), 9}, 0}, 0 },
      {{{OSUTF8("MakeSpeed"), 9}, 0}, 0 },
      {{{OSUTF8("MakeTurnRate"), 12}, 0}, 0 },
      {{{OSUTF8("MetaCommand"), 11}, 0}, 0 },
      {{{OSUTF8("MissionScript"), 13}, 0}, 0 },
      {{{OSUTF8("MissionScriptInline"), 19}, 0}, 0 },
      {{{OSUTF8("Quit"), 4}, 0}, 0 },
      {{{OSUTF8("Realtime"), 8}, 0}, 0 },
      {{{OSUTF8("SendMessage"), 11}, 0}, 0 },
      {{{OSUTF8("SetAileron"), 10}, 0}, 0 },
      {{{OSUTF8("SetElevator"), 11}, 0}, 0 },
      {{{OSUTF8("SetPosition"), 11}, 0}, 0 },
      {{{OSUTF8("SetPower"), 8}, 0}, 0 },
      {{{OSUTF8("SetRudder"), 9}, 0}, 0 },
      {{{OSUTF8("SetStandoff"), 11}, 0}, 0 },
      {{{OSUTF8("SetTime"), 7}, 0}, 0 },
      {{{OSUTF8("SetTimeStep"), 11}, 0}, 0 },
      {{{OSUTF8("Trace"), 5}, 0}, 0 },
      {{{OSUTF8("Wait"), 4}, 0}, 0 },
      {{{OSUTF8("WaitUntilTime"), 13}, 0}, 0 },
      {{{OSUTF8("Waypoint"), 8}, 0}, 0 },
      {{{OSUTF8("AVCLMessage"), 11}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 29, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         UavLoggableEventType_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, UavLoggableEventType_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UavLoggableEventType_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_UavLoggableEventType_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 29, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LoggableEvent                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_LoggableEvent (OSCTXT* pctxt, LoggableEvent *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.uUVEvent = rtxMemAllocType (pctxt, UuvLoggableEventType);

         if (pvalue->u.uUVEvent == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UuvLoggableEventType (pvalue->u.uUVEvent);
         stat = asn1D_UuvLoggableEventType (pctxt, 
            pvalue->u.uUVEvent, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.uGVEvent = rtxMemAllocType (pctxt, UgvLoggableEventType);

         if (pvalue->u.uGVEvent == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UgvLoggableEventType (pvalue->u.uGVEvent);
         stat = asn1D_UgvLoggableEventType (pctxt, 
            pvalue->u.uGVEvent, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.uSVEvent = rtxMemAllocType (pctxt, UsvLoggableEventType);

         if (pvalue->u.uSVEvent == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UsvLoggableEventType (pvalue->u.uSVEvent);
         stat = asn1D_UsvLoggableEventType (pctxt, 
            pvalue->u.uSVEvent, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.uAVEvent = rtxMemAllocType (pctxt, UavLoggableEventType);

         if (pvalue->u.uAVEvent == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UavLoggableEventType (pvalue->u.uAVEvent);
         stat = asn1D_UavLoggableEventType (pctxt, 
            pvalue->u.uAVEvent, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_LoggableEvent (OSCTXT* pctxt, LoggableEvent* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("UUVEvent"), 8}, 0}, 0 },
      {{{OSUTF8("UGVEvent"), 8}, 0}, 1 },
      {{{OSUTF8("USVEvent"), 8}, 0}, 2 },
      {{{OSUTF8("UAVEvent"), 8}, 0}, 3 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 4, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* UUVEvent */
      pvalue->u.uUVEvent = rtxMemAllocType (pctxt, UuvLoggableEventType);

      if (pvalue->u.uUVEvent == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UuvLoggableEventType (pvalue->u.uUVEvent);

      stat = XmlDec_UuvLoggableEventType (pctxt, pvalue->u.uUVEvent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* UGVEvent */
      pvalue->u.uGVEvent = rtxMemAllocType (pctxt, UgvLoggableEventType);

      if (pvalue->u.uGVEvent == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UgvLoggableEventType (pvalue->u.uGVEvent);

      stat = XmlDec_UgvLoggableEventType (pctxt, pvalue->u.uGVEvent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* USVEvent */
      pvalue->u.uSVEvent = rtxMemAllocType (pctxt, UsvLoggableEventType);

      if (pvalue->u.uSVEvent == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UsvLoggableEventType (pvalue->u.uSVEvent);

      stat = XmlDec_UsvLoggableEventType (pctxt, pvalue->u.uSVEvent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* UAVEvent */
      pvalue->u.uAVEvent = rtxMemAllocType (pctxt, UavLoggableEventType);

      if (pvalue->u.uAVEvent == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UavLoggableEventType (pvalue->u.uAVEvent);

      stat = XmlDec_UavLoggableEventType (pctxt, pvalue->u.uAVEvent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MessageBodyContent_sensorDataReport                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_MessageBodyContent_sensorDataReport (OSCTXT* pctxt, 
   MessageBodyContent_sensorDataReport *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.choice_list = rtxMemAllocType (pctxt, OSRTDList);

         if (pvalue->u.choice_list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         rtxDListFastInit (pvalue->u.choice_list);
         /* decode inline SEQUENCE OF type */
         {
            int stat = 0;
            SensorElements* pdata2;
            OSRTDListNode* pnode;
            ASN1CCB ccb;

            /* decode SEQUENCE OF or SET OF */

            rtxDListInit (pvalue->u.choice_list);

            ccb.len = length;
            ccb.ptr = OSRTBUFPTR(pctxt);

            while (!XD_CHKEND (pctxt, &ccb))
            {
               rtxDListAllocNodeAndData (pctxt, SensorElements, &pnode, &pdata2);

               if (pnode == NULL)
                  return LOG_RTERR (pctxt, RTERR_NOMEM);

               asn1Init_SensorElements (pdata2);

               stat = asn1D_SensorElements (pctxt, 
                  pdata2, ASN1EXPL, length);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               rtxDListAppendNode (pvalue->u.choice_list, pnode);
            }

            if (!(pvalue->u.choice_list->count >= 1U)) {
               rtxErrAddStrParm (pctxt, "MessageBodyContent_sensorDataReport.u.choice_list.count");
               rtxErrAddIntParm (pctxt, (int)pvalue->u.choice_list->count);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

         }
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_MessageBodyContent_sensorDataReport (OSCTXT* pctxt, 
   MessageBodyContent_sensorDataReport* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("ActiveSonar"), 11}, 0}, 0 },
      {{{OSUTF8("ImagingSonar"), 12}, 0}, 0 },
      {{{OSUTF8("BlazedArraySonar"), 16}, 0}, 0 },
      {{{OSUTF8("SyntheticApertureSonar"), 22}, 0}, 0 },
      {{{OSUTF8("PassiveSonar"), 12}, 0}, 0 },
      {{{OSUTF8("Radar"), 5}, 0}, 0 },
      {{{OSUTF8("DopplerRadar"), 12}, 0}, 0 },
      {{{OSUTF8("SyntheticApertureRadar"), 22}, 0}, 0 },
      {{{OSUTF8("TrackWhileScanRadar"), 19}, 0}, 0 },
      {{{OSUTF8("EarlyWarningRadar"), 17}, 0}, 0 },
      {{{OSUTF8("AcquisitionRadar"), 16}, 0}, 0 },
      {{{OSUTF8("TrackingRadar"), 13}, 0}, 0 },
      {{{OSUTF8("FireControlRadar"), 16}, 0}, 0 },
      {{{OSUTF8("SurfaceSearchRadar"), 18}, 0}, 0 },
      {{{OSUTF8("ESM"), 3}, 0}, 0 },
      {{{OSUTF8("PassiveSoundDetection"), 21}, 0}, 0 },
      {{{OSUTF8("ChemicalBiologicalRadiologicalDetection"), 39}, 0}, 0 },
      {{{OSUTF8("Video"), 5}, 0}, 0 },
      {{{OSUTF8("FLIR"), 4}, 0}, 0 },
      {{{OSUTF8("MotionSensor"), 12}, 0}, 0 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 20, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: {
      SensorElements* pdata1;

      pvalue->u.choice_list = rtxMemAllocType (pctxt, OSRTDList);
      rtxDListInit (pvalue->u.choice_list);

      do {
         pdata1 = rtxMemAllocType (pctxt, SensorElements);

         if (pdata1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SensorElements (pdata1);

         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_SensorElements (pctxt, pdata1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, pvalue->u.choice_list, (void*)pdata1);

         stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 20, -1, FALSE);
         if (stat < 0 && stat != RTERR_UNEXPELEM)
            return LOG_RTERR (pctxt, stat);
      }
      while (stat == 0);

      rtXmlpMarkLastEventActive (pctxt);
      stat = 0;
      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MessageBodyContent                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_MessageBodyContent (OSCTXT* pctxt, 
   MessageBodyContent *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.choice = rtxMemAllocType (pctxt, MissionSpecification);

         if (pvalue->u.choice == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MissionSpecification (pvalue->u.choice);
         stat = asn1D_MissionSpecification (pctxt, 
            pvalue->u.choice, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.uUVCommand
             = rtxMemAllocType (pctxt, UuvScriptCommandsType);

         if (pvalue->u.uUVCommand == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UuvScriptCommandsType (pvalue->u.uUVCommand);
         stat = asn1D_UuvScriptCommandsType (pctxt, 
            pvalue->u.uUVCommand, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.uGVCommand
             = rtxMemAllocType (pctxt, UgvScriptCommandsType);

         if (pvalue->u.uGVCommand == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UgvScriptCommandsType (pvalue->u.uGVCommand);
         stat = asn1D_UgvScriptCommandsType (pctxt, 
            pvalue->u.uGVCommand, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.uSVCommand
             = rtxMemAllocType (pctxt, UsvScriptCommandsType);

         if (pvalue->u.uSVCommand == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UsvScriptCommandsType (pvalue->u.uSVCommand);
         stat = asn1D_UsvScriptCommandsType (pctxt, 
            pvalue->u.uSVCommand, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.uAVCommand
             = rtxMemAllocType (pctxt, UavScriptCommandsType);

         if (pvalue->u.uAVCommand == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UavScriptCommandsType (pvalue->u.uAVCommand);
         stat = asn1D_UavScriptCommandsType (pctxt, 
            pvalue->u.uAVCommand, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.informationRequest
             = rtxMemAllocType (pctxt, InformationRequestElementType);

         if (pvalue->u.informationRequest == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_InformationRequestElementType (pvalue->u.informationRequest);
         stat = asn1D_InformationRequestElementType (pctxt, 
            pvalue->u.informationRequest, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.groupMaintenance
             = rtxMemAllocType (pctxt, VehicleGroupCompositionElementType);

         if (pvalue->u.groupMaintenance == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_VehicleGroupCompositionElementType (pvalue->u.groupMaintenance);
         stat = asn1D_VehicleGroupCompositionElementType (pctxt, 
            pvalue->u.groupMaintenance, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.choice_1
             = rtxMemAllocType (pctxt, VehicleCharacteristicsGroup);

         if (pvalue->u.choice_1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_VehicleCharacteristicsGroup (pvalue->u.choice_1);
         stat = asn1D_VehicleCharacteristicsGroup (pctxt, 
            pvalue->u.choice_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.vehicleState
             = rtxMemAllocType (pctxt, DiscreteTimeResultsElementType);

         if (pvalue->u.vehicleState == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_DiscreteTimeResultsElementType (pvalue->u.vehicleState);
         stat = asn1D_DiscreteTimeResultsElementType (pctxt, 
            pvalue->u.vehicleState, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.choice_2 = rtxMemAllocType (pctxt, LoggableEvent);

         if (pvalue->u.choice_2 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_LoggableEvent (pvalue->u.choice_2);
         stat = asn1D_LoggableEvent (pctxt, 
            pvalue->u.choice_2, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.sensorDataReport
             = rtxMemAllocType (pctxt, MessageBodyContent_sensorDataReport);

         if (pvalue->u.sensorDataReport == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MessageBodyContent_sensorDataReport (pvalue->u.sensorDataReport);
         stat = asn1D_MessageBodyContent_sensorDataReport (pctxt, 
            pvalue->u.sensorDataReport, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_MessageBodyContent (OSCTXT* pctxt, MessageBodyContent* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("UUVCommandScript"), 16}, 0}, 0 },
      {{{OSUTF8("USVCommandScript"), 16}, 0}, 0 },
      {{{OSUTF8("UGVCommandScript"), 16}, 0}, 0 },
      {{{OSUTF8("UAVCommandScript"), 16}, 0}, 0 },
      {{{OSUTF8("AgendaMission"), 13}, 0}, 0 },
      {{{OSUTF8("UUVCommand"), 10}, 0}, 1 },
      {{{OSUTF8("UGVCommand"), 10}, 0}, 2 },
      {{{OSUTF8("USVCommand"), 10}, 0}, 3 },
      {{{OSUTF8("UAVCommand"), 10}, 0}, 4 },
      {{{OSUTF8("InformationRequest"), 18}, 0}, 5 },
      {{{OSUTF8("GroupMaintenance"), 16}, 0}, 6 },
      {{{OSUTF8("UUVCharacteristics"), 18}, 0}, 7 },
      {{{OSUTF8("UGVCharacteristics"), 18}, 0}, 7 },
      {{{OSUTF8("USVCharacteristics"), 18}, 0}, 7 },
      {{{OSUTF8("UAVCharacteristics"), 18}, 0}, 7 },
      {{{OSUTF8("VehicleState"), 12}, 0}, 8 },
      {{{OSUTF8("UUVEvent"), 8}, 0}, 9 },
      {{{OSUTF8("UGVEvent"), 8}, 0}, 9 },
      {{{OSUTF8("USVEvent"), 8}, 0}, 9 },
      {{{OSUTF8("UAVEvent"), 8}, 0}, 9 },
      {{{OSUTF8("SensorDataReport"), 16}, 0}, 10 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 21, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: {
      rtXmlpMarkLastEventActive (pctxt);

      pvalue->u.choice = rtxMemAllocType (pctxt, MissionSpecification);

      if (pvalue->u.choice == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MissionSpecification (pvalue->u.choice);

      stat = XmlDec_MissionSpecification (pctxt, pvalue->u.choice);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* UUVCommand */
      pvalue->u.uUVCommand = rtxMemAllocType (pctxt, UuvScriptCommandsType);

      if (pvalue->u.uUVCommand == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UuvScriptCommandsType (pvalue->u.uUVCommand);

      stat = XmlDec_UuvScriptCommandsType (pctxt, pvalue->u.uUVCommand);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* UGVCommand */
      pvalue->u.uGVCommand = rtxMemAllocType (pctxt, UgvScriptCommandsType);

      if (pvalue->u.uGVCommand == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UgvScriptCommandsType (pvalue->u.uGVCommand);

      stat = XmlDec_UgvScriptCommandsType (pctxt, pvalue->u.uGVCommand);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* USVCommand */
      pvalue->u.uSVCommand = rtxMemAllocType (pctxt, UsvScriptCommandsType);

      if (pvalue->u.uSVCommand == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UsvScriptCommandsType (pvalue->u.uSVCommand);

      stat = XmlDec_UsvScriptCommandsType (pctxt, pvalue->u.uSVCommand);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* UAVCommand */
      pvalue->u.uAVCommand = rtxMemAllocType (pctxt, UavScriptCommandsType);

      if (pvalue->u.uAVCommand == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UavScriptCommandsType (pvalue->u.uAVCommand);

      stat = XmlDec_UavScriptCommandsType (pctxt, pvalue->u.uAVCommand);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* InformationRequest */
      pvalue->u.informationRequest
          = rtxMemAllocType (pctxt, InformationRequestElementType);

      if (pvalue->u.informationRequest == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_InformationRequestElementType (pvalue->u.informationRequest);

      stat = XmlDec_InformationRequestElementType (pctxt, pvalue->
         u.informationRequest);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* GroupMaintenance */
      pvalue->u.groupMaintenance
          = rtxMemAllocType (pctxt, VehicleGroupCompositionElementType);

      if (pvalue->u.groupMaintenance == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_VehicleGroupCompositionElementType (pvalue->u.groupMaintenance
         );

      stat = XmlDec_VehicleGroupCompositionElementType (pctxt, pvalue->
         u.groupMaintenance);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: {
      rtXmlpMarkLastEventActive (pctxt);

      pvalue->u.choice_1
          = rtxMemAllocType (pctxt, VehicleCharacteristicsGroup);

      if (pvalue->u.choice_1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_VehicleCharacteristicsGroup (pvalue->u.choice_1);

      stat = XmlDec_VehicleCharacteristicsGroup (pctxt, pvalue->u.choice_1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* VehicleState */
      pvalue->u.vehicleState
          = rtxMemAllocType (pctxt, DiscreteTimeResultsElementType);

      if (pvalue->u.vehicleState == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DiscreteTimeResultsElementType (pvalue->u.vehicleState);

      stat = XmlDec_DiscreteTimeResultsElementType (pctxt, pvalue->
         u.vehicleState);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: {
      rtXmlpMarkLastEventActive (pctxt);

      pvalue->u.choice_2 = rtxMemAllocType (pctxt, LoggableEvent);

      if (pvalue->u.choice_2 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_LoggableEvent (pvalue->u.choice_2);

      stat = XmlDec_LoggableEvent (pctxt, pvalue->u.choice_2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* SensorDataReport */
      pvalue->u.sensorDataReport
          = rtxMemAllocType (pctxt, MessageBodyContent_sensorDataReport);

      if (pvalue->u.sensorDataReport == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MessageBodyContent_sensorDataReport (pvalue->u.sensorDataReport
         );

      stat = XmlDec_MessageBodyContent_sensorDataReport (pctxt, pvalue->
         u.sensorDataReport);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AvclMessageBodyType                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AvclMessageBodyType (OSCTXT* pctxt, 
   AvclMessageBodyType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   if (tagging == ASN1EXPL) {
      if (XD_PEEKTAG (pctxt, 0x30)) {
         stat = xd_Tag1AndLen (pctxt, &length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else return LOG_RTERR (pctxt,
         berErrUnexpTag(pctxt, TM_UNIV|TM_CONS|16));
   }

   if (XD_PEEKTAG (pctxt, 0xa0)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_CTXT|TM_CONS|0));

   tagging = ASN1IMPL;
   stat = asn1D_MessageBodyContent (pctxt, 
      pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_AvclMessageBodyType (OSCTXT* pctxt, AvclMessageBodyType* pvalue)
{
   int stat = 0;

   stat = XmlDec_MessageBodyContent (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AvclMessageType                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AvclMessageType (OSCTXT* pctxt, AvclMessageType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode transportStatus */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AvclMessageType_transportStatus (pctxt, 
               &pvalue->transportStatus, ASN1IMPL, length);
            if (stat == 0) {
               if(pvalue->transportStatus < 0 || pvalue->transportStatus > 2)
                  return LOG_RTERR (pctxt, RTERR_INVENUM);

               pvalue->m.transportStatusPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode version */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->version, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode head */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AvclMessageHeadType (pctxt, 
               &pvalue->head, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode body */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AvclMessageBodyType (pctxt, 
               &pvalue->body, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_AvclMessageType (OSCTXT* pctxt, AvclMessageType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("transportStatus"), 15}, 0 },
         { {OSUTF8("version"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 3: /* transportStatus */
            stat = XmlDec_AvclMessageType_transportStatus (pctxt, &pvalue->
               transportStatus);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.transportStatusPresent = TRUE;
            break;

         case 4: /* version */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->version);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "AvclMessageType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "AvclMessageType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("head"), 4}, 0}, 0 },
      {{{OSUTF8("body"), 4}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 1, -1}, {2, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* head */
         stat = XmlDec_AvclMessageHeadType (pctxt, &pvalue->head);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* body */
         stat = XmlDec_AvclMessageBodyType (pctxt, &pvalue->body);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AVCLMessage                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AVCLMessage (OSCTXT* pctxt, AVCLMessage *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = asn1D_AvclMessageType (pctxt, 
      pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_AVCLMessage (OSCTXT* pctxt, AVCLMessage* pvalue)
{
   int stat = 0;

   stat = XmlDec_AvclMessageType (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CalendarDaysType                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CalendarDaysType (OSCTXT* pctxt, CalendarDaysType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_uint8 (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!((*pvalue <= OSUINTCONST(31)))) {
      rtxErrAddStrParm (pctxt, "CalendarDaysType");
      rtxErrAddIntParm (pctxt, (int)*pvalue);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

int XmlDec_CalendarDaysType (OSCTXT* pctxt, CalendarDaysType* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecUInt8 (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!((*pvalue <= OSUINTCONST(31)))) {
      rtxErrAddStrParm (pctxt, "CalendarDaysType");
      rtxErrAddIntParm (pctxt, (int)*pvalue);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MonthsType                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_MonthsType (OSCTXT* pctxt, MonthsType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if(*pvalue < 0 || *pvalue > 11)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   return (stat);
}

int XmlDec_MonthsType (OSCTXT* pctxt, MonthsType* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = MonthsType_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ClockHoursType                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ClockHoursType (OSCTXT* pctxt, ClockHoursType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_uint8 (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!((*pvalue <= OSUINTCONST(23)))) {
      rtxErrAddStrParm (pctxt, "ClockHoursType");
      rtxErrAddIntParm (pctxt, (int)*pvalue);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

int XmlDec_ClockHoursType (OSCTXT* pctxt, ClockHoursType* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecUInt8 (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!((*pvalue <= OSUINTCONST(23)))) {
      rtxErrAddStrParm (pctxt, "ClockHoursType");
      rtxErrAddIntParm (pctxt, (int)*pvalue);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ClockMinutesOrSecondsType                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ClockMinutesOrSecondsType (OSCTXT* pctxt, 
   ClockMinutesOrSecondsType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_uint8 (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!((*pvalue <= OSUINTCONST(59)))) {
      rtxErrAddStrParm (pctxt, "ClockMinutesOrSecondsType");
      rtxErrAddIntParm (pctxt, (int)*pvalue);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

int XmlDec_ClockMinutesOrSecondsType (OSCTXT* pctxt, 
   ClockMinutesOrSecondsType* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecUInt8 (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!((*pvalue <= OSUINTCONST(59)))) {
      rtxErrAddStrParm (pctxt, "ClockMinutesOrSecondsType");
      rtxErrAddIntParm (pctxt, (int)*pvalue);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimeZoneType                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TimeZoneType (OSCTXT* pctxt, TimeZoneType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_int8 (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!((*pvalue >= OSINTCONST(-12) && *pvalue <= OSINTCONST(12)))) {
      rtxErrAddStrParm (pctxt, "TimeZoneType");
      rtxErrAddIntParm (pctxt, (int)*pvalue);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

int XmlDec_TimeZoneType (OSCTXT* pctxt, TimeZoneType* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecInt8 (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!((*pvalue >= OSINTCONST(-12) && *pvalue <= OSINTCONST(12)))) {
      rtxErrAddStrParm (pctxt, "TimeZoneType");
      rtxErrAddIntParm (pctxt, (int)*pvalue);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NonNegativeIntType                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_NonNegativeIntType (OSCTXT* pctxt, 
   NonNegativeIntType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_integer (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!(*pvalue >= 0)) {
      rtxErrAddStrParm (pctxt, "NonNegativeIntType");
      rtxErrAddIntParm (pctxt, *pvalue);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

int XmlDec_NonNegativeIntType (OSCTXT* pctxt, NonNegativeIntType* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecInt (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!(*pvalue >= 0)) {
      rtxErrAddStrParm (pctxt, "NonNegativeIntType");
      rtxErrAddIntParm (pctxt, *pvalue);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AvclHeadType                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AvclHeadType (OSCTXT* pctxt, AvclHeadType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   MetaDataType* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (XD_PEEKTAG (pctxt, 0x30)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_UNIV|TM_CONS|16));

   if (XD_PEEKTAG (pctxt, 0xa0)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_CTXT|TM_CONS|0));

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      rtxDListAllocNodeAndData (pctxt, MetaDataType, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MetaDataType (pdata1);

      stat = asn1D_MetaDataType (pctxt, 
         pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

int XmlDec_AvclHeadType (OSCTXT* pctxt, AvclHeadType* pvalue)
{
   int stat = 0;

   { int elemID;
   MetaDataType* pdata1;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("meta"), 4}, 0}, 0 }
   } ;

   rtxDListInit (pvalue);
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 1, -1, FALSE);
      if (elemID < 0 || elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: /* meta */
         pdata1 = rtxMemAllocType (pctxt, MetaDataType);

         if (pdata1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_MetaDataType (pdata1);

         stat = XmlDec_MetaDataType (pctxt, pdata1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         break;

      }
   }

   if (elemID == RTERR_UNEXPELEM || elemID == XML_OK_EOB) {
      stat = 0;
   }
   else return LOG_RTERR (pctxt, elemID);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  UnitsOfMeasureElementType                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_UnitsOfMeasureElementType (OSCTXT* pctxt, 
   UnitsOfMeasureElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode angle */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->angle, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode distance */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->distance, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode mass */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->mass, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode time_ */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->time_, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 4) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_UnitsOfMeasureElementType (OSCTXT* pctxt, 
   UnitsOfMeasureElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("angle"), 5}, 0 },
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("distance"), 8}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("mass"), 4}, 0 },
         { {OSUTF8("time"), 4}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 7, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* angle */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->angle);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 2: /* distance */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->distance);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 4: /* mass */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->mass);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* time */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->time_);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 6: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "UnitsOfMeasureElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "UnitsOfMeasureElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConfigurationElementType_choice                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ConfigurationElementType_choice (OSCTXT* pctxt, 
   ConfigurationElementType_choice *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.unmannedUnderwaterVehicle
             = rtxMemAllocType (pctxt, UuvCharacteristicsElementType);

         if (pvalue->u.unmannedUnderwaterVehicle == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UuvCharacteristicsElementType (pvalue->u.unmannedUnderwaterVehicle);
         stat = asn1D_UuvCharacteristicsElementType (pctxt, 
            pvalue->u.unmannedUnderwaterVehicle, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.unmannedSurfaceVehicle
             = rtxMemAllocType (pctxt, UsvCharacteristicsElementType);

         if (pvalue->u.unmannedSurfaceVehicle == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UsvCharacteristicsElementType (pvalue->u.unmannedSurfaceVehicle);
         stat = asn1D_UsvCharacteristicsElementType (pctxt, 
            pvalue->u.unmannedSurfaceVehicle, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.unmannedGroundVehicle
             = rtxMemAllocType (pctxt, UgvCharacteristicsElementType);

         if (pvalue->u.unmannedGroundVehicle == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UgvCharacteristicsElementType (pvalue->u.unmannedGroundVehicle);
         stat = asn1D_UgvCharacteristicsElementType (pctxt, 
            pvalue->u.unmannedGroundVehicle, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.unmannedAerialVehicle
             = rtxMemAllocType (pctxt, UavCharacteristicsElementType);

         if (pvalue->u.unmannedAerialVehicle == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UavCharacteristicsElementType (pvalue->u.unmannedAerialVehicle);
         stat = asn1D_UavCharacteristicsElementType (pctxt, 
            pvalue->u.unmannedAerialVehicle, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_ConfigurationElementType_choice (OSCTXT* pctxt, 
   ConfigurationElementType_choice* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("UnmannedUnderwaterVehicle"), 25}, 0}, 0 },
      {{{OSUTF8("UnmannedSurfaceVehicle"), 22}, 0}, 1 },
      {{{OSUTF8("UnmannedGroundVehicle"), 21}, 0}, 2 },
      {{{OSUTF8("UnmannedAerialVehicle"), 21}, 0}, 3 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 4, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* UnmannedUnderwaterVehicle */
      pvalue->u.unmannedUnderwaterVehicle
          = rtxMemAllocType (pctxt, UuvCharacteristicsElementType);

      if (pvalue->u.unmannedUnderwaterVehicle == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UuvCharacteristicsElementType (pvalue->
         u.unmannedUnderwaterVehicle);

      stat = XmlDec_UuvCharacteristicsElementType (pctxt, pvalue->
         u.unmannedUnderwaterVehicle);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* UnmannedSurfaceVehicle */
      pvalue->u.unmannedSurfaceVehicle
          = rtxMemAllocType (pctxt, UsvCharacteristicsElementType);

      if (pvalue->u.unmannedSurfaceVehicle == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UsvCharacteristicsElementType (pvalue->u.unmannedSurfaceVehicle
         );

      stat = XmlDec_UsvCharacteristicsElementType (pctxt, pvalue->
         u.unmannedSurfaceVehicle);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* UnmannedGroundVehicle */
      pvalue->u.unmannedGroundVehicle
          = rtxMemAllocType (pctxt, UgvCharacteristicsElementType);

      if (pvalue->u.unmannedGroundVehicle == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UgvCharacteristicsElementType (pvalue->u.unmannedGroundVehicle
         );

      stat = XmlDec_UgvCharacteristicsElementType (pctxt, pvalue->
         u.unmannedGroundVehicle);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* UnmannedAerialVehicle */
      pvalue->u.unmannedAerialVehicle
          = rtxMemAllocType (pctxt, UavCharacteristicsElementType);

      if (pvalue->u.unmannedAerialVehicle == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UavCharacteristicsElementType (pvalue->u.unmannedAerialVehicle
         );

      stat = XmlDec_UavCharacteristicsElementType (pctxt, pvalue->
         u.unmannedAerialVehicle);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ConfigurationElementType                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ConfigurationElementType (OSCTXT* pctxt, 
   ConfigurationElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_ConfigurationElementType_choice (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_ConfigurationElementType (OSCTXT* pctxt, 
   ConfigurationElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "ConfigurationElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "ConfigurationElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("UnmannedUnderwaterVehicle"), 25}, 0}, 0 },
      {{{OSUTF8("UnmannedSurfaceVehicle"), 22}, 0}, 0 },
      {{{OSUTF8("UnmannedGroundVehicle"), 21}, 0}, 0 },
      {{{OSUTF8("UnmannedAerialVehicle"), 21}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}, {4, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_ConfigurationElementType_choice (pctxt, &pvalue->choice
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MissionPreparationElementType                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_MissionPreparationElementType (OSCTXT* pctxt, 
   MissionPreparationElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode unitsOfMeasure */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_UnitsOfMeasureElementType (pctxt, 
               &pvalue->unitsOfMeasure, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode geoOrigin */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_GeoOriginElementType (pctxt, 
               &pvalue->geoOrigin, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.geoOriginPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode configuration */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_ConfigurationElementType (pctxt, 
               &pvalue->configuration, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.configurationPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_MissionSpecification (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choicePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_MissionPreparationElementType (OSCTXT* pctxt, 
   MissionPreparationElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "MissionPreparationElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "MissionPreparationElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("UnitsOfMeasure"), 14}, 0}, 0 },
      {{{OSUTF8("GeoOrigin"), 9}, 0}, 1 },
      {{{OSUTF8("Configuration"), 13}, 0}, 2 },
      {{{OSUTF8("UUVCommandScript"), 16}, 0}, 3 },
      {{{OSUTF8("USVCommandScript"), 16}, 0}, 3 },
      {{{OSUTF8("UGVCommandScript"), 16}, 0}, 3 },
      {{{OSUTF8("UAVCommandScript"), 16}, 0}, 3 },
      {{{OSUTF8("AgendaMission"), 13}, 0}, 3 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 7, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 4; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* UnitsOfMeasure */
         stat = XmlDec_UnitsOfMeasureElementType (pctxt, &pvalue->
            unitsOfMeasure);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* GeoOrigin */
         stat = XmlDec_GeoOriginElementType (pctxt, &pvalue->geoOrigin);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.geoOriginPresent = TRUE;
         break;
      }
      case 2: { /* Configuration */
         stat = XmlDec_ConfigurationElementType (pctxt, &pvalue->configuration
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.configurationPresent = TRUE;
         break;
      }
      case 3: {
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_MissionSpecification (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choicePresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EventLogElementType                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_EventLogElementType (OSCTXT* pctxt, 
   EventLogElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               LoggableEvent* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, LoggableEvent, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_LoggableEvent (pdata2);

                  stat = asn1D_LoggableEvent (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_EventLogElementType (OSCTXT* pctxt, EventLogElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "EventLogElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "EventLogElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("UUVEvent"), 8}, 0}, 0 },
      {{{OSUTF8("UGVEvent"), 8}, 0}, 0 },
      {{{OSUTF8("USVEvent"), 8}, 0}, 0 },
      {{{OSUTF8("UAVEvent"), 8}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         LoggableEvent* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, LoggableEvent);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_LoggableEvent (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_LoggableEvent (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 4, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DateTimeGroupElementType                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_DateTimeGroupElementType (OSCTXT* pctxt, 
   DateTimeGroupElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode day */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CalendarDaysType (pctxt, 
               &pvalue->day, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode hour */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_ClockHoursType (pctxt, 
               &pvalue->hour, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode minute */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_ClockMinutesOrSecondsType (pctxt, 
               &pvalue->minute, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode month */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_MonthsType (pctxt, 
               &pvalue->month, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode second */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_ClockMinutesOrSecondsType (pctxt, 
               &pvalue->second, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode timeZone */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_TimeZoneType (pctxt, 
               &pvalue->timeZone, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode year */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PositiveIntType (pctxt, 
               &pvalue->year, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 7) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_DateTimeGroupElementType (OSCTXT* pctxt, 
   DateTimeGroupElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("day"), 3}, 0 },
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("hour"), 4}, 0 },
         { {OSUTF8("minute"), 6}, 0 },
         { {OSUTF8("month"), 5}, 0 },
         { {OSUTF8("second"), 6}, 0 },
         { {OSUTF8("timeZone"), 8}, 0 },
         { {OSUTF8("year"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 8, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* day */
            stat = XmlDec_CalendarDaysType (pctxt, &pvalue->day);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 2: /* hour */
            stat = XmlDec_ClockHoursType (pctxt, &pvalue->hour);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* minute */
            stat = XmlDec_ClockMinutesOrSecondsType (pctxt, &pvalue->minute);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* month */
            stat = XmlDec_MonthsType (pctxt, &pvalue->month);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* second */
            stat = XmlDec_ClockMinutesOrSecondsType (pctxt, &pvalue->second);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 6: /* timeZone */
            stat = XmlDec_TimeZoneType (pctxt, &pvalue->timeZone);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 7: /* year */
            stat = XmlDec_PositiveIntType (pctxt, &pvalue->year);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "DateTimeGroupElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "DateTimeGroupElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MissionResultsElementType_element                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_MissionResultsElementType_element (OSCTXT* pctxt, 
   MissionResultsElementType_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.sampledResults
             = rtxMemAllocType (pctxt, DiscreteTimeResultsElementType);

         if (pvalue->u.sampledResults == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_DiscreteTimeResultsElementType (pvalue->u.sampledResults);
         stat = asn1D_DiscreteTimeResultsElementType (pctxt, 
            pvalue->u.sampledResults, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_MissionResultsElementType_element (OSCTXT* pctxt, 
   MissionResultsElementType_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("SampledResults"), 14}, 0}, 0 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 1, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* SampledResults */
      pvalue->u.sampledResults
          = rtxMemAllocType (pctxt, DiscreteTimeResultsElementType);

      if (pvalue->u.sampledResults == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DiscreteTimeResultsElementType (pvalue->u.sampledResults);

      stat = XmlDec_DiscreteTimeResultsElementType (pctxt, pvalue->
         u.sampledResults);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MissionResultsElementType                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_MissionResultsElementType (OSCTXT* pctxt, 
   MissionResultsElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode missionStartTime */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_DateTimeGroupElementType (pctxt, 
               &pvalue->missionStartTime, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.missionStartTimePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               MissionResultsElementType_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, MissionResultsElementType_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_MissionResultsElementType_element (pdata2);

                  stat = asn1D_MissionResultsElementType_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_MissionResultsElementType (OSCTXT* pctxt, 
   MissionResultsElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "MissionResultsElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "MissionResultsElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("MissionStartTime"), 16}, 0}, 0 },
      {{{OSUTF8("SampledResults"), 14}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* MissionStartTime */
         stat = XmlDec_DateTimeGroupElementType (pctxt, &pvalue->
            missionStartTime);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.missionStartTimePresent = TRUE;
         break;
      }
      case 1: {
         MissionResultsElementType_element* pdata1;
         do {
            pdata1
                = rtxMemAllocType (pctxt, MissionResultsElementType_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MissionResultsElementType_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_MissionResultsElementType_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AvclBodyType                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AvclBodyType (OSCTXT* pctxt, AvclBodyType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode _order */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               int xx2;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               xx2 = 0;
               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  if (xx2 >= 3) return LOG_RTERR (pctxt, RTERR_SEQOVFLW);

                  { int length;
                  if (XD_PEEKTAG (pctxt, 0xa)) {
                     stat = xd_Tag1AndLen (pctxt, &length);
                     if (stat != 0) return LOG_RTERR (pctxt, stat);
                  }
                  else return LOG_RTERR (pctxt,
                     berErrUnexpTag(pctxt, TM_UNIV|TM_PRIM|10));

                  stat = xd_uint8 (pctxt, &pvalue->_order.elem[xx2], ASN1IMPL, length);
                  if (stat == 0) {
                     if (!((pvalue->_order.elem[xx2] <= OSUINTCONST(2)))) {
                        rtxErrAddStrParm (pctxt, "AvclBodyType._order.elem[xx2]");
                        rtxErrAddIntParm (pctxt, (int)pvalue->_order.elem[xx2]);
                        return LOG_RTERR (pctxt, RTERR_CONSVIO);
                     }

                  }
                  else return LOG_RTERR (pctxt, stat);

                  }
                  xx2++;
               }
               pvalue->_order.n = xx2;

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode missionPreparation */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_MissionPreparationElementType (pctxt, 
               &pvalue->missionPreparation, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode eventLog */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_EventLogElementType (pctxt, 
               &pvalue->eventLog, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.eventLogPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode missionResults */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_MissionResultsElementType (pctxt, 
               &pvalue->missionResults, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.missionResultsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_AvclBodyType (OSCTXT* pctxt, AvclBodyType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("MissionPreparation"), 18}, 0}, 0 },
      {{{OSUTF8("EventLog"), 8}, 0}, 1 },
      {{{OSUTF8("MissionResults"), 14}, 0}, 2 }
   } ;
   pvalue->_order.n = 0;

   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: { /* MissionPreparation */
         stat = XmlDec_MissionPreparationElementType (pctxt, &pvalue->
            missionPreparation);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* EventLog */
         stat = XmlDec_EventLogElementType (pctxt, &pvalue->eventLog);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.eventLogPresent = TRUE;
         break;
      }
      case 2: { /* MissionResults */
         stat = XmlDec_MissionResultsElementType (pctxt, &pvalue->
            missionResults);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.missionResultsPresent = TRUE;
         break;
      }
      }
      pvalue->_order.elem[pvalue->_order.n++] = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AVCL                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AVCL (OSCTXT* pctxt, AVCL *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   pvalue->vehicleID = 0;

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode date */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_charstr (pctxt, &pvalue->date, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|26), length);
            if (stat == 0) {
               pvalue->m.datePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode vehicleID */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_uint16 (pctxt, &pvalue->vehicleID, ASN1IMPL, length);
            if (stat == 0) {
            }
         }
         break;

      case 5:
         /* decode vehicleType */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->vehicleType, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.vehicleTypePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode version */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->version, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode head */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AvclHeadType (pctxt, 
               &pvalue->head, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.headPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode body */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AvclBodyType (pctxt, 
               &pvalue->body, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_AVCL (OSCTXT* pctxt, AVCL* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("date"), 4}, 0 },
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("vehicleID"), 9}, 0 },
         { {OSUTF8("vehicleType"), 11}, 0 },
         { {OSUTF8("version"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 7, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* date */
            stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)&pvalue->
               date);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.datePresent = TRUE;
            break;

         case 1: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 2: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 3: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 4: /* vehicleID */
            stat = rtXmlpDecUInt16 (pctxt, &pvalue->vehicleID);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* vehicleType */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->vehicleType);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.vehicleTypePresent = TRUE;
            break;

         case 6: /* version */
            stat = rtXmlpDecDouble (pctxt, &pvalue->version, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "AVCL");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "AVCL");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("head"), 4}, 0}, 0 },
      {{{OSUTF8("body"), 4}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}, {2, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* head */
         stat = XmlDec_AvclHeadType (pctxt, &pvalue->head);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.headPresent = TRUE;
         break;
      }
      case 1: { /* body */
         stat = XmlDec_AvclBodyType (pctxt, &pvalue->body);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AvclMessageListBodyType                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AvclMessageListBodyType (OSCTXT* pctxt, 
   AvclMessageListBodyType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   AvclMessageType* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (XD_PEEKTAG (pctxt, 0x30)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_UNIV|TM_CONS|16));

   if (XD_PEEKTAG (pctxt, 0xa0)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_CTXT|TM_CONS|0));

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      rtxDListAllocNodeAndData (pctxt, AvclMessageType, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AvclMessageType (pdata1);

      stat = asn1D_AvclMessageType (pctxt, 
         pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "AvclMessageListBodyType.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

int XmlDec_AvclMessageListBodyType (OSCTXT* pctxt, 
   AvclMessageListBodyType* pvalue)
{
   int stat = 0;

   { int elemID;
   AvclMessageType* pdata1;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("AVCLMessage"), 11}, 0}, 0 }
   } ;

   rtxDListInit (pvalue);
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 1, -1, FALSE);
      if (elemID < 0 || elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: /* AVCLMessage */
         pdata1 = rtxMemAllocType (pctxt, AvclMessageType);

         if (pdata1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AvclMessageType (pdata1);

         stat = XmlDec_AvclMessageType (pctxt, pdata1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         break;

      }
   }

   if (elemID == RTERR_UNEXPELEM || elemID == XML_OK_EOB) {
      stat = 0;
   }
   else return LOG_RTERR (pctxt, elemID);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AVCLMessageList                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AVCLMessageList (OSCTXT* pctxt, AVCLMessageList *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   pvalue->vehicleID = 0;

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode date */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_charstr (pctxt, &pvalue->date, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|26), length);
            if (stat == 0) {
               pvalue->m.datePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode vehicleID */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_uint16 (pctxt, &pvalue->vehicleID, ASN1IMPL, length);
            if (stat == 0) {
            }
         }
         break;

      case 5:
         /* decode vehicleType */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->vehicleType, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.vehicleTypePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode version */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->version, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode head */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AvclHeadType (pctxt, 
               &pvalue->head, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.headPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode body */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AvclMessageListBodyType (pctxt, 
               &pvalue->body, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_AVCLMessageList (OSCTXT* pctxt, AVCLMessageList* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("date"), 4}, 0 },
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("vehicleID"), 9}, 0 },
         { {OSUTF8("vehicleType"), 11}, 0 },
         { {OSUTF8("version"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 7, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* date */
            stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)&pvalue->
               date);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.datePresent = TRUE;
            break;

         case 1: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 2: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 3: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 4: /* vehicleID */
            stat = rtXmlpDecUInt16 (pctxt, &pvalue->vehicleID);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* vehicleType */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->vehicleType);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.vehicleTypePresent = TRUE;
            break;

         case 6: /* version */
            stat = rtXmlpDecDouble (pctxt, &pvalue->version, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "AVCLMessageList");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "AVCLMessageList");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("head"), 4}, 0}, 0 },
      {{{OSUTF8("body"), 4}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}, {2, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* head */
         stat = XmlDec_AvclHeadType (pctxt, &pvalue->head);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.headPresent = TRUE;
         break;
      }
      case 1: { /* body */
         stat = XmlDec_AvclMessageListBodyType (pctxt, &pvalue->body);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NonNegativeScalarElementType                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_NonNegativeScalarElementType (OSCTXT* pctxt, 
   NonNegativeScalarElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_NonNegativeScalarElementType (OSCTXT* pctxt, 
   NonNegativeScalarElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 3: /* value */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "NonNegativeScalarElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "NonNegativeScalarElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IntegerElementType                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_IntegerElementType (OSCTXT* pctxt, 
   IntegerElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_IntegerElementType (OSCTXT* pctxt, IntegerElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 3: /* value */
            stat = rtXmlpDecInt (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "IntegerElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "IntegerElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TokenElementType                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TokenElementType (OSCTXT* pctxt, TokenElementType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode timeStamp */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NonNegativeScalarType (pctxt, 
               &pvalue->timeStamp, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.timeStampPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_TokenElementType (OSCTXT* pctxt, TokenElementType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("description"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("timeStamp"), 9}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* description */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.descriptionPresent = TRUE;
            break;

         case 1: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* timeStamp */
            stat = XmlDec_NonNegativeScalarType (pctxt, &pvalue->timeStamp);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.timeStampPresent = TRUE;
            break;

         case 3: /* value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "TokenElementType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "TokenElementType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TelemetryElement                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TelemetryElement (OSCTXT* pctxt, TelemetryElement *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.uUVTelemetry
             = rtxMemAllocType (pctxt, UuvTelemetryElementType);

         if (pvalue->u.uUVTelemetry == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UuvTelemetryElementType (pvalue->u.uUVTelemetry);
         stat = asn1D_UuvTelemetryElementType (pctxt, 
            pvalue->u.uUVTelemetry, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.uSVTelemetry
             = rtxMemAllocType (pctxt, UsvTelemetryElementType);

         if (pvalue->u.uSVTelemetry == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UsvTelemetryElementType (pvalue->u.uSVTelemetry);
         stat = asn1D_UsvTelemetryElementType (pctxt, 
            pvalue->u.uSVTelemetry, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.uGVTelemetry
             = rtxMemAllocType (pctxt, UgvTelemetryElementType);

         if (pvalue->u.uGVTelemetry == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UgvTelemetryElementType (pvalue->u.uGVTelemetry);
         stat = asn1D_UgvTelemetryElementType (pctxt, 
            pvalue->u.uGVTelemetry, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.uAVTelemetry
             = rtxMemAllocType (pctxt, UavTelemetryElementType);

         if (pvalue->u.uAVTelemetry == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_UavTelemetryElementType (pvalue->u.uAVTelemetry);
         stat = asn1D_UavTelemetryElementType (pctxt, 
            pvalue->u.uAVTelemetry, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_TelemetryElement (OSCTXT* pctxt, TelemetryElement* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("UUVTelemetry"), 12}, 0}, 0 },
      {{{OSUTF8("USVTelemetry"), 12}, 0}, 1 },
      {{{OSUTF8("UGVTelemetry"), 12}, 0}, 2 },
      {{{OSUTF8("UAVTelemetry"), 12}, 0}, 3 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 4, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* UUVTelemetry */
      pvalue->u.uUVTelemetry
          = rtxMemAllocType (pctxt, UuvTelemetryElementType);

      if (pvalue->u.uUVTelemetry == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UuvTelemetryElementType (pvalue->u.uUVTelemetry);

      stat = XmlDec_UuvTelemetryElementType (pctxt, pvalue->u.uUVTelemetry);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* USVTelemetry */
      pvalue->u.uSVTelemetry
          = rtxMemAllocType (pctxt, UsvTelemetryElementType);

      if (pvalue->u.uSVTelemetry == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UsvTelemetryElementType (pvalue->u.uSVTelemetry);

      stat = XmlDec_UsvTelemetryElementType (pctxt, pvalue->u.uSVTelemetry);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* UGVTelemetry */
      pvalue->u.uGVTelemetry
          = rtxMemAllocType (pctxt, UgvTelemetryElementType);

      if (pvalue->u.uGVTelemetry == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UgvTelemetryElementType (pvalue->u.uGVTelemetry);

      stat = XmlDec_UgvTelemetryElementType (pctxt, pvalue->u.uGVTelemetry);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* UAVTelemetry */
      pvalue->u.uAVTelemetry
          = rtxMemAllocType (pctxt, UavTelemetryElementType);

      if (pvalue->u.uAVTelemetry == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UavTelemetryElementType (pvalue->u.uAVTelemetry);

      stat = XmlDec_UavTelemetryElementType (pctxt, pvalue->u.uAVTelemetry);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

int XmlDec_AVCLMessage_PDU (OSCTXT* pctxt, AVCLMessage* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   asn1Init_AVCLMessage (pvalue);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("AVCLMessage"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_AVCLMessage (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_NonNegativeIntType_PDU (OSCTXT* pctxt, NonNegativeIntType* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("nonNegativeIntType"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_NonNegativeIntType (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_AVCL_PDU (OSCTXT* pctxt, AVCL* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   asn1Init_AVCL (pvalue);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("AVCL"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_AVCL (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_AVCLMessageList_PDU (OSCTXT* pctxt, AVCLMessageList* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   asn1Init_AVCLMessageList (pvalue);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("AVCLMessageList"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_AVCLMessageList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_NonNegativeScalarElementType_PDU (OSCTXT* pctxt, NonNegativeScalarElementType* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   asn1Init_NonNegativeScalarElementType (pvalue);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("nonNegativeScalarElementType"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_NonNegativeScalarElementType (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_IntegerElementType_PDU (OSCTXT* pctxt, IntegerElementType* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   asn1Init_IntegerElementType (pvalue);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("integerElementType"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_IntegerElementType (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_TokenElementType_PDU (OSCTXT* pctxt, TokenElementType* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   asn1Init_TokenElementType (pvalue);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("tokenElementType"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_TokenElementType (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_TelemetryElement_PDU (OSCTXT* pctxt, TelemetryElement* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   asn1Init_TelemetryElement (pvalue);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("telemetryElement"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_TelemetryElement (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
