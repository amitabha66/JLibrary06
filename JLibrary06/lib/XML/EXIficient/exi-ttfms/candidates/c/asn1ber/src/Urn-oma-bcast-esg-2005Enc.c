/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 19-Sep-2006.
 */
#include "Urn-oma-bcast-esg-2005.h"
#include "rtxsrc/rtxCommon.h"

/**************************************************************/
/*                                                            */
/*  GenreElementType                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_GenreElementType (OSCTXT* pctxt,
   GenreElementType pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_utf8str (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_GenreElementType (OSCTXT* pctxt, GenreElementType value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt, value, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PreviewDataIDType                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PreviewDataIDType (OSCTXT* pctxt,
   PreviewDataIDType pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_utf8str (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_PreviewDataIDType (OSCTXT* pctxt, PreviewDataIDType value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt, value, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelativeDateType                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RelativeDateType (OSCTXT* pctxt,
   RelativeDateType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_unsigned (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_RelativeDateType (OSCTXT* pctxt, RelativeDateType value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUInt (pctxt, value, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ContentIDType                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ContentIDType (OSCTXT* pctxt,
   ContentIDType pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_utf8str (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_ContentIDType (OSCTXT* pctxt, ContentIDType value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt, value, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ScheduleIDType                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ScheduleIDType (OSCTXT* pctxt,
   ScheduleIDType pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_utf8str (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_ScheduleIDType (OSCTXT* pctxt, ScheduleIDType value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt, value, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ServiceIDType                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ServiceIDType (OSCTXT* pctxt,
   ServiceIDType pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_utf8str (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_ServiceIDType (OSCTXT* pctxt, ServiceIDType value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt, value, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AccessIDType                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AccessIDType (OSCTXT* pctxt,
   AccessIDType pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_utf8str (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_AccessIDType (OSCTXT* pctxt, AccessIDType value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt, value, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TextType                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TextType (OSCTXT* pctxt,
   TextType pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_utf8str (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_TextType (OSCTXT* pctxt, TextType value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt, value, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InteractivityDataIDType                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_InteractivityDataIDType (OSCTXT* pctxt,
   InteractivityDataIDType pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_utf8str (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_InteractivityDataIDType (OSCTXT* pctxt, 
   InteractivityDataIDType value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt, value, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InteractivityMediaIDType                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_InteractivityMediaIDType (OSCTXT* pctxt,
   InteractivityMediaIDType pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_utf8str (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_InteractivityMediaIDType (OSCTXT* pctxt, 
   InteractivityMediaIDType value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt, value, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetUserProfileType                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TargetUserProfileType (OSCTXT* pctxt,
   TargetUserProfileType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode profileAttributeValue */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->profileAttributeValue, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode profileAttributeName */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->profileAttributeName, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TargetUserProfileType (OSCTXT* pctxt, 
   TargetUserProfileType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      OSRTSAFEMEMCPY (pctxt, OSUTF8(" ProfileAttributeName=\""), 23);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->profileAttributeName, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');

      OSRTSAFEMEMCPY (pctxt, OSUTF8(" ProfileAttributeValue=\""), 24);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->profileAttributeValue, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PreviewDataIDRefType                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PreviewDataIDRefType (OSCTXT* pctxt,
   PreviewDataIDRefType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode usage */

   if (pvalue->m.usagePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_int8 (pctxt, &pvalue->usage, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PreviewDataIDRefType (OSCTXT* pctxt, PreviewDataIDRefType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      if (pvalue->m.usagePresent) {
         stat = rtXmlEncIntAttr
            (pctxt, pvalue->usage, OSUTF8("usage"), 5);
      }

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Broadcast_areaType_target_area                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Broadcast_areaType_target_area (OSCTXT* pctxt,
   Broadcast_areaType_target_area *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode cell_Group_ID */

   if (pvalue->m.cell_Group_IDPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
         xe_utf8str (pctxt, pvalue->cell_Group_ID, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode cell_ID_list */

   pnode2 = pvalue->cell_ID_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode zip_code */

   if (pvalue->m.zip_codePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_integer (pctxt, &pvalue->zip_code, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name_area */

   if (pvalue->m.name_areaPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->name_area, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode cc */

   if (pvalue->m.ccPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->cc, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode shape */

   if (pvalue->m.shapePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->shape, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Broadcast_areaType_target_area (OSCTXT* pctxt, 
   Broadcast_areaType_target_area* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode shape */

   if (pvalue->m.shapePresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->shape
         , OSUTF8("shape"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode cc */

   if (pvalue->m.ccPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->cc, OSUTF8("cc"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode name_area */

   if (pvalue->m.name_areaPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->name_area
         , OSUTF8("name_area"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode zip_code */

   if (pvalue->m.zip_codePresent) {
      stat = rtXmlEncInt (pctxt, pvalue->zip_code, OSUTF8("zip_code"), nsPrefix
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode cell_ID_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->cell_ID_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("Cell_ID"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode cell_Group_ID */

   if (pvalue->m.cell_Group_IDPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->cell_Group_ID
         , OSUTF8("Cell_Group_ID"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Broadcast_areaType                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Broadcast_areaType (OSCTXT* pctxt,
   Broadcast_areaType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode hor_ac_list */

   pnode2 = pvalue->hor_ac_list.tail;
   while (0 != pnode2) {
      switch (((OSXSDAny*)pnode2->data)->t) {
      case OSXSDAny_binary:
         ll = xe_OpenType (pctxt, ((OSXSDAny*)pnode2->data)->u.binary->data, 
            ((OSXSDAny*)pnode2->data)->u.binary->numocts);
         break;
      case OSXSDAny_xmlText:
         ll = xe_utf8str (pctxt, ((OSXSDAny*)pnode2->data)->
            u.xmlText, ASN1EXPL);
         break;
      }
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      else ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode target_area_list */

   pnode2 = pvalue->target_area_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Broadcast_areaType_target_area (pctxt, ((Broadcast_areaType_target_area*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode polarity */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_boolean (pctxt, &pvalue->polarity, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Broadcast_areaType (OSCTXT* pctxt, Broadcast_areaType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      stat = rtXmlEncBoolAttr (pctxt, pvalue->polarity
         , OSUTF8("polarity"), 8);

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode target_area_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->target_area_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Broadcast_areaType_target_area (pctxt, 
         ((Broadcast_areaType_target_area*)pnode->data)
         , OSUTF8("target_area"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode hor_ac_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->hor_ac_list.head;
   while (0 != pnode) {
      if (((OSXSDAny*)pnode->data)->t == OSXSDAny_xmlText) {
         stat = rtXmlEncAnyStr (pctxt, ((OSXSDAny*)pnode->data)->u.xmlText
            , OSUTF8("hor_ac"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         char buf[40];
         os_snprintf (buf, 40, "%d", ((OSXSDAny*)pnode->data)->t);
         rtxErrAddStrParm (pctxt, buf);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ServiceType                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ServiceType (OSCTXT* pctxt,
   ServiceType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;
   int xx2;

   /* encode broadcast_area */

   if (pvalue->m.broadcast_areaPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|17,
         asn1E_Broadcast_areaType (pctxt, &pvalue->broadcast_area, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode previewDataIDRef_list */

   pnode2 = pvalue->previewDataIDRef_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PreviewDataIDRefType (pctxt, ((PreviewDataIDRefType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|16, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode userRating_list */

   for (xx2 = (pvalue->userRating_list.n - 1); xx2 >= 0; xx2--)
   {
      ll = xe_integer (pctxt, &pvalue->userRating_list.elem[xx2], ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|15, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode genre_list */

   pnode2 = pvalue->genre_list.tail;
   while (0 != pnode2) {
      ll = asn1E_GenreElementType (pctxt, ((GenreElementType)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|14, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode targetUserProfile_list */

   pnode2 = pvalue->targetUserProfile_list.tail;
   while (0 != pnode2) {
      ll = asn1E_TargetUserProfileType (pctxt, ((TargetUserProfileType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|13, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode parentalRating_list */

   pnode2 = pvalue->parentalRating_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|12, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode description_list */

   pnode2 = pvalue->description_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|11, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode name_list */

   if (!(pvalue->name_list.count >= 1)) {
      rtxErrAddStrParm (pctxt, "ServiceType.name_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->name_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->name_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode globalServiceID */

   if (pvalue->m.globalServiceIDPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|9,
         xe_utf8str (pctxt, pvalue->globalServiceID, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode extensionURL_list */

   pnode2 = pvalue->extensionURL_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode version */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
      xe_unsigned (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode validTo */

   if (pvalue->m.validToPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
         xe_unsigned (pctxt, &pvalue->validTo, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode validFrom */

   if (pvalue->m.validFromPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
         xe_unsigned (pctxt, &pvalue->validFrom, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode type */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
      xe_int8 (pctxt, &pvalue->type, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
      xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode weight */

   if (pvalue->m.weightPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_unsigned (pctxt, &pvalue->weight, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode serviceProtection */

   if (pvalue->m.serviceProtectionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_boolean (pctxt, &pvalue->serviceProtection, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode serviceBaseCID */

   if (pvalue->m.serviceBaseCIDPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->serviceBaseCID, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ServiceType (OSCTXT* pctxt, ServiceType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      if (pvalue->m.serviceBaseCIDPresent) {
         OSRTSAFEMEMCPY (pctxt, OSUTF8(" ServiceBaseCID=\""), 17);

         stat = rtXmlEncUTF8Str (pctxt, pvalue->serviceBaseCID, 0, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         OSRTSAFEPUTCHAR (pctxt, '\"');
      }

      if (pvalue->m.serviceProtectionPresent) {
         stat = rtXmlEncBoolAttr (pctxt, pvalue->serviceProtection
            , OSUTF8("ServiceProtection"), 17);
      }

      if (pvalue->m.weightPresent) {
         stat = rtXmlEncUIntAttr
            (pctxt, pvalue->weight, OSUTF8("Weight"), 6);
      }

      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');

      stat = rtXmlEncIntAttr
         (pctxt, pvalue->type, OSUTF8("type"), 4);

      if (pvalue->m.validFromPresent) {
         stat = rtXmlEncUIntAttr
            (pctxt, pvalue->validFrom, OSUTF8("validFrom"), 9);
      }

      if (pvalue->m.validToPresent) {
         stat = rtXmlEncUIntAttr
            (pctxt, pvalue->validTo, OSUTF8("validTo"), 7);
      }

      stat = rtXmlEncUIntAttr
         (pctxt, pvalue->version, OSUTF8("version"), 7);

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode extensionURL_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->extensionURL_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("ExtensionURL"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode globalServiceID */

   if (pvalue->m.globalServiceIDPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->globalServiceID
         , OSUTF8("GlobalServiceID"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode name_list */

   if (!(pvalue->name_list.count >= 1)) {
      rtxErrAddStrParm (pctxt, "ServiceType.name_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->name_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->name_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("Name"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode description_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->description_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("Description"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode parentalRating_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->parentalRating_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("ParentalRating"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode targetUserProfile_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->targetUserProfile_list.head;
   while (0 != pnode) {
      stat = XmlEnc_TargetUserProfileType (pctxt, 
         ((TargetUserProfileType*)pnode->data)
         , OSUTF8("TargetUserProfile"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode genre_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->genre_list.head;
   while (0 != pnode) {
      stat = XmlEnc_GenreElementType (pctxt, ((GenreElementType)pnode->data)
         , OSUTF8("Genre"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode userRating_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSUINT32 xx1;
   for (xx1 = 0; xx1 < pvalue->userRating_list.n; xx1++) {
      stat = rtXmlEncInt (pctxt, pvalue->userRating_list.elem[xx1]
         , OSUTF8("UserRating"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }}
   nsPrefix = savedPrefix;
   }

   /* encode previewDataIDRef_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->previewDataIDRef_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PreviewDataIDRefType (pctxt, 
         ((PreviewDataIDRefType*)pnode->data)
         , OSUTF8("PreviewDataIDRef"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode broadcast_area */

   if (pvalue->m.broadcast_areaPresent) {
      stat = XmlEnc_Broadcast_areaType (pctxt, &pvalue->broadcast_area
         , OSUTF8("broadcast_area"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Distribution_WindowType_repeatType                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Distribution_WindowType_repeatType (OSCTXT* pctxt,
   Distribution_WindowType_repeatType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode unit */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_integer (pctxt, &pvalue->unit, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode num */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_integer (pctxt, &pvalue->num, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Distribution_WindowType_repeatType (OSCTXT* pctxt, 
   Distribution_WindowType_repeatType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      stat = rtXmlEncIntAttr
         (pctxt, pvalue->num, OSUTF8("Num"), 3);

      stat = rtXmlEncIntAttr
         (pctxt, pvalue->unit, OSUTF8("Unit"), 4);

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Distribution_WindowType                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Distribution_WindowType (OSCTXT* pctxt,
   Distribution_WindowType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode repeatType */

   if (pvalue->m.repeatTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Distribution_WindowType_repeatType (pctxt, &pvalue->repeatType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode duration */

   if (pvalue->m.durationPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_integer (pctxt, &pvalue->duration, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode distribution_Start_Time */

   if (pvalue->m.distribution_Start_TimePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_unsigned (pctxt, &pvalue->distribution_Start_Time, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode distribution_End_Time */

   if (pvalue->m.distribution_End_TimePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_unsigned (pctxt, &pvalue->distribution_End_Time, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode dWid */

   if (pvalue->m.dWidPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_integer (pctxt, &pvalue->dWid, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Distribution_WindowType (OSCTXT* pctxt, 
   Distribution_WindowType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      if (pvalue->m.dWidPresent) {
         stat = rtXmlEncIntAttr
            (pctxt, pvalue->dWid, OSUTF8("DWid"), 4);
      }

      if (pvalue->m.distribution_End_TimePresent) {
         stat = rtXmlEncUIntAttr
            (pctxt, pvalue->distribution_End_Time
               , OSUTF8("Distribution_End_Time"), 21);
      }

      if (pvalue->m.distribution_Start_TimePresent) {
         stat = rtXmlEncUIntAttr
            (pctxt, pvalue->distribution_Start_Time
               , OSUTF8("Distribution_Start_Time"), 23);
      }

      if (pvalue->m.durationPresent) {
         stat = rtXmlEncIntAttr
            (pctxt, pvalue->duration, OSUTF8("Duration"), 8);
      }

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode repeatType */

   if (pvalue->m.repeatTypePresent) {
      stat = XmlEnc_Distribution_WindowType_repeatType (pctxt, &pvalue->
         repeatType, OSUTF8("RepeatType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ScheduleType_interactivityDataIDRef                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ScheduleType_interactivityDataIDRef (OSCTXT* pctxt,
   ScheduleType_interactivityDataIDRef *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode distribution_Window_list */

   pnode2 = pvalue->distribution_Window_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Distribution_WindowType (pctxt, ((Distribution_WindowType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode idRef */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->idRef, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode autoStart */

   if (pvalue->m.autoStartPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_boolean (pctxt, &pvalue->autoStart, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ScheduleType_interactivityDataIDRef (OSCTXT* pctxt, 
   ScheduleType_interactivityDataIDRef* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      if (pvalue->m.autoStartPresent) {
         stat = rtXmlEncBoolAttr (pctxt, pvalue->autoStart
            , OSUTF8("AutoStart"), 9);
      }

      OSRTSAFEMEMCPY (pctxt, OSUTF8(" idRef=\""), 8);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->idRef, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode distribution_Window_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->distribution_Window_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Distribution_WindowType (pctxt, 
         ((Distribution_WindowType*)pnode->data)
         , OSUTF8("Distribution_Window"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Presentation_WindowType_repeatType                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Presentation_WindowType_repeatType (OSCTXT* pctxt,
   Presentation_WindowType_repeatType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode unit */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_integer (pctxt, &pvalue->unit, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode num */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_integer (pctxt, &pvalue->num, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Presentation_WindowType_repeatType (OSCTXT* pctxt, 
   Presentation_WindowType_repeatType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      stat = rtXmlEncIntAttr
         (pctxt, pvalue->num, OSUTF8("Num"), 3);

      stat = rtXmlEncIntAttr
         (pctxt, pvalue->unit, OSUTF8("Unit"), 4);

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Presentation_WindowType                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Presentation_WindowType (OSCTXT* pctxt,
   Presentation_WindowType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode repeatType */

   if (pvalue->m.repeatTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_Presentation_WindowType_repeatType (pctxt, &pvalue->repeatType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode presentation_Start_Time */

   if (pvalue->m.presentation_Start_TimePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         asn1E_RelativeDateType (pctxt, &pvalue->presentation_Start_Time, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode presentation_End_Time */

   if (pvalue->m.presentation_End_TimePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         asn1E_RelativeDateType (pctxt, &pvalue->presentation_End_Time, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode pWid */

   if (pvalue->m.pWidPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_integer (pctxt, &pvalue->pWid, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode duration */

   if (pvalue->m.durationPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_integer (pctxt, &pvalue->duration, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Presentation_WindowType (OSCTXT* pctxt, 
   Presentation_WindowType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      if (pvalue->m.durationPresent) {
         stat = rtXmlEncIntAttr
            (pctxt, pvalue->duration, OSUTF8("Duration"), 8);
      }

      if (pvalue->m.pWidPresent) {
         stat = rtXmlEncIntAttr
            (pctxt, pvalue->pWid, OSUTF8("PWid"), 4);
      }

      if (pvalue->m.presentation_End_TimePresent) {
         OSRTSAFEMEMCPY (pctxt, OSUTF8(" Presentation_End_Time=\""), 24);

         stat = XmlEnc_RelativeDateType (pctxt, pvalue->presentation_End_Time
            , 0, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         OSRTSAFEPUTCHAR (pctxt, '"');
      }

      if (pvalue->m.presentation_Start_TimePresent) {
         OSRTSAFEMEMCPY (pctxt, OSUTF8(" Presentation_Start_Time=\""), 26);

         stat = XmlEnc_RelativeDateType (pctxt, pvalue->presentation_Start_Time
            , 0, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         OSRTSAFEPUTCHAR (pctxt, '"');
      }

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode repeatType */

   if (pvalue->m.repeatTypePresent) {
      stat = XmlEnc_Presentation_WindowType_repeatType (pctxt, &pvalue->
         repeatType, OSUTF8("RepeatType"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ScheduleType_contentIDRef                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ScheduleType_contentIDRef (OSCTXT* pctxt,
   ScheduleType_contentIDRef *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode presentation_Window_list */

   pnode2 = pvalue->presentation_Window_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Presentation_WindowType (pctxt, ((Presentation_WindowType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode distribution_Window_list */

   pnode2 = pvalue->distribution_Window_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Distribution_WindowType (pctxt, ((Distribution_WindowType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode idRef */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      asn1E_ContentIDType (pctxt, pvalue->idRef, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode repeatPlayback */

   if (pvalue->m.repeatPlaybackPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_boolean (pctxt, &pvalue->repeatPlayback, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode autoStart */

   if (pvalue->m.autoStartPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_boolean (pctxt, &pvalue->autoStart, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ScheduleType_contentIDRef (OSCTXT* pctxt, 
   ScheduleType_contentIDRef* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      if (pvalue->m.autoStartPresent) {
         stat = rtXmlEncBoolAttr (pctxt, pvalue->autoStart
            , OSUTF8("AutoStart"), 9);
      }

      if (pvalue->m.repeatPlaybackPresent) {
         stat = rtXmlEncBoolAttr (pctxt, pvalue->repeatPlayback
            , OSUTF8("RepeatPlayback"), 14);
      }

      OSRTSAFEMEMCPY (pctxt, OSUTF8(" idRef=\""), 8);

      stat = XmlEnc_ContentIDType (pctxt, pvalue->idRef, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode distribution_Window_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->distribution_Window_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Distribution_WindowType (pctxt, 
         ((Distribution_WindowType*)pnode->data)
         , OSUTF8("Distribution_Window"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode presentation_Window_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->presentation_Window_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Presentation_WindowType (pctxt, 
         ((Presentation_WindowType*)pnode->data)
         , OSUTF8("Presentation_Window"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ScheduleType                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ScheduleType (OSCTXT* pctxt,
   ScheduleType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode previewDataIDRef_list */

   pnode2 = pvalue->previewDataIDRef_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PreviewDataIDRefType (pctxt, ((PreviewDataIDRefType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode description_list */

   pnode2 = pvalue->description_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode name_list */

   pnode2 = pvalue->name_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode extensionURL_list */

   pnode2 = pvalue->extensionURL_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode contentIDRef_list */

   pnode2 = pvalue->contentIDRef_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ScheduleType_contentIDRef (pctxt, ((ScheduleType_contentIDRef*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode interactivityDataIDRef_list */

   pnode2 = pvalue->interactivityDataIDRef_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ScheduleType_interactivityDataIDRef (pctxt, ((ScheduleType_interactivityDataIDRef*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode version */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
      xe_unsigned (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode validTo */

   if (pvalue->m.validToPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_unsigned (pctxt, &pvalue->validTo, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode validFrom */

   if (pvalue->m.validFromPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_unsigned (pctxt, &pvalue->validFrom, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_ScheduleIDType (pctxt, pvalue->id, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode serviceIDRef */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_ServiceIDType (pctxt, pvalue->serviceIDRef, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ScheduleType (OSCTXT* pctxt, ScheduleType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      OSRTSAFEMEMCPY (pctxt, OSUTF8(" ServiceIDRef=\""), 15);

      stat = XmlEnc_ServiceIDType (pctxt, pvalue->serviceIDRef, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');

      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = XmlEnc_ScheduleIDType (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');

      if (pvalue->m.validFromPresent) {
         stat = rtXmlEncUIntAttr
            (pctxt, pvalue->validFrom, OSUTF8("validFrom"), 9);
      }

      if (pvalue->m.validToPresent) {
         stat = rtXmlEncUIntAttr
            (pctxt, pvalue->validTo, OSUTF8("validTo"), 7);
      }

      stat = rtXmlEncUIntAttr
         (pctxt, pvalue->version, OSUTF8("version"), 7);

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode interactivityDataIDRef_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->interactivityDataIDRef_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ScheduleType_interactivityDataIDRef (pctxt, 
         ((ScheduleType_interactivityDataIDRef*)pnode->data)
         , OSUTF8("InteractivityDataIDRef"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode contentIDRef_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->contentIDRef_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ScheduleType_contentIDRef (pctxt, 
         ((ScheduleType_contentIDRef*)pnode->data)
         , OSUTF8("ContentIDRef"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode extensionURL_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->extensionURL_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("ExtensionURL"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode name_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->name_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("Name"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode description_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->description_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("Description"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode previewDataIDRef_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->previewDataIDRef_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PreviewDataIDRefType (pctxt, 
         ((PreviewDataIDRefType*)pnode->data)
         , OSUTF8("PreviewDataIDRef"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FileType                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FileType (OSCTXT* pctxt,
   FileType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode transfer_Length */

   if (pvalue->m.transfer_LengthPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|10,
         xe_uint64 (pctxt, &pvalue->transfer_Length, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode tOI */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|9,
      xe_unsigned (pctxt, &pvalue->tOI, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode fEC_OTI_Maximum_Source_Block_Length */

   if (pvalue->m.fEC_OTI_Maximum_Source_Block_LengthPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|8,
         xe_uint64 (pctxt, &pvalue->fEC_OTI_Maximum_Source_Block_Length, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode fEC_OTI_Max_Number_of_Encoding_Symbols */

   if (pvalue->m.fEC_OTI_Max_Number_of_Encoding_SymbolsPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
         xe_uint64 (pctxt, &pvalue->fEC_OTI_Max_Number_of_Encoding_Symbols, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode fEC_OTI_FEC_Instance_ID */

   if (pvalue->m.fEC_OTI_FEC_Instance_IDPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
         xe_uint64 (pctxt, &pvalue->fEC_OTI_FEC_Instance_ID, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode fEC_OTI_Encoding_Symbol_Length */

   if (pvalue->m.fEC_OTI_Encoding_Symbol_LengthPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
         xe_uint64 (pctxt, &pvalue->fEC_OTI_Encoding_Symbol_Length, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode content_Type */

   if (pvalue->m.content_TypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_utf8str (pctxt, pvalue->content_Type, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode content_MD5 */

   if (pvalue->m.content_MD5Present) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_octstr (pctxt, pvalue->content_MD5.data, pvalue->content_MD5.numocts, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode content_Location */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_utf8str (pctxt, pvalue->content_Location, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode content_Length */

   if (pvalue->m.content_LengthPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_uint64 (pctxt, &pvalue->content_Length, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode content_Encoding */

   if (pvalue->m.content_EncodingPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->content_Encoding, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FileType (OSCTXT* pctxt, FileType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      if (pvalue->m.content_EncodingPresent) {
         OSRTSAFEMEMCPY (pctxt, OSUTF8(" Content-Encoding=\""), 19);

         stat = rtXmlEncUTF8Str (pctxt, pvalue->content_Encoding, 0, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         OSRTSAFEPUTCHAR (pctxt, '\"');
      }

      if (pvalue->m.content_LengthPresent) {
         stat = rtXmlEncUInt64Attr
            (pctxt, pvalue->content_Length, OSUTF8("Content-Length"), 14);
      }

      OSRTSAFEMEMCPY (pctxt, OSUTF8(" Content-Location=\""), 19);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->content_Location, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');

      if (pvalue->m.content_MD5Present) {
         OSRTSAFEMEMCPY (pctxt, OSUTF8(" Content-MD5=\""), 14);

         stat = rtXmlEncBase64Binary
            (pctxt, pvalue->content_MD5.numocts, pvalue->content_MD5.data, 
               0, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         OSRTSAFEPUTCHAR (pctxt, '\"');
      }

      if (pvalue->m.content_TypePresent) {
         OSRTSAFEMEMCPY (pctxt, OSUTF8(" Content-Type=\""), 15);

         stat = rtXmlEncUTF8Str (pctxt, pvalue->content_Type, 0, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         OSRTSAFEPUTCHAR (pctxt, '\"');
      }

      if (pvalue->m.fEC_OTI_Encoding_Symbol_LengthPresent) {
         stat = rtXmlEncUInt64Attr
            (pctxt, pvalue->fEC_OTI_Encoding_Symbol_Length
               , OSUTF8("FEC-OTI-Encoding-Symbol-Length"), 30);
      }

      if (pvalue->m.fEC_OTI_FEC_Instance_IDPresent) {
         stat = rtXmlEncUInt64Attr
            (pctxt, pvalue->fEC_OTI_FEC_Instance_ID
               , OSUTF8("FEC-OTI-FEC-Instance-ID"), 23);
      }

      if (pvalue->m.fEC_OTI_Max_Number_of_Encoding_SymbolsPresent) {
         stat = rtXmlEncUInt64Attr
            (pctxt, pvalue->fEC_OTI_Max_Number_of_Encoding_Symbols
               , OSUTF8("FEC-OTI-Max-Number-of-Encoding-Symbols"), 38);
      }

      if (pvalue->m.fEC_OTI_Maximum_Source_Block_LengthPresent) {
         stat = rtXmlEncUInt64Attr
            (pctxt, pvalue->fEC_OTI_Maximum_Source_Block_Length
               , OSUTF8("FEC-OTI-Maximum-Source-Block-Length"), 35);
      }

      stat = rtXmlEncUIntAttr
         (pctxt, pvalue->tOI, OSUTF8("TOI"), 3);

      if (pvalue->m.transfer_LengthPresent) {
         stat = rtXmlEncUInt64Attr
            (pctxt, pvalue->transfer_Length, OSUTF8("Transfer-Length"), 15);
      }

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FileDescriptionType                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_FileDescriptionType (OSCTXT* pctxt,
   FileDescriptionType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode file_list */

   if (!(pvalue->file_list.count >= 1)) {
      rtxErrAddStrParm (pctxt, "FileDescriptionType.file_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->file_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->file_list.tail;
   while (0 != pnode2) {
      ll = asn1E_FileType (pctxt, ((FileType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode transfer_Length */

   if (pvalue->m.transfer_LengthPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|8,
         xe_uint64 (pctxt, &pvalue->transfer_Length, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode fEC_OTI_Maximum_Source_Block_Length */

   if (pvalue->m.fEC_OTI_Maximum_Source_Block_LengthPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
         xe_uint64 (pctxt, &pvalue->fEC_OTI_Maximum_Source_Block_Length, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode fEC_OTI_Max_Number_of_Encoding_Symbols */

   if (pvalue->m.fEC_OTI_Max_Number_of_Encoding_SymbolsPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
         xe_uint64 (pctxt, &pvalue->fEC_OTI_Max_Number_of_Encoding_Symbols, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode fEC_OTI_FEC_Instance_ID */

   if (pvalue->m.fEC_OTI_FEC_Instance_IDPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
         xe_uint64 (pctxt, &pvalue->fEC_OTI_FEC_Instance_ID, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode fEC_OTI_Encoding_Symbol_Length */

   if (pvalue->m.fEC_OTI_Encoding_Symbol_LengthPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_uint64 (pctxt, &pvalue->fEC_OTI_Encoding_Symbol_Length, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode content_Type */

   if (pvalue->m.content_TypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_utf8str (pctxt, pvalue->content_Type, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode content_MD5 */

   if (pvalue->m.content_MD5Present) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_octstr (pctxt, pvalue->content_MD5.data, pvalue->content_MD5.numocts, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode content_Length */

   if (pvalue->m.content_LengthPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_uint64 (pctxt, &pvalue->content_Length, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode content_Encoding */

   if (pvalue->m.content_EncodingPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->content_Encoding, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_FileDescriptionType (OSCTXT* pctxt, FileDescriptionType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      if (pvalue->m.content_EncodingPresent) {
         OSRTSAFEMEMCPY (pctxt, OSUTF8(" Content-Encoding=\""), 19);

         stat = rtXmlEncUTF8Str (pctxt, pvalue->content_Encoding, 0, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         OSRTSAFEPUTCHAR (pctxt, '\"');
      }

      if (pvalue->m.content_LengthPresent) {
         stat = rtXmlEncUInt64Attr
            (pctxt, pvalue->content_Length, OSUTF8("Content-Length"), 14);
      }

      if (pvalue->m.content_MD5Present) {
         OSRTSAFEMEMCPY (pctxt, OSUTF8(" Content-MD5=\""), 14);

         stat = rtXmlEncBase64Binary
            (pctxt, pvalue->content_MD5.numocts, pvalue->content_MD5.data, 
               0, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         OSRTSAFEPUTCHAR (pctxt, '\"');
      }

      if (pvalue->m.content_TypePresent) {
         OSRTSAFEMEMCPY (pctxt, OSUTF8(" Content-Type=\""), 15);

         stat = rtXmlEncUTF8Str (pctxt, pvalue->content_Type, 0, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         OSRTSAFEPUTCHAR (pctxt, '\"');
      }

      if (pvalue->m.fEC_OTI_Encoding_Symbol_LengthPresent) {
         stat = rtXmlEncUInt64Attr
            (pctxt, pvalue->fEC_OTI_Encoding_Symbol_Length
               , OSUTF8("FEC-OTI-Encoding-Symbol-Length"), 30);
      }

      if (pvalue->m.fEC_OTI_FEC_Instance_IDPresent) {
         stat = rtXmlEncUInt64Attr
            (pctxt, pvalue->fEC_OTI_FEC_Instance_ID
               , OSUTF8("FEC-OTI-FEC-Instance-ID"), 23);
      }

      if (pvalue->m.fEC_OTI_Max_Number_of_Encoding_SymbolsPresent) {
         stat = rtXmlEncUInt64Attr
            (pctxt, pvalue->fEC_OTI_Max_Number_of_Encoding_Symbols
               , OSUTF8("FEC-OTI-Max-Number-of-Encoding-Symbols"), 38);
      }

      if (pvalue->m.fEC_OTI_Maximum_Source_Block_LengthPresent) {
         stat = rtXmlEncUInt64Attr
            (pctxt, pvalue->fEC_OTI_Maximum_Source_Block_Length
               , OSUTF8("FEC-OTI-Maximum-Source-Block-Length"), 35);
      }

      if (pvalue->m.transfer_LengthPresent) {
         stat = rtXmlEncUInt64Attr
            (pctxt, pvalue->transfer_Length, OSUTF8("Transfer-Length"), 15);
      }

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode file_list */

   if (!(pvalue->file_list.count >= 1)) {
      rtxErrAddStrParm (pctxt, "FileDescriptionType.file_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->file_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->file_list.head;
   while (0 != pnode) {
      stat = XmlEnc_FileType (pctxt, ((FileType*)pnode->data)
         , OSUTF8("File"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ContentType                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ContentType (OSCTXT* pctxt,
   ContentType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode fileDescription */

   if (pvalue->m.fileDescriptionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|15,
         asn1E_FileDescriptionType (pctxt, &pvalue->fileDescription, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode broadcast_area */

   if (pvalue->m.broadcast_areaPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|14,
         asn1E_Broadcast_areaType (pctxt, &pvalue->broadcast_area, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode previewDataIDRef_list */

   pnode2 = pvalue->previewDataIDRef_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PreviewDataIDRefType (pctxt, ((PreviewDataIDRefType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|13, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode userRating */

   if (pvalue->m.userRatingPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|12,
         xe_integer (pctxt, &pvalue->userRating, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode genre_list */

   pnode2 = pvalue->genre_list.tail;
   while (0 != pnode2) {
      ll = asn1E_GenreElementType (pctxt, ((GenreElementType)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|11, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode targetUserProfile */

   if (pvalue->m.targetUserProfilePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10,
         asn1E_TargetUserProfileType (pctxt, &pvalue->targetUserProfile, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode parentalRating_list */

   pnode2 = pvalue->parentalRating_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode description_list */

   pnode2 = pvalue->description_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode name_list */

   if (!(pvalue->name_list.count >= 1)) {
      rtxErrAddStrParm (pctxt, "ContentType.name_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->name_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->name_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode extensionURL_list */

   pnode2 = pvalue->extensionURL_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode version */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
      xe_unsigned (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode validTo */

   if (pvalue->m.validToPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_unsigned (pctxt, &pvalue->validTo, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode validFrom */

   if (pvalue->m.validFromPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_unsigned (pctxt, &pvalue->validFrom, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      asn1E_ContentIDType (pctxt, pvalue->id, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode serviceIDRef */

   if (pvalue->m.serviceIDRefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         asn1E_ServiceIDType (pctxt, pvalue->serviceIDRef, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode contentType */

   if (pvalue->m.contentTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->contentType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ContentType (OSCTXT* pctxt, ContentType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      if (pvalue->m.contentTypePresent) {
         OSRTSAFEMEMCPY (pctxt, OSUTF8(" ContentType=\""), 14);

         stat = rtXmlEncUTF8Str (pctxt, pvalue->contentType, 0, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         OSRTSAFEPUTCHAR (pctxt, '\"');
      }

      if (pvalue->m.serviceIDRefPresent) {
         OSRTSAFEMEMCPY (pctxt, OSUTF8(" ServiceIDRef=\""), 15);

         stat = XmlEnc_ServiceIDType (pctxt, pvalue->serviceIDRef, 0, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         OSRTSAFEPUTCHAR (pctxt, '"');
      }

      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = XmlEnc_ContentIDType (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');

      if (pvalue->m.validFromPresent) {
         stat = rtXmlEncUIntAttr
            (pctxt, pvalue->validFrom, OSUTF8("validFrom"), 9);
      }

      if (pvalue->m.validToPresent) {
         stat = rtXmlEncUIntAttr
            (pctxt, pvalue->validTo, OSUTF8("validTo"), 7);
      }

      stat = rtXmlEncUIntAttr
         (pctxt, pvalue->version, OSUTF8("version"), 7);

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode extensionURL_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->extensionURL_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("ExtensionURL"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode name_list */

   if (!(pvalue->name_list.count >= 1)) {
      rtxErrAddStrParm (pctxt, "ContentType.name_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->name_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->name_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("Name"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode description_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->description_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("Description"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode parentalRating_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->parentalRating_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("ParentalRating"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode targetUserProfile */

   if (pvalue->m.targetUserProfilePresent) {
      stat = XmlEnc_TargetUserProfileType (pctxt, &pvalue->targetUserProfile
         , OSUTF8("TargetUserProfile"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode genre_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->genre_list.head;
   while (0 != pnode) {
      stat = XmlEnc_GenreElementType (pctxt, ((GenreElementType)pnode->data)
         , OSUTF8("Genre"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode userRating */

   if (pvalue->m.userRatingPresent) {
      stat = rtXmlEncInt (pctxt, pvalue->userRating
         , OSUTF8("UserRating"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode previewDataIDRef_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->previewDataIDRef_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PreviewDataIDRefType (pctxt, 
         ((PreviewDataIDRefType*)pnode->data)
         , OSUTF8("PreviewDataIDRef"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode broadcast_area */

   if (pvalue->m.broadcast_areaPresent) {
      stat = XmlEnc_Broadcast_areaType (pctxt, &pvalue->broadcast_area
         , OSUTF8("broadcast_area"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode fileDescription */

   if (pvalue->m.fileDescriptionPresent) {
      stat = XmlEnc_FileDescriptionType (pctxt, &pvalue->fileDescription
         , OSUTF8("FileDescription"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AccessTypeType_broadcastTransmission_sessionDescriptionR  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AccessTypeType_broadcastTransmission_sessionDescriptionReference (OSCTXT* pctxt,
   AccessTypeType_broadcastTransmission_sessionDescriptionReference *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode idRef */

   if (pvalue->m.idRefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->idRef, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode uRI */

   if (pvalue->m.uRIPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->uRI, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode type */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_integer (pctxt, &pvalue->type, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_AccessTypeType_broadcastTransmission_sessionDescriptionReference 
   (OSCTXT* pctxt, 
   AccessTypeType_broadcastTransmission_sessionDescriptionReference* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      stat = rtXmlEncIntAttr
         (pctxt, pvalue->type, OSUTF8("Type"), 4);

      if (pvalue->m.uRIPresent) {
         OSRTSAFEMEMCPY (pctxt, OSUTF8(" URI=\""), 6);

         stat = rtXmlEncUTF8Str (pctxt, pvalue->uRI, 0, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         OSRTSAFEPUTCHAR (pctxt, '\"');
      }

      if (pvalue->m.idRefPresent) {
         OSRTSAFEMEMCPY (pctxt, OSUTF8(" idRef=\""), 8);

         stat = rtXmlEncUTF8Str (pctxt, pvalue->idRef, 0, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         OSRTSAFEPUTCHAR (pctxt, '\"');
      }

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AccessTypeType_broadcastTransmission                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AccessTypeType_broadcastTransmission (OSCTXT* pctxt,
   AccessTypeType_broadcastTransmission *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode sDP */

   if (pvalue->m.sDPPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->sDP, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode sessionDescriptionReference_list */

   pnode2 = pvalue->sessionDescriptionReference_list.tail;
   while (0 != pnode2) {
      ll = asn1E_AccessTypeType_broadcastTransmission_sessionDescriptionReference (pctxt, ((AccessTypeType_broadcastTransmission_sessionDescriptionReference*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode iPAddress */

   if (pvalue->m.iPAddressPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->iPAddress, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_AccessTypeType_broadcastTransmission (OSCTXT* pctxt, 
   AccessTypeType_broadcastTransmission* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      if (pvalue->m.iPAddressPresent) {
         OSRTSAFEMEMCPY (pctxt, OSUTF8(" IPAddress=\""), 12);

         stat = rtXmlEncUTF8Str (pctxt, pvalue->iPAddress, 0, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         OSRTSAFEPUTCHAR (pctxt, '\"');
      }

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode sessionDescriptionReference_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->sessionDescriptionReference_list.head;
   while (0 != pnode) {
      stat = XmlEnc_AccessTypeType_broadcastTransmission_sessionDescriptionReference (pctxt
         , 
         ((AccessTypeType_broadcastTransmission_sessionDescriptionReference*)pnode->data)
         , OSUTF8("SessionDescriptionReference"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode sDP */

   if (pvalue->m.sDPPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->sDP, OSUTF8("SDP"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AccessTypeType_interactiveTransmissionScheme              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AccessTypeType_interactiveTransmissionScheme (OSCTXT* pctxt,
   AccessTypeType_interactiveTransmissionScheme *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;
   int xx2;

   /* encode accessServerPhoneNumber_list */

   for (xx2 = (pvalue->accessServerPhoneNumber_list.n - 1); xx2 >= 0; xx2--)
   {
      ll = xe_integer (pctxt, &pvalue->accessServerPhoneNumber_list.elem[xx2], ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode accessServerURL_list */

   pnode2 = pvalue->accessServerURL_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode accessServerIPAddress_list */

   pnode2 = pvalue->accessServerIPAddress_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode transmissionSchemeType */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_integer (pctxt, &pvalue->transmissionSchemeType, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_AccessTypeType_interactiveTransmissionScheme (OSCTXT* pctxt, 
   AccessTypeType_interactiveTransmissionScheme* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      stat = rtXmlEncIntAttr
         (pctxt, pvalue->transmissionSchemeType
            , OSUTF8("TransmissionSchemeType"), 22);

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode accessServerIPAddress_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->accessServerIPAddress_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("AccessServerIPAddress"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode accessServerURL_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->accessServerURL_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("AccessServerURL"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode accessServerPhoneNumber_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSUINT32 xx1;
   for (xx1 = 0; xx1 < pvalue->accessServerPhoneNumber_list.n; xx1++) {
      stat = rtXmlEncInt (pctxt, pvalue->accessServerPhoneNumber_list.elem[xx1]
         , OSUTF8("AccessServerPhoneNumber"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AccessTypeType                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AccessTypeType (OSCTXT* pctxt,
   AccessTypeType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode interactiveTransmissionScheme */

   if (pvalue->m.interactiveTransmissionSchemePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_AccessTypeType_interactiveTransmissionScheme (pctxt, &pvalue->interactiveTransmissionScheme, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode broadcastTransmission */

   if (pvalue->m.broadcastTransmissionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_AccessTypeType_broadcastTransmission (pctxt, &pvalue->broadcastTransmission, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode transmissionMedia */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_integer (pctxt, &pvalue->transmissionMedia, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_AccessTypeType (OSCTXT* pctxt, AccessTypeType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      stat = rtXmlEncIntAttr
         (pctxt, pvalue->transmissionMedia, OSUTF8("TransmissionMedia"), 17);

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode broadcastTransmission */

   if (pvalue->m.broadcastTransmissionPresent) {
      stat = XmlEnc_AccessTypeType_broadcastTransmission (pctxt, &pvalue->
         broadcastTransmission, OSUTF8("BroadcastTransmission"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode interactiveTransmissionScheme */

   if (pvalue->m.interactiveTransmissionSchemePresent) {
      stat = XmlEnc_AccessTypeType_interactiveTransmissionScheme (pctxt, &
         pvalue->interactiveTransmissionScheme
         , OSUTF8("InteractiveTransmissionScheme"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  KMSType                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_KMSType (OSCTXT* pctxt,
   KMSType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode protectionType */

   if (pvalue->m.protectionTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_integer (pctxt, &pvalue->protectionType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode rightsIssuerURI */

   if (pvalue->m.rightsIssuerURIPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->rightsIssuerURI, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_KMSType (OSCTXT* pctxt, KMSType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      if (pvalue->m.rightsIssuerURIPresent) {
         OSRTSAFEMEMCPY (pctxt, OSUTF8(" RightsIssuerURI=\""), 18);

         stat = rtXmlEncUTF8Str (pctxt, pvalue->rightsIssuerURI, 0, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         OSRTSAFEPUTCHAR (pctxt, '\"');
      }

      if (pvalue->m.protectionTypePresent) {
         stat = rtXmlEncIntAttr
            (pctxt, pvalue->protectionType, OSUTF8("protectionType"), 14);
      }

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AccessType_scheduleIDRef                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AccessType_scheduleIDRef (OSCTXT* pctxt,
   AccessType_scheduleIDRef *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode distributionWindowID */

   if (pvalue->m.distributionWindowIDPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->distributionWindowID, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_AccessType_scheduleIDRef (OSCTXT* pctxt, 
   AccessType_scheduleIDRef* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      if (pvalue->m.distributionWindowIDPresent) {
         OSRTSAFEMEMCPY (pctxt, OSUTF8(" DistributionWindowID=\""), 23);

         stat = rtXmlEncUTF8Str (pctxt, pvalue->distributionWindowID, 0, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         OSRTSAFEPUTCHAR (pctxt, '\"');
      }

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AccessType_choice                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AccessType_choice (OSCTXT* pctxt,
   AccessType_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         pnode2 = pvalue->u.serviceIDRef_list->tail;
         while (0 != pnode2) {
            ll = asn1E_ServiceIDType (pctxt, ((ServiceIDType)pnode2->data), ASN1EXPL);
            if (ll < 0) return LOG_RTERR (pctxt, ll);
            ll2 += ll;

            pnode2 = pnode2->prev;
         }
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else { ll1 += ll; ll2 = 0; }
         break;

      case 2:
         pnode2 = pvalue->u.scheduleIDRef_list->tail;
         while (0 != pnode2) {
            ll = asn1E_AccessType_scheduleIDRef (pctxt, ((AccessType_scheduleIDRef*)pnode2->data), ASN1EXPL);
            if (ll < 0) return LOG_RTERR (pctxt, ll);
            ll2 += ll;

            pnode2 = pnode2->prev;
         }
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else { ll1 += ll; ll2 = 0; }
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_AccessType_choice (OSCTXT* pctxt, AccessType_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   switch (pvalue->t)
   {
      case 1:
         /* encode serviceIDRef_list */

         { const OSUTF8CHAR* savedPrefix = nsPrefix;
         nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
            "urn:oma:bcast:esg:2005"));

         { OSRTDListNode* pnode = pvalue->u.serviceIDRef_list->head;
         while (0 != pnode) {
            stat = XmlEnc_ServiceIDType (pctxt, ((ServiceIDType)pnode->data)
               , OSUTF8("ServiceIDRef"), nsPrefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            pnode = pnode->next;
         }}
         nsPrefix = savedPrefix;
         }

         break;

      case 2:
         /* encode scheduleIDRef_list */

         { const OSUTF8CHAR* savedPrefix = nsPrefix;
         nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
            "urn:oma:bcast:esg:2005"));

         { OSRTDListNode* pnode = pvalue->u.scheduleIDRef_list->head;
         while (0 != pnode) {
            stat = XmlEnc_AccessType_scheduleIDRef (pctxt, 
               ((AccessType_scheduleIDRef*)pnode->data)
               , OSUTF8("ScheduleIDRef"), nsPrefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            pnode = pnode->next;
         }}
         nsPrefix = savedPrefix;
         }

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminalCapabilityRequirementType_video_bitrate           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TerminalCapabilityRequirementType_video_bitrate (OSCTXT* pctxt,
   TerminalCapabilityRequirementType_video_bitrate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode maximum */

   if (pvalue->m.maximumPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_uint16 (pctxt, &pvalue->maximum, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode average */

   if (pvalue->m.averagePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_uint16 (pctxt, &pvalue->average, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TerminalCapabilityRequirementType_video_bitrate (OSCTXT* pctxt, 
   TerminalCapabilityRequirementType_video_bitrate* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      if (pvalue->m.averagePresent) {
         stat = rtXmlEncUIntAttr
            (pctxt, pvalue->average, OSUTF8("average"), 7);
      }

      if (pvalue->m.maximumPresent) {
         stat = rtXmlEncUIntAttr
            (pctxt, pvalue->maximum, OSUTF8("maximum"), 7);
      }

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminalCapabilityRequirementType_video_resolution        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TerminalCapabilityRequirementType_video_resolution (OSCTXT* pctxt,
   TerminalCapabilityRequirementType_video_resolution *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode vertical */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_uint16 (pctxt, &pvalue->vertical, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode horizontal */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_uint16 (pctxt, &pvalue->horizontal, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TerminalCapabilityRequirementType_video_resolution (OSCTXT* pctxt, 
   TerminalCapabilityRequirementType_video_resolution* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      stat = rtXmlEncUIntAttr
         (pctxt, pvalue->horizontal, OSUTF8("horizontal"), 10);

      stat = rtXmlEncUIntAttr
         (pctxt, pvalue->vertical, OSUTF8("vertical"), 8);

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminalCapabilityRequirementType_video                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TerminalCapabilityRequirementType_video (OSCTXT* pctxt,
   TerminalCapabilityRequirementType_video *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode minimumBufferSize */

   if (pvalue->m.minimumBufferSizePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_unsigned (pctxt, &pvalue->minimumBufferSize, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode resolution */

   if (pvalue->m.resolutionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_TerminalCapabilityRequirementType_video_resolution (pctxt, &pvalue->resolution, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bitrate */

   if (pvalue->m.bitratePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_TerminalCapabilityRequirementType_video_bitrate (pctxt, &pvalue->bitrate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TerminalCapabilityRequirementType_video (OSCTXT* pctxt, 
   TerminalCapabilityRequirementType_video* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   stat = rtXmlEncStartElement (pctxt, OSUTF8("Complexity"), nsPrefix, TRUE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode bitrate */

   if (pvalue->m.bitratePresent) {
      stat = XmlEnc_TerminalCapabilityRequirementType_video_bitrate (pctxt, &
         pvalue->bitrate, OSUTF8("Bitrate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode resolution */

   if (pvalue->m.resolutionPresent) {
      stat = XmlEnc_TerminalCapabilityRequirementType_video_resolution (pctxt, 
         &pvalue->resolution, OSUTF8("Resolution"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode minimumBufferSize */

   if (pvalue->m.minimumBufferSizePresent) {
      stat = rtXmlEncUInt (pctxt, pvalue->minimumBufferSize
         , OSUTF8("MinimumBufferSize"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, OSUTF8("Complexity"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminalCapabilityRequirementType_audio_bitrate           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TerminalCapabilityRequirementType_audio_bitrate (OSCTXT* pctxt,
   TerminalCapabilityRequirementType_audio_bitrate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode maximum */

   if (pvalue->m.maximumPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_uint16 (pctxt, &pvalue->maximum, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode average */

   if (pvalue->m.averagePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_uint16 (pctxt, &pvalue->average, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TerminalCapabilityRequirementType_audio_bitrate (OSCTXT* pctxt, 
   TerminalCapabilityRequirementType_audio_bitrate* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      if (pvalue->m.averagePresent) {
         stat = rtXmlEncUIntAttr
            (pctxt, pvalue->average, OSUTF8("average"), 7);
      }

      if (pvalue->m.maximumPresent) {
         stat = rtXmlEncUIntAttr
            (pctxt, pvalue->maximum, OSUTF8("maximum"), 7);
      }

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminalCapabilityRequirementType_audio                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TerminalCapabilityRequirementType_audio (OSCTXT* pctxt,
   TerminalCapabilityRequirementType_audio *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode minimumBufferSize */

   if (pvalue->m.minimumBufferSizePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_unsigned (pctxt, &pvalue->minimumBufferSize, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode bitrate */

   if (pvalue->m.bitratePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_TerminalCapabilityRequirementType_audio_bitrate (pctxt, &pvalue->bitrate, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TerminalCapabilityRequirementType_audio (OSCTXT* pctxt, 
   TerminalCapabilityRequirementType_audio* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   stat = rtXmlEncStartElement (pctxt, OSUTF8("Complexity"), nsPrefix, TRUE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode bitrate */

   if (pvalue->m.bitratePresent) {
      stat = XmlEnc_TerminalCapabilityRequirementType_audio_bitrate (pctxt, &
         pvalue->bitrate, OSUTF8("Bitrate"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode minimumBufferSize */

   if (pvalue->m.minimumBufferSizePresent) {
      stat = rtXmlEncUInt (pctxt, pvalue->minimumBufferSize
         , OSUTF8("MinimumBufferSize"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtXmlEncEndElement (pctxt, OSUTF8("Complexity"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminalCapabilityRequirementType                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TerminalCapabilityRequirementType (OSCTXT* pctxt,
   TerminalCapabilityRequirementType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;
   OSRTDListNode* pnode3;
   int ll3 = 0;

   /* encode downloadFile */

   if (pvalue->m.downloadFilePresent) {
      pnode2 = pvalue->downloadFile.tail;
      while (0 != pnode2) {
         pnode3 = ((OSRTDList*)pnode2->data)->tail;
         while (0 != pnode3) {
            ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode3->data), ASN1EXPL);
            if (ll < 0) return LOG_RTERR (pctxt, ll);
            ll3 += ll;

            pnode3 = pnode3->prev;
         }
         ll3 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll3);
         if (ll3 < 0) return LOG_RTERR (pctxt, ll3);

         ll = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll3);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else { ll2 += ll; ll3 = 0; }

         pnode2 = pnode2->prev;
      }
      ll2 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
      if (ll2 < 0) return LOG_RTERR (pctxt, ll2);

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      else { ll1 += ll; ll2 = 0; }
   }
   /* encode audio */

   if (pvalue->m.audioPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_TerminalCapabilityRequirementType_audio (pctxt, &pvalue->audio, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode video */

   if (pvalue->m.videoPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_TerminalCapabilityRequirementType_video (pctxt, &pvalue->video, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TerminalCapabilityRequirementType (OSCTXT* pctxt, 
   TerminalCapabilityRequirementType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode video */

   if (pvalue->m.videoPresent) {
      stat = XmlEnc_TerminalCapabilityRequirementType_video (pctxt, &pvalue->
         video, OSUTF8("Video"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode audio */

   if (pvalue->m.audioPresent) {
      stat = XmlEnc_TerminalCapabilityRequirementType_audio (pctxt, &pvalue->
         audio, OSUTF8("Audio"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode downloadFile */

   if (pvalue->m.downloadFilePresent) {
      stat = rtXmlEncStartElement (pctxt, OSUTF8("DownloadFile"), nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      { const OSUTF8CHAR* savedPrefix = nsPrefix;
      nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

      { OSRTDListNode* pnode = pvalue->downloadFile.head;
      while (0 != pnode) {
         stat = rtXmlEncStartElement (pctxt, OSUTF8("MIMETypeSet"), nsPrefix, TRUE);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { const OSUTF8CHAR* savedPrefix = nsPrefix;
         nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
            "urn:oma:bcast:esg:2005"));

         { OSRTDListNode* pnode = ((OSRTDList*)pnode->data)->head;
         while (0 != pnode) {
            stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
               , OSUTF8("Type"), nsPrefix);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            pnode = pnode->next;
         }}
         nsPrefix = savedPrefix;
         }

         stat = rtXmlEncEndElement (pctxt, OSUTF8("MIMETypeSet"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         pnode = pnode->next;
      }}
      nsPrefix = savedPrefix;
      }

      stat = rtXmlEncEndElement (pctxt, OSUTF8("DownloadFile"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NotificationReceptionType                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_NotificationReceptionType (OSCTXT* pctxt,
   NotificationReceptionType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode notificationPort */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_integer (pctxt, &pvalue->notificationPort, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode notificationAddress */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->notificationAddress, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_NotificationReceptionType (OSCTXT* pctxt, 
   NotificationReceptionType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      OSRTSAFEMEMCPY (pctxt, OSUTF8(" NotificationAddress=\""), 22);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->notificationAddress, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');

      stat = rtXmlEncIntAttr
         (pctxt, pvalue->notificationPort, OSUTF8("NotificationPort"), 16);

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AccessType                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AccessType (OSCTXT* pctxt,
   AccessType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode notificationReception */

   if (pvalue->m.notificationReceptionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|16,
         asn1E_NotificationReceptionType (pctxt, &pvalue->notificationReception, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode previewDataIDRef_list */

   pnode2 = pvalue->previewDataIDRef_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PreviewDataIDRefType (pctxt, ((PreviewDataIDRefType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|15, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode serviceClass_list */

   if (!(pvalue->serviceClass_list.count >= 1)) {
      rtxErrAddStrParm (pctxt, "AccessType.serviceClass_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->serviceClass_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->serviceClass_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|14, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode bandwidthRequirement */

   if (pvalue->m.bandwidthRequirementPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|13,
         xe_integer (pctxt, &pvalue->bandwidthRequirement, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode terminalCapabilityRequirement */

   if (pvalue->m.terminalCapabilityRequirementPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|12,
         asn1E_TerminalCapabilityRequirementType (pctxt, &pvalue->terminalCapabilityRequirement, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode alternativeAccessURL_list */

   pnode2 = pvalue->alternativeAccessURL_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|11, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode usageInfo_list */

   pnode2 = pvalue->usageInfo_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode choice */

   if (pvalue->m.choicePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9,
         asn1E_AccessType_choice (pctxt, &pvalue->choice, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode extensionURL_list */

   pnode2 = pvalue->extensionURL_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode keyManagementSystem_list */

   pnode2 = pvalue->keyManagementSystem_list.tail;
   while (0 != pnode2) {
      ll = asn1E_KMSType (pctxt, ((KMSType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode accessType */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_AccessTypeType (pctxt, &pvalue->accessType, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode version */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
      xe_unsigned (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode validTo */

   if (pvalue->m.validToPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_unsigned (pctxt, &pvalue->validTo, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode validFrom */

   if (pvalue->m.validFromPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_unsigned (pctxt, &pvalue->validFrom, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      asn1E_AccessIDType (pctxt, pvalue->id, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode serviceProtection */

   if (pvalue->m.serviceProtectionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_boolean (pctxt, &pvalue->serviceProtection, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode audioLanguage */

   if (pvalue->m.audioLanguagePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->audioLanguage, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_AccessType (OSCTXT* pctxt, AccessType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      if (pvalue->m.audioLanguagePresent) {
         OSRTSAFEMEMCPY (pctxt, OSUTF8(" AudioLanguage=\""), 16);

         stat = rtXmlEncUTF8Str (pctxt, pvalue->audioLanguage, 0, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         OSRTSAFEPUTCHAR (pctxt, '\"');
      }

      if (pvalue->m.serviceProtectionPresent) {
         stat = rtXmlEncBoolAttr (pctxt, pvalue->serviceProtection
            , OSUTF8("ServiceProtection"), 17);
      }

      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = XmlEnc_AccessIDType (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');

      if (pvalue->m.validFromPresent) {
         stat = rtXmlEncUIntAttr
            (pctxt, pvalue->validFrom, OSUTF8("validFrom"), 9);
      }

      if (pvalue->m.validToPresent) {
         stat = rtXmlEncUIntAttr
            (pctxt, pvalue->validTo, OSUTF8("validTo"), 7);
      }

      stat = rtXmlEncUIntAttr
         (pctxt, pvalue->version, OSUTF8("version"), 7);

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode accessType */

   stat = XmlEnc_AccessTypeType (pctxt, &pvalue->accessType
      , OSUTF8("AccessType"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode keyManagementSystem_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->keyManagementSystem_list.head;
   while (0 != pnode) {
      stat = XmlEnc_KMSType (pctxt, ((KMSType*)pnode->data)
         , OSUTF8("KeyManagementSystem"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode extensionURL_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->extensionURL_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("ExtensionURL"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode choice */

   if (pvalue->m.choicePresent) {
      stat = XmlEnc_AccessType_choice (pctxt, &pvalue->choice, OSUTF8(""), 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode usageInfo_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->usageInfo_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("UsageInfo"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode alternativeAccessURL_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->alternativeAccessURL_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("AlternativeAccessURL"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode terminalCapabilityRequirement */

   if (pvalue->m.terminalCapabilityRequirementPresent) {
      stat = XmlEnc_TerminalCapabilityRequirementType (pctxt, &pvalue->
         terminalCapabilityRequirement
         , OSUTF8("TerminalCapabilityRequirement"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode bandwidthRequirement */

   if (pvalue->m.bandwidthRequirementPresent) {
      stat = rtXmlEncInt (pctxt, pvalue->bandwidthRequirement
         , OSUTF8("BandwidthRequirement"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode serviceClass_list */

   if (!(pvalue->serviceClass_list.count >= 1)) {
      rtxErrAddStrParm (pctxt, "AccessType.serviceClass_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->serviceClass_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->serviceClass_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("ServiceClass"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode previewDataIDRef_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->previewDataIDRef_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PreviewDataIDRefType (pctxt, 
         ((PreviewDataIDRefType*)pnode->data)
         , OSUTF8("PreviewDataIDRef"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode notificationReception */

   if (pvalue->m.notificationReceptionPresent) {
      stat = XmlEnc_NotificationReceptionType (pctxt, &pvalue->
         notificationReception, OSUTF8("NotificationReception"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PictureType                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PictureType (OSCTXT* pctxt,
   PictureType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode alternativeText */

   if (pvalue->m.alternativeTextPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         asn1E_TextType (pctxt, pvalue->alternativeText, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode codec */

   if (pvalue->m.codecPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_integer (pctxt, &pvalue->codec, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode pictureData */

   if (pvalue->m.pictureDataPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_octstr (pctxt, pvalue->pictureData.data, pvalue->pictureData.numocts, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode pictureURI */

   if (pvalue->m.pictureURIPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->pictureURI, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PictureType (OSCTXT* pctxt, PictureType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode pictureURI */

   if (pvalue->m.pictureURIPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->pictureURI
         , OSUTF8("PictureURI"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode pictureData */

   if (pvalue->m.pictureDataPresent) {
      stat = rtXmlEncBase64Binary
         (pctxt, pvalue->pictureData.numocts, pvalue->pictureData.data, 
            OSUTF8("PictureData"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode codec */

   if (pvalue->m.codecPresent) {
      stat = rtXmlEncInt (pctxt, pvalue->codec, OSUTF8("Codec"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode alternativeText */

   if (pvalue->m.alternativeTextPresent) {
      stat = XmlEnc_TextType (pctxt, pvalue->alternativeText
         , OSUTF8("AlternativeText"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VideoType                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_VideoType (OSCTXT* pctxt,
   VideoType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode alternativePicture */

   if (pvalue->m.alternativePicturePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_PictureType (pctxt, &pvalue->alternativePicture, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode alternativeText */

   if (pvalue->m.alternativeTextPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         asn1E_TextType (pctxt, pvalue->alternativeText, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode codec */

   if (pvalue->m.codecPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_integer (pctxt, &pvalue->codec, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode videoURI */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->videoURI, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_VideoType (OSCTXT* pctxt, VideoType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode videoURI */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->videoURI
      , OSUTF8("VideoURI"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode codec */

   if (pvalue->m.codecPresent) {
      stat = rtXmlEncInt (pctxt, pvalue->codec, OSUTF8("Codec"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode alternativeText */

   if (pvalue->m.alternativeTextPresent) {
      stat = XmlEnc_TextType (pctxt, pvalue->alternativeText
         , OSUTF8("AlternativeText"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode alternativePicture */

   if (pvalue->m.alternativePicturePresent) {
      stat = XmlEnc_PictureType (pctxt, &pvalue->alternativePicture
         , OSUTF8("AlternativePicture"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AudioType                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_AudioType (OSCTXT* pctxt,
   AudioType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode alternativePicture */

   if (pvalue->m.alternativePicturePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_PictureType (pctxt, &pvalue->alternativePicture, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode alternativeText */

   if (pvalue->m.alternativeTextPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         asn1E_TextType (pctxt, pvalue->alternativeText, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode codec */

   if (pvalue->m.codecPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_integer (pctxt, &pvalue->codec, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode audioURI */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->audioURI, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_AudioType (OSCTXT* pctxt, AudioType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode audioURI */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->audioURI
      , OSUTF8("AudioURI"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode codec */

   if (pvalue->m.codecPresent) {
      stat = rtXmlEncInt (pctxt, pvalue->codec, OSUTF8("Codec"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode alternativeText */

   if (pvalue->m.alternativeTextPresent) {
      stat = XmlEnc_TextType (pctxt, pvalue->alternativeText
         , OSUTF8("AlternativeText"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode alternativePicture */

   if (pvalue->m.alternativePicturePresent) {
      stat = XmlEnc_PictureType (pctxt, &pvalue->alternativePicture
         , OSUTF8("AlternativePicture"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PreviewDataType                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PreviewDataType (OSCTXT* pctxt,
   PreviewDataType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode accessIDRef */

   if (pvalue->m.accessIDRefPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|9,
         asn1E_AccessIDType (pctxt, pvalue->accessIDRef, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode text */

   if (pvalue->m.textPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|8,
         asn1E_TextType (pctxt, pvalue->text, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode picture */

   if (pvalue->m.picturePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7,
         asn1E_PictureType (pctxt, &pvalue->picture, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode audio */

   if (pvalue->m.audioPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_AudioType (pctxt, &pvalue->audio, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode video */

   if (pvalue->m.videoPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_VideoType (pctxt, &pvalue->video, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode sMIL */

   if (pvalue->m.sMILPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_utf8str (pctxt, pvalue->sMIL, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode version */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
      xe_unsigned (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode validTo */

   if (pvalue->m.validToPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_integer (pctxt, &pvalue->validTo, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode validFrom */

   if (pvalue->m.validFromPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_integer (pctxt, &pvalue->validFrom, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_PreviewDataIDType (pctxt, pvalue->id, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PreviewDataType (OSCTXT* pctxt, PreviewDataType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = XmlEnc_PreviewDataIDType (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');

      if (pvalue->m.validFromPresent) {
         stat = rtXmlEncIntAttr
            (pctxt, pvalue->validFrom, OSUTF8("validFrom"), 9);
      }

      if (pvalue->m.validToPresent) {
         stat = rtXmlEncIntAttr
            (pctxt, pvalue->validTo, OSUTF8("validTo"), 7);
      }

      stat = rtXmlEncUIntAttr
         (pctxt, pvalue->version, OSUTF8("version"), 7);

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode sMIL */

   if (pvalue->m.sMILPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->sMIL, OSUTF8("SMIL"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode video */

   if (pvalue->m.videoPresent) {
      stat = XmlEnc_VideoType (pctxt, &pvalue->video
         , OSUTF8("Video"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode audio */

   if (pvalue->m.audioPresent) {
      stat = XmlEnc_AudioType (pctxt, &pvalue->audio
         , OSUTF8("Audio"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode picture */

   if (pvalue->m.picturePresent) {
      stat = XmlEnc_PictureType (pctxt, &pvalue->picture
         , OSUTF8("Picture"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode text */

   if (pvalue->m.textPresent) {
      stat = XmlEnc_TextType (pctxt, pvalue->text, OSUTF8("Text"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode accessIDRef */

   if (pvalue->m.accessIDRefPresent) {
      stat = XmlEnc_AccessIDType (pctxt, pvalue->accessIDRef
         , OSUTF8("AccessIDRef"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseItemType                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PurchaseItemType (OSCTXT* pctxt,
   PurchaseItemType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode purchaseDataIDRef_list */

   pnode2 = pvalue->purchaseDataIDRef_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|12, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode parentalRating */

   if (pvalue->m.parentalRatingPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|11,
         xe_integer (pctxt, &pvalue->parentalRating, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode description_list */

   pnode2 = pvalue->description_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode name_list */

   if (!(pvalue->name_list.count >= 1)) {
      rtxErrAddStrParm (pctxt, "PurchaseItemType.name_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->name_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->name_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode contentIDRef_list */

   pnode2 = pvalue->contentIDRef_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode scheduleIDRef_list */

   pnode2 = pvalue->scheduleIDRef_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ScheduleIDType (pctxt, ((ScheduleIDType)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode serviceIDRef_list */

   pnode2 = pvalue->serviceIDRef_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode extensionURL_list */

   pnode2 = pvalue->extensionURL_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode version */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
      xe_unsigned (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode validTo */

   if (pvalue->m.validToPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_unsigned (pctxt, &pvalue->validTo, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode validFrom */

   if (pvalue->m.validFromPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_unsigned (pctxt, &pvalue->validFrom, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode weight */

   if (pvalue->m.weightPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_unsigned (pctxt, &pvalue->weight, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PurchaseItemType (OSCTXT* pctxt, PurchaseItemType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      if (pvalue->m.weightPresent) {
         stat = rtXmlEncUIntAttr
            (pctxt, pvalue->weight, OSUTF8("Weight"), 6);
      }

      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');

      if (pvalue->m.validFromPresent) {
         stat = rtXmlEncUIntAttr
            (pctxt, pvalue->validFrom, OSUTF8("validFrom"), 9);
      }

      if (pvalue->m.validToPresent) {
         stat = rtXmlEncUIntAttr
            (pctxt, pvalue->validTo, OSUTF8("validTo"), 7);
      }

      stat = rtXmlEncUIntAttr
         (pctxt, pvalue->version, OSUTF8("version"), 7);

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode extensionURL_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->extensionURL_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("ExtensionURL"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode serviceIDRef_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->serviceIDRef_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("ServiceIDRef"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode scheduleIDRef_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->scheduleIDRef_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ScheduleIDType (pctxt, ((ScheduleIDType)pnode->data)
         , OSUTF8("ScheduleIDRef"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode contentIDRef_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->contentIDRef_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("ContentIDRef"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode name_list */

   if (!(pvalue->name_list.count >= 1)) {
      rtxErrAddStrParm (pctxt, "PurchaseItemType.name_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->name_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->name_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("Name"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode description_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->description_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("Description"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode parentalRating */

   if (pvalue->m.parentalRatingPresent) {
      stat = rtXmlEncInt (pctxt, pvalue->parentalRating
         , OSUTF8("ParentalRating"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode purchaseDataIDRef_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->purchaseDataIDRef_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("PurchaseDataIDRef"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseDataType_priceInfo_subscriptionUnit               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PurchaseDataType_priceInfo_subscriptionUnit (OSCTXT* pctxt,
   PurchaseDataType_priceInfo_subscriptionUnit *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode value */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_integer (pctxt, &pvalue->value, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode unit */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_integer (pctxt, &pvalue->unit, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode type */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_integer (pctxt, &pvalue->type, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PurchaseDataType_priceInfo_subscriptionUnit (OSCTXT* pctxt, 
   PurchaseDataType_priceInfo_subscriptionUnit* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      stat = rtXmlEncIntAttr
         (pctxt, pvalue->type, OSUTF8("Type"), 4);

      stat = rtXmlEncIntAttr
         (pctxt, pvalue->unit, OSUTF8("Unit"), 4);

      stat = rtXmlEncIntAttr
         (pctxt, pvalue->value, OSUTF8("Value"), 5);

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseDataType_priceInfo_price                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PurchaseDataType_priceInfo_price (OSCTXT* pctxt,
   PurchaseDataType_priceInfo_price *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode value */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_integer (pctxt, &pvalue->value, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode currency */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->currency, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PurchaseDataType_priceInfo_price (OSCTXT* pctxt, 
   PurchaseDataType_priceInfo_price* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      OSRTSAFEMEMCPY (pctxt, OSUTF8(" Currency=\""), 11);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->currency, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');

      stat = rtXmlEncIntAttr
         (pctxt, pvalue->value, OSUTF8("Value"), 5);

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseDataType_priceInfo                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PurchaseDataType_priceInfo (OSCTXT* pctxt,
   PurchaseDataType_priceInfo *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode price_list */

   pnode2 = pvalue->price_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PurchaseDataType_priceInfo_price (pctxt, ((PurchaseDataType_priceInfo_price*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode unitText */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->unitText, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode subscriptionUnit */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_PurchaseDataType_priceInfo_subscriptionUnit (pctxt, &pvalue->subscriptionUnit, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PurchaseDataType_priceInfo (OSCTXT* pctxt, 
   PurchaseDataType_priceInfo* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode subscriptionUnit */

   stat = XmlEnc_PurchaseDataType_priceInfo_subscriptionUnit (pctxt, &pvalue->
      subscriptionUnit, OSUTF8("SubscriptionUnit"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode unitText */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->unitText
      , OSUTF8("UnitText"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode price_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->price_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PurchaseDataType_priceInfo_price (pctxt, 
         ((PurchaseDataType_priceInfo_price*)pnode->data)
         , OSUTF8("Price"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseDataType_mediaInformation                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PurchaseDataType_mediaInformation (OSCTXT* pctxt,
   PurchaseDataType_mediaInformation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode usage */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_integer (pctxt, &pvalue->usage, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode idRef */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->idRef, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PurchaseDataType_mediaInformation (OSCTXT* pctxt, 
   PurchaseDataType_mediaInformation* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      OSRTSAFEMEMCPY (pctxt, OSUTF8(" idRef=\""), 8);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->idRef, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');

      stat = rtXmlEncIntAttr
         (pctxt, pvalue->usage, OSUTF8("usage"), 5);

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseDataType_promotionInfo                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PurchaseDataType_promotionInfo (OSCTXT* pctxt,
   PurchaseDataType_promotionInfo *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode uRL */

   if (pvalue->m.uRLPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
         xe_utf8str (pctxt, pvalue->uRL, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode description */

   if (pvalue->m.descriptionPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
         xe_utf8str (pctxt, pvalue->description, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode targetUserProfile */

   if (pvalue->m.targetUserProfilePresent) {
      switch (pvalue->targetUserProfile.t) {
      case OSXSDAny_binary:
         ll = xe_OpenType (pctxt, pvalue->targetUserProfile.u.binary->data, 
            pvalue->targetUserProfile.u.binary->numocts);
         if (ll > 0) ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4, ll);
         break;
      case OSXSDAny_xmlText:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
            xe_utf8str (pctxt, pvalue->targetUserProfile.
            u.xmlText, ASN1IMPL));
         break;
      }
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      else ll1 += ll;
   }
   /* encode title */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
      xe_utf8str (pctxt, pvalue->title, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode validTo */

   if (pvalue->m.validToPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_unsigned (pctxt, &pvalue->validTo, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode validFrom */

   if (pvalue->m.validFromPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_unsigned (pctxt, &pvalue->validFrom, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_unsigned (pctxt, &pvalue->id, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PurchaseDataType_promotionInfo (OSCTXT* pctxt, 
   PurchaseDataType_promotionInfo* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      stat = rtXmlEncUIntAttr
         (pctxt, pvalue->id, OSUTF8("id"), 2);

      if (pvalue->m.validFromPresent) {
         stat = rtXmlEncUIntAttr
            (pctxt, pvalue->validFrom, OSUTF8("validFrom"), 9);
      }

      if (pvalue->m.validToPresent) {
         stat = rtXmlEncUIntAttr
            (pctxt, pvalue->validTo, OSUTF8("validTo"), 7);
      }

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode title */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->title, OSUTF8("Title"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode targetUserProfile */

   if (pvalue->m.targetUserProfilePresent) {
      if (pvalue->targetUserProfile.t == OSXSDAny_xmlText) {
         stat = rtXmlEncAnyStr (pctxt, pvalue->targetUserProfile.u.xmlText
            , OSUTF8(""), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->targetUserProfile.t);
         rtxErrAddStrParm (pctxt, buf);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   /* encode description */

   if (pvalue->m.descriptionPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->description
         , OSUTF8("Description"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode uRL */

   if (pvalue->m.uRLPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->uRL, OSUTF8("URL"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseDataType                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PurchaseDataType (OSCTXT* pctxt,
   PurchaseDataType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode promotionInfo_list */

   pnode2 = pvalue->promotionInfo_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PurchaseDataType_promotionInfo (pctxt, ((PurchaseDataType_promotionInfo*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode mediaInformation_list */

   pnode2 = pvalue->mediaInformation_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PurchaseDataType_mediaInformation (pctxt, ((PurchaseDataType_mediaInformation*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode priceInfo_list */

   if (!(pvalue->priceInfo_list.count >= 1)) {
      rtxErrAddStrParm (pctxt, "PurchaseDataType.priceInfo_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->priceInfo_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->priceInfo_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PurchaseDataType_priceInfo (pctxt, ((PurchaseDataType_priceInfo*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode purchaseChannelIDRef_list */

   if (!(pvalue->purchaseChannelIDRef_list.count >= 1)) {
      rtxErrAddStrParm (pctxt, "PurchaseDataType.purchaseChannelIDRef_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->purchaseChannelIDRef_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->purchaseChannelIDRef_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode purchaseItemIDRef */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
      xe_utf8str (pctxt, pvalue->purchaseItemIDRef, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode description_list */

   pnode2 = pvalue->description_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode extensionURL_list */

   pnode2 = pvalue->extensionURL_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode version */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
      xe_unsigned (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode validTo */

   if (pvalue->m.validToPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_unsigned (pctxt, &pvalue->validTo, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode validFrom */

   if (pvalue->m.validFromPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_unsigned (pctxt, &pvalue->validFrom, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PurchaseDataType (OSCTXT* pctxt, PurchaseDataType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');

      if (pvalue->m.validFromPresent) {
         stat = rtXmlEncUIntAttr
            (pctxt, pvalue->validFrom, OSUTF8("validFrom"), 9);
      }

      if (pvalue->m.validToPresent) {
         stat = rtXmlEncUIntAttr
            (pctxt, pvalue->validTo, OSUTF8("validTo"), 7);
      }

      stat = rtXmlEncUIntAttr
         (pctxt, pvalue->version, OSUTF8("version"), 7);

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode extensionURL_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->extensionURL_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("ExtensionURL"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode description_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->description_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("Description"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode purchaseItemIDRef */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->purchaseItemIDRef
      , OSUTF8("PurchaseItemIDRef"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode purchaseChannelIDRef_list */

   if (!(pvalue->purchaseChannelIDRef_list.count >= 1)) {
      rtxErrAddStrParm (pctxt, "PurchaseDataType.purchaseChannelIDRef_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->purchaseChannelIDRef_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->purchaseChannelIDRef_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("PurchaseChannelIDRef"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode priceInfo_list */

   if (!(pvalue->priceInfo_list.count >= 1)) {
      rtxErrAddStrParm (pctxt, "PurchaseDataType.priceInfo_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->priceInfo_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->priceInfo_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PurchaseDataType_priceInfo (pctxt, 
         ((PurchaseDataType_priceInfo*)pnode->data)
         , OSUTF8("PriceInfo"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode mediaInformation_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->mediaInformation_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PurchaseDataType_mediaInformation (pctxt, 
         ((PurchaseDataType_mediaInformation*)pnode->data)
         , OSUTF8("MediaInformation"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode promotionInfo_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->promotionInfo_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PurchaseDataType_promotionInfo (pctxt, 
         ((PurchaseDataType_promotionInfo*)pnode->data)
         , OSUTF8("PromotionInfo"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseChannelType_selector                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PurchaseChannelType_selector (OSCTXT* pctxt,
   PurchaseChannelType_selector *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode type */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->type, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PurchaseChannelType_selector (OSCTXT* pctxt, 
   PurchaseChannelType_selector* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      OSRTSAFEMEMCPY (pctxt, OSUTF8(" Type=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->type, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseChannelType_connection_purchaseURL                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PurchaseChannelType_connection_purchaseURL (OSCTXT* pctxt,
   PurchaseChannelType_connection_purchaseURL *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->base, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode bearer */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_integer (pctxt, &pvalue->bearer, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PurchaseChannelType_connection_purchaseURL (OSCTXT* pctxt, 
   PurchaseChannelType_connection_purchaseURL* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      stat = rtXmlEncIntAttr
         (pctxt, pvalue->bearer, OSUTF8("Bearer"), 6);

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode base */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->base, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseChannelType                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PurchaseChannelType (OSCTXT* pctxt,
   PurchaseChannelType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;
   OSRTDListNode* pnode3;
   int ll3 = 0;

   /* encode contactInfo */

   if (pvalue->m.contactInfoPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|12,
         xe_utf8str (pctxt, pvalue->contactInfo, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode connection_list */

   if (!(pvalue->connection_list.count >= 1)) {
      rtxErrAddStrParm (pctxt, "PurchaseChannelType.connection_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->connection_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->connection_list.tail;
   while (0 != pnode2) {
      if (!(((OSRTDList*)pnode2->data)->count >= 1)) {
         rtxErrAddStrParm (pctxt, "<unknown>.count");
         rtxErrAddIntParm (pctxt, (int)((OSRTDList*)pnode2->data)->count);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      pnode3 = ((OSRTDList*)pnode2->data)->tail;
      while (0 != pnode3) {
         ll = asn1E_PurchaseChannelType_connection_purchaseURL (pctxt, ((PurchaseChannelType_connection_purchaseURL*)pnode3->data), ASN1EXPL);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll3 += ll;

         pnode3 = pnode3->prev;
      }
      ll3 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll3);
      if (ll3 < 0) return LOG_RTERR (pctxt, ll3);

      ll = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll3);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      else { ll2 += ll; ll3 = 0; }

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|11, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode description_list */

   pnode2 = pvalue->description_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode portalURL */

   if (pvalue->m.portalURLPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|9,
         xe_utf8str (pctxt, pvalue->portalURL, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode name_list */

   if (!(pvalue->name_list.count >= 1)) {
      rtxErrAddStrParm (pctxt, "PurchaseChannelType.name_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->name_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->name_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode extensionURL_list */

   pnode2 = pvalue->extensionURL_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode selector */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
      asn1E_PurchaseChannelType_selector (pctxt, &pvalue->selector, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode version */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
      xe_unsigned (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode validTo */

   if (pvalue->m.validToPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_unsigned (pctxt, &pvalue->validTo, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode validFrom */

   if (pvalue->m.validFromPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_unsigned (pctxt, &pvalue->validFrom, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode localflag */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      xe_boolean (pctxt, &pvalue->localflag, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode rightsIssuerURI */

   if (pvalue->m.rightsIssuerURIPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->rightsIssuerURI, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PurchaseChannelType (OSCTXT* pctxt, PurchaseChannelType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      if (pvalue->m.rightsIssuerURIPresent) {
         OSRTSAFEMEMCPY (pctxt, OSUTF8(" RightsIssuerURI=\""), 18);

         stat = rtXmlEncUTF8Str (pctxt, pvalue->rightsIssuerURI, 0, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         OSRTSAFEPUTCHAR (pctxt, '\"');
      }

      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');

      stat = rtXmlEncBoolAttr (pctxt, pvalue->localflag
         , OSUTF8("localflag"), 9);

      if (pvalue->m.validFromPresent) {
         stat = rtXmlEncUIntAttr
            (pctxt, pvalue->validFrom, OSUTF8("validFrom"), 9);
      }

      if (pvalue->m.validToPresent) {
         stat = rtXmlEncUIntAttr
            (pctxt, pvalue->validTo, OSUTF8("validTo"), 7);
      }

      stat = rtXmlEncUIntAttr
         (pctxt, pvalue->version, OSUTF8("version"), 7);

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode selector */

   stat = XmlEnc_PurchaseChannelType_selector (pctxt, &pvalue->selector
      , OSUTF8("Selector"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode extensionURL_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->extensionURL_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("ExtensionURL"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode name_list */

   if (!(pvalue->name_list.count >= 1)) {
      rtxErrAddStrParm (pctxt, "PurchaseChannelType.name_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->name_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->name_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("Name"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode portalURL */

   if (pvalue->m.portalURLPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->portalURL
         , OSUTF8("PortalURL"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode description_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->description_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("Description"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode connection_list */

   if (!(pvalue->connection_list.count >= 1)) {
      rtxErrAddStrParm (pctxt, "PurchaseChannelType.connection_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->connection_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->connection_list.head;
   while (0 != pnode) {
      if (!(((OSRTDList*)pnode->data)->count >= 1)) {
         rtxErrAddStrParm (pctxt, "<unknown>.count");
         rtxErrAddIntParm (pctxt, (int)((OSRTDList*)pnode->data)->count);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      stat = rtXmlEncStartElement (pctxt, OSUTF8("Connection"), nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      { const OSUTF8CHAR* savedPrefix = nsPrefix;
      nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

      { OSRTDListNode* pnode = ((OSRTDList*)pnode->data)->head;
      while (0 != pnode) {
         stat = XmlEnc_PurchaseChannelType_connection_purchaseURL (pctxt, 
            ((PurchaseChannelType_connection_purchaseURL*)pnode->data)
            , OSUTF8("PurchaseURL"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         pnode = pnode->next;
      }}
      nsPrefix = savedPrefix;
      }

      stat = rtXmlEncEndElement (pctxt, OSUTF8("Connection"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode contactInfo */

   if (pvalue->m.contactInfoPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->contactInfo
         , OSUTF8("ContactInfo"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ScheduleReferenceType                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ScheduleReferenceType (OSCTXT* pctxt,
   ScheduleReferenceType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   int xx2;
   int ll2 = 0;

   /* encode presentationWindowID_list */

   for (xx2 = (pvalue->presentationWindowID_list.n - 1); xx2 >= 0; xx2--)
   {
      ll = xe_integer (pctxt, &pvalue->presentationWindowID_list.elem[xx2], ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode idRef */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_ScheduleIDType (pctxt, pvalue->idRef, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ScheduleReferenceType (OSCTXT* pctxt, 
   ScheduleReferenceType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      OSRTSAFEMEMCPY (pctxt, OSUTF8(" idRef=\""), 8);

      stat = XmlEnc_ScheduleIDType (pctxt, pvalue->idRef, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode presentationWindowID_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSUINT32 xx1;
   for (xx1 = 0; xx1 < pvalue->presentationWindowID_list.n; xx1++) {
      stat = rtXmlEncInt (pctxt, pvalue->presentationWindowID_list.elem[xx1]
         , OSUTF8("PresentationWindowID"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InteractivityWindowType                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_InteractivityWindowType (OSCTXT* pctxt,
   InteractivityWindowType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode interactivityWindowStartTime */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_RelativeDateType (pctxt, &pvalue->interactivityWindowStartTime, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode interactivityWindowEndTime */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_RelativeDateType (pctxt, &pvalue->interactivityWindowEndTime, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_InteractivityWindowType (OSCTXT* pctxt, 
   InteractivityWindowType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      OSRTSAFEMEMCPY (pctxt, OSUTF8(" InteractivityWindowEndTime=\""), 29);

      stat = XmlEnc_RelativeDateType (pctxt, pvalue->interactivityWindowEndTime
         , 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');

      OSRTSAFEMEMCPY (pctxt, OSUTF8(" InteractivityWindowStartTime=\""), 31);

      stat = XmlEnc_RelativeDateType (pctxt, pvalue->
         interactivityWindowStartTime, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InteractivityDataType                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_InteractivityDataType (OSCTXT* pctxt,
   InteractivityDataType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode extensionURL_list */

   pnode2 = pvalue->extensionURL_list.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|10, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode interactivityWindow_list */

   pnode2 = pvalue->interactivityWindow_list.tail;
   while (0 != pnode2) {
      ll = asn1E_InteractivityWindowType (pctxt, ((InteractivityWindowType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode scheduleReference_list */

   pnode2 = pvalue->scheduleReference_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ScheduleReferenceType (pctxt, ((ScheduleReferenceType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode contentIDRef_list */

   pnode2 = pvalue->contentIDRef_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ContentIDType (pctxt, ((ContentIDType)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode serviceIDRed_list */

   pnode2 = pvalue->serviceIDRed_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ServiceIDType (pctxt, ((ServiceIDType)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode version */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
      xe_unsigned (pctxt, &pvalue->version, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode validTo */

   if (pvalue->m.validToPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_unsigned (pctxt, &pvalue->validTo, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode validFrom */

   if (pvalue->m.validFromPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         xe_unsigned (pctxt, &pvalue->validFrom, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      asn1E_InteractivityDataIDType (pctxt, pvalue->id, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode prelistenIndicator */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_boolean (pctxt, &pvalue->prelistenIndicator, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode interactivityMediaDocumentPointer */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_InteractivityMediaIDType (pctxt, pvalue->interactivityMediaDocumentPointer, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_InteractivityDataType (OSCTXT* pctxt, 
   InteractivityDataType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* add attributes */

      OSRTSAFEMEMCPY (pctxt, OSUTF8(" InteractivityMediaDocumentPointer=\""), 36);

      stat = XmlEnc_InteractivityMediaIDType (pctxt, pvalue->
         interactivityMediaDocumentPointer, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');

      stat = rtXmlEncBoolAttr (pctxt, pvalue->prelistenIndicator
         , OSUTF8("PrelistenIndicator"), 18);

      OSRTSAFEMEMCPY (pctxt, OSUTF8(" id=\""), 5);

      stat = XmlEnc_InteractivityDataIDType (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');

      if (pvalue->m.validFromPresent) {
         stat = rtXmlEncUIntAttr
            (pctxt, pvalue->validFrom, OSUTF8("validFrom"), 9);
      }

      if (pvalue->m.validToPresent) {
         stat = rtXmlEncUIntAttr
            (pctxt, pvalue->validTo, OSUTF8("validTo"), 7);
      }

      stat = rtXmlEncUIntAttr
         (pctxt, pvalue->version, OSUTF8("version"), 7);

      OSRTSAFEPUTCHAR (pctxt, '>');
      pctxt->state = OSXMLSTART;
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode serviceIDRed_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->serviceIDRed_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ServiceIDType (pctxt, ((ServiceIDType)pnode->data)
         , OSUTF8("ServiceIDRed"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode contentIDRef_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->contentIDRef_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ContentIDType (pctxt, ((ContentIDType)pnode->data)
         , OSUTF8("ContentIDRef"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode scheduleReference_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->scheduleReference_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ScheduleReferenceType (pctxt, 
         ((ScheduleReferenceType*)pnode->data)
         , OSUTF8("ScheduleReference"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode interactivityWindow_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->interactivityWindow_list.head;
   while (0 != pnode) {
      stat = XmlEnc_InteractivityWindowType (pctxt, 
         ((InteractivityWindowType*)pnode->data)
         , OSUTF8("InteractivityWindow"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode extensionURL_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->extensionURL_list.head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8("ExtensionURL"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ESGMainBCAST                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ESGMainBCAST (OSCTXT* pctxt,
   ESGMainBCAST *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode interactivityData_list */

   pnode2 = pvalue->interactivityData_list.tail;
   while (0 != pnode2) {
      ll = asn1E_InteractivityDataType (pctxt, ((InteractivityDataType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|8, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode purchaseChannel_list */

   pnode2 = pvalue->purchaseChannel_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PurchaseChannelType (pctxt, ((PurchaseChannelType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|7, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode purchaseData_list */

   pnode2 = pvalue->purchaseData_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PurchaseDataType (pctxt, ((PurchaseDataType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode purchaseItem_list */

   pnode2 = pvalue->purchaseItem_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PurchaseItemType (pctxt, ((PurchaseItemType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode previewData_list */

   pnode2 = pvalue->previewData_list.tail;
   while (0 != pnode2) {
      ll = asn1E_PreviewDataType (pctxt, ((PreviewDataType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode access_list */

   pnode2 = pvalue->access_list.tail;
   while (0 != pnode2) {
      ll = asn1E_AccessType (pctxt, ((AccessType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode content_list */

   pnode2 = pvalue->content_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ContentType (pctxt, ((ContentType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode schedule_list */

   pnode2 = pvalue->schedule_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ScheduleType (pctxt, ((ScheduleType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode service_list */

   pnode2 = pvalue->service_list.tail;
   while (0 != pnode2) {
      ll = asn1E_ServiceType (pctxt, ((ServiceType*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ESGMainBCAST (OSCTXT* pctxt, ESGMainBCAST* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   /* encode service_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->service_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ServiceType (pctxt, ((ServiceType*)pnode->data)
         , OSUTF8("Service"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode schedule_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->schedule_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ScheduleType (pctxt, ((ScheduleType*)pnode->data)
         , OSUTF8("Schedule"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode content_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->content_list.head;
   while (0 != pnode) {
      stat = XmlEnc_ContentType (pctxt, ((ContentType*)pnode->data)
         , OSUTF8("Content"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode access_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->access_list.head;
   while (0 != pnode) {
      stat = XmlEnc_AccessType (pctxt, ((AccessType*)pnode->data)
         , OSUTF8("Access"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode previewData_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->previewData_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PreviewDataType (pctxt, ((PreviewDataType*)pnode->data)
         , OSUTF8("PreviewData"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode purchaseItem_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->purchaseItem_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PurchaseItemType (pctxt, ((PurchaseItemType*)pnode->data)
         , OSUTF8("PurchaseItem"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode purchaseData_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->purchaseData_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PurchaseDataType (pctxt, ((PurchaseDataType*)pnode->data)
         , OSUTF8("PurchaseData"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode purchaseChannel_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->purchaseChannel_list.head;
   while (0 != pnode) {
      stat = XmlEnc_PurchaseChannelType (pctxt, 
         ((PurchaseChannelType*)pnode->data)
         , OSUTF8("PurchaseChannel"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   /* encode interactivityData_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   { OSRTDListNode* pnode = pvalue->interactivityData_list.head;
   while (0 != pnode) {
      stat = XmlEnc_InteractivityDataType (pctxt, 
         ((InteractivityDataType*)pnode->data)
         , OSUTF8("InteractivityData"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlEnc_ESGMainBCAST_PDU (OSCTXT* pctxt, ESGMainBCAST* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   rtXmlNSSetNamespace (pctxt, 0, OSUTF8("urn:oma:bcast:esg:2005"), FALSE);

   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8("urn:oma:bcast:esg:2005"));

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("ESGMainBCAST"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->state = OSXMLSTART;

   stat = XmlEnc_ESGMainBCAST (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("ESGMainBCAST"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
