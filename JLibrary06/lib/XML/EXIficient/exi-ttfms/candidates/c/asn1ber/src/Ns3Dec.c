/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 18-Oct-2006.
 */
#include "Ns3.h"
#include "Odf.h"
#include "Ns13.h"
#include "Ns10.h"
#include "Ns15.h"
#include "Ns12.h"
#include "Ns7.h"
#include "Ns9.h"
#include "MathML.h"
#include "Ns8.h"
#include "rtxsrc/rtxCommon.h"

/**************************************************************/
/*                                                            */
/*  Display_name                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Display_name (OSCTXT* pctxt, Ns3_Display_name *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Display_name (OSCTXT* pctxt, Ns3_Display_name* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Caption_point_x                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Caption_point_x (OSCTXT* pctxt, 
   Ns3_Caption_point_x *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Caption_point_x (OSCTXT* pctxt, Ns3_Caption_point_x* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Caption_point_y                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Caption_point_y (OSCTXT* pctxt, 
   Ns3_Caption_point_y *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Caption_point_y (OSCTXT* pctxt, Ns3_Caption_point_y* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Class_names                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Class_names (OSCTXT* pctxt, Ns3_Class_names *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   const OSUTF8CHAR* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_utf8str (pctxt, &pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Class_names (OSCTXT* pctxt, Ns3_Class_names* pvalue)
{
   int stat = 0;

   rtxDListInit (pvalue);

   stat = rtXmlpDecStrList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Corner_radius                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Corner_radius (OSCTXT* pctxt, Ns3_Corner_radius *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Corner_radius (OSCTXT* pctxt, Ns3_Corner_radius* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Id                                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Id (OSCTXT* pctxt, Ns3_Id *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Id (OSCTXT* pctxt, Ns3_Id* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Layer_1                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Layer_1 (OSCTXT* pctxt, Ns3_Layer_1 *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Layer_1 (OSCTXT* pctxt, Ns3_Layer_1* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Style_name                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Style_name (OSCTXT* pctxt, Ns3_Style_name *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Style_name (OSCTXT* pctxt, Ns3_Style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Text_style_name                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Text_style_name (OSCTXT* pctxt, 
   Ns3_Text_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Text_style_name (OSCTXT* pctxt, Ns3_Text_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Transform                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Transform (OSCTXT* pctxt, Ns3_Transform *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Transform (OSCTXT* pctxt, Ns3_Transform* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Z_index                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Z_index (OSCTXT* pctxt, Ns3_Z_index *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_unsigned (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Z_index (OSCTXT* pctxt, Ns3_Z_index* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecUInt (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Glue_point_align                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Glue_point_align (OSCTXT* pctxt, 
   Ns3_Glue_point_align *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Glue_point_align (OSCTXT* pctxt, Ns3_Glue_point_align* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Glue_point_align_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Glue_point_x                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Glue_point_x (OSCTXT* pctxt, Ns3_Glue_point_x *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Glue_point_x (OSCTXT* pctxt, Ns3_Glue_point_x* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Glue_point_y                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Glue_point_y (OSCTXT* pctxt, Ns3_Glue_point_y *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Glue_point_y (OSCTXT* pctxt, Ns3_Glue_point_y* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Glue_point                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Glue_point (OSCTXT* pctxt, Ns3_Glue_point *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode align */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Glue_point_align (pctxt, 
               &pvalue->align, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode x */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Glue_point_x (pctxt, 
               &pvalue->x, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode y */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Glue_point_y (pctxt, 
               &pvalue->y, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 4) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Glue_point (OSCTXT* pctxt, Ns3_Glue_point* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("align"), 5}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("x"), 1}, 0 },
         { {OSUTF8("y"), 1}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* align */
            stat = XmlDec_Ns3_Glue_point_align (pctxt, &pvalue->align);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* id */
            stat = rtXmlpDecUInt (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* x */
            stat = XmlDec_Ns3_Glue_point_x (pctxt, &pvalue->x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* y */
            stat = XmlDec_Ns3_Glue_point_y (pctxt, &pvalue->y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Glue_point");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Glue_point");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Rect_element                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Rect_element (OSCTXT* pctxt, Ns3_Rect_element *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P ((Odf_P*)pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            (Odf_P*)pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List ((Odf_List*)pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            (Odf_List*)pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Rect_element (OSCTXT* pctxt, Ns3_Rect_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("list"), 4}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P ((Odf_P*)pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List ((Odf_List*)pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Rect                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Rect (OSCTXT* pctxt, Ns3_Rect *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode class_names */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_namesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode corner_radius */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Corner_radius (pctxt, 
               &pvalue->corner_radius, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.corner_radiusPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Id (pctxt, 
               &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode layer */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Layer_1 (pctxt, 
               &pvalue->layer, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.layerPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode text_style_name */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Text_style_name (pctxt, 
               &pvalue->text_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.text_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode transform */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Transform (pctxt, 
               &pvalue->transform, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.transformPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode z_index */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Z_index (pctxt, 
               &pvalue->z_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.z_indexPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode class_names_1 */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_names_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 10:
         /* decode style_name_1 */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_name_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 11:
         /* decode height */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->height, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.heightPresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode width */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->width, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.widthPresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode x */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.xPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode y */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.yPresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode end_cell_address */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_cell_address (pctxt, 
               (End_cell_address*)&pvalue->end_cell_address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_cell_addressPresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode end_x */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_x (pctxt, 
               (End_x*)&pvalue->end_x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_xPresent = TRUE;
            }
         }
         break;

      case 17:
         /* decode end_y */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_y (pctxt, 
               (End_y*)&pvalue->end_y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_yPresent = TRUE;
            }
         }
         break;

      case 18:
         /* decode table_background */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_background (pctxt, 
               (Table_background*)&pvalue->table_background, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_backgroundPresent = TRUE;
            }
         }
         break;

      case 19:
         /* decode anchor_page_number */
         if (XD_PEEKTAG (pctxt, 0x93)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_page_number (pctxt, 
               (Odf_Anchor_page_number*)&pvalue->anchor_page_number, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_page_numberPresent = TRUE;
            }
         }
         break;

      case 20:
         /* decode anchor_type */
         if (XD_PEEKTAG (pctxt, 0x94)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_type (pctxt, 
               (Odf_Anchor_type*)&pvalue->anchor_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_typePresent = TRUE;
            }
         }
         break;

      case 21:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x95)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 22:
         /* decode glue_point_list */
         if (XD_PEEKTAG (pctxt, 0x96)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Glue_point* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->glue_point_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Glue_point, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Glue_point (pdata2);

                  stat = asn1D_Ns3_Glue_point (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->glue_point_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 23:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x97)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Rect_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Rect_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Rect_element (pdata2);

                  stat = asn1D_Ns3_Rect_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_PRIM|16):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_PRIM|17):
         case (TM_CTXT|TM_CONS|17):
         case (TM_CTXT|TM_PRIM|18):
         case (TM_CTXT|TM_PRIM|19):
         case (TM_CTXT|TM_PRIM|20):
         case (TM_CTXT|TM_CONS|21):
         case (TM_CTXT|TM_CONS|22):
         case (TM_CTXT|TM_CONS|23):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Rect (OSCTXT* pctxt, Ns3_Rect* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("corner-radius"), 13}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("layer"), 5}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("text-style-name"), 15}, 0 },
         { {OSUTF8("transform"), 9}, 0 },
         { {OSUTF8("z-index"), 7}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("height"), 6}, 0 },
         { {OSUTF8("width"), 5}, 0 },
         { {OSUTF8("x"), 1}, 0 },
         { {OSUTF8("y"), 1}, 0 },
         { {OSUTF8("end-cell-address"), 16}, 0 },
         { {OSUTF8("end-x"), 5}, 0 },
         { {OSUTF8("end-y"), 5}, 0 },
         { {OSUTF8("table-background"), 16}, 0 },
         { {OSUTF8("anchor-page-number"), 18}, 0 },
         { {OSUTF8("anchor-type"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 21, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* class-names */
            rtxDListInit (&pvalue->class_names);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_namesPresent = TRUE;
            break;

         case 1: /* corner-radius */
            stat = XmlDec_Ns3_Corner_radius (pctxt, &pvalue->corner_radius);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.corner_radiusPresent = TRUE;
            break;

         case 2: /* id */
            stat = XmlDec_Ns3_Id (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 3: /* layer */
            stat = XmlDec_Ns3_Layer_1 (pctxt, &pvalue->layer);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.layerPresent = TRUE;
            break;

         case 4: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 5: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         case 6: /* text-style-name */
            stat = XmlDec_Ns3_Text_style_name (pctxt, &pvalue->text_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.text_style_namePresent = TRUE;
            break;

         case 7: /* transform */
            stat = XmlDec_Ns3_Transform (pctxt, &pvalue->transform);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.transformPresent = TRUE;
            break;

         case 8: /* z-index */
            stat = XmlDec_Ns3_Z_index (pctxt, &pvalue->z_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.z_indexPresent = TRUE;
            break;

         case 9: /* class-names */
            rtxDListInit (&pvalue->class_names_1);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_names_1Present = TRUE;
            break;

         case 10: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_name_1Present = TRUE;
            break;

         case 11: /* height */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->height);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.heightPresent = TRUE;
            break;

         case 12: /* width */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->width);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.widthPresent = TRUE;
            break;

         case 13: /* x */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.xPresent = TRUE;
            break;

         case 14: /* y */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.yPresent = TRUE;
            break;

         case 15: /* end-cell-address */
            stat = XmlDec_End_cell_address (pctxt, &pvalue->end_cell_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_cell_addressPresent = TRUE;
            break;

         case 16: /* end-x */
            stat = XmlDec_End_x (pctxt, &pvalue->end_x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_xPresent = TRUE;
            break;

         case 17: /* end-y */
            stat = XmlDec_End_y (pctxt, &pvalue->end_y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_yPresent = TRUE;
            break;

         case 18: /* table-background */
            stat = XmlDec_Table_background (pctxt, &pvalue->table_background);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.table_backgroundPresent = TRUE;
            break;

         case 19: /* anchor-page-number */
            stat = XmlDec_Odf_Anchor_page_number (pctxt, &pvalue->
               anchor_page_number);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_page_numberPresent = TRUE;
            break;

         case 20: /* anchor-type */
            stat = XmlDec_Odf_Anchor_type (pctxt, &pvalue->anchor_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_typePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Rect");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Rect");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("event-listeners"), 15}, 0}, 0 },
      {{{OSUTF8("glue-point"), 10}, 0}, 1 },
      {{{OSUTF8("p"), 1}, 0}, 2 },
      {{{OSUTF8("list"), 4}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      case 1: {
         Ns3_Glue_point* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Glue_point);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Glue_point (pdata1);

            stat = XmlDec_Ns3_Glue_point (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->glue_point_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 2: {
         Ns3_Rect_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Rect_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Rect_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns3_Rect_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 2, 2, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Line_element                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Line_element (OSCTXT* pctxt, Ns3_Line_element *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P ((Odf_P*)pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            (Odf_P*)pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List ((Odf_List*)pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            (Odf_List*)pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Line_element (OSCTXT* pctxt, Ns3_Line_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("list"), 4}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P ((Odf_P*)pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List ((Odf_List*)pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Line                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Line (OSCTXT* pctxt, Ns3_Line *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode class_names */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_namesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Id (pctxt, 
               &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode layer */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Layer_1 (pctxt, 
               &pvalue->layer, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.layerPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode text_style_name */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Text_style_name (pctxt, 
               &pvalue->text_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.text_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode transform */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Transform (pctxt, 
               &pvalue->transform, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.transformPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode z_index */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Z_index (pctxt, 
               &pvalue->z_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.z_indexPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode class_names_1 */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_names_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode style_name_1 */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_name_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 10:
         /* decode x1 */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_X1 (pctxt, 
               (X1*)&pvalue->x1, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 11:
         /* decode x2 */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_X2 (pctxt, 
               (X2*)&pvalue->x2, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 12:
         /* decode y1 */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Y1 (pctxt, 
               (Y1*)&pvalue->y1, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 13:
         /* decode y2 */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Y2 (pctxt, 
               (Y2*)&pvalue->y2, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 14:
         /* decode end_cell_address */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_cell_address (pctxt, 
               (End_cell_address*)&pvalue->end_cell_address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_cell_addressPresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode end_x */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_x (pctxt, 
               (End_x*)&pvalue->end_x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_xPresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode end_y */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_y (pctxt, 
               (End_y*)&pvalue->end_y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_yPresent = TRUE;
            }
         }
         break;

      case 17:
         /* decode table_background */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_background (pctxt, 
               (Table_background*)&pvalue->table_background, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_backgroundPresent = TRUE;
            }
         }
         break;

      case 18:
         /* decode anchor_page_number */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_page_number (pctxt, 
               (Odf_Anchor_page_number*)&pvalue->anchor_page_number, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_page_numberPresent = TRUE;
            }
         }
         break;

      case 19:
         /* decode anchor_type */
         if (XD_PEEKTAG (pctxt, 0x93)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_type (pctxt, 
               (Odf_Anchor_type*)&pvalue->anchor_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_typePresent = TRUE;
            }
         }
         break;

      case 20:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x94)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 21:
         /* decode glue_point_list */
         if (XD_PEEKTAG (pctxt, 0x95)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Glue_point* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->glue_point_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Glue_point, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Glue_point (pdata2);

                  stat = asn1D_Ns3_Glue_point (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->glue_point_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 22:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x96)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Line_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Line_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Line_element (pdata2);

                  stat = asn1D_Ns3_Line_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_PRIM|16):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_PRIM|17):
         case (TM_CTXT|TM_PRIM|18):
         case (TM_CTXT|TM_PRIM|19):
         case (TM_CTXT|TM_CONS|20):
         case (TM_CTXT|TM_CONS|21):
         case (TM_CTXT|TM_CONS|22):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 6) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Line (OSCTXT* pctxt, Ns3_Line* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("layer"), 5}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("text-style-name"), 15}, 0 },
         { {OSUTF8("transform"), 9}, 0 },
         { {OSUTF8("z-index"), 7}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("x1"), 2}, 0 },
         { {OSUTF8("x2"), 2}, 0 },
         { {OSUTF8("y1"), 2}, 0 },
         { {OSUTF8("y2"), 2}, 0 },
         { {OSUTF8("end-cell-address"), 16}, 0 },
         { {OSUTF8("end-x"), 5}, 0 },
         { {OSUTF8("end-y"), 5}, 0 },
         { {OSUTF8("table-background"), 16}, 0 },
         { {OSUTF8("anchor-page-number"), 18}, 0 },
         { {OSUTF8("anchor-type"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 20, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* class-names */
            rtxDListInit (&pvalue->class_names);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_namesPresent = TRUE;
            break;

         case 1: /* id */
            stat = XmlDec_Ns3_Id (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* layer */
            stat = XmlDec_Ns3_Layer_1 (pctxt, &pvalue->layer);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.layerPresent = TRUE;
            break;

         case 3: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 4: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         case 5: /* text-style-name */
            stat = XmlDec_Ns3_Text_style_name (pctxt, &pvalue->text_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.text_style_namePresent = TRUE;
            break;

         case 6: /* transform */
            stat = XmlDec_Ns3_Transform (pctxt, &pvalue->transform);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.transformPresent = TRUE;
            break;

         case 7: /* z-index */
            stat = XmlDec_Ns3_Z_index (pctxt, &pvalue->z_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.z_indexPresent = TRUE;
            break;

         case 8: /* class-names */
            rtxDListInit (&pvalue->class_names_1);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_names_1Present = TRUE;
            break;

         case 9: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_name_1Present = TRUE;
            break;

         case 10: /* x1 */
            stat = XmlDec_X1 (pctxt, &pvalue->x1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 11: /* x2 */
            stat = XmlDec_X2 (pctxt, &pvalue->x2);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 12: /* y1 */
            stat = XmlDec_Y1 (pctxt, &pvalue->y1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 13: /* y2 */
            stat = XmlDec_Y2 (pctxt, &pvalue->y2);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 14: /* end-cell-address */
            stat = XmlDec_End_cell_address (pctxt, &pvalue->end_cell_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_cell_addressPresent = TRUE;
            break;

         case 15: /* end-x */
            stat = XmlDec_End_x (pctxt, &pvalue->end_x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_xPresent = TRUE;
            break;

         case 16: /* end-y */
            stat = XmlDec_End_y (pctxt, &pvalue->end_y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_yPresent = TRUE;
            break;

         case 17: /* table-background */
            stat = XmlDec_Table_background (pctxt, &pvalue->table_background);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.table_backgroundPresent = TRUE;
            break;

         case 18: /* anchor-page-number */
            stat = XmlDec_Odf_Anchor_page_number (pctxt, &pvalue->
               anchor_page_number);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_page_numberPresent = TRUE;
            break;

         case 19: /* anchor-type */
            stat = XmlDec_Odf_Anchor_type (pctxt, &pvalue->anchor_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_typePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Line");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Line");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("event-listeners"), 15}, 0}, 0 },
      {{{OSUTF8("glue-point"), 10}, 0}, 1 },
      {{{OSUTF8("p"), 1}, 0}, 2 },
      {{{OSUTF8("list"), 4}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      case 1: {
         Ns3_Glue_point* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Glue_point);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Glue_point (pdata1);

            stat = XmlDec_Ns3_Glue_point (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->glue_point_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 2: {
         Ns3_Line_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Line_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Line_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns3_Line_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 2, 2, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Polyline_element                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Polyline_element (OSCTXT* pctxt, 
   Ns3_Polyline_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P ((Odf_P*)pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            (Odf_P*)pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List ((Odf_List*)pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            (Odf_List*)pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Polyline_element (OSCTXT* pctxt, Ns3_Polyline_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("list"), 4}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P ((Odf_P*)pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List ((Odf_List*)pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Polyline                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Polyline (OSCTXT* pctxt, Ns3_Polyline *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode class_names */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_namesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Id (pctxt, 
               &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode layer */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Layer_1 (pctxt, 
               &pvalue->layer, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.layerPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode points */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->points, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode text_style_name */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Text_style_name (pctxt, 
               &pvalue->text_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.text_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode transform */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Transform (pctxt, 
               &pvalue->transform, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.transformPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode z_index */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Z_index (pctxt, 
               &pvalue->z_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.z_indexPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode class_names_1 */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_names_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 10:
         /* decode style_name_1 */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_name_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 11:
         /* decode height */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->height, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.heightPresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode viewBox */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_ViewBox (pctxt, 
               (ViewBox*)&pvalue->viewBox, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 13:
         /* decode width */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->width, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.widthPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode x */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.xPresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode y */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.yPresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode end_cell_address */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_cell_address (pctxt, 
               (End_cell_address*)&pvalue->end_cell_address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_cell_addressPresent = TRUE;
            }
         }
         break;

      case 17:
         /* decode end_x */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_x (pctxt, 
               (End_x*)&pvalue->end_x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_xPresent = TRUE;
            }
         }
         break;

      case 18:
         /* decode end_y */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_y (pctxt, 
               (End_y*)&pvalue->end_y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_yPresent = TRUE;
            }
         }
         break;

      case 19:
         /* decode table_background */
         if (XD_PEEKTAG (pctxt, 0x93)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_background (pctxt, 
               (Table_background*)&pvalue->table_background, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_backgroundPresent = TRUE;
            }
         }
         break;

      case 20:
         /* decode anchor_page_number */
         if (XD_PEEKTAG (pctxt, 0x94)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_page_number (pctxt, 
               (Odf_Anchor_page_number*)&pvalue->anchor_page_number, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_page_numberPresent = TRUE;
            }
         }
         break;

      case 21:
         /* decode anchor_type */
         if (XD_PEEKTAG (pctxt, 0x95)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_type (pctxt, 
               (Odf_Anchor_type*)&pvalue->anchor_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_typePresent = TRUE;
            }
         }
         break;

      case 22:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x96)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 23:
         /* decode glue_point_list */
         if (XD_PEEKTAG (pctxt, 0x97)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Glue_point* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->glue_point_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Glue_point, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Glue_point (pdata2);

                  stat = asn1D_Ns3_Glue_point (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->glue_point_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 24:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x98)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Polyline_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Polyline_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Polyline_element (pdata2);

                  stat = asn1D_Ns3_Polyline_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_PRIM|16):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_PRIM|17):
         case (TM_CTXT|TM_CONS|17):
         case (TM_CTXT|TM_PRIM|18):
         case (TM_CTXT|TM_CONS|18):
         case (TM_CTXT|TM_PRIM|19):
         case (TM_CTXT|TM_PRIM|20):
         case (TM_CTXT|TM_PRIM|21):
         case (TM_CTXT|TM_CONS|22):
         case (TM_CTXT|TM_CONS|23):
         case (TM_CTXT|TM_CONS|24):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 4) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Polyline (OSCTXT* pctxt, Ns3_Polyline* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("layer"), 5}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("points"), 6}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("text-style-name"), 15}, 0 },
         { {OSUTF8("transform"), 9}, 0 },
         { {OSUTF8("z-index"), 7}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("height"), 6}, 0 },
         { {OSUTF8("viewBox"), 7}, 0 },
         { {OSUTF8("width"), 5}, 0 },
         { {OSUTF8("x"), 1}, 0 },
         { {OSUTF8("y"), 1}, 0 },
         { {OSUTF8("end-cell-address"), 16}, 0 },
         { {OSUTF8("end-x"), 5}, 0 },
         { {OSUTF8("end-y"), 5}, 0 },
         { {OSUTF8("table-background"), 16}, 0 },
         { {OSUTF8("anchor-page-number"), 18}, 0 },
         { {OSUTF8("anchor-type"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 22, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* class-names */
            rtxDListInit (&pvalue->class_names);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_namesPresent = TRUE;
            break;

         case 1: /* id */
            stat = XmlDec_Ns3_Id (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* layer */
            stat = XmlDec_Ns3_Layer_1 (pctxt, &pvalue->layer);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.layerPresent = TRUE;
            break;

         case 3: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 4: /* points */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->points);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         case 6: /* text-style-name */
            stat = XmlDec_Ns3_Text_style_name (pctxt, &pvalue->text_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.text_style_namePresent = TRUE;
            break;

         case 7: /* transform */
            stat = XmlDec_Ns3_Transform (pctxt, &pvalue->transform);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.transformPresent = TRUE;
            break;

         case 8: /* z-index */
            stat = XmlDec_Ns3_Z_index (pctxt, &pvalue->z_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.z_indexPresent = TRUE;
            break;

         case 9: /* class-names */
            rtxDListInit (&pvalue->class_names_1);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_names_1Present = TRUE;
            break;

         case 10: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_name_1Present = TRUE;
            break;

         case 11: /* height */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->height);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.heightPresent = TRUE;
            break;

         case 12: /* viewBox */
            rtxDListInit (&pvalue->viewBox);
            rtXmlpSetListMode (pctxt);

            while (rtXmlpListHasItem(pctxt)) {
               ViewBox_element* pdata1 = rtxMemAllocType (pctxt, 
                  ViewBox_element);
               if (0 == pdata1) LOG_RTERR (pctxt, RTERR_NOMEM);

               stat = XmlDec_ViewBox_element (pctxt, pdata1);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               if (0 == rtxDListAppend (pctxt, &pvalue->viewBox, pdata1)) {
                  return LOG_RTERR (pctxt, RTERR_NOMEM);
               }
            }
            break;

         case 13: /* width */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->width);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.widthPresent = TRUE;
            break;

         case 14: /* x */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.xPresent = TRUE;
            break;

         case 15: /* y */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.yPresent = TRUE;
            break;

         case 16: /* end-cell-address */
            stat = XmlDec_End_cell_address (pctxt, &pvalue->end_cell_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_cell_addressPresent = TRUE;
            break;

         case 17: /* end-x */
            stat = XmlDec_End_x (pctxt, &pvalue->end_x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_xPresent = TRUE;
            break;

         case 18: /* end-y */
            stat = XmlDec_End_y (pctxt, &pvalue->end_y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_yPresent = TRUE;
            break;

         case 19: /* table-background */
            stat = XmlDec_Table_background (pctxt, &pvalue->table_background);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.table_backgroundPresent = TRUE;
            break;

         case 20: /* anchor-page-number */
            stat = XmlDec_Odf_Anchor_page_number (pctxt, &pvalue->
               anchor_page_number);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_page_numberPresent = TRUE;
            break;

         case 21: /* anchor-type */
            stat = XmlDec_Odf_Anchor_type (pctxt, &pvalue->anchor_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_typePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Polyline");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Polyline");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("event-listeners"), 15}, 0}, 0 },
      {{{OSUTF8("glue-point"), 10}, 0}, 1 },
      {{{OSUTF8("p"), 1}, 0}, 2 },
      {{{OSUTF8("list"), 4}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      case 1: {
         Ns3_Glue_point* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Glue_point);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Glue_point (pdata1);

            stat = XmlDec_Ns3_Glue_point (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->glue_point_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 2: {
         Ns3_Polyline_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Polyline_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Polyline_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns3_Polyline_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 2, 2, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Polygon_element                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Polygon_element (OSCTXT* pctxt, 
   Ns3_Polygon_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P ((Odf_P*)pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            (Odf_P*)pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List ((Odf_List*)pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            (Odf_List*)pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Polygon_element (OSCTXT* pctxt, Ns3_Polygon_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("list"), 4}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P ((Odf_P*)pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List ((Odf_List*)pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Polygon                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Polygon (OSCTXT* pctxt, Ns3_Polygon *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode class_names */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_namesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Id (pctxt, 
               &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode layer */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Layer_1 (pctxt, 
               &pvalue->layer, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.layerPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode points */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->points, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode text_style_name */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Text_style_name (pctxt, 
               &pvalue->text_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.text_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode transform */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Transform (pctxt, 
               &pvalue->transform, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.transformPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode z_index */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Z_index (pctxt, 
               &pvalue->z_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.z_indexPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode class_names_1 */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_names_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 10:
         /* decode style_name_1 */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_name_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 11:
         /* decode height */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->height, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.heightPresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode viewBox */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_ViewBox (pctxt, 
               (ViewBox*)&pvalue->viewBox, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 13:
         /* decode width */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->width, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.widthPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode x */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.xPresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode y */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.yPresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode end_cell_address */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_cell_address (pctxt, 
               (End_cell_address*)&pvalue->end_cell_address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_cell_addressPresent = TRUE;
            }
         }
         break;

      case 17:
         /* decode end_x */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_x (pctxt, 
               (End_x*)&pvalue->end_x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_xPresent = TRUE;
            }
         }
         break;

      case 18:
         /* decode end_y */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_y (pctxt, 
               (End_y*)&pvalue->end_y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_yPresent = TRUE;
            }
         }
         break;

      case 19:
         /* decode table_background */
         if (XD_PEEKTAG (pctxt, 0x93)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_background (pctxt, 
               (Table_background*)&pvalue->table_background, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_backgroundPresent = TRUE;
            }
         }
         break;

      case 20:
         /* decode anchor_page_number */
         if (XD_PEEKTAG (pctxt, 0x94)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_page_number (pctxt, 
               (Odf_Anchor_page_number*)&pvalue->anchor_page_number, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_page_numberPresent = TRUE;
            }
         }
         break;

      case 21:
         /* decode anchor_type */
         if (XD_PEEKTAG (pctxt, 0x95)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_type (pctxt, 
               (Odf_Anchor_type*)&pvalue->anchor_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_typePresent = TRUE;
            }
         }
         break;

      case 22:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x96)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 23:
         /* decode glue_point_list */
         if (XD_PEEKTAG (pctxt, 0x97)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Glue_point* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->glue_point_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Glue_point, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Glue_point (pdata2);

                  stat = asn1D_Ns3_Glue_point (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->glue_point_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 24:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x98)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Polygon_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Polygon_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Polygon_element (pdata2);

                  stat = asn1D_Ns3_Polygon_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_PRIM|16):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_PRIM|17):
         case (TM_CTXT|TM_CONS|17):
         case (TM_CTXT|TM_PRIM|18):
         case (TM_CTXT|TM_CONS|18):
         case (TM_CTXT|TM_PRIM|19):
         case (TM_CTXT|TM_PRIM|20):
         case (TM_CTXT|TM_PRIM|21):
         case (TM_CTXT|TM_CONS|22):
         case (TM_CTXT|TM_CONS|23):
         case (TM_CTXT|TM_CONS|24):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 4) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Polygon (OSCTXT* pctxt, Ns3_Polygon* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("layer"), 5}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("points"), 6}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("text-style-name"), 15}, 0 },
         { {OSUTF8("transform"), 9}, 0 },
         { {OSUTF8("z-index"), 7}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("height"), 6}, 0 },
         { {OSUTF8("viewBox"), 7}, 0 },
         { {OSUTF8("width"), 5}, 0 },
         { {OSUTF8("x"), 1}, 0 },
         { {OSUTF8("y"), 1}, 0 },
         { {OSUTF8("end-cell-address"), 16}, 0 },
         { {OSUTF8("end-x"), 5}, 0 },
         { {OSUTF8("end-y"), 5}, 0 },
         { {OSUTF8("table-background"), 16}, 0 },
         { {OSUTF8("anchor-page-number"), 18}, 0 },
         { {OSUTF8("anchor-type"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 22, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* class-names */
            rtxDListInit (&pvalue->class_names);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_namesPresent = TRUE;
            break;

         case 1: /* id */
            stat = XmlDec_Ns3_Id (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* layer */
            stat = XmlDec_Ns3_Layer_1 (pctxt, &pvalue->layer);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.layerPresent = TRUE;
            break;

         case 3: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 4: /* points */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->points);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         case 6: /* text-style-name */
            stat = XmlDec_Ns3_Text_style_name (pctxt, &pvalue->text_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.text_style_namePresent = TRUE;
            break;

         case 7: /* transform */
            stat = XmlDec_Ns3_Transform (pctxt, &pvalue->transform);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.transformPresent = TRUE;
            break;

         case 8: /* z-index */
            stat = XmlDec_Ns3_Z_index (pctxt, &pvalue->z_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.z_indexPresent = TRUE;
            break;

         case 9: /* class-names */
            rtxDListInit (&pvalue->class_names_1);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_names_1Present = TRUE;
            break;

         case 10: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_name_1Present = TRUE;
            break;

         case 11: /* height */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->height);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.heightPresent = TRUE;
            break;

         case 12: /* viewBox */
            rtxDListInit (&pvalue->viewBox);
            rtXmlpSetListMode (pctxt);

            while (rtXmlpListHasItem(pctxt)) {
               ViewBox_element* pdata1 = rtxMemAllocType (pctxt, 
                  ViewBox_element);
               if (0 == pdata1) LOG_RTERR (pctxt, RTERR_NOMEM);

               stat = XmlDec_ViewBox_element (pctxt, pdata1);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               if (0 == rtxDListAppend (pctxt, &pvalue->viewBox, pdata1)) {
                  return LOG_RTERR (pctxt, RTERR_NOMEM);
               }
            }
            break;

         case 13: /* width */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->width);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.widthPresent = TRUE;
            break;

         case 14: /* x */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.xPresent = TRUE;
            break;

         case 15: /* y */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.yPresent = TRUE;
            break;

         case 16: /* end-cell-address */
            stat = XmlDec_End_cell_address (pctxt, &pvalue->end_cell_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_cell_addressPresent = TRUE;
            break;

         case 17: /* end-x */
            stat = XmlDec_End_x (pctxt, &pvalue->end_x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_xPresent = TRUE;
            break;

         case 18: /* end-y */
            stat = XmlDec_End_y (pctxt, &pvalue->end_y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_yPresent = TRUE;
            break;

         case 19: /* table-background */
            stat = XmlDec_Table_background (pctxt, &pvalue->table_background);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.table_backgroundPresent = TRUE;
            break;

         case 20: /* anchor-page-number */
            stat = XmlDec_Odf_Anchor_page_number (pctxt, &pvalue->
               anchor_page_number);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_page_numberPresent = TRUE;
            break;

         case 21: /* anchor-type */
            stat = XmlDec_Odf_Anchor_type (pctxt, &pvalue->anchor_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_typePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Polygon");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Polygon");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("event-listeners"), 15}, 0}, 0 },
      {{{OSUTF8("glue-point"), 10}, 0}, 1 },
      {{{OSUTF8("p"), 1}, 0}, 2 },
      {{{OSUTF8("list"), 4}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      case 1: {
         Ns3_Glue_point* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Glue_point);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Glue_point (pdata1);

            stat = XmlDec_Ns3_Glue_point (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->glue_point_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 2: {
         Ns3_Polygon_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Polygon_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Polygon_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns3_Polygon_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 2, 2, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Regular_polygon_concave                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Regular_polygon_concave (OSCTXT* pctxt, 
   Ns3_Regular_polygon_concave *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Regular_polygon_concave (OSCTXT* pctxt, 
   Ns3_Regular_polygon_concave* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Regular_polygon_concave_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Regular_polygon_element                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Regular_polygon_element (OSCTXT* pctxt, 
   Ns3_Regular_polygon_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P ((Odf_P*)pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            (Odf_P*)pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List ((Odf_List*)pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            (Odf_List*)pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Regular_polygon_element (OSCTXT* pctxt, 
   Ns3_Regular_polygon_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("list"), 4}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P ((Odf_P*)pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List ((Odf_List*)pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Regular_polygon                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Regular_polygon (OSCTXT* pctxt, 
   Ns3_Regular_polygon *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode class_names */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_namesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode concave */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Regular_polygon_concave (pctxt, 
               &pvalue->concave, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode corners */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->corners, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Id (pctxt, 
               &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode layer */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Layer_1 (pctxt, 
               &pvalue->layer, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.layerPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode sharpness */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->sharpness, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sharpnessPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode text_style_name */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Text_style_name (pctxt, 
               &pvalue->text_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.text_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode transform */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Transform (pctxt, 
               &pvalue->transform, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.transformPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode z_index */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Z_index (pctxt, 
               &pvalue->z_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.z_indexPresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode class_names_1 */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_names_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 12:
         /* decode style_name_1 */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_name_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 13:
         /* decode height */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->height, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.heightPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode width */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->width, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.widthPresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode x */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.xPresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode y */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.yPresent = TRUE;
            }
         }
         break;

      case 17:
         /* decode end_cell_address */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_cell_address (pctxt, 
               (End_cell_address*)&pvalue->end_cell_address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_cell_addressPresent = TRUE;
            }
         }
         break;

      case 18:
         /* decode end_x */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_x (pctxt, 
               (End_x*)&pvalue->end_x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_xPresent = TRUE;
            }
         }
         break;

      case 19:
         /* decode end_y */
         if (XD_PEEKTAG (pctxt, 0x93)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_y (pctxt, 
               (End_y*)&pvalue->end_y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_yPresent = TRUE;
            }
         }
         break;

      case 20:
         /* decode table_background */
         if (XD_PEEKTAG (pctxt, 0x94)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_background (pctxt, 
               (Table_background*)&pvalue->table_background, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_backgroundPresent = TRUE;
            }
         }
         break;

      case 21:
         /* decode anchor_page_number */
         if (XD_PEEKTAG (pctxt, 0x95)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_page_number (pctxt, 
               (Odf_Anchor_page_number*)&pvalue->anchor_page_number, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_page_numberPresent = TRUE;
            }
         }
         break;

      case 22:
         /* decode anchor_type */
         if (XD_PEEKTAG (pctxt, 0x96)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_type (pctxt, 
               (Odf_Anchor_type*)&pvalue->anchor_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_typePresent = TRUE;
            }
         }
         break;

      case 23:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x97)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 24:
         /* decode glue_point_list */
         if (XD_PEEKTAG (pctxt, 0x98)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Glue_point* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->glue_point_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Glue_point, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Glue_point (pdata2);

                  stat = asn1D_Ns3_Glue_point (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->glue_point_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 25:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x99)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Regular_polygon_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Regular_polygon_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Regular_polygon_element (pdata2);

                  stat = asn1D_Ns3_Regular_polygon_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_PRIM|16):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_PRIM|17):
         case (TM_CTXT|TM_CONS|17):
         case (TM_CTXT|TM_PRIM|18):
         case (TM_CTXT|TM_CONS|18):
         case (TM_CTXT|TM_PRIM|19):
         case (TM_CTXT|TM_CONS|19):
         case (TM_CTXT|TM_PRIM|20):
         case (TM_CTXT|TM_PRIM|21):
         case (TM_CTXT|TM_PRIM|22):
         case (TM_CTXT|TM_CONS|23):
         case (TM_CTXT|TM_CONS|24):
         case (TM_CTXT|TM_CONS|25):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 4) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Regular_polygon (OSCTXT* pctxt, Ns3_Regular_polygon* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("concave"), 7}, 0 },
         { {OSUTF8("corners"), 7}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("layer"), 5}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("sharpness"), 9}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("text-style-name"), 15}, 0 },
         { {OSUTF8("transform"), 9}, 0 },
         { {OSUTF8("z-index"), 7}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("height"), 6}, 0 },
         { {OSUTF8("width"), 5}, 0 },
         { {OSUTF8("x"), 1}, 0 },
         { {OSUTF8("y"), 1}, 0 },
         { {OSUTF8("end-cell-address"), 16}, 0 },
         { {OSUTF8("end-x"), 5}, 0 },
         { {OSUTF8("end-y"), 5}, 0 },
         { {OSUTF8("table-background"), 16}, 0 },
         { {OSUTF8("anchor-page-number"), 18}, 0 },
         { {OSUTF8("anchor-type"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 23, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* class-names */
            rtxDListInit (&pvalue->class_names);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_namesPresent = TRUE;
            break;

         case 1: /* concave */
            stat = XmlDec_Ns3_Regular_polygon_concave (pctxt, &pvalue->concave
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* corners */
            stat = rtXmlpDecUInt (pctxt, &pvalue->corners);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* id */
            stat = XmlDec_Ns3_Id (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 4: /* layer */
            stat = XmlDec_Ns3_Layer_1 (pctxt, &pvalue->layer);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.layerPresent = TRUE;
            break;

         case 5: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 6: /* sharpness */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->sharpness);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.sharpnessPresent = TRUE;
            break;

         case 7: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         case 8: /* text-style-name */
            stat = XmlDec_Ns3_Text_style_name (pctxt, &pvalue->text_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.text_style_namePresent = TRUE;
            break;

         case 9: /* transform */
            stat = XmlDec_Ns3_Transform (pctxt, &pvalue->transform);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.transformPresent = TRUE;
            break;

         case 10: /* z-index */
            stat = XmlDec_Ns3_Z_index (pctxt, &pvalue->z_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.z_indexPresent = TRUE;
            break;

         case 11: /* class-names */
            rtxDListInit (&pvalue->class_names_1);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_names_1Present = TRUE;
            break;

         case 12: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_name_1Present = TRUE;
            break;

         case 13: /* height */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->height);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.heightPresent = TRUE;
            break;

         case 14: /* width */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->width);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.widthPresent = TRUE;
            break;

         case 15: /* x */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.xPresent = TRUE;
            break;

         case 16: /* y */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.yPresent = TRUE;
            break;

         case 17: /* end-cell-address */
            stat = XmlDec_End_cell_address (pctxt, &pvalue->end_cell_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_cell_addressPresent = TRUE;
            break;

         case 18: /* end-x */
            stat = XmlDec_End_x (pctxt, &pvalue->end_x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_xPresent = TRUE;
            break;

         case 19: /* end-y */
            stat = XmlDec_End_y (pctxt, &pvalue->end_y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_yPresent = TRUE;
            break;

         case 20: /* table-background */
            stat = XmlDec_Table_background (pctxt, &pvalue->table_background);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.table_backgroundPresent = TRUE;
            break;

         case 21: /* anchor-page-number */
            stat = XmlDec_Odf_Anchor_page_number (pctxt, &pvalue->
               anchor_page_number);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_page_numberPresent = TRUE;
            break;

         case 22: /* anchor-type */
            stat = XmlDec_Odf_Anchor_type (pctxt, &pvalue->anchor_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_typePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Regular_polygon");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Regular_polygon");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("event-listeners"), 15}, 0}, 0 },
      {{{OSUTF8("glue-point"), 10}, 0}, 1 },
      {{{OSUTF8("p"), 1}, 0}, 2 },
      {{{OSUTF8("list"), 4}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      case 1: {
         Ns3_Glue_point* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Glue_point);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Glue_point (pdata1);

            stat = XmlDec_Ns3_Glue_point (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->glue_point_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 2: {
         Ns3_Regular_polygon_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Regular_polygon_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Regular_polygon_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns3_Regular_polygon_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 2, 2, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Path_element                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Path_element (OSCTXT* pctxt, Ns3_Path_element *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P ((Odf_P*)pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            (Odf_P*)pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List ((Odf_List*)pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            (Odf_List*)pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Path_element (OSCTXT* pctxt, Ns3_Path_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("list"), 4}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P ((Odf_P*)pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List ((Odf_List*)pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Path                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Path (OSCTXT* pctxt, Ns3_Path *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode class_names */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_namesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Id (pctxt, 
               &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode layer */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Layer_1 (pctxt, 
               &pvalue->layer, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.layerPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode text_style_name */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Text_style_name (pctxt, 
               &pvalue->text_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.text_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode transform */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Transform (pctxt, 
               &pvalue->transform, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.transformPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode z_index */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Z_index (pctxt, 
               &pvalue->z_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.z_indexPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode class_names_1 */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_names_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode style_name_1 */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_name_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 10:
         /* decode d */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_D (pctxt, 
               (D*)&pvalue->d, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 11:
         /* decode height */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->height, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.heightPresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode viewBox */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_ViewBox (pctxt, 
               (ViewBox*)&pvalue->viewBox, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 13:
         /* decode width */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->width, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.widthPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode x */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.xPresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode y */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.yPresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode end_cell_address */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_cell_address (pctxt, 
               (End_cell_address*)&pvalue->end_cell_address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_cell_addressPresent = TRUE;
            }
         }
         break;

      case 17:
         /* decode end_x */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_x (pctxt, 
               (End_x*)&pvalue->end_x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_xPresent = TRUE;
            }
         }
         break;

      case 18:
         /* decode end_y */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_y (pctxt, 
               (End_y*)&pvalue->end_y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_yPresent = TRUE;
            }
         }
         break;

      case 19:
         /* decode table_background */
         if (XD_PEEKTAG (pctxt, 0x93)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_background (pctxt, 
               (Table_background*)&pvalue->table_background, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_backgroundPresent = TRUE;
            }
         }
         break;

      case 20:
         /* decode anchor_page_number */
         if (XD_PEEKTAG (pctxt, 0x94)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_page_number (pctxt, 
               (Odf_Anchor_page_number*)&pvalue->anchor_page_number, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_page_numberPresent = TRUE;
            }
         }
         break;

      case 21:
         /* decode anchor_type */
         if (XD_PEEKTAG (pctxt, 0x95)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_type (pctxt, 
               (Odf_Anchor_type*)&pvalue->anchor_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_typePresent = TRUE;
            }
         }
         break;

      case 22:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x96)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 23:
         /* decode glue_point_list */
         if (XD_PEEKTAG (pctxt, 0x97)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Glue_point* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->glue_point_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Glue_point, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Glue_point (pdata2);

                  stat = asn1D_Ns3_Glue_point (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->glue_point_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 24:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x98)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Path_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Path_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Path_element (pdata2);

                  stat = asn1D_Ns3_Path_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_PRIM|16):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_PRIM|17):
         case (TM_CTXT|TM_CONS|17):
         case (TM_CTXT|TM_PRIM|18):
         case (TM_CTXT|TM_CONS|18):
         case (TM_CTXT|TM_PRIM|19):
         case (TM_CTXT|TM_PRIM|20):
         case (TM_CTXT|TM_PRIM|21):
         case (TM_CTXT|TM_CONS|22):
         case (TM_CTXT|TM_CONS|23):
         case (TM_CTXT|TM_CONS|24):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 4) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Path (OSCTXT* pctxt, Ns3_Path* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("layer"), 5}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("text-style-name"), 15}, 0 },
         { {OSUTF8("transform"), 9}, 0 },
         { {OSUTF8("z-index"), 7}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("d"), 1}, 0 },
         { {OSUTF8("height"), 6}, 0 },
         { {OSUTF8("viewBox"), 7}, 0 },
         { {OSUTF8("width"), 5}, 0 },
         { {OSUTF8("x"), 1}, 0 },
         { {OSUTF8("y"), 1}, 0 },
         { {OSUTF8("end-cell-address"), 16}, 0 },
         { {OSUTF8("end-x"), 5}, 0 },
         { {OSUTF8("end-y"), 5}, 0 },
         { {OSUTF8("table-background"), 16}, 0 },
         { {OSUTF8("anchor-page-number"), 18}, 0 },
         { {OSUTF8("anchor-type"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 22, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* class-names */
            rtxDListInit (&pvalue->class_names);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_namesPresent = TRUE;
            break;

         case 1: /* id */
            stat = XmlDec_Ns3_Id (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* layer */
            stat = XmlDec_Ns3_Layer_1 (pctxt, &pvalue->layer);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.layerPresent = TRUE;
            break;

         case 3: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 4: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         case 5: /* text-style-name */
            stat = XmlDec_Ns3_Text_style_name (pctxt, &pvalue->text_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.text_style_namePresent = TRUE;
            break;

         case 6: /* transform */
            stat = XmlDec_Ns3_Transform (pctxt, &pvalue->transform);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.transformPresent = TRUE;
            break;

         case 7: /* z-index */
            stat = XmlDec_Ns3_Z_index (pctxt, &pvalue->z_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.z_indexPresent = TRUE;
            break;

         case 8: /* class-names */
            rtxDListInit (&pvalue->class_names_1);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_names_1Present = TRUE;
            break;

         case 9: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_name_1Present = TRUE;
            break;

         case 10: /* d */
            stat = XmlDec_D (pctxt, &pvalue->d);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 11: /* height */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->height);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.heightPresent = TRUE;
            break;

         case 12: /* viewBox */
            rtxDListInit (&pvalue->viewBox);
            rtXmlpSetListMode (pctxt);

            while (rtXmlpListHasItem(pctxt)) {
               ViewBox_element* pdata1 = rtxMemAllocType (pctxt, 
                  ViewBox_element);
               if (0 == pdata1) LOG_RTERR (pctxt, RTERR_NOMEM);

               stat = XmlDec_ViewBox_element (pctxt, pdata1);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               if (0 == rtxDListAppend (pctxt, &pvalue->viewBox, pdata1)) {
                  return LOG_RTERR (pctxt, RTERR_NOMEM);
               }
            }
            break;

         case 13: /* width */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->width);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.widthPresent = TRUE;
            break;

         case 14: /* x */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.xPresent = TRUE;
            break;

         case 15: /* y */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.yPresent = TRUE;
            break;

         case 16: /* end-cell-address */
            stat = XmlDec_End_cell_address (pctxt, &pvalue->end_cell_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_cell_addressPresent = TRUE;
            break;

         case 17: /* end-x */
            stat = XmlDec_End_x (pctxt, &pvalue->end_x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_xPresent = TRUE;
            break;

         case 18: /* end-y */
            stat = XmlDec_End_y (pctxt, &pvalue->end_y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_yPresent = TRUE;
            break;

         case 19: /* table-background */
            stat = XmlDec_Table_background (pctxt, &pvalue->table_background);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.table_backgroundPresent = TRUE;
            break;

         case 20: /* anchor-page-number */
            stat = XmlDec_Odf_Anchor_page_number (pctxt, &pvalue->
               anchor_page_number);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_page_numberPresent = TRUE;
            break;

         case 21: /* anchor-type */
            stat = XmlDec_Odf_Anchor_type (pctxt, &pvalue->anchor_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_typePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Path");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Path");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("event-listeners"), 15}, 0}, 0 },
      {{{OSUTF8("glue-point"), 10}, 0}, 1 },
      {{{OSUTF8("p"), 1}, 0}, 2 },
      {{{OSUTF8("list"), 4}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      case 1: {
         Ns3_Glue_point* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Glue_point);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Glue_point (pdata1);

            stat = XmlDec_Ns3_Glue_point (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->glue_point_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 2: {
         Ns3_Path_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Path_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Path_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns3_Path_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 2, 2, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Circle_kind                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Circle_kind (OSCTXT* pctxt, Ns3_Circle_kind *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Circle_kind (OSCTXT* pctxt, Ns3_Circle_kind* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Circle_kind_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Circle_element                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Circle_element (OSCTXT* pctxt, 
   Ns3_Circle_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P ((Odf_P*)pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            (Odf_P*)pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List ((Odf_List*)pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            (Odf_List*)pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Circle_element (OSCTXT* pctxt, Ns3_Circle_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("list"), 4}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P ((Odf_P*)pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List ((Odf_List*)pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Circle                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Circle (OSCTXT* pctxt, Ns3_Circle *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode class_names */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_namesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode end_angle */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->end_angle, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_anglePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Id (pctxt, 
               &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode kind */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Circle_kind (pctxt, 
               &pvalue->kind, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.kindPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode layer */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Layer_1 (pctxt, 
               &pvalue->layer, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.layerPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode start_angle */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->start_angle, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.start_anglePresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode text_style_name */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Text_style_name (pctxt, 
               &pvalue->text_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.text_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode transform */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Transform (pctxt, 
               &pvalue->transform, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.transformPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode z_index */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Z_index (pctxt, 
               &pvalue->z_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.z_indexPresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode class_names_1 */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_names_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 12:
         /* decode style_name_1 */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_name_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 13:
         /* decode cx */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Cx (pctxt, 
               (Cx*)&pvalue->cx, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.cxPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode cy */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Cy (pctxt, 
               (Cy*)&pvalue->cy, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.cyPresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode height */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->height, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.heightPresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode r */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_R (pctxt, 
               (R*)&pvalue->r, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.rPresent = TRUE;
            }
         }
         break;

      case 17:
         /* decode width */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->width, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.widthPresent = TRUE;
            }
         }
         break;

      case 18:
         /* decode x */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.xPresent = TRUE;
            }
         }
         break;

      case 19:
         /* decode y */
         if (XD_PEEKTAG (pctxt, 0x93)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.yPresent = TRUE;
            }
         }
         break;

      case 20:
         /* decode end_cell_address */
         if (XD_PEEKTAG (pctxt, 0x94)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_cell_address (pctxt, 
               (End_cell_address*)&pvalue->end_cell_address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_cell_addressPresent = TRUE;
            }
         }
         break;

      case 21:
         /* decode end_x */
         if (XD_PEEKTAG (pctxt, 0x95)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_x (pctxt, 
               (End_x*)&pvalue->end_x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_xPresent = TRUE;
            }
         }
         break;

      case 22:
         /* decode end_y */
         if (XD_PEEKTAG (pctxt, 0x96)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_y (pctxt, 
               (End_y*)&pvalue->end_y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_yPresent = TRUE;
            }
         }
         break;

      case 23:
         /* decode table_background */
         if (XD_PEEKTAG (pctxt, 0x97)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_background (pctxt, 
               (Table_background*)&pvalue->table_background, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_backgroundPresent = TRUE;
            }
         }
         break;

      case 24:
         /* decode anchor_page_number */
         if (XD_PEEKTAG (pctxt, 0x98)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_page_number (pctxt, 
               (Odf_Anchor_page_number*)&pvalue->anchor_page_number, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_page_numberPresent = TRUE;
            }
         }
         break;

      case 25:
         /* decode anchor_type */
         if (XD_PEEKTAG (pctxt, 0x99)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_type (pctxt, 
               (Odf_Anchor_type*)&pvalue->anchor_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_typePresent = TRUE;
            }
         }
         break;

      case 26:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x9a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 27:
         /* decode glue_point_list */
         if (XD_PEEKTAG (pctxt, 0x9b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Glue_point* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->glue_point_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Glue_point, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Glue_point (pdata2);

                  stat = asn1D_Ns3_Glue_point (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->glue_point_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 28:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x9c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Circle_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Circle_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Circle_element (pdata2);

                  stat = asn1D_Ns3_Circle_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_PRIM|16):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_PRIM|17):
         case (TM_CTXT|TM_CONS|17):
         case (TM_CTXT|TM_PRIM|18):
         case (TM_CTXT|TM_CONS|18):
         case (TM_CTXT|TM_PRIM|19):
         case (TM_CTXT|TM_CONS|19):
         case (TM_CTXT|TM_PRIM|20):
         case (TM_CTXT|TM_CONS|20):
         case (TM_CTXT|TM_PRIM|21):
         case (TM_CTXT|TM_CONS|21):
         case (TM_CTXT|TM_PRIM|22):
         case (TM_CTXT|TM_CONS|22):
         case (TM_CTXT|TM_PRIM|23):
         case (TM_CTXT|TM_PRIM|24):
         case (TM_CTXT|TM_PRIM|25):
         case (TM_CTXT|TM_CONS|26):
         case (TM_CTXT|TM_CONS|27):
         case (TM_CTXT|TM_CONS|28):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Circle (OSCTXT* pctxt, Ns3_Circle* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("end-angle"), 9}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("kind"), 4}, 0 },
         { {OSUTF8("layer"), 5}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("start-angle"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("text-style-name"), 15}, 0 },
         { {OSUTF8("transform"), 9}, 0 },
         { {OSUTF8("z-index"), 7}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("cx"), 2}, 0 },
         { {OSUTF8("cy"), 2}, 0 },
         { {OSUTF8("height"), 6}, 0 },
         { {OSUTF8("r"), 1}, 0 },
         { {OSUTF8("width"), 5}, 0 },
         { {OSUTF8("x"), 1}, 0 },
         { {OSUTF8("y"), 1}, 0 },
         { {OSUTF8("end-cell-address"), 16}, 0 },
         { {OSUTF8("end-x"), 5}, 0 },
         { {OSUTF8("end-y"), 5}, 0 },
         { {OSUTF8("table-background"), 16}, 0 },
         { {OSUTF8("anchor-page-number"), 18}, 0 },
         { {OSUTF8("anchor-type"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 26, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* class-names */
            rtxDListInit (&pvalue->class_names);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_namesPresent = TRUE;
            break;

         case 1: /* end-angle */
            stat = rtXmlpDecDouble (pctxt, &pvalue->end_angle, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_anglePresent = TRUE;
            break;

         case 2: /* id */
            stat = XmlDec_Ns3_Id (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 3: /* kind */
            stat = XmlDec_Ns3_Circle_kind (pctxt, &pvalue->kind);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.kindPresent = TRUE;
            break;

         case 4: /* layer */
            stat = XmlDec_Ns3_Layer_1 (pctxt, &pvalue->layer);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.layerPresent = TRUE;
            break;

         case 5: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 6: /* start-angle */
            stat = rtXmlpDecDouble (pctxt, &pvalue->start_angle, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.start_anglePresent = TRUE;
            break;

         case 7: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         case 8: /* text-style-name */
            stat = XmlDec_Ns3_Text_style_name (pctxt, &pvalue->text_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.text_style_namePresent = TRUE;
            break;

         case 9: /* transform */
            stat = XmlDec_Ns3_Transform (pctxt, &pvalue->transform);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.transformPresent = TRUE;
            break;

         case 10: /* z-index */
            stat = XmlDec_Ns3_Z_index (pctxt, &pvalue->z_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.z_indexPresent = TRUE;
            break;

         case 11: /* class-names */
            rtxDListInit (&pvalue->class_names_1);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_names_1Present = TRUE;
            break;

         case 12: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_name_1Present = TRUE;
            break;

         case 13: /* cx */
            stat = XmlDec_Cx (pctxt, &pvalue->cx);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.cxPresent = TRUE;
            break;

         case 14: /* cy */
            stat = XmlDec_Cy (pctxt, &pvalue->cy);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.cyPresent = TRUE;
            break;

         case 15: /* height */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->height);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.heightPresent = TRUE;
            break;

         case 16: /* r */
            stat = XmlDec_R (pctxt, &pvalue->r);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.rPresent = TRUE;
            break;

         case 17: /* width */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->width);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.widthPresent = TRUE;
            break;

         case 18: /* x */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.xPresent = TRUE;
            break;

         case 19: /* y */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.yPresent = TRUE;
            break;

         case 20: /* end-cell-address */
            stat = XmlDec_End_cell_address (pctxt, &pvalue->end_cell_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_cell_addressPresent = TRUE;
            break;

         case 21: /* end-x */
            stat = XmlDec_End_x (pctxt, &pvalue->end_x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_xPresent = TRUE;
            break;

         case 22: /* end-y */
            stat = XmlDec_End_y (pctxt, &pvalue->end_y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_yPresent = TRUE;
            break;

         case 23: /* table-background */
            stat = XmlDec_Table_background (pctxt, &pvalue->table_background);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.table_backgroundPresent = TRUE;
            break;

         case 24: /* anchor-page-number */
            stat = XmlDec_Odf_Anchor_page_number (pctxt, &pvalue->
               anchor_page_number);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_page_numberPresent = TRUE;
            break;

         case 25: /* anchor-type */
            stat = XmlDec_Odf_Anchor_type (pctxt, &pvalue->anchor_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_typePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Circle");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Circle");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("event-listeners"), 15}, 0}, 0 },
      {{{OSUTF8("glue-point"), 10}, 0}, 1 },
      {{{OSUTF8("p"), 1}, 0}, 2 },
      {{{OSUTF8("list"), 4}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      case 1: {
         Ns3_Glue_point* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Glue_point);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Glue_point (pdata1);

            stat = XmlDec_Ns3_Glue_point (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->glue_point_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 2: {
         Ns3_Circle_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Circle_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Circle_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns3_Circle_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 2, 2, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ellipse_kind                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Ellipse_kind (OSCTXT* pctxt, Ns3_Ellipse_kind *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Ellipse_kind (OSCTXT* pctxt, Ns3_Ellipse_kind* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Ellipse_kind_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ellipse_element                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Ellipse_element (OSCTXT* pctxt, 
   Ns3_Ellipse_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P ((Odf_P*)pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            (Odf_P*)pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List ((Odf_List*)pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            (Odf_List*)pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Ellipse_element (OSCTXT* pctxt, Ns3_Ellipse_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("list"), 4}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P ((Odf_P*)pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List ((Odf_List*)pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Ellipse                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Ellipse (OSCTXT* pctxt, Ns3_Ellipse *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode class_names */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_namesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode end_angle */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->end_angle, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_anglePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Id (pctxt, 
               &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode kind */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Ellipse_kind (pctxt, 
               &pvalue->kind, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.kindPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode layer */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Layer_1 (pctxt, 
               &pvalue->layer, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.layerPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode start_angle */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->start_angle, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.start_anglePresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode text_style_name */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Text_style_name (pctxt, 
               &pvalue->text_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.text_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode transform */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Transform (pctxt, 
               &pvalue->transform, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.transformPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode z_index */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Z_index (pctxt, 
               &pvalue->z_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.z_indexPresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode class_names_1 */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_names_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 12:
         /* decode style_name_1 */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_name_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 13:
         /* decode cx */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Cx (pctxt, 
               (Cx*)&pvalue->cx, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.cxPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode cy */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Cy (pctxt, 
               (Cy*)&pvalue->cy, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.cyPresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode height */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->height, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.heightPresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode rx */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Rx (pctxt, 
               (Rx*)&pvalue->rx, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.rxPresent = TRUE;
            }
         }
         break;

      case 17:
         /* decode ry */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ry (pctxt, 
               (Ry*)&pvalue->ry, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.ryPresent = TRUE;
            }
         }
         break;

      case 18:
         /* decode width */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->width, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.widthPresent = TRUE;
            }
         }
         break;

      case 19:
         /* decode x */
         if (XD_PEEKTAG (pctxt, 0x93)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.xPresent = TRUE;
            }
         }
         break;

      case 20:
         /* decode y */
         if (XD_PEEKTAG (pctxt, 0x94)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.yPresent = TRUE;
            }
         }
         break;

      case 21:
         /* decode end_cell_address */
         if (XD_PEEKTAG (pctxt, 0x95)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_cell_address (pctxt, 
               (End_cell_address*)&pvalue->end_cell_address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_cell_addressPresent = TRUE;
            }
         }
         break;

      case 22:
         /* decode end_x */
         if (XD_PEEKTAG (pctxt, 0x96)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_x (pctxt, 
               (End_x*)&pvalue->end_x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_xPresent = TRUE;
            }
         }
         break;

      case 23:
         /* decode end_y */
         if (XD_PEEKTAG (pctxt, 0x97)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_y (pctxt, 
               (End_y*)&pvalue->end_y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_yPresent = TRUE;
            }
         }
         break;

      case 24:
         /* decode table_background */
         if (XD_PEEKTAG (pctxt, 0x98)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_background (pctxt, 
               (Table_background*)&pvalue->table_background, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_backgroundPresent = TRUE;
            }
         }
         break;

      case 25:
         /* decode anchor_page_number */
         if (XD_PEEKTAG (pctxt, 0x99)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_page_number (pctxt, 
               (Odf_Anchor_page_number*)&pvalue->anchor_page_number, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_page_numberPresent = TRUE;
            }
         }
         break;

      case 26:
         /* decode anchor_type */
         if (XD_PEEKTAG (pctxt, 0x9a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_type (pctxt, 
               (Odf_Anchor_type*)&pvalue->anchor_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_typePresent = TRUE;
            }
         }
         break;

      case 27:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x9b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 28:
         /* decode glue_point_list */
         if (XD_PEEKTAG (pctxt, 0x9c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Glue_point* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->glue_point_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Glue_point, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Glue_point (pdata2);

                  stat = asn1D_Ns3_Glue_point (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->glue_point_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 29:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x9d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Ellipse_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Ellipse_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Ellipse_element (pdata2);

                  stat = asn1D_Ns3_Ellipse_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_PRIM|16):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_PRIM|17):
         case (TM_CTXT|TM_CONS|17):
         case (TM_CTXT|TM_PRIM|18):
         case (TM_CTXT|TM_CONS|18):
         case (TM_CTXT|TM_PRIM|19):
         case (TM_CTXT|TM_CONS|19):
         case (TM_CTXT|TM_PRIM|20):
         case (TM_CTXT|TM_CONS|20):
         case (TM_CTXT|TM_PRIM|21):
         case (TM_CTXT|TM_CONS|21):
         case (TM_CTXT|TM_PRIM|22):
         case (TM_CTXT|TM_CONS|22):
         case (TM_CTXT|TM_PRIM|23):
         case (TM_CTXT|TM_CONS|23):
         case (TM_CTXT|TM_PRIM|24):
         case (TM_CTXT|TM_PRIM|25):
         case (TM_CTXT|TM_PRIM|26):
         case (TM_CTXT|TM_CONS|27):
         case (TM_CTXT|TM_CONS|28):
         case (TM_CTXT|TM_CONS|29):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Ellipse (OSCTXT* pctxt, Ns3_Ellipse* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("end-angle"), 9}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("kind"), 4}, 0 },
         { {OSUTF8("layer"), 5}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("start-angle"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("text-style-name"), 15}, 0 },
         { {OSUTF8("transform"), 9}, 0 },
         { {OSUTF8("z-index"), 7}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("cx"), 2}, 0 },
         { {OSUTF8("cy"), 2}, 0 },
         { {OSUTF8("height"), 6}, 0 },
         { {OSUTF8("rx"), 2}, 0 },
         { {OSUTF8("ry"), 2}, 0 },
         { {OSUTF8("width"), 5}, 0 },
         { {OSUTF8("x"), 1}, 0 },
         { {OSUTF8("y"), 1}, 0 },
         { {OSUTF8("end-cell-address"), 16}, 0 },
         { {OSUTF8("end-x"), 5}, 0 },
         { {OSUTF8("end-y"), 5}, 0 },
         { {OSUTF8("table-background"), 16}, 0 },
         { {OSUTF8("anchor-page-number"), 18}, 0 },
         { {OSUTF8("anchor-type"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 27, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* class-names */
            rtxDListInit (&pvalue->class_names);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_namesPresent = TRUE;
            break;

         case 1: /* end-angle */
            stat = rtXmlpDecDouble (pctxt, &pvalue->end_angle, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_anglePresent = TRUE;
            break;

         case 2: /* id */
            stat = XmlDec_Ns3_Id (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 3: /* kind */
            stat = XmlDec_Ns3_Ellipse_kind (pctxt, &pvalue->kind);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.kindPresent = TRUE;
            break;

         case 4: /* layer */
            stat = XmlDec_Ns3_Layer_1 (pctxt, &pvalue->layer);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.layerPresent = TRUE;
            break;

         case 5: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 6: /* start-angle */
            stat = rtXmlpDecDouble (pctxt, &pvalue->start_angle, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.start_anglePresent = TRUE;
            break;

         case 7: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         case 8: /* text-style-name */
            stat = XmlDec_Ns3_Text_style_name (pctxt, &pvalue->text_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.text_style_namePresent = TRUE;
            break;

         case 9: /* transform */
            stat = XmlDec_Ns3_Transform (pctxt, &pvalue->transform);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.transformPresent = TRUE;
            break;

         case 10: /* z-index */
            stat = XmlDec_Ns3_Z_index (pctxt, &pvalue->z_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.z_indexPresent = TRUE;
            break;

         case 11: /* class-names */
            rtxDListInit (&pvalue->class_names_1);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_names_1Present = TRUE;
            break;

         case 12: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_name_1Present = TRUE;
            break;

         case 13: /* cx */
            stat = XmlDec_Cx (pctxt, &pvalue->cx);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.cxPresent = TRUE;
            break;

         case 14: /* cy */
            stat = XmlDec_Cy (pctxt, &pvalue->cy);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.cyPresent = TRUE;
            break;

         case 15: /* height */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->height);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.heightPresent = TRUE;
            break;

         case 16: /* rx */
            stat = XmlDec_Rx (pctxt, &pvalue->rx);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.rxPresent = TRUE;
            break;

         case 17: /* ry */
            stat = XmlDec_Ry (pctxt, &pvalue->ry);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.ryPresent = TRUE;
            break;

         case 18: /* width */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->width);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.widthPresent = TRUE;
            break;

         case 19: /* x */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.xPresent = TRUE;
            break;

         case 20: /* y */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.yPresent = TRUE;
            break;

         case 21: /* end-cell-address */
            stat = XmlDec_End_cell_address (pctxt, &pvalue->end_cell_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_cell_addressPresent = TRUE;
            break;

         case 22: /* end-x */
            stat = XmlDec_End_x (pctxt, &pvalue->end_x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_xPresent = TRUE;
            break;

         case 23: /* end-y */
            stat = XmlDec_End_y (pctxt, &pvalue->end_y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_yPresent = TRUE;
            break;

         case 24: /* table-background */
            stat = XmlDec_Table_background (pctxt, &pvalue->table_background);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.table_backgroundPresent = TRUE;
            break;

         case 25: /* anchor-page-number */
            stat = XmlDec_Odf_Anchor_page_number (pctxt, &pvalue->
               anchor_page_number);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_page_numberPresent = TRUE;
            break;

         case 26: /* anchor-type */
            stat = XmlDec_Odf_Anchor_type (pctxt, &pvalue->anchor_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_typePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Ellipse");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Ellipse");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("event-listeners"), 15}, 0}, 0 },
      {{{OSUTF8("glue-point"), 10}, 0}, 1 },
      {{{OSUTF8("p"), 1}, 0}, 2 },
      {{{OSUTF8("list"), 4}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      case 1: {
         Ns3_Glue_point* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Glue_point);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Glue_point (pdata1);

            stat = XmlDec_Ns3_Glue_point (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->glue_point_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 2: {
         Ns3_Ellipse_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Ellipse_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Ellipse_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns3_Ellipse_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 2, 2, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Page_thumbnail                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Page_thumbnail (OSCTXT* pctxt, 
   Ns3_Page_thumbnail *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode class_names */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_namesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Id (pctxt, 
               &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode layer */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Layer_1 (pctxt, 
               &pvalue->layer, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.layerPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode page_number */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->page_number, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.page_numberPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode transform */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Transform (pctxt, 
               &pvalue->transform, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.transformPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode z_index */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Z_index (pctxt, 
               &pvalue->z_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.z_indexPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode class_ */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns10_Class (pctxt, 
               (Ns10_Class*)&pvalue->class_, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_Present = TRUE;
            }
         }
         break;

      case 9:
         /* decode class_names_1 */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_names_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 10:
         /* decode placeholder */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns10_Placeholder_1 (pctxt, 
               (Ns10_Placeholder_1*)&pvalue->placeholder, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.placeholderPresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode style_name_1 */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_name_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 12:
         /* decode user_transformed */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns10_User_transformed (pctxt, 
               (Ns10_User_transformed*)&pvalue->user_transformed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.user_transformedPresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode height */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->height, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.heightPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode width */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->width, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.widthPresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode x */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.xPresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode y */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.yPresent = TRUE;
            }
         }
         break;

      case 17:
         /* decode end_cell_address */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_cell_address (pctxt, 
               (End_cell_address*)&pvalue->end_cell_address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_cell_addressPresent = TRUE;
            }
         }
         break;

      case 18:
         /* decode end_x */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_x (pctxt, 
               (End_x*)&pvalue->end_x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_xPresent = TRUE;
            }
         }
         break;

      case 19:
         /* decode end_y */
         if (XD_PEEKTAG (pctxt, 0x93)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_y (pctxt, 
               (End_y*)&pvalue->end_y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_yPresent = TRUE;
            }
         }
         break;

      case 20:
         /* decode table_background */
         if (XD_PEEKTAG (pctxt, 0x94)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_background (pctxt, 
               (Table_background*)&pvalue->table_background, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_backgroundPresent = TRUE;
            }
         }
         break;

      case 21:
         /* decode anchor_page_number */
         if (XD_PEEKTAG (pctxt, 0x95)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_page_number (pctxt, 
               (Odf_Anchor_page_number*)&pvalue->anchor_page_number, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_page_numberPresent = TRUE;
            }
         }
         break;

      case 22:
         /* decode anchor_type */
         if (XD_PEEKTAG (pctxt, 0x96)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_type (pctxt, 
               (Odf_Anchor_type*)&pvalue->anchor_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_typePresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_PRIM|16):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_PRIM|17):
         case (TM_CTXT|TM_CONS|17):
         case (TM_CTXT|TM_PRIM|18):
         case (TM_CTXT|TM_CONS|18):
         case (TM_CTXT|TM_PRIM|19):
         case (TM_CTXT|TM_CONS|19):
         case (TM_CTXT|TM_PRIM|20):
         case (TM_CTXT|TM_PRIM|21):
         case (TM_CTXT|TM_PRIM|22):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Page_thumbnail (OSCTXT* pctxt, Ns3_Page_thumbnail* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("layer"), 5}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("page-number"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("transform"), 9}, 0 },
         { {OSUTF8("z-index"), 7}, 0 },
         { {OSUTF8("class"), 5}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("placeholder"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("user-transformed"), 16}, 0 },
         { {OSUTF8("height"), 6}, 0 },
         { {OSUTF8("width"), 5}, 0 },
         { {OSUTF8("x"), 1}, 0 },
         { {OSUTF8("y"), 1}, 0 },
         { {OSUTF8("end-cell-address"), 16}, 0 },
         { {OSUTF8("end-x"), 5}, 0 },
         { {OSUTF8("end-y"), 5}, 0 },
         { {OSUTF8("table-background"), 16}, 0 },
         { {OSUTF8("anchor-page-number"), 18}, 0 },
         { {OSUTF8("anchor-type"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 23, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* class-names */
            rtxDListInit (&pvalue->class_names);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_namesPresent = TRUE;
            break;

         case 1: /* id */
            stat = XmlDec_Ns3_Id (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* layer */
            stat = XmlDec_Ns3_Layer_1 (pctxt, &pvalue->layer);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.layerPresent = TRUE;
            break;

         case 3: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 4: /* page-number */
            stat = rtXmlpDecUInt (pctxt, &pvalue->page_number);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.page_numberPresent = TRUE;
            break;

         case 5: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         case 6: /* transform */
            stat = XmlDec_Ns3_Transform (pctxt, &pvalue->transform);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.transformPresent = TRUE;
            break;

         case 7: /* z-index */
            stat = XmlDec_Ns3_Z_index (pctxt, &pvalue->z_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.z_indexPresent = TRUE;
            break;

         case 8: /* class */
            stat = XmlDec_Ns10_Class (pctxt, &pvalue->class_);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_Present = TRUE;
            break;

         case 9: /* class-names */
            rtxDListInit (&pvalue->class_names_1);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_names_1Present = TRUE;
            break;

         case 10: /* placeholder */
            stat = XmlDec_Ns10_Placeholder_1 (pctxt, &pvalue->placeholder);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.placeholderPresent = TRUE;
            break;

         case 11: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_name_1Present = TRUE;
            break;

         case 12: /* user-transformed */
            stat = XmlDec_Ns10_User_transformed (pctxt, &pvalue->
               user_transformed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.user_transformedPresent = TRUE;
            break;

         case 13: /* height */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->height);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.heightPresent = TRUE;
            break;

         case 14: /* width */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->width);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.widthPresent = TRUE;
            break;

         case 15: /* x */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.xPresent = TRUE;
            break;

         case 16: /* y */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.yPresent = TRUE;
            break;

         case 17: /* end-cell-address */
            stat = XmlDec_End_cell_address (pctxt, &pvalue->end_cell_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_cell_addressPresent = TRUE;
            break;

         case 18: /* end-x */
            stat = XmlDec_End_x (pctxt, &pvalue->end_x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_xPresent = TRUE;
            break;

         case 19: /* end-y */
            stat = XmlDec_End_y (pctxt, &pvalue->end_y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_yPresent = TRUE;
            break;

         case 20: /* table-background */
            stat = XmlDec_Table_background (pctxt, &pvalue->table_background);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.table_backgroundPresent = TRUE;
            break;

         case 21: /* anchor-page-number */
            stat = XmlDec_Odf_Anchor_page_number (pctxt, &pvalue->
               anchor_page_number);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_page_numberPresent = TRUE;
            break;

         case 22: /* anchor-type */
            stat = XmlDec_Odf_Anchor_type (pctxt, &pvalue->anchor_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_typePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Page_thumbnail");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Page_thumbnail");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Measure_element                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Measure_element (OSCTXT* pctxt, 
   Ns3_Measure_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P ((Odf_P*)pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            (Odf_P*)pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List ((Odf_List*)pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            (Odf_List*)pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Measure_element (OSCTXT* pctxt, Ns3_Measure_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("list"), 4}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P ((Odf_P*)pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List ((Odf_List*)pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Measure                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Measure (OSCTXT* pctxt, Ns3_Measure *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode class_names */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_namesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Id (pctxt, 
               &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode layer */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Layer_1 (pctxt, 
               &pvalue->layer, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.layerPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode text_style_name */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Text_style_name (pctxt, 
               &pvalue->text_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.text_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode transform */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Transform (pctxt, 
               &pvalue->transform, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.transformPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode z_index */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Z_index (pctxt, 
               &pvalue->z_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.z_indexPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode class_names_1 */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_names_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode style_name_1 */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_name_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 10:
         /* decode x1 */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_X1 (pctxt, 
               (X1*)&pvalue->x1, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 11:
         /* decode x2 */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_X2 (pctxt, 
               (X2*)&pvalue->x2, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 12:
         /* decode y1 */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Y1 (pctxt, 
               (Y1*)&pvalue->y1, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 13:
         /* decode y2 */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Y2 (pctxt, 
               (Y2*)&pvalue->y2, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 14:
         /* decode end_cell_address */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_cell_address (pctxt, 
               (End_cell_address*)&pvalue->end_cell_address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_cell_addressPresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode end_x */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_x (pctxt, 
               (End_x*)&pvalue->end_x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_xPresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode end_y */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_y (pctxt, 
               (End_y*)&pvalue->end_y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_yPresent = TRUE;
            }
         }
         break;

      case 17:
         /* decode table_background */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_background (pctxt, 
               (Table_background*)&pvalue->table_background, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_backgroundPresent = TRUE;
            }
         }
         break;

      case 18:
         /* decode anchor_page_number */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_page_number (pctxt, 
               (Odf_Anchor_page_number*)&pvalue->anchor_page_number, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_page_numberPresent = TRUE;
            }
         }
         break;

      case 19:
         /* decode anchor_type */
         if (XD_PEEKTAG (pctxt, 0x93)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_type (pctxt, 
               (Odf_Anchor_type*)&pvalue->anchor_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_typePresent = TRUE;
            }
         }
         break;

      case 20:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x94)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 21:
         /* decode glue_point_list */
         if (XD_PEEKTAG (pctxt, 0x95)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Glue_point* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->glue_point_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Glue_point, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Glue_point (pdata2);

                  stat = asn1D_Ns3_Glue_point (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->glue_point_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 22:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x96)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Measure_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Measure_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Measure_element (pdata2);

                  stat = asn1D_Ns3_Measure_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_PRIM|16):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_PRIM|17):
         case (TM_CTXT|TM_PRIM|18):
         case (TM_CTXT|TM_PRIM|19):
         case (TM_CTXT|TM_CONS|20):
         case (TM_CTXT|TM_CONS|21):
         case (TM_CTXT|TM_CONS|22):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 6) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Measure (OSCTXT* pctxt, Ns3_Measure* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("layer"), 5}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("text-style-name"), 15}, 0 },
         { {OSUTF8("transform"), 9}, 0 },
         { {OSUTF8("z-index"), 7}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("x1"), 2}, 0 },
         { {OSUTF8("x2"), 2}, 0 },
         { {OSUTF8("y1"), 2}, 0 },
         { {OSUTF8("y2"), 2}, 0 },
         { {OSUTF8("end-cell-address"), 16}, 0 },
         { {OSUTF8("end-x"), 5}, 0 },
         { {OSUTF8("end-y"), 5}, 0 },
         { {OSUTF8("table-background"), 16}, 0 },
         { {OSUTF8("anchor-page-number"), 18}, 0 },
         { {OSUTF8("anchor-type"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 20, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* class-names */
            rtxDListInit (&pvalue->class_names);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_namesPresent = TRUE;
            break;

         case 1: /* id */
            stat = XmlDec_Ns3_Id (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* layer */
            stat = XmlDec_Ns3_Layer_1 (pctxt, &pvalue->layer);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.layerPresent = TRUE;
            break;

         case 3: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 4: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         case 5: /* text-style-name */
            stat = XmlDec_Ns3_Text_style_name (pctxt, &pvalue->text_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.text_style_namePresent = TRUE;
            break;

         case 6: /* transform */
            stat = XmlDec_Ns3_Transform (pctxt, &pvalue->transform);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.transformPresent = TRUE;
            break;

         case 7: /* z-index */
            stat = XmlDec_Ns3_Z_index (pctxt, &pvalue->z_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.z_indexPresent = TRUE;
            break;

         case 8: /* class-names */
            rtxDListInit (&pvalue->class_names_1);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_names_1Present = TRUE;
            break;

         case 9: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_name_1Present = TRUE;
            break;

         case 10: /* x1 */
            stat = XmlDec_X1 (pctxt, &pvalue->x1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 11: /* x2 */
            stat = XmlDec_X2 (pctxt, &pvalue->x2);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 12: /* y1 */
            stat = XmlDec_Y1 (pctxt, &pvalue->y1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 13: /* y2 */
            stat = XmlDec_Y2 (pctxt, &pvalue->y2);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 14: /* end-cell-address */
            stat = XmlDec_End_cell_address (pctxt, &pvalue->end_cell_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_cell_addressPresent = TRUE;
            break;

         case 15: /* end-x */
            stat = XmlDec_End_x (pctxt, &pvalue->end_x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_xPresent = TRUE;
            break;

         case 16: /* end-y */
            stat = XmlDec_End_y (pctxt, &pvalue->end_y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_yPresent = TRUE;
            break;

         case 17: /* table-background */
            stat = XmlDec_Table_background (pctxt, &pvalue->table_background);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.table_backgroundPresent = TRUE;
            break;

         case 18: /* anchor-page-number */
            stat = XmlDec_Odf_Anchor_page_number (pctxt, &pvalue->
               anchor_page_number);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_page_numberPresent = TRUE;
            break;

         case 19: /* anchor-type */
            stat = XmlDec_Odf_Anchor_type (pctxt, &pvalue->anchor_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_typePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Measure");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Measure");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("event-listeners"), 15}, 0}, 0 },
      {{{OSUTF8("glue-point"), 10}, 0}, 1 },
      {{{OSUTF8("p"), 1}, 0}, 2 },
      {{{OSUTF8("list"), 4}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      case 1: {
         Ns3_Glue_point* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Glue_point);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Glue_point (pdata1);

            stat = XmlDec_Ns3_Glue_point (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->glue_point_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 2: {
         Ns3_Measure_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Measure_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Measure_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns3_Measure_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 2, 2, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Caption_element                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Caption_element (OSCTXT* pctxt, 
   Ns3_Caption_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P ((Odf_P*)pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            (Odf_P*)pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List ((Odf_List*)pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            (Odf_List*)pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Caption_element (OSCTXT* pctxt, Ns3_Caption_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("list"), 4}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P ((Odf_P*)pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List ((Odf_List*)pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Caption                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Caption (OSCTXT* pctxt, Ns3_Caption *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode caption_point_x */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Caption_point_x (pctxt, 
               &pvalue->caption_point_x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.caption_point_xPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode caption_point_y */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Caption_point_y (pctxt, 
               &pvalue->caption_point_y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.caption_point_yPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode class_names */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_namesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode corner_radius */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Corner_radius (pctxt, 
               &pvalue->corner_radius, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.corner_radiusPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Id (pctxt, 
               &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode layer */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Layer_1 (pctxt, 
               &pvalue->layer, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.layerPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode text_style_name */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Text_style_name (pctxt, 
               &pvalue->text_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.text_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode transform */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Transform (pctxt, 
               &pvalue->transform, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.transformPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode z_index */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Z_index (pctxt, 
               &pvalue->z_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.z_indexPresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode class_names_1 */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_names_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 12:
         /* decode style_name_1 */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_name_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 13:
         /* decode height */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->height, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.heightPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode width */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->width, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.widthPresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode x */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.xPresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode y */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.yPresent = TRUE;
            }
         }
         break;

      case 17:
         /* decode end_cell_address */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_cell_address (pctxt, 
               (End_cell_address*)&pvalue->end_cell_address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_cell_addressPresent = TRUE;
            }
         }
         break;

      case 18:
         /* decode end_x */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_x (pctxt, 
               (End_x*)&pvalue->end_x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_xPresent = TRUE;
            }
         }
         break;

      case 19:
         /* decode end_y */
         if (XD_PEEKTAG (pctxt, 0x93)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_y (pctxt, 
               (End_y*)&pvalue->end_y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_yPresent = TRUE;
            }
         }
         break;

      case 20:
         /* decode table_background */
         if (XD_PEEKTAG (pctxt, 0x94)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_background (pctxt, 
               (Table_background*)&pvalue->table_background, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_backgroundPresent = TRUE;
            }
         }
         break;

      case 21:
         /* decode anchor_page_number */
         if (XD_PEEKTAG (pctxt, 0x95)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_page_number (pctxt, 
               (Odf_Anchor_page_number*)&pvalue->anchor_page_number, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_page_numberPresent = TRUE;
            }
         }
         break;

      case 22:
         /* decode anchor_type */
         if (XD_PEEKTAG (pctxt, 0x96)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_type (pctxt, 
               (Odf_Anchor_type*)&pvalue->anchor_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_typePresent = TRUE;
            }
         }
         break;

      case 23:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x97)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 24:
         /* decode glue_point_list */
         if (XD_PEEKTAG (pctxt, 0x98)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Glue_point* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->glue_point_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Glue_point, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Glue_point (pdata2);

                  stat = asn1D_Ns3_Glue_point (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->glue_point_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 25:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x99)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Caption_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Caption_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Caption_element (pdata2);

                  stat = asn1D_Ns3_Caption_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_PRIM|16):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_PRIM|17):
         case (TM_CTXT|TM_CONS|17):
         case (TM_CTXT|TM_PRIM|18):
         case (TM_CTXT|TM_CONS|18):
         case (TM_CTXT|TM_PRIM|19):
         case (TM_CTXT|TM_CONS|19):
         case (TM_CTXT|TM_PRIM|20):
         case (TM_CTXT|TM_PRIM|21):
         case (TM_CTXT|TM_PRIM|22):
         case (TM_CTXT|TM_CONS|23):
         case (TM_CTXT|TM_CONS|24):
         case (TM_CTXT|TM_CONS|25):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Caption (OSCTXT* pctxt, Ns3_Caption* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("caption-point-x"), 15}, 0 },
         { {OSUTF8("caption-point-y"), 15}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("corner-radius"), 13}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("layer"), 5}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("text-style-name"), 15}, 0 },
         { {OSUTF8("transform"), 9}, 0 },
         { {OSUTF8("z-index"), 7}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("height"), 6}, 0 },
         { {OSUTF8("width"), 5}, 0 },
         { {OSUTF8("x"), 1}, 0 },
         { {OSUTF8("y"), 1}, 0 },
         { {OSUTF8("end-cell-address"), 16}, 0 },
         { {OSUTF8("end-x"), 5}, 0 },
         { {OSUTF8("end-y"), 5}, 0 },
         { {OSUTF8("table-background"), 16}, 0 },
         { {OSUTF8("anchor-page-number"), 18}, 0 },
         { {OSUTF8("anchor-type"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 23, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* caption-point-x */
            stat = XmlDec_Ns3_Caption_point_x (pctxt, &pvalue->caption_point_x
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.caption_point_xPresent = TRUE;
            break;

         case 1: /* caption-point-y */
            stat = XmlDec_Ns3_Caption_point_y (pctxt, &pvalue->caption_point_y
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.caption_point_yPresent = TRUE;
            break;

         case 2: /* class-names */
            rtxDListInit (&pvalue->class_names);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_namesPresent = TRUE;
            break;

         case 3: /* corner-radius */
            stat = XmlDec_Ns3_Corner_radius (pctxt, &pvalue->corner_radius);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.corner_radiusPresent = TRUE;
            break;

         case 4: /* id */
            stat = XmlDec_Ns3_Id (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 5: /* layer */
            stat = XmlDec_Ns3_Layer_1 (pctxt, &pvalue->layer);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.layerPresent = TRUE;
            break;

         case 6: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 7: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         case 8: /* text-style-name */
            stat = XmlDec_Ns3_Text_style_name (pctxt, &pvalue->text_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.text_style_namePresent = TRUE;
            break;

         case 9: /* transform */
            stat = XmlDec_Ns3_Transform (pctxt, &pvalue->transform);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.transformPresent = TRUE;
            break;

         case 10: /* z-index */
            stat = XmlDec_Ns3_Z_index (pctxt, &pvalue->z_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.z_indexPresent = TRUE;
            break;

         case 11: /* class-names */
            rtxDListInit (&pvalue->class_names_1);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_names_1Present = TRUE;
            break;

         case 12: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_name_1Present = TRUE;
            break;

         case 13: /* height */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->height);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.heightPresent = TRUE;
            break;

         case 14: /* width */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->width);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.widthPresent = TRUE;
            break;

         case 15: /* x */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.xPresent = TRUE;
            break;

         case 16: /* y */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.yPresent = TRUE;
            break;

         case 17: /* end-cell-address */
            stat = XmlDec_End_cell_address (pctxt, &pvalue->end_cell_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_cell_addressPresent = TRUE;
            break;

         case 18: /* end-x */
            stat = XmlDec_End_x (pctxt, &pvalue->end_x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_xPresent = TRUE;
            break;

         case 19: /* end-y */
            stat = XmlDec_End_y (pctxt, &pvalue->end_y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_yPresent = TRUE;
            break;

         case 20: /* table-background */
            stat = XmlDec_Table_background (pctxt, &pvalue->table_background);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.table_backgroundPresent = TRUE;
            break;

         case 21: /* anchor-page-number */
            stat = XmlDec_Odf_Anchor_page_number (pctxt, &pvalue->
               anchor_page_number);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_page_numberPresent = TRUE;
            break;

         case 22: /* anchor-type */
            stat = XmlDec_Odf_Anchor_type (pctxt, &pvalue->anchor_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_typePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Caption");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Caption");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("event-listeners"), 15}, 0}, 0 },
      {{{OSUTF8("glue-point"), 10}, 0}, 1 },
      {{{OSUTF8("p"), 1}, 0}, 2 },
      {{{OSUTF8("list"), 4}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      case 1: {
         Ns3_Glue_point* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Glue_point);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Glue_point (pdata1);

            stat = XmlDec_Ns3_Glue_point (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->glue_point_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 2: {
         Ns3_Caption_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Caption_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Caption_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns3_Caption_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 2, 2, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Connector_line_skew_element                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Connector_line_skew_element (OSCTXT* pctxt, 
   Ns3_Connector_line_skew_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|2):
      case (TM_CTXT|TM_CONS|2):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_2, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Connector_line_skew_element (OSCTXT* pctxt, 
   Ns3_Connector_line_skew_element* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_2 = pdata1;
      pvalue->t = 3;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Connector_type                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Connector_type (OSCTXT* pctxt, 
   Ns3_Connector_type *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Connector_type (OSCTXT* pctxt, Ns3_Connector_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Connector_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Connector_element                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Connector_element (OSCTXT* pctxt, 
   Ns3_Connector_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P ((Odf_P*)pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            (Odf_P*)pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List ((Odf_List*)pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            (Odf_List*)pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Connector_element (OSCTXT* pctxt, Ns3_Connector_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("list"), 4}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P ((Odf_P*)pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List ((Odf_List*)pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Connector                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Connector (OSCTXT* pctxt, Ns3_Connector *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode class_names */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_namesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode end_glue_point */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->end_glue_point, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_glue_pointPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode end_shape */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->end_shape, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_shapePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Id (pctxt, 
               &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode layer */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Layer_1 (pctxt, 
               &pvalue->layer, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.layerPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode line_skew */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Connector_line_skew_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->line_skew);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  if (pvalue->line_skew.count >= 3) return LOG_RTERR (pctxt, RTERR_SEQOVFLW);

                  rtxDListAllocNodeAndData (pctxt, Ns3_Connector_line_skew_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Connector_line_skew_element (pdata2);

                  stat = asn1D_Ns3_Connector_line_skew_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->line_skew, pnode);
               }

            }
            if (stat == 0) {
               pvalue->m.line_skewPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode start_glue_point */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->start_glue_point, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.start_glue_pointPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode start_shape */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->start_shape, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.start_shapePresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 10:
         /* decode text_style_name */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Text_style_name (pctxt, 
               &pvalue->text_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.text_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 11:
         /* decode transform */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Transform (pctxt, 
               &pvalue->transform, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.transformPresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Connector_type (pctxt, 
               &pvalue->type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.typePresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode z_index */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Z_index (pctxt, 
               &pvalue->z_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.z_indexPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode class_names_1 */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_names_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 15:
         /* decode style_name_1 */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_name_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 16:
         /* decode x1 */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_X1 (pctxt, 
               (X1*)&pvalue->x1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.x1Present = TRUE;
            }
         }
         break;

      case 17:
         /* decode x2 */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_X2 (pctxt, 
               (X2*)&pvalue->x2, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.x2Present = TRUE;
            }
         }
         break;

      case 18:
         /* decode y1 */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Y1 (pctxt, 
               (Y1*)&pvalue->y1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.y1Present = TRUE;
            }
         }
         break;

      case 19:
         /* decode y2 */
         if (XD_PEEKTAG (pctxt, 0x93)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Y2 (pctxt, 
               (Y2*)&pvalue->y2, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.y2Present = TRUE;
            }
         }
         break;

      case 20:
         /* decode end_cell_address */
         if (XD_PEEKTAG (pctxt, 0x94)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_cell_address (pctxt, 
               (End_cell_address*)&pvalue->end_cell_address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_cell_addressPresent = TRUE;
            }
         }
         break;

      case 21:
         /* decode end_x */
         if (XD_PEEKTAG (pctxt, 0x95)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_x (pctxt, 
               (End_x*)&pvalue->end_x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_xPresent = TRUE;
            }
         }
         break;

      case 22:
         /* decode end_y */
         if (XD_PEEKTAG (pctxt, 0x96)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_y (pctxt, 
               (End_y*)&pvalue->end_y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_yPresent = TRUE;
            }
         }
         break;

      case 23:
         /* decode table_background */
         if (XD_PEEKTAG (pctxt, 0x97)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_background (pctxt, 
               (Table_background*)&pvalue->table_background, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_backgroundPresent = TRUE;
            }
         }
         break;

      case 24:
         /* decode anchor_page_number */
         if (XD_PEEKTAG (pctxt, 0x98)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_page_number (pctxt, 
               (Odf_Anchor_page_number*)&pvalue->anchor_page_number, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_page_numberPresent = TRUE;
            }
         }
         break;

      case 25:
         /* decode anchor_type */
         if (XD_PEEKTAG (pctxt, 0x99)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_type (pctxt, 
               (Odf_Anchor_type*)&pvalue->anchor_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_typePresent = TRUE;
            }
         }
         break;

      case 26:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x9a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 27:
         /* decode glue_point_list */
         if (XD_PEEKTAG (pctxt, 0x9b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Glue_point* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->glue_point_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Glue_point, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Glue_point (pdata2);

                  stat = asn1D_Ns3_Glue_point (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->glue_point_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 28:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x9c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Connector_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Connector_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Connector_element (pdata2);

                  stat = asn1D_Ns3_Connector_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_PRIM|16):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_PRIM|17):
         case (TM_CTXT|TM_CONS|17):
         case (TM_CTXT|TM_PRIM|18):
         case (TM_CTXT|TM_CONS|18):
         case (TM_CTXT|TM_PRIM|19):
         case (TM_CTXT|TM_CONS|19):
         case (TM_CTXT|TM_PRIM|20):
         case (TM_CTXT|TM_CONS|20):
         case (TM_CTXT|TM_PRIM|21):
         case (TM_CTXT|TM_CONS|21):
         case (TM_CTXT|TM_PRIM|22):
         case (TM_CTXT|TM_CONS|22):
         case (TM_CTXT|TM_PRIM|23):
         case (TM_CTXT|TM_PRIM|24):
         case (TM_CTXT|TM_PRIM|25):
         case (TM_CTXT|TM_CONS|26):
         case (TM_CTXT|TM_CONS|27):
         case (TM_CTXT|TM_CONS|28):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Connector (OSCTXT* pctxt, Ns3_Connector* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("end-glue-point"), 14}, 0 },
         { {OSUTF8("end-shape"), 9}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("layer"), 5}, 0 },
         { {OSUTF8("line-skew"), 9}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("start-glue-point"), 16}, 0 },
         { {OSUTF8("start-shape"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("text-style-name"), 15}, 0 },
         { {OSUTF8("transform"), 9}, 0 },
         { {OSUTF8("type"), 4}, 0 },
         { {OSUTF8("z-index"), 7}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("x1"), 2}, 0 },
         { {OSUTF8("x2"), 2}, 0 },
         { {OSUTF8("y1"), 2}, 0 },
         { {OSUTF8("y2"), 2}, 0 },
         { {OSUTF8("end-cell-address"), 16}, 0 },
         { {OSUTF8("end-x"), 5}, 0 },
         { {OSUTF8("end-y"), 5}, 0 },
         { {OSUTF8("table-background"), 16}, 0 },
         { {OSUTF8("anchor-page-number"), 18}, 0 },
         { {OSUTF8("anchor-type"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 26, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* class-names */
            rtxDListInit (&pvalue->class_names);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_namesPresent = TRUE;
            break;

         case 1: /* end-glue-point */
            stat = rtXmlpDecUInt (pctxt, &pvalue->end_glue_point);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_glue_pointPresent = TRUE;
            break;

         case 2: /* end-shape */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->end_shape);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_shapePresent = TRUE;
            break;

         case 3: /* id */
            stat = XmlDec_Ns3_Id (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 4: /* layer */
            stat = XmlDec_Ns3_Layer_1 (pctxt, &pvalue->layer);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.layerPresent = TRUE;
            break;

         case 5: /* line-skew */
            rtxDListInit (&pvalue->line_skew);
            rtXmlpSetListMode (pctxt);

            while (rtXmlpListHasItem(pctxt)) {
               Ns3_Connector_line_skew_element*
                   pdata1 = rtxMemAllocType (pctxt, 
                  Ns3_Connector_line_skew_element);
               if (0 == pdata1) LOG_RTERR (pctxt, RTERR_NOMEM);

               stat = XmlDec_Ns3_Connector_line_skew_element (pctxt, pdata1);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               if (0 == rtxDListAppend (pctxt, &pvalue->line_skew, pdata1)) {
                  return LOG_RTERR (pctxt, RTERR_NOMEM);
               }
            }

            pvalue->m.line_skewPresent = TRUE;
            break;

         case 6: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 7: /* start-glue-point */
            stat = rtXmlpDecUInt (pctxt, &pvalue->start_glue_point);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.start_glue_pointPresent = TRUE;
            break;

         case 8: /* start-shape */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->start_shape);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.start_shapePresent = TRUE;
            break;

         case 9: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         case 10: /* text-style-name */
            stat = XmlDec_Ns3_Text_style_name (pctxt, &pvalue->text_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.text_style_namePresent = TRUE;
            break;

         case 11: /* transform */
            stat = XmlDec_Ns3_Transform (pctxt, &pvalue->transform);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.transformPresent = TRUE;
            break;

         case 12: /* type */
            stat = XmlDec_Ns3_Connector_type (pctxt, &pvalue->type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.typePresent = TRUE;
            break;

         case 13: /* z-index */
            stat = XmlDec_Ns3_Z_index (pctxt, &pvalue->z_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.z_indexPresent = TRUE;
            break;

         case 14: /* class-names */
            rtxDListInit (&pvalue->class_names_1);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_names_1Present = TRUE;
            break;

         case 15: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_name_1Present = TRUE;
            break;

         case 16: /* x1 */
            stat = XmlDec_X1 (pctxt, &pvalue->x1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.x1Present = TRUE;
            break;

         case 17: /* x2 */
            stat = XmlDec_X2 (pctxt, &pvalue->x2);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.x2Present = TRUE;
            break;

         case 18: /* y1 */
            stat = XmlDec_Y1 (pctxt, &pvalue->y1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.y1Present = TRUE;
            break;

         case 19: /* y2 */
            stat = XmlDec_Y2 (pctxt, &pvalue->y2);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.y2Present = TRUE;
            break;

         case 20: /* end-cell-address */
            stat = XmlDec_End_cell_address (pctxt, &pvalue->end_cell_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_cell_addressPresent = TRUE;
            break;

         case 21: /* end-x */
            stat = XmlDec_End_x (pctxt, &pvalue->end_x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_xPresent = TRUE;
            break;

         case 22: /* end-y */
            stat = XmlDec_End_y (pctxt, &pvalue->end_y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_yPresent = TRUE;
            break;

         case 23: /* table-background */
            stat = XmlDec_Table_background (pctxt, &pvalue->table_background);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.table_backgroundPresent = TRUE;
            break;

         case 24: /* anchor-page-number */
            stat = XmlDec_Odf_Anchor_page_number (pctxt, &pvalue->
               anchor_page_number);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_page_numberPresent = TRUE;
            break;

         case 25: /* anchor-type */
            stat = XmlDec_Odf_Anchor_type (pctxt, &pvalue->anchor_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_typePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Connector");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Connector");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("event-listeners"), 15}, 0}, 0 },
      {{{OSUTF8("glue-point"), 10}, 0}, 1 },
      {{{OSUTF8("p"), 1}, 0}, 2 },
      {{{OSUTF8("list"), 4}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 4, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      case 1: {
         Ns3_Glue_point* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Glue_point);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Glue_point (pdata1);

            stat = XmlDec_Ns3_Glue_point (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->glue_point_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 2: {
         Ns3_Connector_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Connector_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Connector_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns3_Connector_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 2, 2, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Control                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Control (OSCTXT* pctxt, Ns3_Control *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode class_names */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_namesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode control */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->control, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Id (pctxt, 
               &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode layer */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Layer_1 (pctxt, 
               &pvalue->layer, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.layerPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode text_style_name */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Text_style_name (pctxt, 
               &pvalue->text_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.text_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode transform */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Transform (pctxt, 
               &pvalue->transform, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.transformPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode z_index */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Z_index (pctxt, 
               &pvalue->z_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.z_indexPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode class_names_1 */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_names_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 10:
         /* decode style_name_1 */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_name_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 11:
         /* decode height */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->height, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.heightPresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode width */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->width, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.widthPresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode x */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.xPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode y */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.yPresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode end_cell_address */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_cell_address (pctxt, 
               (End_cell_address*)&pvalue->end_cell_address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_cell_addressPresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode end_x */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_x (pctxt, 
               (End_x*)&pvalue->end_x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_xPresent = TRUE;
            }
         }
         break;

      case 17:
         /* decode end_y */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_y (pctxt, 
               (End_y*)&pvalue->end_y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_yPresent = TRUE;
            }
         }
         break;

      case 18:
         /* decode table_background */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_background (pctxt, 
               (Table_background*)&pvalue->table_background, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_backgroundPresent = TRUE;
            }
         }
         break;

      case 19:
         /* decode anchor_page_number */
         if (XD_PEEKTAG (pctxt, 0x93)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_page_number (pctxt, 
               (Odf_Anchor_page_number*)&pvalue->anchor_page_number, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_page_numberPresent = TRUE;
            }
         }
         break;

      case 20:
         /* decode anchor_type */
         if (XD_PEEKTAG (pctxt, 0x94)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_type (pctxt, 
               (Odf_Anchor_type*)&pvalue->anchor_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_typePresent = TRUE;
            }
         }
         break;

      case 21:
         /* decode glue_point_list */
         if (XD_PEEKTAG (pctxt, 0x95)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Glue_point* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->glue_point_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Glue_point, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Glue_point (pdata2);

                  stat = asn1D_Ns3_Glue_point (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->glue_point_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_PRIM|16):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_PRIM|17):
         case (TM_CTXT|TM_CONS|17):
         case (TM_CTXT|TM_PRIM|18):
         case (TM_CTXT|TM_PRIM|19):
         case (TM_CTXT|TM_PRIM|20):
         case (TM_CTXT|TM_CONS|21):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Control (OSCTXT* pctxt, Ns3_Control* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("control"), 7}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("layer"), 5}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("text-style-name"), 15}, 0 },
         { {OSUTF8("transform"), 9}, 0 },
         { {OSUTF8("z-index"), 7}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("height"), 6}, 0 },
         { {OSUTF8("width"), 5}, 0 },
         { {OSUTF8("x"), 1}, 0 },
         { {OSUTF8("y"), 1}, 0 },
         { {OSUTF8("end-cell-address"), 16}, 0 },
         { {OSUTF8("end-x"), 5}, 0 },
         { {OSUTF8("end-y"), 5}, 0 },
         { {OSUTF8("table-background"), 16}, 0 },
         { {OSUTF8("anchor-page-number"), 18}, 0 },
         { {OSUTF8("anchor-type"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 21, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* class-names */
            rtxDListInit (&pvalue->class_names);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_namesPresent = TRUE;
            break;

         case 1: /* control */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->control);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* id */
            stat = XmlDec_Ns3_Id (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 3: /* layer */
            stat = XmlDec_Ns3_Layer_1 (pctxt, &pvalue->layer);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.layerPresent = TRUE;
            break;

         case 4: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 5: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         case 6: /* text-style-name */
            stat = XmlDec_Ns3_Text_style_name (pctxt, &pvalue->text_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.text_style_namePresent = TRUE;
            break;

         case 7: /* transform */
            stat = XmlDec_Ns3_Transform (pctxt, &pvalue->transform);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.transformPresent = TRUE;
            break;

         case 8: /* z-index */
            stat = XmlDec_Ns3_Z_index (pctxt, &pvalue->z_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.z_indexPresent = TRUE;
            break;

         case 9: /* class-names */
            rtxDListInit (&pvalue->class_names_1);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_names_1Present = TRUE;
            break;

         case 10: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_name_1Present = TRUE;
            break;

         case 11: /* height */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->height);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.heightPresent = TRUE;
            break;

         case 12: /* width */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->width);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.widthPresent = TRUE;
            break;

         case 13: /* x */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.xPresent = TRUE;
            break;

         case 14: /* y */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.yPresent = TRUE;
            break;

         case 15: /* end-cell-address */
            stat = XmlDec_End_cell_address (pctxt, &pvalue->end_cell_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_cell_addressPresent = TRUE;
            break;

         case 16: /* end-x */
            stat = XmlDec_End_x (pctxt, &pvalue->end_x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_xPresent = TRUE;
            break;

         case 17: /* end-y */
            stat = XmlDec_End_y (pctxt, &pvalue->end_y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_yPresent = TRUE;
            break;

         case 18: /* table-background */
            stat = XmlDec_Table_background (pctxt, &pvalue->table_background);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.table_backgroundPresent = TRUE;
            break;

         case 19: /* anchor-page-number */
            stat = XmlDec_Odf_Anchor_page_number (pctxt, &pvalue->
               anchor_page_number);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_page_numberPresent = TRUE;
            break;

         case 20: /* anchor-type */
            stat = XmlDec_Odf_Anchor_type (pctxt, &pvalue->anchor_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_typePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Control");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Control");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("glue-point"), 10}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Ns3_Glue_point* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Glue_point);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Glue_point (pdata1);

            stat = XmlDec_Ns3_Glue_point (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->glue_point_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Custom_shape_element                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Custom_shape_element (OSCTXT* pctxt, 
   Ns3_Custom_shape_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P ((Odf_P*)pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            (Odf_P*)pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List ((Odf_List*)pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            (Odf_List*)pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Custom_shape_element (OSCTXT* pctxt, 
   Ns3_Custom_shape_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("list"), 4}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P ((Odf_P*)pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List ((Odf_List*)pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Enhanced_geometry_concentric_gradient_fill_allowed        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Enhanced_geometry_concentric_gradient_fill_allowed (
   OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_concentric_gradient_fill_allowed *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Enhanced_geometry_concentric_gradient_fill_allowed 
   (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_concentric_gradient_fill_allowed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Enhanced_geometry_concentric_gradient_fill_allowed_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Enhanced_geometry_extrusion                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Enhanced_geometry_extrusion (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_extrusion *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Enhanced_geometry_extrusion (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_extrusion* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Enhanced_geometry_extrusion_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Enhanced_geometry_extrusion_allowed                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Enhanced_geometry_extrusion_allowed (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_extrusion_allowed *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Enhanced_geometry_extrusion_allowed (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_extrusion_allowed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Enhanced_geometry_extrusion_allowed_ToEnum (pctxt, strval, pvalue
      );
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Enhanced_geometry_extrusion_color                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Enhanced_geometry_extrusion_color (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_extrusion_color *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Enhanced_geometry_extrusion_color (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_extrusion_color* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Enhanced_geometry_extrusion_color_ToEnum (pctxt, strval, pvalue
      );
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Enhanced_geometry_extrusion_depth_element                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Enhanced_geometry_extrusion_depth_element (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_extrusion_depth_element *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
         stat = xd_real (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Enhanced_geometry_extrusion_depth_element (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_extrusion_depth_element* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      stat = rtxUTF8StrToDouble (pdata1, &pvalue->u.alt);
      if (stat == 0) pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Enhanced_geometry_extrusion_first_light_harsh             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Enhanced_geometry_extrusion_first_light_harsh (
   OSCTXT* pctxt, Ns3_Enhanced_geometry_extrusion_first_light_harsh *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Enhanced_geometry_extrusion_first_light_harsh (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_extrusion_first_light_harsh* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Enhanced_geometry_extrusion_first_light_harsh_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Enhanced_geometry_extrusion_light_face                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Enhanced_geometry_extrusion_light_face (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_extrusion_light_face *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Enhanced_geometry_extrusion_light_face (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_extrusion_light_face* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Enhanced_geometry_extrusion_light_face_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Enhanced_geometry_extrusion_metal                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Enhanced_geometry_extrusion_metal (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_extrusion_metal *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Enhanced_geometry_extrusion_metal (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_extrusion_metal* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Enhanced_geometry_extrusion_metal_ToEnum (pctxt, strval, pvalue
      );
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Enhanced_geometry_extrusion_origin_element                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Enhanced_geometry_extrusion_origin_element (
   OSCTXT* pctxt, Ns3_Enhanced_geometry_extrusion_origin_element *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
         stat = xd_real (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Enhanced_geometry_extrusion_origin_element (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_extrusion_origin_element* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      stat = rtxUTF8StrToDouble (pdata1, &pvalue->u.alt);
      if (stat == 0) pvalue->t = 1;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Enhanced_geometry_extrusion_rotation_angle_element        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Enhanced_geometry_extrusion_rotation_angle_element (
   OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_extrusion_rotation_angle_element *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
         stat = xd_real (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Enhanced_geometry_extrusion_rotation_angle_element 
   (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_extrusion_rotation_angle_element* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      stat = rtxUTF8StrToDouble (pdata1, &pvalue->u.alt);
      if (stat == 0) pvalue->t = 1;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Enhanced_geometry_extrusion_second_light_harsh            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Enhanced_geometry_extrusion_second_light_harsh (
   OSCTXT* pctxt, Ns3_Enhanced_geometry_extrusion_second_light_harsh *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Enhanced_geometry_extrusion_second_light_harsh (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_extrusion_second_light_harsh* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Enhanced_geometry_extrusion_second_light_harsh_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Enhanced_geometry_extrusion_skew_element                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Enhanced_geometry_extrusion_skew_element (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_extrusion_skew_element *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
         stat = xd_real (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Enhanced_geometry_extrusion_skew_element (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_extrusion_skew_element* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      stat = rtxUTF8StrToDouble (pdata1, &pvalue->u.alt);
      if (stat == 0) pvalue->t = 1;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Enhanced_geometry_glue_point_type                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Enhanced_geometry_glue_point_type (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_glue_point_type *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Enhanced_geometry_glue_point_type (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_glue_point_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Enhanced_geometry_glue_point_type_ToEnum (pctxt, strval, pvalue
      );
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Enhanced_geometry_mirror_horizontal                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Enhanced_geometry_mirror_horizontal (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_mirror_horizontal *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Enhanced_geometry_mirror_horizontal (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_mirror_horizontal* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Enhanced_geometry_mirror_horizontal_ToEnum (pctxt, strval, pvalue
      );
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Enhanced_geometry_mirror_vertical                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Enhanced_geometry_mirror_vertical (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_mirror_vertical *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Enhanced_geometry_mirror_vertical (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_mirror_vertical* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Enhanced_geometry_mirror_vertical_ToEnum (pctxt, strval, pvalue
      );
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Enhanced_geometry_text_path                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Enhanced_geometry_text_path (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_text_path *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Enhanced_geometry_text_path (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_text_path* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Enhanced_geometry_text_path_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Enhanced_geometry_text_path_allowed                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Enhanced_geometry_text_path_allowed (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_text_path_allowed *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Enhanced_geometry_text_path_allowed (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_text_path_allowed* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Enhanced_geometry_text_path_allowed_ToEnum (pctxt, strval, pvalue
      );
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Enhanced_geometry_text_path_mode                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Enhanced_geometry_text_path_mode (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_text_path_mode *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Enhanced_geometry_text_path_mode (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_text_path_mode* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Enhanced_geometry_text_path_mode_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Enhanced_geometry_text_path_same_letter_heights           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Enhanced_geometry_text_path_same_letter_heights (
   OSCTXT* pctxt, Ns3_Enhanced_geometry_text_path_same_letter_heights *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Enhanced_geometry_text_path_same_letter_heights (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_text_path_same_letter_heights* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Enhanced_geometry_text_path_same_letter_heights_ToEnum (pctxt, strval, 
      pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Enhanced_geometry_text_path_scale                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Enhanced_geometry_text_path_scale (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_text_path_scale *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Enhanced_geometry_text_path_scale (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_text_path_scale* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Enhanced_geometry_text_path_scale_ToEnum (pctxt, strval, pvalue
      );
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Enhanced_geometry_type_alt_1                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Enhanced_geometry_type_alt_1 (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_type_alt_1 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Enhanced_geometry_type_alt_1 (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_type_alt_1* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Enhanced_geometry_type_alt_1_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Enhanced_geometry_type                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Enhanced_geometry_type (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_type *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
         stat = asn1D_Ns3_Enhanced_geometry_type_alt_1 (pctxt, 
            &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Enhanced_geometry_type (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      stat = Ns3_Enhanced_geometry_type_alt_1_ToEnum (pctxt, pdata1, &pvalue->
         u.alt_1);
      if (stat == 0) pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Equation                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Equation (OSCTXT* pctxt, Ns3_Equation *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode formula */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->formula, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.formulaPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Equation (OSCTXT* pctxt, Ns3_Equation* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("formula"), 7}, 0 },
         { {OSUTF8("name"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* formula */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->formula);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.formulaPresent = TRUE;
            break;

         case 1: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Equation");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Equation");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Handle_handle_mirror_horizontal                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Handle_handle_mirror_horizontal (OSCTXT* pctxt, 
   Ns3_Handle_handle_mirror_horizontal *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Handle_handle_mirror_horizontal (OSCTXT* pctxt, 
   Ns3_Handle_handle_mirror_horizontal* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Handle_handle_mirror_horizontal_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Handle_handle_mirror_vertical                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Handle_handle_mirror_vertical (OSCTXT* pctxt, 
   Ns3_Handle_handle_mirror_vertical *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Handle_handle_mirror_vertical (OSCTXT* pctxt, 
   Ns3_Handle_handle_mirror_vertical* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Handle_handle_mirror_vertical_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Handle_handle_switched                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Handle_handle_switched (OSCTXT* pctxt, 
   Ns3_Handle_handle_switched *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Handle_handle_switched (OSCTXT* pctxt, 
   Ns3_Handle_handle_switched* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Handle_handle_switched_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Handle                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Handle (OSCTXT* pctxt, Ns3_Handle *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode handle_mirror_horizontal */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Handle_handle_mirror_horizontal (pctxt, 
               &pvalue->handle_mirror_horizontal, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.handle_mirror_horizontalPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode handle_mirror_vertical */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Handle_handle_mirror_vertical (pctxt, 
               &pvalue->handle_mirror_vertical, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.handle_mirror_verticalPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode handle_polar */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->handle_polar, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.handle_polarPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode handle_position */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->handle_position, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode handle_radius_range_maximum */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->handle_radius_range_maximum, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.handle_radius_range_maximumPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode handle_radius_range_minimum */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->handle_radius_range_minimum, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.handle_radius_range_minimumPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode handle_range_x_maximum */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->handle_range_x_maximum, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.handle_range_x_maximumPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode handle_range_x_minimum */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->handle_range_x_minimum, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.handle_range_x_minimumPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode handle_range_y_maximum */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->handle_range_y_maximum, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.handle_range_y_maximumPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode handle_range_y_minimum */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->handle_range_y_minimum, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.handle_range_y_minimumPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode handle_switched */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Handle_handle_switched (pctxt, 
               &pvalue->handle_switched, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.handle_switchedPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_PRIM|10):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Handle (OSCTXT* pctxt, Ns3_Handle* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("handle-mirror-horizontal"), 24}, 0 },
         { {OSUTF8("handle-mirror-vertical"), 22}, 0 },
         { {OSUTF8("handle-polar"), 12}, 0 },
         { {OSUTF8("handle-position"), 15}, 0 },
         { {OSUTF8("handle-radius-range-maximum"), 27}, 0 },
         { {OSUTF8("handle-radius-range-minimum"), 27}, 0 },
         { {OSUTF8("handle-range-x-maximum"), 22}, 0 },
         { {OSUTF8("handle-range-x-minimum"), 22}, 0 },
         { {OSUTF8("handle-range-y-maximum"), 22}, 0 },
         { {OSUTF8("handle-range-y-minimum"), 22}, 0 },
         { {OSUTF8("handle-switched"), 15}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 11, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* handle-mirror-horizontal */
            stat = XmlDec_Ns3_Handle_handle_mirror_horizontal (pctxt, &pvalue->
               handle_mirror_horizontal);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.handle_mirror_horizontalPresent = TRUE;
            break;

         case 1: /* handle-mirror-vertical */
            stat = XmlDec_Ns3_Handle_handle_mirror_vertical (pctxt, &pvalue->
               handle_mirror_vertical);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.handle_mirror_verticalPresent = TRUE;
            break;

         case 2: /* handle-polar */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->handle_polar);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.handle_polarPresent = TRUE;
            break;

         case 3: /* handle-position */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->handle_position);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* handle-radius-range-maximum */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->
               handle_radius_range_maximum);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.handle_radius_range_maximumPresent = TRUE;
            break;

         case 5: /* handle-radius-range-minimum */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->
               handle_radius_range_minimum);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.handle_radius_range_minimumPresent = TRUE;
            break;

         case 6: /* handle-range-x-maximum */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->handle_range_x_maximum
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.handle_range_x_maximumPresent = TRUE;
            break;

         case 7: /* handle-range-x-minimum */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->handle_range_x_minimum
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.handle_range_x_minimumPresent = TRUE;
            break;

         case 8: /* handle-range-y-maximum */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->handle_range_y_maximum
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.handle_range_y_maximumPresent = TRUE;
            break;

         case 9: /* handle-range-y-minimum */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->handle_range_y_minimum
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.handle_range_y_minimumPresent = TRUE;
            break;

         case 10: /* handle-switched */
            stat = XmlDec_Ns3_Handle_handle_switched (pctxt, &pvalue->
               handle_switched);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.handle_switchedPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Handle");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Handle");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Enhanced_geometry                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Enhanced_geometry (OSCTXT* pctxt, 
   Ns3_Enhanced_geometry *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode projection */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns7_Projection (pctxt, 
               (Ns7_Projection*)&pvalue->projection, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.projectionPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode shade_mode */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns7_Shade_mode (pctxt, 
               (Ns7_Shade_mode*)&pvalue->shade_mode, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.shade_modePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode concentric_gradient_fill_allowed */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Enhanced_geometry_concentric_gradient_fill_allowed (pctxt, 
               &pvalue->concentric_gradient_fill_allowed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.concentric_gradient_fill_allowedPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode enhanced_path */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->enhanced_path, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.enhanced_pathPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode extrusion */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Enhanced_geometry_extrusion (pctxt, 
               &pvalue->extrusion, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.extrusionPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode extrusion_allowed */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Enhanced_geometry_extrusion_allowed (pctxt, 
               &pvalue->extrusion_allowed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.extrusion_allowedPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode extrusion_brightness */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->extrusion_brightness, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.extrusion_brightnessPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode extrusion_color */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Enhanced_geometry_extrusion_color (pctxt, 
               &pvalue->extrusion_color, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.extrusion_colorPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode extrusion_depth */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Enhanced_geometry_extrusion_depth_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->extrusion_depth);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  if (pvalue->extrusion_depth.count >= 2) return LOG_RTERR (pctxt, RTERR_SEQOVFLW);

                  rtxDListAllocNodeAndData (pctxt, Ns3_Enhanced_geometry_extrusion_depth_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Enhanced_geometry_extrusion_depth_element (pdata2);

                  stat = asn1D_Ns3_Enhanced_geometry_extrusion_depth_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->extrusion_depth, pnode);
               }

            }
            if (stat == 0) {
               pvalue->m.extrusion_depthPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode extrusion_diffusion */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->extrusion_diffusion, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.extrusion_diffusionPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode extrusion_first_light_direction */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->extrusion_first_light_direction, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.extrusion_first_light_directionPresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode extrusion_first_light_harsh */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Enhanced_geometry_extrusion_first_light_harsh (pctxt, 
               &pvalue->extrusion_first_light_harsh, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.extrusion_first_light_harshPresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode extrusion_first_light_level */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->extrusion_first_light_level, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.extrusion_first_light_levelPresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode extrusion_light_face */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Enhanced_geometry_extrusion_light_face (pctxt, 
               &pvalue->extrusion_light_face, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.extrusion_light_facePresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode extrusion_metal */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Enhanced_geometry_extrusion_metal (pctxt, 
               &pvalue->extrusion_metal, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.extrusion_metalPresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode extrusion_number_of_line_segments */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->extrusion_number_of_line_segments, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.extrusion_number_of_line_segmentsPresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode extrusion_origin */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Enhanced_geometry_extrusion_origin_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->extrusion_origin);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  if (pvalue->extrusion_origin.count >= 2) return LOG_RTERR (pctxt, RTERR_SEQOVFLW);

                  rtxDListAllocNodeAndData (pctxt, Ns3_Enhanced_geometry_extrusion_origin_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Enhanced_geometry_extrusion_origin_element (pdata2);

                  stat = asn1D_Ns3_Enhanced_geometry_extrusion_origin_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->extrusion_origin, pnode);
               }

            }
            if (stat == 0) {
               pvalue->m.extrusion_originPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 17:
         /* decode extrusion_rotation_angle */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Enhanced_geometry_extrusion_rotation_angle_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->extrusion_rotation_angle);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  if (pvalue->extrusion_rotation_angle.count >= 2) return LOG_RTERR (pctxt, RTERR_SEQOVFLW);

                  rtxDListAllocNodeAndData (pctxt, Ns3_Enhanced_geometry_extrusion_rotation_angle_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Enhanced_geometry_extrusion_rotation_angle_element (pdata2);

                  stat = asn1D_Ns3_Enhanced_geometry_extrusion_rotation_angle_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->extrusion_rotation_angle, pnode);
               }

            }
            if (stat == 0) {
               pvalue->m.extrusion_rotation_anglePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 18:
         /* decode extrusion_rotation_center */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->extrusion_rotation_center, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.extrusion_rotation_centerPresent = TRUE;
            }
         }
         break;

      case 19:
         /* decode extrusion_second_light_direction */
         if (XD_PEEKTAG (pctxt, 0x93)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->extrusion_second_light_direction, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.extrusion_second_light_directionPresent = TRUE;
            }
         }
         break;

      case 20:
         /* decode extrusion_second_light_harsh */
         if (XD_PEEKTAG (pctxt, 0x94)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Enhanced_geometry_extrusion_second_light_harsh (pctxt, 
               &pvalue->extrusion_second_light_harsh, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.extrusion_second_light_harshPresent = TRUE;
            }
         }
         break;

      case 21:
         /* decode extrusion_second_light_level */
         if (XD_PEEKTAG (pctxt, 0x95)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->extrusion_second_light_level, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.extrusion_second_light_levelPresent = TRUE;
            }
         }
         break;

      case 22:
         /* decode extrusion_shininess */
         if (XD_PEEKTAG (pctxt, 0x96)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->extrusion_shininess, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.extrusion_shininessPresent = TRUE;
            }
         }
         break;

      case 23:
         /* decode extrusion_skew */
         if (XD_PEEKTAG (pctxt, 0x97)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Enhanced_geometry_extrusion_skew_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->extrusion_skew);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  if (pvalue->extrusion_skew.count >= 2) return LOG_RTERR (pctxt, RTERR_SEQOVFLW);

                  rtxDListAllocNodeAndData (pctxt, Ns3_Enhanced_geometry_extrusion_skew_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Enhanced_geometry_extrusion_skew_element (pdata2);

                  stat = asn1D_Ns3_Enhanced_geometry_extrusion_skew_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->extrusion_skew, pnode);
               }

            }
            if (stat == 0) {
               pvalue->m.extrusion_skewPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 24:
         /* decode extrusion_specularity */
         if (XD_PEEKTAG (pctxt, 0x98)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->extrusion_specularity, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.extrusion_specularityPresent = TRUE;
            }
         }
         break;

      case 25:
         /* decode extrusion_viewpoint */
         if (XD_PEEKTAG (pctxt, 0x99)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->extrusion_viewpoint, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.extrusion_viewpointPresent = TRUE;
            }
         }
         break;

      case 26:
         /* decode glue_point_leaving_directions */
         if (XD_PEEKTAG (pctxt, 0x9a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->glue_point_leaving_directions, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.glue_point_leaving_directionsPresent = TRUE;
            }
         }
         break;

      case 27:
         /* decode glue_point_type */
         if (XD_PEEKTAG (pctxt, 0x9b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Enhanced_geometry_glue_point_type (pctxt, 
               &pvalue->glue_point_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.glue_point_typePresent = TRUE;
            }
         }
         break;

      case 28:
         /* decode glue_points */
         if (XD_PEEKTAG (pctxt, 0x9c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->glue_points, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.glue_pointsPresent = TRUE;
            }
         }
         break;

      case 29:
         /* decode mirror_horizontal */
         if (XD_PEEKTAG (pctxt, 0x9d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Enhanced_geometry_mirror_horizontal (pctxt, 
               &pvalue->mirror_horizontal, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mirror_horizontalPresent = TRUE;
            }
         }
         break;

      case 30:
         /* decode mirror_vertical */
         if (XD_PEEKTAG (pctxt, 0x9e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Enhanced_geometry_mirror_vertical (pctxt, 
               &pvalue->mirror_vertical, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mirror_verticalPresent = TRUE;
            }
         }
         break;

      case 31:
         /* decode modifiers */
         if ((stat = xd_match (pctxt, TM_CTXT|TM_PRIM|31, &length, XM_ADVANCE)) == 0) {
            stat = xd_utf8str (pctxt, &pvalue->modifiers, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.modifiersPresent = TRUE;
            }
         }
         else if (stat == RTERR_IDNOTFOU) {
            stat = rtxErrReset (pctxt);
         }
         break;

      case 32:
         /* decode path_stretchpoint_x */
         if ((stat = xd_match (pctxt, TM_CTXT|TM_PRIM|32, &length, XM_ADVANCE)) == 0) {
            stat = xd_real (pctxt, &pvalue->path_stretchpoint_x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.path_stretchpoint_xPresent = TRUE;
            }
         }
         else if (stat == RTERR_IDNOTFOU) {
            stat = rtxErrReset (pctxt);
         }
         break;

      case 33:
         /* decode path_stretchpoint_y */
         if ((stat = xd_match (pctxt, TM_CTXT|TM_PRIM|33, &length, XM_ADVANCE)) == 0) {
            stat = xd_real (pctxt, &pvalue->path_stretchpoint_y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.path_stretchpoint_yPresent = TRUE;
            }
         }
         else if (stat == RTERR_IDNOTFOU) {
            stat = rtxErrReset (pctxt);
         }
         break;

      case 34:
         /* decode text_areas */
         if ((stat = xd_match (pctxt, TM_CTXT|TM_PRIM|34, &length, XM_ADVANCE)) == 0) {
            stat = xd_utf8str (pctxt, &pvalue->text_areas, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.text_areasPresent = TRUE;
            }
         }
         else if (stat == RTERR_IDNOTFOU) {
            stat = rtxErrReset (pctxt);
         }
         break;

      case 35:
         /* decode text_path */
         if ((stat = xd_match (pctxt, TM_CTXT|TM_PRIM|35, &length, XM_ADVANCE)) == 0) {
            stat = asn1D_Ns3_Enhanced_geometry_text_path (pctxt, 
               &pvalue->text_path, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.text_pathPresent = TRUE;
            }
         }
         else if (stat == RTERR_IDNOTFOU) {
            stat = rtxErrReset (pctxt);
         }
         break;

      case 36:
         /* decode text_path_allowed */
         if ((stat = xd_match (pctxt, TM_CTXT|TM_PRIM|36, &length, XM_ADVANCE)) == 0) {
            stat = asn1D_Ns3_Enhanced_geometry_text_path_allowed (pctxt, 
               &pvalue->text_path_allowed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.text_path_allowedPresent = TRUE;
            }
         }
         else if (stat == RTERR_IDNOTFOU) {
            stat = rtxErrReset (pctxt);
         }
         break;

      case 37:
         /* decode text_path_mode */
         if ((stat = xd_match (pctxt, TM_CTXT|TM_PRIM|37, &length, XM_ADVANCE)) == 0) {
            stat = asn1D_Ns3_Enhanced_geometry_text_path_mode (pctxt, 
               &pvalue->text_path_mode, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.text_path_modePresent = TRUE;
            }
         }
         else if (stat == RTERR_IDNOTFOU) {
            stat = rtxErrReset (pctxt);
         }
         break;

      case 38:
         /* decode text_path_same_letter_heights */
         if ((stat = xd_match (pctxt, TM_CTXT|TM_PRIM|38, &length, XM_ADVANCE)) == 0) {
            stat = asn1D_Ns3_Enhanced_geometry_text_path_same_letter_heights (pctxt, 
               &pvalue->text_path_same_letter_heights, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.text_path_same_letter_heightsPresent = TRUE;
            }
         }
         else if (stat == RTERR_IDNOTFOU) {
            stat = rtxErrReset (pctxt);
         }
         break;

      case 39:
         /* decode text_path_scale */
         if ((stat = xd_match (pctxt, TM_CTXT|TM_PRIM|39, &length, XM_ADVANCE)) == 0) {
            stat = asn1D_Ns3_Enhanced_geometry_text_path_scale (pctxt, 
               &pvalue->text_path_scale, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.text_path_scalePresent = TRUE;
            }
         }
         else if (stat == RTERR_IDNOTFOU) {
            stat = rtxErrReset (pctxt);
         }
         break;

      case 40:
         /* decode text_rotate_angle */
         if ((stat = xd_match (pctxt, TM_CTXT|TM_PRIM|40, &length, XM_ADVANCE)) == 0) {
            stat = xd_real (pctxt, &pvalue->text_rotate_angle, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.text_rotate_anglePresent = TRUE;
            }
         }
         else if (stat == RTERR_IDNOTFOU) {
            stat = rtxErrReset (pctxt);
         }
         break;

      case 41:
         /* decode type */
         if ((stat = xd_match (pctxt, TM_CTXT|TM_CONS|41, &length, XM_ADVANCE)) == 0) {
            stat = asn1D_Ns3_Enhanced_geometry_type (pctxt, 
               &pvalue->type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.typePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         else if (stat == RTERR_IDNOTFOU) {
            stat = rtxErrReset (pctxt);
         }
         break;

      case 42:
         /* decode viewBox */
         if ((stat = xd_match (pctxt, TM_CTXT|TM_CONS|42, &length, XM_ADVANCE)) == 0) {
            stat = asn1D_ViewBox (pctxt, 
               (ViewBox*)&pvalue->viewBox, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.viewBoxPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         else if (stat == RTERR_IDNOTFOU) {
            stat = rtxErrReset (pctxt);
         }
         break;

      case 43:
         /* decode equation_list */
         if ((stat = xd_match (pctxt, TM_CTXT|TM_CONS|43, &length, XM_ADVANCE)) == 0) {
            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Equation* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->equation_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Equation, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Equation (pdata2);

                  stat = asn1D_Ns3_Equation (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->equation_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 44:
         /* decode handle_list */
         if ((stat = xd_match (pctxt, TM_CTXT|TM_CONS|44, &length, XM_ADVANCE)) == 0) {
            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Handle* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->handle_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Handle, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Handle (pdata2);

                  stat = asn1D_Ns3_Handle (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->handle_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_CONS|17):
         case (TM_CTXT|TM_PRIM|18):
         case (TM_CTXT|TM_CONS|18):
         case (TM_CTXT|TM_PRIM|19):
         case (TM_CTXT|TM_CONS|19):
         case (TM_CTXT|TM_PRIM|20):
         case (TM_CTXT|TM_PRIM|21):
         case (TM_CTXT|TM_CONS|21):
         case (TM_CTXT|TM_PRIM|22):
         case (TM_CTXT|TM_CONS|22):
         case (TM_CTXT|TM_CONS|23):
         case (TM_CTXT|TM_PRIM|24):
         case (TM_CTXT|TM_CONS|24):
         case (TM_CTXT|TM_PRIM|25):
         case (TM_CTXT|TM_CONS|25):
         case (TM_CTXT|TM_PRIM|26):
         case (TM_CTXT|TM_CONS|26):
         case (TM_CTXT|TM_PRIM|27):
         case (TM_CTXT|TM_PRIM|28):
         case (TM_CTXT|TM_CONS|28):
         case (TM_CTXT|TM_PRIM|29):
         case (TM_CTXT|TM_PRIM|30):
         case (TM_CTXT|TM_PRIM|31):
         case (TM_CTXT|TM_CONS|31):
         case (TM_CTXT|TM_PRIM|32):
         case (TM_CTXT|TM_PRIM|33):
         case (TM_CTXT|TM_PRIM|34):
         case (TM_CTXT|TM_CONS|34):
         case (TM_CTXT|TM_PRIM|35):
         case (TM_CTXT|TM_PRIM|36):
         case (TM_CTXT|TM_PRIM|37):
         case (TM_CTXT|TM_PRIM|38):
         case (TM_CTXT|TM_PRIM|39):
         case (TM_CTXT|TM_PRIM|40):
         case (TM_CTXT|TM_CONS|41):
         case (TM_CTXT|TM_CONS|42):
         case (TM_CTXT|TM_CONS|43):
         case (TM_CTXT|TM_CONS|44):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Enhanced_geometry (OSCTXT* pctxt, Ns3_Enhanced_geometry* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("projection"), 10}, 0 },
         { {OSUTF8("shade-mode"), 10}, 0 },
         { {OSUTF8("concentric-gradient-fill-allowed"), 32}, 0 },
         { {OSUTF8("enhanced-path"), 13}, 0 },
         { {OSUTF8("extrusion"), 9}, 0 },
         { {OSUTF8("extrusion-allowed"), 17}, 0 },
         { {OSUTF8("extrusion-brightness"), 20}, 0 },
         { {OSUTF8("extrusion-color"), 15}, 0 },
         { {OSUTF8("extrusion-depth"), 15}, 0 },
         { {OSUTF8("extrusion-diffusion"), 19}, 0 },
         { {OSUTF8("extrusion-first-light-direction"), 31}, 0 },
         { {OSUTF8("extrusion-first-light-harsh"), 27}, 0 },
         { {OSUTF8("extrusion-first-light-level"), 27}, 0 },
         { {OSUTF8("extrusion-light-face"), 20}, 0 },
         { {OSUTF8("extrusion-metal"), 15}, 0 },
         { {OSUTF8("extrusion-number-of-line-segments"), 33}, 0 },
         { {OSUTF8("extrusion-origin"), 16}, 0 },
         { {OSUTF8("extrusion-rotation-angle"), 24}, 0 },
         { {OSUTF8("extrusion-rotation-center"), 25}, 0 },
         { {OSUTF8("extrusion-second-light-direction"), 32}, 0 },
         { {OSUTF8("extrusion-second-light-harsh"), 28}, 0 },
         { {OSUTF8("extrusion-second-light-level"), 28}, 0 },
         { {OSUTF8("extrusion-shininess"), 19}, 0 },
         { {OSUTF8("extrusion-skew"), 14}, 0 },
         { {OSUTF8("extrusion-specularity"), 21}, 0 },
         { {OSUTF8("extrusion-viewpoint"), 19}, 0 },
         { {OSUTF8("glue-point-leaving-directions"), 29}, 0 },
         { {OSUTF8("glue-point-type"), 15}, 0 },
         { {OSUTF8("glue-points"), 11}, 0 },
         { {OSUTF8("mirror-horizontal"), 17}, 0 },
         { {OSUTF8("mirror-vertical"), 15}, 0 },
         { {OSUTF8("modifiers"), 9}, 0 },
         { {OSUTF8("path-stretchpoint-x"), 19}, 0 },
         { {OSUTF8("path-stretchpoint-y"), 19}, 0 },
         { {OSUTF8("text-areas"), 10}, 0 },
         { {OSUTF8("text-path"), 9}, 0 },
         { {OSUTF8("text-path-allowed"), 17}, 0 },
         { {OSUTF8("text-path-mode"), 14}, 0 },
         { {OSUTF8("text-path-same-letter-heights"), 29}, 0 },
         { {OSUTF8("text-path-scale"), 15}, 0 },
         { {OSUTF8("text-rotate-angle"), 17}, 0 },
         { {OSUTF8("type"), 4}, 0 },
         { {OSUTF8("viewBox"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[2];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 43, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* projection */
            stat = XmlDec_Ns7_Projection (pctxt, &pvalue->projection);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.projectionPresent = TRUE;
            break;

         case 1: /* shade-mode */
            stat = XmlDec_Ns7_Shade_mode (pctxt, &pvalue->shade_mode);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.shade_modePresent = TRUE;
            break;

         case 2: /* concentric-gradient-fill-allowed */
            stat = XmlDec_Ns3_Enhanced_geometry_concentric_gradient_fill_allowed 
               (pctxt, &pvalue->concentric_gradient_fill_allowed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.concentric_gradient_fill_allowedPresent = TRUE;
            break;

         case 3: /* enhanced-path */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->enhanced_path);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.enhanced_pathPresent = TRUE;
            break;

         case 4: /* extrusion */
            stat = XmlDec_Ns3_Enhanced_geometry_extrusion (pctxt, &pvalue->
               extrusion);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.extrusionPresent = TRUE;
            break;

         case 5: /* extrusion-allowed */
            stat = XmlDec_Ns3_Enhanced_geometry_extrusion_allowed (pctxt, &
               pvalue->extrusion_allowed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.extrusion_allowedPresent = TRUE;
            break;

         case 6: /* extrusion-brightness */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->extrusion_brightness);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.extrusion_brightnessPresent = TRUE;
            break;

         case 7: /* extrusion-color */
            stat = XmlDec_Ns3_Enhanced_geometry_extrusion_color (pctxt, &pvalue
               ->extrusion_color);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.extrusion_colorPresent = TRUE;
            break;

         case 8: /* extrusion-depth */
            rtxDListInit (&pvalue->extrusion_depth);
            rtXmlpSetListMode (pctxt);

            while (rtXmlpListHasItem(pctxt)) {
               Ns3_Enhanced_geometry_extrusion_depth_element*
                   pdata1 = rtxMemAllocType (pctxt, 
                  Ns3_Enhanced_geometry_extrusion_depth_element);
               if (0 == pdata1) LOG_RTERR (pctxt, RTERR_NOMEM);

               stat = XmlDec_Ns3_Enhanced_geometry_extrusion_depth_element 
                  (pctxt, pdata1);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               if (0 == rtxDListAppend (pctxt, &pvalue->extrusion_depth
                  , pdata1)) {
                  return LOG_RTERR (pctxt, RTERR_NOMEM);
               }
            }

            pvalue->m.extrusion_depthPresent = TRUE;
            break;

         case 9: /* extrusion-diffusion */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->extrusion_diffusion);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.extrusion_diffusionPresent = TRUE;
            break;

         case 10: /* extrusion-first-light-direction */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->
               extrusion_first_light_direction);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.extrusion_first_light_directionPresent = TRUE;
            break;

         case 11: /* extrusion-first-light-harsh */
            stat = XmlDec_Ns3_Enhanced_geometry_extrusion_first_light_harsh 
               (pctxt, &pvalue->extrusion_first_light_harsh);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.extrusion_first_light_harshPresent = TRUE;
            break;

         case 12: /* extrusion-first-light-level */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->
               extrusion_first_light_level);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.extrusion_first_light_levelPresent = TRUE;
            break;

         case 13: /* extrusion-light-face */
            stat = XmlDec_Ns3_Enhanced_geometry_extrusion_light_face (pctxt, &
               pvalue->extrusion_light_face);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.extrusion_light_facePresent = TRUE;
            break;

         case 14: /* extrusion-metal */
            stat = XmlDec_Ns3_Enhanced_geometry_extrusion_metal (pctxt, &pvalue
               ->extrusion_metal);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.extrusion_metalPresent = TRUE;
            break;

         case 15: /* extrusion-number-of-line-segments */
            stat = rtXmlpDecInt (pctxt, &pvalue->
               extrusion_number_of_line_segments);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.extrusion_number_of_line_segmentsPresent = TRUE;
            break;

         case 16: /* extrusion-origin */
            rtxDListInit (&pvalue->extrusion_origin);
            rtXmlpSetListMode (pctxt);

            while (rtXmlpListHasItem(pctxt)) {
               Ns3_Enhanced_geometry_extrusion_origin_element*
                   pdata1 = rtxMemAllocType (pctxt, 
                  Ns3_Enhanced_geometry_extrusion_origin_element);
               if (0 == pdata1) LOG_RTERR (pctxt, RTERR_NOMEM);

               stat = XmlDec_Ns3_Enhanced_geometry_extrusion_origin_element 
                  (pctxt, pdata1);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               if (0 == rtxDListAppend (pctxt, &pvalue->extrusion_origin
                  , pdata1)) {
                  return LOG_RTERR (pctxt, RTERR_NOMEM);
               }
            }

            pvalue->m.extrusion_originPresent = TRUE;
            break;

         case 17: /* extrusion-rotation-angle */
            rtxDListInit (&pvalue->extrusion_rotation_angle);
            rtXmlpSetListMode (pctxt);

            while (rtXmlpListHasItem(pctxt)) {
               Ns3_Enhanced_geometry_extrusion_rotation_angle_element*
                   pdata1 = rtxMemAllocType (pctxt, 
                  Ns3_Enhanced_geometry_extrusion_rotation_angle_element);
               if (0 == pdata1) LOG_RTERR (pctxt, RTERR_NOMEM);

               stat = XmlDec_Ns3_Enhanced_geometry_extrusion_rotation_angle_element 
                  (pctxt, pdata1);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               if (0 == rtxDListAppend (pctxt, &pvalue->
                  extrusion_rotation_angle, pdata1)) {
                  return LOG_RTERR (pctxt, RTERR_NOMEM);
               }
            }

            pvalue->m.extrusion_rotation_anglePresent = TRUE;
            break;

         case 18: /* extrusion-rotation-center */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->
               extrusion_rotation_center);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.extrusion_rotation_centerPresent = TRUE;
            break;

         case 19: /* extrusion-second-light-direction */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->
               extrusion_second_light_direction);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.extrusion_second_light_directionPresent = TRUE;
            break;

         case 20: /* extrusion-second-light-harsh */
            stat = XmlDec_Ns3_Enhanced_geometry_extrusion_second_light_harsh 
               (pctxt, &pvalue->extrusion_second_light_harsh);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.extrusion_second_light_harshPresent = TRUE;
            break;

         case 21: /* extrusion-second-light-level */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->
               extrusion_second_light_level);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.extrusion_second_light_levelPresent = TRUE;
            break;

         case 22: /* extrusion-shininess */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->extrusion_shininess);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.extrusion_shininessPresent = TRUE;
            break;

         case 23: /* extrusion-skew */
            rtxDListInit (&pvalue->extrusion_skew);
            rtXmlpSetListMode (pctxt);

            while (rtXmlpListHasItem(pctxt)) {
               Ns3_Enhanced_geometry_extrusion_skew_element*
                   pdata1 = rtxMemAllocType (pctxt, 
                  Ns3_Enhanced_geometry_extrusion_skew_element);
               if (0 == pdata1) LOG_RTERR (pctxt, RTERR_NOMEM);

               stat = XmlDec_Ns3_Enhanced_geometry_extrusion_skew_element 
                  (pctxt, pdata1);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               if (0 == rtxDListAppend (pctxt, &pvalue->extrusion_skew
                  , pdata1)) {
                  return LOG_RTERR (pctxt, RTERR_NOMEM);
               }
            }

            pvalue->m.extrusion_skewPresent = TRUE;
            break;

         case 24: /* extrusion-specularity */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->extrusion_specularity
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.extrusion_specularityPresent = TRUE;
            break;

         case 25: /* extrusion-viewpoint */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->extrusion_viewpoint);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.extrusion_viewpointPresent = TRUE;
            break;

         case 26: /* glue-point-leaving-directions */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->
               glue_point_leaving_directions);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.glue_point_leaving_directionsPresent = TRUE;
            break;

         case 27: /* glue-point-type */
            stat = XmlDec_Ns3_Enhanced_geometry_glue_point_type (pctxt, &pvalue
               ->glue_point_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.glue_point_typePresent = TRUE;
            break;

         case 28: /* glue-points */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->glue_points);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.glue_pointsPresent = TRUE;
            break;

         case 29: /* mirror-horizontal */
            stat = XmlDec_Ns3_Enhanced_geometry_mirror_horizontal (pctxt, &
               pvalue->mirror_horizontal);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mirror_horizontalPresent = TRUE;
            break;

         case 30: /* mirror-vertical */
            stat = XmlDec_Ns3_Enhanced_geometry_mirror_vertical (pctxt, &pvalue
               ->mirror_vertical);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mirror_verticalPresent = TRUE;
            break;

         case 31: /* modifiers */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->modifiers);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.modifiersPresent = TRUE;
            break;

         case 32: /* path-stretchpoint-x */
            stat = rtXmlpDecDouble (pctxt, &pvalue->path_stretchpoint_x
               , -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.path_stretchpoint_xPresent = TRUE;
            break;

         case 33: /* path-stretchpoint-y */
            stat = rtXmlpDecDouble (pctxt, &pvalue->path_stretchpoint_y
               , -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.path_stretchpoint_yPresent = TRUE;
            break;

         case 34: /* text-areas */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->text_areas);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.text_areasPresent = TRUE;
            break;

         case 35: /* text-path */
            stat = XmlDec_Ns3_Enhanced_geometry_text_path (pctxt, &pvalue->
               text_path);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.text_pathPresent = TRUE;
            break;

         case 36: /* text-path-allowed */
            stat = XmlDec_Ns3_Enhanced_geometry_text_path_allowed (pctxt, &
               pvalue->text_path_allowed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.text_path_allowedPresent = TRUE;
            break;

         case 37: /* text-path-mode */
            stat = XmlDec_Ns3_Enhanced_geometry_text_path_mode (pctxt, &pvalue
               ->text_path_mode);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.text_path_modePresent = TRUE;
            break;

         case 38: /* text-path-same-letter-heights */
            stat = XmlDec_Ns3_Enhanced_geometry_text_path_same_letter_heights 
               (pctxt, &pvalue->text_path_same_letter_heights);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.text_path_same_letter_heightsPresent = TRUE;
            break;

         case 39: /* text-path-scale */
            stat = XmlDec_Ns3_Enhanced_geometry_text_path_scale (pctxt, &pvalue
               ->text_path_scale);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.text_path_scalePresent = TRUE;
            break;

         case 40: /* text-rotate-angle */
            stat = rtXmlpDecDouble (pctxt, &pvalue->text_rotate_angle
               , -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.text_rotate_anglePresent = TRUE;
            break;

         case 41: /* type */
            stat = XmlDec_Ns3_Enhanced_geometry_type (pctxt, &pvalue->type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.typePresent = TRUE;
            break;

         case 42: /* viewBox */
            rtxDListInit (&pvalue->viewBox);
            rtXmlpSetListMode (pctxt);

            while (rtXmlpListHasItem(pctxt)) {
               ViewBox_element* pdata1 = rtxMemAllocType (pctxt, 
                  ViewBox_element);
               if (0 == pdata1) LOG_RTERR (pctxt, RTERR_NOMEM);

               stat = XmlDec_ViewBox_element (pctxt, pdata1);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               if (0 == rtxDListAppend (pctxt, &pvalue->viewBox, pdata1)) {
                  return LOG_RTERR (pctxt, RTERR_NOMEM);
               }
            }

            pvalue->m.viewBoxPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Enhanced_geometry");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Enhanced_geometry");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("equation"), 8}, 0}, 0 },
      {{{OSUTF8("handle"), 6}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Ns3_Equation* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Equation);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Equation (pdata1);

            stat = XmlDec_Ns3_Equation (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->equation_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 1: {
         Ns3_Handle* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Handle);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Handle (pdata1);

            stat = XmlDec_Ns3_Handle (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->handle_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Custom_shape                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Custom_shape (OSCTXT* pctxt, Ns3_Custom_shape *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode class_names */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_namesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode data */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->data, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dataPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode engine */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->engine, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.enginePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Id (pctxt, 
               &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode layer */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Layer_1 (pctxt, 
               &pvalue->layer, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.layerPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode text_style_name */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Text_style_name (pctxt, 
               &pvalue->text_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.text_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode transform */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Transform (pctxt, 
               &pvalue->transform, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.transformPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode z_index */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Z_index (pctxt, 
               &pvalue->z_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.z_indexPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode class_names_1 */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_names_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 11:
         /* decode style_name_1 */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_name_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 12:
         /* decode height */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->height, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.heightPresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode width */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->width, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.widthPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode x */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.xPresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode y */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.yPresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode end_cell_address */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_cell_address (pctxt, 
               (End_cell_address*)&pvalue->end_cell_address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_cell_addressPresent = TRUE;
            }
         }
         break;

      case 17:
         /* decode end_x */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_x (pctxt, 
               (End_x*)&pvalue->end_x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_xPresent = TRUE;
            }
         }
         break;

      case 18:
         /* decode end_y */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_y (pctxt, 
               (End_y*)&pvalue->end_y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_yPresent = TRUE;
            }
         }
         break;

      case 19:
         /* decode table_background */
         if (XD_PEEKTAG (pctxt, 0x93)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_background (pctxt, 
               (Table_background*)&pvalue->table_background, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_backgroundPresent = TRUE;
            }
         }
         break;

      case 20:
         /* decode anchor_page_number */
         if (XD_PEEKTAG (pctxt, 0x94)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_page_number (pctxt, 
               (Odf_Anchor_page_number*)&pvalue->anchor_page_number, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_page_numberPresent = TRUE;
            }
         }
         break;

      case 21:
         /* decode anchor_type */
         if (XD_PEEKTAG (pctxt, 0x95)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_type (pctxt, 
               (Odf_Anchor_type*)&pvalue->anchor_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_typePresent = TRUE;
            }
         }
         break;

      case 22:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x96)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 23:
         /* decode glue_point_list */
         if (XD_PEEKTAG (pctxt, 0x97)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Glue_point* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->glue_point_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Glue_point, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Glue_point (pdata2);

                  stat = asn1D_Ns3_Glue_point (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->glue_point_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 24:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x98)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Custom_shape_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Custom_shape_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Custom_shape_element (pdata2);

                  stat = asn1D_Ns3_Custom_shape_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 25:
         /* decode enhanced_geometry */
         if (XD_PEEKTAG (pctxt, 0x99)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Enhanced_geometry (pctxt, 
               &pvalue->enhanced_geometry, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.enhanced_geometryPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_PRIM|16):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_PRIM|17):
         case (TM_CTXT|TM_CONS|17):
         case (TM_CTXT|TM_PRIM|18):
         case (TM_CTXT|TM_CONS|18):
         case (TM_CTXT|TM_PRIM|19):
         case (TM_CTXT|TM_PRIM|20):
         case (TM_CTXT|TM_PRIM|21):
         case (TM_CTXT|TM_CONS|22):
         case (TM_CTXT|TM_CONS|23):
         case (TM_CTXT|TM_CONS|24):
         case (TM_CTXT|TM_CONS|25):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Custom_shape (OSCTXT* pctxt, Ns3_Custom_shape* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("data"), 4}, 0 },
         { {OSUTF8("engine"), 6}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("layer"), 5}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("text-style-name"), 15}, 0 },
         { {OSUTF8("transform"), 9}, 0 },
         { {OSUTF8("z-index"), 7}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("height"), 6}, 0 },
         { {OSUTF8("width"), 5}, 0 },
         { {OSUTF8("x"), 1}, 0 },
         { {OSUTF8("y"), 1}, 0 },
         { {OSUTF8("end-cell-address"), 16}, 0 },
         { {OSUTF8("end-x"), 5}, 0 },
         { {OSUTF8("end-y"), 5}, 0 },
         { {OSUTF8("table-background"), 16}, 0 },
         { {OSUTF8("anchor-page-number"), 18}, 0 },
         { {OSUTF8("anchor-type"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 22, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* class-names */
            rtxDListInit (&pvalue->class_names);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_namesPresent = TRUE;
            break;

         case 1: /* data */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->data);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.dataPresent = TRUE;
            break;

         case 2: /* engine */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->engine);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.enginePresent = TRUE;
            break;

         case 3: /* id */
            stat = XmlDec_Ns3_Id (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 4: /* layer */
            stat = XmlDec_Ns3_Layer_1 (pctxt, &pvalue->layer);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.layerPresent = TRUE;
            break;

         case 5: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 6: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         case 7: /* text-style-name */
            stat = XmlDec_Ns3_Text_style_name (pctxt, &pvalue->text_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.text_style_namePresent = TRUE;
            break;

         case 8: /* transform */
            stat = XmlDec_Ns3_Transform (pctxt, &pvalue->transform);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.transformPresent = TRUE;
            break;

         case 9: /* z-index */
            stat = XmlDec_Ns3_Z_index (pctxt, &pvalue->z_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.z_indexPresent = TRUE;
            break;

         case 10: /* class-names */
            rtxDListInit (&pvalue->class_names_1);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_names_1Present = TRUE;
            break;

         case 11: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_name_1Present = TRUE;
            break;

         case 12: /* height */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->height);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.heightPresent = TRUE;
            break;

         case 13: /* width */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->width);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.widthPresent = TRUE;
            break;

         case 14: /* x */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.xPresent = TRUE;
            break;

         case 15: /* y */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.yPresent = TRUE;
            break;

         case 16: /* end-cell-address */
            stat = XmlDec_End_cell_address (pctxt, &pvalue->end_cell_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_cell_addressPresent = TRUE;
            break;

         case 17: /* end-x */
            stat = XmlDec_End_x (pctxt, &pvalue->end_x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_xPresent = TRUE;
            break;

         case 18: /* end-y */
            stat = XmlDec_End_y (pctxt, &pvalue->end_y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_yPresent = TRUE;
            break;

         case 19: /* table-background */
            stat = XmlDec_Table_background (pctxt, &pvalue->table_background);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.table_backgroundPresent = TRUE;
            break;

         case 20: /* anchor-page-number */
            stat = XmlDec_Odf_Anchor_page_number (pctxt, &pvalue->
               anchor_page_number);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_page_numberPresent = TRUE;
            break;

         case 21: /* anchor-type */
            stat = XmlDec_Odf_Anchor_type (pctxt, &pvalue->anchor_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_typePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Custom_shape");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Custom_shape");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("event-listeners"), 15}, 0}, 0 },
      {{{OSUTF8("glue-point"), 10}, 0}, 1 },
      {{{OSUTF8("p"), 1}, 0}, 2 },
      {{{OSUTF8("list"), 4}, 0}, 2 },
      {{{OSUTF8("enhanced-geometry"), 17}, 0}, 3 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 5, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 4; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      case 1: {
         Ns3_Glue_point* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Glue_point);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Glue_point (pdata1);

            stat = XmlDec_Ns3_Glue_point (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->glue_point_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 2: {
         Ns3_Custom_shape_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Custom_shape_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Custom_shape_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns3_Custom_shape_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 2, 2, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 3: { /* enhanced-geometry */
         stat = XmlDec_Ns3_Enhanced_geometry (pctxt, &pvalue->enhanced_geometry
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.enhanced_geometryPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  A_actuate                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_A_actuate (OSCTXT* pctxt, Ns3_A_actuate *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_A_actuate (OSCTXT* pctxt, Ns3_A_actuate* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_A_actuate_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  A_show                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_A_show (OSCTXT* pctxt, Ns3_A_show *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_A_show (OSCTXT* pctxt, Ns3_A_show* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_A_show_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  A                                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_A (OSCTXT* pctxt, Ns3_A *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode actuate */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_A_actuate (pctxt, 
               &pvalue->actuate, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.actuatePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode href */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Href (pctxt, 
               &pvalue->href, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode show */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_A_show (pctxt, 
               &pvalue->show, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.showPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Type (pctxt, 
               &pvalue->type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.typePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Name (pctxt, 
               (Ns13_Name*)&pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode server_map */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Server_map (pctxt, 
               (Ns13_Server_map*)&pvalue->server_map, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.server_mapPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode target_frame_name */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->target_frame_name
                = rtxMemAllocType (pctxt, Ns13_Target_frame_name);

            if (pvalue->target_frame_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Target_frame_name ((Ns13_Target_frame_name*)pvalue->target_frame_name);
            asn1Init_Ns13_Target_frame_name ((Ns13_Target_frame_name*)pvalue->target_frame_name);

            stat = asn1D_Ns13_Target_frame_name (pctxt, 
               (Ns13_Target_frame_name*)pvalue->target_frame_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.target_frame_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode frame */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->frame = rtxMemAllocType (pctxt, Ns3_Frame);

            if (pvalue->frame == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->frame);
            asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->frame);

            stat = asn1D_Ns3_Frame (pctxt, 
               (Ns3_Frame*)pvalue->frame, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_A (OSCTXT* pctxt, Ns3_A* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("actuate"), 7}, 0 },
         { {OSUTF8("href"), 4}, 0 },
         { {OSUTF8("show"), 4}, 0 },
         { {OSUTF8("type"), 4}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("server-map"), 10}, 0 },
         { {OSUTF8("target-frame-name"), 17}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 7, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* actuate */
            stat = XmlDec_Ns3_A_actuate (pctxt, &pvalue->actuate);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.actuatePresent = TRUE;
            break;

         case 1: /* href */
            stat = XmlDec_Xlink_Href (pctxt, &pvalue->href);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* show */
            stat = XmlDec_Ns3_A_show (pctxt, &pvalue->show);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.showPresent = TRUE;
            break;

         case 3: /* type */
            stat = XmlDec_Xlink_Type (pctxt, &pvalue->type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.typePresent = TRUE;
            break;

         case 4: /* name */
            stat = XmlDec_Ns13_Name (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 5: /* server-map */
            stat = XmlDec_Ns13_Server_map (pctxt, &pvalue->server_map);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.server_mapPresent = TRUE;
            break;

         case 6: /* target-frame-name */
            pvalue->target_frame_name
                = rtxMemAllocType (pctxt, Ns13_Target_frame_name);

            if (pvalue->target_frame_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Target_frame_name ((Ns13_Target_frame_name*)pvalue->
               target_frame_name);

            stat = XmlDec_Ns13_Target_frame_name (pctxt, pvalue->
               target_frame_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.target_frame_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_A");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_A");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("frame"), 5}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* frame */
         pvalue->frame = rtxMemAllocType (pctxt, Ns3_Frame);

         if (pvalue->frame == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->frame);

         stat = XmlDec_Ns3_Frame (pctxt, pvalue->frame);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Text_box_element                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Text_box_element (OSCTXT* pctxt, 
   Ns3_Text_box_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

         if (pvalue->u.h == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_H ((Odf_H*)pvalue->u.h);
         stat = asn1D_Odf_H (pctxt, 
            (Odf_H*)pvalue->u.h, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P ((Odf_P*)pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            (Odf_P*)pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List ((Odf_List*)pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            (Odf_List*)pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.numbered_paragraph
             = rtxMemAllocType (pctxt, Odf_Numbered_paragraph);

         if (pvalue->u.numbered_paragraph == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Numbered_paragraph ((Odf_Numbered_paragraph*)pvalue->u.numbered_paragraph);
         stat = asn1D_Odf_Numbered_paragraph (pctxt, 
            (Odf_Numbered_paragraph*)pvalue->u.numbered_paragraph, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.table = rtxMemAllocType (pctxt, Table);

         if (pvalue->u.table == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Table ((Table*)pvalue->u.table);
         stat = asn1D_Table (pctxt, 
            (Table*)pvalue->u.table, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.a = rtxMemAllocType (pctxt, Ns3_A);

         if (pvalue->u.a == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_A (pvalue->u.a);
         stat = asn1D_Ns3_A (pctxt, 
            pvalue->u.a, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.section = rtxMemAllocType (pctxt, Odf_Section);

         if (pvalue->u.section == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Section ((Odf_Section*)pvalue->u.section);
         stat = asn1D_Odf_Section (pctxt, 
            (Odf_Section*)pvalue->u.section, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.table_of_content
             = rtxMemAllocType (pctxt, Odf_Table_of_content);

         if (pvalue->u.table_of_content == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_of_content ((Odf_Table_of_content*)pvalue->u.table_of_content);
         stat = asn1D_Odf_Table_of_content (pctxt, 
            (Odf_Table_of_content*)pvalue->u.table_of_content, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.illustration_index
             = rtxMemAllocType (pctxt, Odf_Illustration_index);

         if (pvalue->u.illustration_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Illustration_index ((Odf_Illustration_index*)pvalue->u.illustration_index);
         stat = asn1D_Odf_Illustration_index (pctxt, 
            (Odf_Illustration_index*)pvalue->u.illustration_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.table_index = rtxMemAllocType (pctxt, Odf_Table_index);

         if (pvalue->u.table_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Table_index ((Odf_Table_index*)pvalue->u.table_index);
         stat = asn1D_Odf_Table_index (pctxt, 
            (Odf_Table_index*)pvalue->u.table_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.object_index = rtxMemAllocType (pctxt, Odf_Object_index);

         if (pvalue->u.object_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Object_index ((Odf_Object_index*)pvalue->u.object_index);
         stat = asn1D_Odf_Object_index (pctxt, 
            (Odf_Object_index*)pvalue->u.object_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.user_index = rtxMemAllocType (pctxt, Odf_User_index);

         if (pvalue->u.user_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_User_index ((Odf_User_index*)pvalue->u.user_index);
         stat = asn1D_Odf_User_index (pctxt, 
            (Odf_User_index*)pvalue->u.user_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.alphabetical_index
             = rtxMemAllocType (pctxt, Odf_Alphabetical_index);

         if (pvalue->u.alphabetical_index == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Alphabetical_index ((Odf_Alphabetical_index*)pvalue->u.alphabetical_index);
         stat = asn1D_Odf_Alphabetical_index (pctxt, 
            (Odf_Alphabetical_index*)pvalue->u.alphabetical_index, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.bibliography = rtxMemAllocType (pctxt, Odf_Bibliography);

         if (pvalue->u.bibliography == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Bibliography ((Odf_Bibliography*)pvalue->u.bibliography);
         stat = asn1D_Odf_Bibliography (pctxt, 
            (Odf_Bibliography*)pvalue->u.bibliography, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

         if (pvalue->u.rect == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Rect (pvalue->u.rect);
         stat = asn1D_Ns3_Rect (pctxt, 
            pvalue->u.rect, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

         if (pvalue->u.line == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Line (pvalue->u.line);
         stat = asn1D_Ns3_Line (pctxt, 
            pvalue->u.line, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

         if (pvalue->u.polyline == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polyline (pvalue->u.polyline);
         stat = asn1D_Ns3_Polyline (pctxt, 
            pvalue->u.polyline, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      case (TM_CTXT|TM_CONS|17):
         pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

         if (pvalue->u.polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polygon (pvalue->u.polygon);
         stat = asn1D_Ns3_Polygon (pctxt, 
            pvalue->u.polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 18;
         break;

      case (TM_CTXT|TM_CONS|18):
         pvalue->u.regular_polygon
             = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

         if (pvalue->u.regular_polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Regular_polygon (pvalue->u.regular_polygon);
         stat = asn1D_Ns3_Regular_polygon (pctxt, 
            pvalue->u.regular_polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 19;
         break;

      case (TM_CTXT|TM_CONS|19):
         pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

         if (pvalue->u.path == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Path (pvalue->u.path);
         stat = asn1D_Ns3_Path (pctxt, 
            pvalue->u.path, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 20;
         break;

      case (TM_CTXT|TM_CONS|20):
         pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

         if (pvalue->u.circle == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Circle (pvalue->u.circle);
         stat = asn1D_Ns3_Circle (pctxt, 
            pvalue->u.circle, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 21;
         break;

      case (TM_CTXT|TM_CONS|21):
         pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

         if (pvalue->u.ellipse == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Ellipse (pvalue->u.ellipse);
         stat = asn1D_Ns3_Ellipse (pctxt, 
            pvalue->u.ellipse, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 22;
         break;

      case (TM_CTXT|TM_CONS|22):
         pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

         if (pvalue->u.g == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);
         stat = asn1D_Ns3_G (pctxt, 
            (Ns3_G*)pvalue->u.g, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 23;
         break;

      case (TM_CTXT|TM_CONS|23):
         pvalue->u.page_thumbnail
             = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

         if (pvalue->u.page_thumbnail == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Page_thumbnail (pvalue->u.page_thumbnail);
         stat = asn1D_Ns3_Page_thumbnail (pctxt, 
            pvalue->u.page_thumbnail, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 24;
         break;

      case (TM_CTXT|TM_CONS|24):
         pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

         if (pvalue->u.frame == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);
         stat = asn1D_Ns3_Frame (pctxt, 
            (Ns3_Frame*)pvalue->u.frame, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 25;
         break;

      case (TM_CTXT|TM_CONS|25):
         pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

         if (pvalue->u.measure == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Measure (pvalue->u.measure);
         stat = asn1D_Ns3_Measure (pctxt, 
            pvalue->u.measure, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 26;
         break;

      case (TM_CTXT|TM_CONS|26):
         pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

         if (pvalue->u.caption == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Caption (pvalue->u.caption);
         stat = asn1D_Ns3_Caption (pctxt, 
            pvalue->u.caption, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 27;
         break;

      case (TM_CTXT|TM_CONS|27):
         pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

         if (pvalue->u.connector == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Connector (pvalue->u.connector);
         stat = asn1D_Ns3_Connector (pctxt, 
            pvalue->u.connector, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 28;
         break;

      case (TM_CTXT|TM_CONS|28):
         pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

         if (pvalue->u.control == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Control (pvalue->u.control);
         stat = asn1D_Ns3_Control (pctxt, 
            pvalue->u.control, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 29;
         break;

      case (TM_CTXT|TM_CONS|29):
         pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

         if (pvalue->u.scene == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);
         stat = asn1D_Ns7_Scene (pctxt, 
            (Ns7_Scene*)pvalue->u.scene, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 30;
         break;

      case (TM_CTXT|TM_CONS|30):
         pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

         if (pvalue->u.custom_shape == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Custom_shape (pvalue->u.custom_shape);
         stat = asn1D_Ns3_Custom_shape (pctxt, 
            pvalue->u.custom_shape, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 31;
         break;

      case (TM_CTXT|TM_CONS|31):
         pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

         if (pvalue->u.change == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change ((Odf_Change*)pvalue->u.change);
         stat = asn1D_Odf_Change (pctxt, 
            (Odf_Change*)pvalue->u.change, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 32;
         break;

      case (TM_CTXT|TM_CONS|32):
         pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

         if (pvalue->u.change_start == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_start ((Odf_Change_start*)pvalue->u.change_start);
         stat = asn1D_Odf_Change_start (pctxt, 
            (Odf_Change_start*)pvalue->u.change_start, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 33;
         break;

      case (TM_CTXT|TM_CONS|33):
         pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

         if (pvalue->u.change_end == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_Change_end ((Odf_Change_end*)pvalue->u.change_end);
         stat = asn1D_Odf_Change_end (pctxt, 
            (Odf_Change_end*)pvalue->u.change_end, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 34;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Text_box_element (OSCTXT* pctxt, Ns3_Text_box_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("h"), 1}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 1 },
      {{{OSUTF8("list"), 4}, 0}, 2 },
      {{{OSUTF8("numbered-paragraph"), 18}, 0}, 3 },
      {{{OSUTF8("table"), 5}, 0}, 4 },
      {{{OSUTF8("a"), 1}, 0}, 5 },
      {{{OSUTF8("section"), 7}, 0}, 6 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 7 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 8 },
      {{{OSUTF8("table-index"), 11}, 0}, 9 },
      {{{OSUTF8("object-index"), 12}, 0}, 10 },
      {{{OSUTF8("user-index"), 10}, 0}, 11 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 12 },
      {{{OSUTF8("bibliography"), 12}, 0}, 13 },
      {{{OSUTF8("rect"), 4}, 0}, 14 },
      {{{OSUTF8("line"), 4}, 0}, 15 },
      {{{OSUTF8("polyline"), 8}, 0}, 16 },
      {{{OSUTF8("polygon"), 7}, 0}, 17 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 18 },
      {{{OSUTF8("path"), 4}, 0}, 19 },
      {{{OSUTF8("circle"), 6}, 0}, 20 },
      {{{OSUTF8("ellipse"), 7}, 0}, 21 },
      {{{OSUTF8("g"), 1}, 0}, 22 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 23 },
      {{{OSUTF8("frame"), 5}, 0}, 24 },
      {{{OSUTF8("measure"), 7}, 0}, 25 },
      {{{OSUTF8("caption"), 7}, 0}, 26 },
      {{{OSUTF8("connector"), 9}, 0}, 27 },
      {{{OSUTF8("control"), 7}, 0}, 28 },
      {{{OSUTF8("scene"), 5}, 0}, 29 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 30 },
      {{{OSUTF8("change"), 6}, 0}, 31 },
      {{{OSUTF8("change-start"), 12}, 0}, 32 },
      {{{OSUTF8("change-end"), 10}, 0}, 33 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 34, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* h */
      pvalue->u.h = rtxMemAllocType (pctxt, Odf_H);

      if (pvalue->u.h == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_H ((Odf_H*)pvalue->u.h);

      stat = XmlDec_Odf_H (pctxt, pvalue->u.h);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P ((Odf_P*)pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List ((Odf_List*)pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* numbered-paragraph */
      pvalue->u.numbered_paragraph
          = rtxMemAllocType (pctxt, Odf_Numbered_paragraph);

      if (pvalue->u.numbered_paragraph == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Numbered_paragraph ((Odf_Numbered_paragraph*)pvalue->
         u.numbered_paragraph);

      stat = XmlDec_Odf_Numbered_paragraph (pctxt, pvalue->u.numbered_paragraph
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* table */
      pvalue->u.table = rtxMemAllocType (pctxt, Table);

      if (pvalue->u.table == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Table ((Table*)pvalue->u.table);

      stat = XmlDec_Table (pctxt, pvalue->u.table);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* a */
      pvalue->u.a = rtxMemAllocType (pctxt, Ns3_A);

      if (pvalue->u.a == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_A (pvalue->u.a);

      stat = XmlDec_Ns3_A (pctxt, pvalue->u.a);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* section */
      pvalue->u.section = rtxMemAllocType (pctxt, Odf_Section);

      if (pvalue->u.section == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Section ((Odf_Section*)pvalue->u.section);

      stat = XmlDec_Odf_Section (pctxt, pvalue->u.section);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* table-of-content */
      pvalue->u.table_of_content
          = rtxMemAllocType (pctxt, Odf_Table_of_content);

      if (pvalue->u.table_of_content == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_of_content ((Odf_Table_of_content*)pvalue->
         u.table_of_content);

      stat = XmlDec_Odf_Table_of_content (pctxt, pvalue->u.table_of_content);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* illustration-index */
      pvalue->u.illustration_index
          = rtxMemAllocType (pctxt, Odf_Illustration_index);

      if (pvalue->u.illustration_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Illustration_index ((Odf_Illustration_index*)pvalue->
         u.illustration_index);

      stat = XmlDec_Odf_Illustration_index (pctxt, pvalue->u.illustration_index
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* table-index */
      pvalue->u.table_index = rtxMemAllocType (pctxt, Odf_Table_index);

      if (pvalue->u.table_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Table_index ((Odf_Table_index*)pvalue->u.table_index);

      stat = XmlDec_Odf_Table_index (pctxt, pvalue->u.table_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* object-index */
      pvalue->u.object_index = rtxMemAllocType (pctxt, Odf_Object_index);

      if (pvalue->u.object_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Object_index ((Odf_Object_index*)pvalue->u.object_index);

      stat = XmlDec_Odf_Object_index (pctxt, pvalue->u.object_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* user-index */
      pvalue->u.user_index = rtxMemAllocType (pctxt, Odf_User_index);

      if (pvalue->u.user_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_User_index ((Odf_User_index*)pvalue->u.user_index);

      stat = XmlDec_Odf_User_index (pctxt, pvalue->u.user_index);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* alphabetical-index */
      pvalue->u.alphabetical_index
          = rtxMemAllocType (pctxt, Odf_Alphabetical_index);

      if (pvalue->u.alphabetical_index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Alphabetical_index ((Odf_Alphabetical_index*)pvalue->
         u.alphabetical_index);

      stat = XmlDec_Odf_Alphabetical_index (pctxt, pvalue->u.alphabetical_index
         );
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* bibliography */
      pvalue->u.bibliography = rtxMemAllocType (pctxt, Odf_Bibliography);

      if (pvalue->u.bibliography == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Bibliography ((Odf_Bibliography*)pvalue->u.bibliography);

      stat = XmlDec_Odf_Bibliography (pctxt, pvalue->u.bibliography);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* rect */
      pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

      if (pvalue->u.rect == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Rect (pvalue->u.rect);

      stat = XmlDec_Ns3_Rect (pctxt, pvalue->u.rect);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* line */
      pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

      if (pvalue->u.line == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Line (pvalue->u.line);

      stat = XmlDec_Ns3_Line (pctxt, pvalue->u.line);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* polyline */
      pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

      if (pvalue->u.polyline == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polyline (pvalue->u.polyline);

      stat = XmlDec_Ns3_Polyline (pctxt, pvalue->u.polyline);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 17: { /* polygon */
      pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

      if (pvalue->u.polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polygon (pvalue->u.polygon);

      stat = XmlDec_Ns3_Polygon (pctxt, pvalue->u.polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 18: { /* regular-polygon */
      pvalue->u.regular_polygon
          = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

      if (pvalue->u.regular_polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Regular_polygon (pvalue->u.regular_polygon);

      stat = XmlDec_Ns3_Regular_polygon (pctxt, pvalue->u.regular_polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 19: { /* path */
      pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

      if (pvalue->u.path == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Path (pvalue->u.path);

      stat = XmlDec_Ns3_Path (pctxt, pvalue->u.path);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 20: { /* circle */
      pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

      if (pvalue->u.circle == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Circle (pvalue->u.circle);

      stat = XmlDec_Ns3_Circle (pctxt, pvalue->u.circle);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 21: { /* ellipse */
      pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

      if (pvalue->u.ellipse == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Ellipse (pvalue->u.ellipse);

      stat = XmlDec_Ns3_Ellipse (pctxt, pvalue->u.ellipse);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 22: { /* g */
      pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

      if (pvalue->u.g == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);

      stat = XmlDec_Ns3_G (pctxt, pvalue->u.g);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 23: { /* page-thumbnail */
      pvalue->u.page_thumbnail = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

      if (pvalue->u.page_thumbnail == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Page_thumbnail (pvalue->u.page_thumbnail);

      stat = XmlDec_Ns3_Page_thumbnail (pctxt, pvalue->u.page_thumbnail);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 24: { /* frame */
      pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

      if (pvalue->u.frame == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Frame ((Ns3_Frame*)pvalue->u.frame);

      stat = XmlDec_Ns3_Frame (pctxt, pvalue->u.frame);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 25: { /* measure */
      pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

      if (pvalue->u.measure == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Measure (pvalue->u.measure);

      stat = XmlDec_Ns3_Measure (pctxt, pvalue->u.measure);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 26: { /* caption */
      pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

      if (pvalue->u.caption == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Caption (pvalue->u.caption);

      stat = XmlDec_Ns3_Caption (pctxt, pvalue->u.caption);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 27: { /* connector */
      pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

      if (pvalue->u.connector == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Connector (pvalue->u.connector);

      stat = XmlDec_Ns3_Connector (pctxt, pvalue->u.connector);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 28: { /* control */
      pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

      if (pvalue->u.control == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Control (pvalue->u.control);

      stat = XmlDec_Ns3_Control (pctxt, pvalue->u.control);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 29: { /* scene */
      pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

      if (pvalue->u.scene == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);

      stat = XmlDec_Ns7_Scene (pctxt, pvalue->u.scene);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 30: { /* custom-shape */
      pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

      if (pvalue->u.custom_shape == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Custom_shape (pvalue->u.custom_shape);

      stat = XmlDec_Ns3_Custom_shape (pctxt, pvalue->u.custom_shape);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 31: { /* change */
      pvalue->u.change = rtxMemAllocType (pctxt, Odf_Change);

      if (pvalue->u.change == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change ((Odf_Change*)pvalue->u.change);

      stat = XmlDec_Odf_Change (pctxt, pvalue->u.change);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 32: { /* change-start */
      pvalue->u.change_start = rtxMemAllocType (pctxt, Odf_Change_start);

      if (pvalue->u.change_start == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_start ((Odf_Change_start*)pvalue->u.change_start);

      stat = XmlDec_Odf_Change_start (pctxt, pvalue->u.change_start);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 33: { /* change-end */
      pvalue->u.change_end = rtxMemAllocType (pctxt, Odf_Change_end);

      if (pvalue->u.change_end == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_Change_end ((Odf_Change_end*)pvalue->u.change_end);

      stat = XmlDec_Odf_Change_end (pctxt, pvalue->u.change_end);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Text_box                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Text_box (OSCTXT* pctxt, Ns3_Text_box *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode chain_next_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->chain_next_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.chain_next_namePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode corner_radius */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Corner_radius (pctxt, 
               &pvalue->corner_radius, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.corner_radiusPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode max_height */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns1_Max_height (pctxt, 
               &pvalue->max_height, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.max_heightPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode max_width */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns1_Max_width (pctxt, 
               &pvalue->max_width, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.max_widthPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode min_height */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns1_Min_height (pctxt, 
               &pvalue->min_height, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.min_heightPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode min_width */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns1_Min_width (pctxt, 
               &pvalue->min_width, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.min_widthPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Text_box_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Text_box_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Text_box_element (pdata2);

                  stat = asn1D_Ns3_Text_box_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Text_box (OSCTXT* pctxt, Ns3_Text_box* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("chain-next-name"), 15}, 0 },
         { {OSUTF8("corner-radius"), 13}, 0 },
         { {OSUTF8("max-height"), 10}, 0 },
         { {OSUTF8("max-width"), 9}, 0 },
         { {OSUTF8("min-height"), 10}, 0 },
         { {OSUTF8("min-width"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 6, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* chain-next-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->chain_next_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.chain_next_namePresent = TRUE;
            break;

         case 1: /* corner-radius */
            stat = XmlDec_Ns3_Corner_radius (pctxt, &pvalue->corner_radius);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.corner_radiusPresent = TRUE;
            break;

         case 2: /* max-height */
            stat = XmlDec_Ns1_Max_height (pctxt, &pvalue->max_height);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.max_heightPresent = TRUE;
            break;

         case 3: /* max-width */
            stat = XmlDec_Ns1_Max_width (pctxt, &pvalue->max_width);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.max_widthPresent = TRUE;
            break;

         case 4: /* min-height */
            stat = XmlDec_Ns1_Min_height (pctxt, &pvalue->min_height);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.min_heightPresent = TRUE;
            break;

         case 5: /* min-width */
            stat = XmlDec_Ns1_Min_width (pctxt, &pvalue->min_width);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.min_widthPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Text_box");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Text_box");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("h"), 1}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("list"), 4}, 0}, 0 },
      {{{OSUTF8("numbered-paragraph"), 18}, 0}, 0 },
      {{{OSUTF8("table"), 5}, 0}, 0 },
      {{{OSUTF8("a"), 1}, 0}, 0 },
      {{{OSUTF8("section"), 7}, 0}, 0 },
      {{{OSUTF8("table-of-content"), 16}, 0}, 0 },
      {{{OSUTF8("illustration-index"), 18}, 0}, 0 },
      {{{OSUTF8("table-index"), 11}, 0}, 0 },
      {{{OSUTF8("object-index"), 12}, 0}, 0 },
      {{{OSUTF8("user-index"), 10}, 0}, 0 },
      {{{OSUTF8("alphabetical-index"), 18}, 0}, 0 },
      {{{OSUTF8("bibliography"), 12}, 0}, 0 },
      {{{OSUTF8("rect"), 4}, 0}, 0 },
      {{{OSUTF8("line"), 4}, 0}, 0 },
      {{{OSUTF8("polyline"), 8}, 0}, 0 },
      {{{OSUTF8("polygon"), 7}, 0}, 0 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 0 },
      {{{OSUTF8("path"), 4}, 0}, 0 },
      {{{OSUTF8("circle"), 6}, 0}, 0 },
      {{{OSUTF8("ellipse"), 7}, 0}, 0 },
      {{{OSUTF8("g"), 1}, 0}, 0 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 0 },
      {{{OSUTF8("frame"), 5}, 0}, 0 },
      {{{OSUTF8("measure"), 7}, 0}, 0 },
      {{{OSUTF8("caption"), 7}, 0}, 0 },
      {{{OSUTF8("connector"), 9}, 0}, 0 },
      {{{OSUTF8("control"), 7}, 0}, 0 },
      {{{OSUTF8("scene"), 5}, 0}, 0 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 0 },
      {{{OSUTF8("change"), 6}, 0}, 0 },
      {{{OSUTF8("change-start"), 12}, 0}, 0 },
      {{{OSUTF8("change-end"), 10}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 34, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Ns3_Text_box_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Text_box_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Text_box_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns3_Text_box_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 34, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Image_actuate                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Image_actuate (OSCTXT* pctxt, Ns3_Image_actuate *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Image_actuate (OSCTXT* pctxt, Ns3_Image_actuate* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Image_actuate_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Image_show                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Image_show (OSCTXT* pctxt, Ns3_Image_show *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Image_show (OSCTXT* pctxt, Ns3_Image_show* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Image_show_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Image_element                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Image_element (OSCTXT* pctxt, Ns3_Image_element *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

         if (pvalue->u.p == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_P ((Odf_P*)pvalue->u.p);
         stat = asn1D_Odf_P (pctxt, 
            (Odf_P*)pvalue->u.p, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

         if (pvalue->u.list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Odf_List ((Odf_List*)pvalue->u.list);
         stat = asn1D_Odf_List (pctxt, 
            (Odf_List*)pvalue->u.list, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Image_element (OSCTXT* pctxt, Ns3_Image_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("p"), 1}, 0}, 0 },
      {{{OSUTF8("list"), 4}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* p */
      pvalue->u.p = rtxMemAllocType (pctxt, Odf_P);

      if (pvalue->u.p == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_P ((Odf_P*)pvalue->u.p);

      stat = XmlDec_Odf_P (pctxt, pvalue->u.p);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* list */
      pvalue->u.list = rtxMemAllocType (pctxt, Odf_List);

      if (pvalue->u.list == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Odf_List ((Odf_List*)pvalue->u.list);

      stat = XmlDec_Odf_List (pctxt, pvalue->u.list);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Image                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Image (OSCTXT* pctxt, Ns3_Image *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode actuate */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Image_actuate (pctxt, 
               &pvalue->actuate, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.actuatePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode href */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Href (pctxt, 
               &pvalue->href, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.hrefPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode show */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Image_show (pctxt, 
               &pvalue->show, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.showPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Type (pctxt, 
               &pvalue->type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.typePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode filter_name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->filter_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.filter_namePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode binary_data */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Binary_data (pctxt, 
               (Ns13_Binary_data*)&pvalue->binary_data, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.binary_dataPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Image_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Image_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Image_element (pdata2);

                  stat = asn1D_Ns3_Image_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Image (OSCTXT* pctxt, Ns3_Image* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("actuate"), 7}, 0 },
         { {OSUTF8("href"), 4}, 0 },
         { {OSUTF8("show"), 4}, 0 },
         { {OSUTF8("type"), 4}, 0 },
         { {OSUTF8("filter-name"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* actuate */
            stat = XmlDec_Ns3_Image_actuate (pctxt, &pvalue->actuate);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.actuatePresent = TRUE;
            break;

         case 1: /* href */
            stat = XmlDec_Xlink_Href (pctxt, &pvalue->href);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.hrefPresent = TRUE;
            break;

         case 2: /* show */
            stat = XmlDec_Ns3_Image_show (pctxt, &pvalue->show);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.showPresent = TRUE;
            break;

         case 3: /* type */
            stat = XmlDec_Xlink_Type (pctxt, &pvalue->type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.typePresent = TRUE;
            break;

         case 4: /* filter-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->filter_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.filter_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Image");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Image");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("binary-data"), 11}, 0}, 0 },
      {{{OSUTF8("p"), 1}, 0}, 1 },
      {{{OSUTF8("list"), 4}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* binary-data */
         stat = XmlDec_Ns13_Binary_data (pctxt, &pvalue->binary_data);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.binary_dataPresent = TRUE;
         break;
      }
      case 1: {
         Ns3_Image_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Image_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Image_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns3_Image_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 2, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Object_actuate                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Object_actuate (OSCTXT* pctxt, 
   Ns3_Object_actuate *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Object_actuate (OSCTXT* pctxt, Ns3_Object_actuate* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Object_actuate_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Object_show                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Object_show (OSCTXT* pctxt, Ns3_Object_show *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Object_show (OSCTXT* pctxt, Ns3_Object_show* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Object_show_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Gradient_style                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Gradient_style (OSCTXT* pctxt, 
   Ns3_Gradient_style *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Gradient_style (OSCTXT* pctxt, Ns3_Gradient_style* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Gradient_style_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Gradient                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Gradient (OSCTXT* pctxt, Ns3_Gradient *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode angle */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->angle, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anglePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode border */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->border, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.borderPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode cx */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->cx, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.cxPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode cy */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->cy, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.cyPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode display_name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Display_name (pctxt, 
               &pvalue->display_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.display_namePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode end_color */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->end_color, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_colorPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode end_intensity */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->end_intensity, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_intensityPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode start_color */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->start_color, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.start_colorPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode start_intensity */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->start_intensity, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.start_intensityPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode style */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Gradient_style (pctxt, 
               &pvalue->style, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_PRIM|10):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Gradient (OSCTXT* pctxt, Ns3_Gradient* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("angle"), 5}, 0 },
         { {OSUTF8("border"), 6}, 0 },
         { {OSUTF8("cx"), 2}, 0 },
         { {OSUTF8("cy"), 2}, 0 },
         { {OSUTF8("display-name"), 12}, 0 },
         { {OSUTF8("end-color"), 9}, 0 },
         { {OSUTF8("end-intensity"), 13}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("start-color"), 11}, 0 },
         { {OSUTF8("start-intensity"), 15}, 0 },
         { {OSUTF8("style"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 11, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* angle */
            stat = rtXmlpDecInt (pctxt, &pvalue->angle);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anglePresent = TRUE;
            break;

         case 1: /* border */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->border);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.borderPresent = TRUE;
            break;

         case 2: /* cx */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->cx);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.cxPresent = TRUE;
            break;

         case 3: /* cy */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->cy);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.cyPresent = TRUE;
            break;

         case 4: /* display-name */
            stat = XmlDec_Ns3_Display_name (pctxt, &pvalue->display_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.display_namePresent = TRUE;
            break;

         case 5: /* end-color */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->end_color);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_colorPresent = TRUE;
            break;

         case 6: /* end-intensity */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->end_intensity);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_intensityPresent = TRUE;
            break;

         case 7: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 8: /* start-color */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->start_color);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.start_colorPresent = TRUE;
            break;

         case 9: /* start-intensity */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->start_intensity);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.start_intensityPresent = TRUE;
            break;

         case 10: /* style */
            stat = XmlDec_Ns3_Gradient_style (pctxt, &pvalue->style);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Gradient");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Gradient");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Color                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Color (OSCTXT* pctxt, Ns3_Color *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Color (OSCTXT* pctxt, Ns3_Color* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Hatch_style                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Hatch_style (OSCTXT* pctxt, Ns3_Hatch_style *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Hatch_style (OSCTXT* pctxt, Ns3_Hatch_style* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Hatch_style_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Hatch                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Hatch (OSCTXT* pctxt, Ns3_Hatch *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode color */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Color (pctxt, 
               &pvalue->color, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.colorPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode display_name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Display_name (pctxt, 
               &pvalue->display_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.display_namePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode distance */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->distance, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.distancePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode rotation */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->rotation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.rotationPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode style */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Hatch_style (pctxt, 
               &pvalue->style, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Hatch (OSCTXT* pctxt, Ns3_Hatch* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("color"), 5}, 0 },
         { {OSUTF8("display-name"), 12}, 0 },
         { {OSUTF8("distance"), 8}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("rotation"), 8}, 0 },
         { {OSUTF8("style"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 6, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* color */
            stat = XmlDec_Ns3_Color (pctxt, &pvalue->color);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.colorPresent = TRUE;
            break;

         case 1: /* display-name */
            stat = XmlDec_Ns3_Display_name (pctxt, &pvalue->display_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.display_namePresent = TRUE;
            break;

         case 2: /* distance */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->distance);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.distancePresent = TRUE;
            break;

         case 3: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* rotation */
            stat = rtXmlpDecInt (pctxt, &pvalue->rotation);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.rotationPresent = TRUE;
            break;

         case 5: /* style */
            stat = XmlDec_Ns3_Hatch_style (pctxt, &pvalue->style);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Hatch");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Hatch");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Fill_image_actuate                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Fill_image_actuate (OSCTXT* pctxt, 
   Ns3_Fill_image_actuate *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Fill_image_actuate (OSCTXT* pctxt, 
   Ns3_Fill_image_actuate* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Fill_image_actuate_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Fill_image_show                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Fill_image_show (OSCTXT* pctxt, 
   Ns3_Fill_image_show *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Fill_image_show (OSCTXT* pctxt, Ns3_Fill_image_show* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Fill_image_show_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Fill_image                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Fill_image (OSCTXT* pctxt, Ns3_Fill_image *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode actuate */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Fill_image_actuate (pctxt, 
               &pvalue->actuate, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.actuatePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode href */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Href (pctxt, 
               &pvalue->href, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode show */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Fill_image_show (pctxt, 
               &pvalue->show, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.showPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Type (pctxt, 
               &pvalue->type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.typePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode display_name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Display_name (pctxt, 
               &pvalue->display_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.display_namePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode height */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->height, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.heightPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode width */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->width, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.widthPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Fill_image (OSCTXT* pctxt, Ns3_Fill_image* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("actuate"), 7}, 0 },
         { {OSUTF8("href"), 4}, 0 },
         { {OSUTF8("show"), 4}, 0 },
         { {OSUTF8("type"), 4}, 0 },
         { {OSUTF8("display-name"), 12}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("height"), 6}, 0 },
         { {OSUTF8("width"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 8, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* actuate */
            stat = XmlDec_Ns3_Fill_image_actuate (pctxt, &pvalue->actuate);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.actuatePresent = TRUE;
            break;

         case 1: /* href */
            stat = XmlDec_Xlink_Href (pctxt, &pvalue->href);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* show */
            stat = XmlDec_Ns3_Fill_image_show (pctxt, &pvalue->show);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.showPresent = TRUE;
            break;

         case 3: /* type */
            stat = XmlDec_Xlink_Type (pctxt, &pvalue->type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.typePresent = TRUE;
            break;

         case 4: /* display-name */
            stat = XmlDec_Ns3_Display_name (pctxt, &pvalue->display_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.display_namePresent = TRUE;
            break;

         case 5: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 6: /* height */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->height);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.heightPresent = TRUE;
            break;

         case 7: /* width */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->width);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.widthPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Fill_image");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Fill_image");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Marker                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Marker (OSCTXT* pctxt, Ns3_Marker *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode display_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Display_name (pctxt, 
               &pvalue->display_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.display_namePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode d */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_D (pctxt, 
               (D*)&pvalue->d, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode viewBox */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_ViewBox (pctxt, 
               (ViewBox*)&pvalue->viewBox, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Marker (OSCTXT* pctxt, Ns3_Marker* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("display-name"), 12}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("d"), 1}, 0 },
         { {OSUTF8("viewBox"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* display-name */
            stat = XmlDec_Ns3_Display_name (pctxt, &pvalue->display_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.display_namePresent = TRUE;
            break;

         case 1: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* d */
            stat = XmlDec_D (pctxt, &pvalue->d);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* viewBox */
            rtxDListInit (&pvalue->viewBox);
            rtXmlpSetListMode (pctxt);

            while (rtXmlpListHasItem(pctxt)) {
               ViewBox_element* pdata1 = rtxMemAllocType (pctxt, 
                  ViewBox_element);
               if (0 == pdata1) LOG_RTERR (pctxt, RTERR_NOMEM);

               stat = XmlDec_ViewBox_element (pctxt, pdata1);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               if (0 == rtxDListAppend (pctxt, &pvalue->viewBox, pdata1)) {
                  return LOG_RTERR (pctxt, RTERR_NOMEM);
               }
            }
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Marker");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Marker");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Stroke_dash_style                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Stroke_dash_style (OSCTXT* pctxt, 
   Ns3_Stroke_dash_style *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Stroke_dash_style (OSCTXT* pctxt, Ns3_Stroke_dash_style* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Stroke_dash_style_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Stroke_dash                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Stroke_dash (OSCTXT* pctxt, Ns3_Stroke_dash *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode display_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Display_name (pctxt, 
               &pvalue->display_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.display_namePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode distance */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->distance, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.distancePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode dots1 */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->dots1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dots1Present = TRUE;
            }
         }
         break;

      case 3:
         /* decode dots1_length */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->dots1_length, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dots1_lengthPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode dots2 */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->dots2, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dots2Present = TRUE;
            }
         }
         break;

      case 5:
         /* decode dots2_length */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->dots2_length, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dots2_lengthPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode style */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Stroke_dash_style (pctxt, 
               &pvalue->style, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.stylePresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Stroke_dash (OSCTXT* pctxt, Ns3_Stroke_dash* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("display-name"), 12}, 0 },
         { {OSUTF8("distance"), 8}, 0 },
         { {OSUTF8("dots1"), 5}, 0 },
         { {OSUTF8("dots1-length"), 12}, 0 },
         { {OSUTF8("dots2"), 5}, 0 },
         { {OSUTF8("dots2-length"), 12}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("style"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 8, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* display-name */
            stat = XmlDec_Ns3_Display_name (pctxt, &pvalue->display_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.display_namePresent = TRUE;
            break;

         case 1: /* distance */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->distance);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.distancePresent = TRUE;
            break;

         case 2: /* dots1 */
            stat = rtXmlpDecInt (pctxt, &pvalue->dots1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.dots1Present = TRUE;
            break;

         case 3: /* dots1-length */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->dots1_length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.dots1_lengthPresent = TRUE;
            break;

         case 4: /* dots2 */
            stat = rtXmlpDecInt (pctxt, &pvalue->dots2);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.dots2Present = TRUE;
            break;

         case 5: /* dots2-length */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->dots2_length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.dots2_lengthPresent = TRUE;
            break;

         case 6: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 7: /* style */
            stat = XmlDec_Ns3_Stroke_dash_style (pctxt, &pvalue->style);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.stylePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Stroke_dash");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Stroke_dash");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Opacity_style                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Opacity_style (OSCTXT* pctxt, Ns3_Opacity_style *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Opacity_style (OSCTXT* pctxt, Ns3_Opacity_style* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Opacity_style_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Opacity                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Opacity (OSCTXT* pctxt, Ns3_Opacity *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode angle */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->angle, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anglePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode border */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->border, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.borderPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode cx */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->cx, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.cxPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode cy */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->cy, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.cyPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode display_name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Display_name (pctxt, 
               &pvalue->display_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.display_namePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode end */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->end, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.endPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode start */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->start, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.startPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode style */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Opacity_style (pctxt, 
               &pvalue->style, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Opacity (OSCTXT* pctxt, Ns3_Opacity* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("angle"), 5}, 0 },
         { {OSUTF8("border"), 6}, 0 },
         { {OSUTF8("cx"), 2}, 0 },
         { {OSUTF8("cy"), 2}, 0 },
         { {OSUTF8("display-name"), 12}, 0 },
         { {OSUTF8("end"), 3}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("start"), 5}, 0 },
         { {OSUTF8("style"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 9, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* angle */
            stat = rtXmlpDecInt (pctxt, &pvalue->angle);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anglePresent = TRUE;
            break;

         case 1: /* border */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->border);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.borderPresent = TRUE;
            break;

         case 2: /* cx */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->cx);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.cxPresent = TRUE;
            break;

         case 3: /* cy */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->cy);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.cyPresent = TRUE;
            break;

         case 4: /* display-name */
            stat = XmlDec_Ns3_Display_name (pctxt, &pvalue->display_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.display_namePresent = TRUE;
            break;

         case 5: /* end */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->end);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.endPresent = TRUE;
            break;

         case 6: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 7: /* start */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->start);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.startPresent = TRUE;
            break;

         case 8: /* style */
            stat = XmlDec_Ns3_Opacity_style (pctxt, &pvalue->style);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Opacity");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Opacity");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  G                                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_G (OSCTXT* pctxt, Ns3_G *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode class_names */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_namesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Id (pctxt, 
               &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode z_index */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Z_index (pctxt, 
               &pvalue->z_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.z_indexPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode class_names_1 */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_names_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode style_name_1 */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_name_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode y */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.yPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode end_cell_address */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_cell_address (pctxt, 
               (End_cell_address*)&pvalue->end_cell_address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_cell_addressPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode end_x */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_x (pctxt, 
               (End_x*)&pvalue->end_x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_xPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode end_y */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_y (pctxt, 
               (End_y*)&pvalue->end_y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_yPresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode table_background */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_background (pctxt, 
               (Table_background*)&pvalue->table_background, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_backgroundPresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode anchor_page_number */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_page_number (pctxt, 
               (Odf_Anchor_page_number*)&pvalue->anchor_page_number, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_page_numberPresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode anchor_type */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_type (pctxt, 
               (Odf_Anchor_type*)&pvalue->anchor_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_typePresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 15:
         /* decode glue_point_list */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Glue_point* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->glue_point_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Glue_point, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Glue_point (pdata2);

                  stat = asn1D_Ns3_Glue_point (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->glue_point_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 16:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_G_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_G_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_G_element (pdata2);

                  stat = asn1D_Ns3_G_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_G (OSCTXT* pctxt, Ns3_G* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("z-index"), 7}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("y"), 1}, 0 },
         { {OSUTF8("end-cell-address"), 16}, 0 },
         { {OSUTF8("end-x"), 5}, 0 },
         { {OSUTF8("end-y"), 5}, 0 },
         { {OSUTF8("table-background"), 16}, 0 },
         { {OSUTF8("anchor-page-number"), 18}, 0 },
         { {OSUTF8("anchor-type"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 14, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* class-names */
            rtxDListInit (&pvalue->class_names);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_namesPresent = TRUE;
            break;

         case 1: /* id */
            stat = XmlDec_Ns3_Id (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 2: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 3: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         case 4: /* z-index */
            stat = XmlDec_Ns3_Z_index (pctxt, &pvalue->z_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.z_indexPresent = TRUE;
            break;

         case 5: /* class-names */
            rtxDListInit (&pvalue->class_names_1);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_names_1Present = TRUE;
            break;

         case 6: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_name_1Present = TRUE;
            break;

         case 7: /* y */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.yPresent = TRUE;
            break;

         case 8: /* end-cell-address */
            stat = XmlDec_End_cell_address (pctxt, &pvalue->end_cell_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_cell_addressPresent = TRUE;
            break;

         case 9: /* end-x */
            stat = XmlDec_End_x (pctxt, &pvalue->end_x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_xPresent = TRUE;
            break;

         case 10: /* end-y */
            stat = XmlDec_End_y (pctxt, &pvalue->end_y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_yPresent = TRUE;
            break;

         case 11: /* table-background */
            stat = XmlDec_Table_background (pctxt, &pvalue->table_background);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.table_backgroundPresent = TRUE;
            break;

         case 12: /* anchor-page-number */
            stat = XmlDec_Odf_Anchor_page_number (pctxt, &pvalue->
               anchor_page_number);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_page_numberPresent = TRUE;
            break;

         case 13: /* anchor-type */
            stat = XmlDec_Odf_Anchor_type (pctxt, &pvalue->anchor_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_typePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_G");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_G");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("event-listeners"), 15}, 0}, 0 },
      {{{OSUTF8("glue-point"), 10}, 0}, 1 },
      {{{OSUTF8("rect"), 4}, 0}, 2 },
      {{{OSUTF8("line"), 4}, 0}, 2 },
      {{{OSUTF8("polyline"), 8}, 0}, 2 },
      {{{OSUTF8("polygon"), 7}, 0}, 2 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 2 },
      {{{OSUTF8("path"), 4}, 0}, 2 },
      {{{OSUTF8("circle"), 6}, 0}, 2 },
      {{{OSUTF8("ellipse"), 7}, 0}, 2 },
      {{{OSUTF8("g"), 1}, 0}, 2 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 2 },
      {{{OSUTF8("frame"), 5}, 0}, 2 },
      {{{OSUTF8("measure"), 7}, 0}, 2 },
      {{{OSUTF8("caption"), 7}, 0}, 2 },
      {{{OSUTF8("connector"), 9}, 0}, 2 },
      {{{OSUTF8("control"), 7}, 0}, 2 },
      {{{OSUTF8("scene"), 5}, 0}, 2 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 19, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      case 1: {
         Ns3_Glue_point* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Glue_point);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Glue_point (pdata1);

            stat = XmlDec_Ns3_Glue_point (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->glue_point_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 2: {
         Ns3_G_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_G_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_G_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns3_G_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 2, 17, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Area_rectangle_show                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Area_rectangle_show (OSCTXT* pctxt, 
   Ns3_Area_rectangle_show *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Area_rectangle_show (OSCTXT* pctxt, 
   Ns3_Area_rectangle_show* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Area_rectangle_show_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Area_rectangle_nohref                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Area_rectangle_nohref (OSCTXT* pctxt, 
   Ns3_Area_rectangle_nohref *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Area_rectangle_nohref (OSCTXT* pctxt, 
   Ns3_Area_rectangle_nohref* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Area_rectangle_nohref_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Area_rectangle                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Area_rectangle (OSCTXT* pctxt, 
   Ns3_Area_rectangle *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode href */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Href (pctxt, 
               &pvalue->href, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.hrefPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode show */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Area_rectangle_show (pctxt, 
               &pvalue->show, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.showPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Type (pctxt, 
               &pvalue->type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.typePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode nohref */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Area_rectangle_nohref (pctxt, 
               &pvalue->nohref, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.nohrefPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Name (pctxt, 
               (Ns13_Name*)&pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode target_frame_name */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->target_frame_name
                = rtxMemAllocType (pctxt, Ns13_Target_frame_name);

            if (pvalue->target_frame_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Target_frame_name ((Ns13_Target_frame_name*)pvalue->target_frame_name);
            asn1Init_Ns13_Target_frame_name ((Ns13_Target_frame_name*)pvalue->target_frame_name);

            stat = asn1D_Ns13_Target_frame_name (pctxt, 
               (Ns13_Target_frame_name*)pvalue->target_frame_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.target_frame_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode height */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->height, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.heightPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode width */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->width, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.widthPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode x */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.xPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode y */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.yPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode desc */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Desc (pctxt, 
               (Desc*)&pvalue->desc, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descPresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_CONS|11):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Area_rectangle (OSCTXT* pctxt, Ns3_Area_rectangle* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("href"), 4}, 0 },
         { {OSUTF8("show"), 4}, 0 },
         { {OSUTF8("type"), 4}, 0 },
         { {OSUTF8("nohref"), 6}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("target-frame-name"), 17}, 0 },
         { {OSUTF8("height"), 6}, 0 },
         { {OSUTF8("width"), 5}, 0 },
         { {OSUTF8("x"), 1}, 0 },
         { {OSUTF8("y"), 1}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 10, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* href */
            stat = XmlDec_Xlink_Href (pctxt, &pvalue->href);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.hrefPresent = TRUE;
            break;

         case 1: /* show */
            stat = XmlDec_Ns3_Area_rectangle_show (pctxt, &pvalue->show);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.showPresent = TRUE;
            break;

         case 2: /* type */
            stat = XmlDec_Xlink_Type (pctxt, &pvalue->type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.typePresent = TRUE;
            break;

         case 3: /* nohref */
            stat = XmlDec_Ns3_Area_rectangle_nohref (pctxt, &pvalue->nohref);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.nohrefPresent = TRUE;
            break;

         case 4: /* name */
            stat = XmlDec_Ns13_Name (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 5: /* target-frame-name */
            pvalue->target_frame_name
                = rtxMemAllocType (pctxt, Ns13_Target_frame_name);

            if (pvalue->target_frame_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Target_frame_name ((Ns13_Target_frame_name*)pvalue->
               target_frame_name);

            stat = XmlDec_Ns13_Target_frame_name (pctxt, pvalue->
               target_frame_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.target_frame_namePresent = TRUE;
            break;

         case 6: /* height */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->height);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.heightPresent = TRUE;
            break;

         case 7: /* width */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->width);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.widthPresent = TRUE;
            break;

         case 8: /* x */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.xPresent = TRUE;
            break;

         case 9: /* y */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.yPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Area_rectangle");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Area_rectangle");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("desc"), 4}, 0}, 0 },
      {{{OSUTF8("event-listeners"), 15}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* desc */
         stat = XmlDec_Desc (pctxt, &pvalue->desc);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.descPresent = TRUE;
         break;
      }
      case 1: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Area_circle_show                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Area_circle_show (OSCTXT* pctxt, 
   Ns3_Area_circle_show *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Area_circle_show (OSCTXT* pctxt, Ns3_Area_circle_show* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Area_circle_show_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Area_circle_nohref                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Area_circle_nohref (OSCTXT* pctxt, 
   Ns3_Area_circle_nohref *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Area_circle_nohref (OSCTXT* pctxt, 
   Ns3_Area_circle_nohref* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Area_circle_nohref_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Area_circle                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Area_circle (OSCTXT* pctxt, Ns3_Area_circle *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode href */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Href (pctxt, 
               &pvalue->href, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.hrefPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode show */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Area_circle_show (pctxt, 
               &pvalue->show, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.showPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Type (pctxt, 
               &pvalue->type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.typePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode nohref */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Area_circle_nohref (pctxt, 
               &pvalue->nohref, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.nohrefPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Name (pctxt, 
               (Ns13_Name*)&pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode target_frame_name */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->target_frame_name
                = rtxMemAllocType (pctxt, Ns13_Target_frame_name);

            if (pvalue->target_frame_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Target_frame_name ((Ns13_Target_frame_name*)pvalue->target_frame_name);
            asn1Init_Ns13_Target_frame_name ((Ns13_Target_frame_name*)pvalue->target_frame_name);

            stat = asn1D_Ns13_Target_frame_name (pctxt, 
               (Ns13_Target_frame_name*)pvalue->target_frame_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.target_frame_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode cx */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Cx (pctxt, 
               (Cx*)&pvalue->cx, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode cy */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Cy (pctxt, 
               (Cy*)&pvalue->cy, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 8:
         /* decode r */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_R (pctxt, 
               (R*)&pvalue->r, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 9:
         /* decode desc */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Desc (pctxt, 
               (Desc*)&pvalue->desc, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Area_circle (OSCTXT* pctxt, Ns3_Area_circle* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("href"), 4}, 0 },
         { {OSUTF8("show"), 4}, 0 },
         { {OSUTF8("type"), 4}, 0 },
         { {OSUTF8("nohref"), 6}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("target-frame-name"), 17}, 0 },
         { {OSUTF8("cx"), 2}, 0 },
         { {OSUTF8("cy"), 2}, 0 },
         { {OSUTF8("r"), 1}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 9, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* href */
            stat = XmlDec_Xlink_Href (pctxt, &pvalue->href);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.hrefPresent = TRUE;
            break;

         case 1: /* show */
            stat = XmlDec_Ns3_Area_circle_show (pctxt, &pvalue->show);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.showPresent = TRUE;
            break;

         case 2: /* type */
            stat = XmlDec_Xlink_Type (pctxt, &pvalue->type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.typePresent = TRUE;
            break;

         case 3: /* nohref */
            stat = XmlDec_Ns3_Area_circle_nohref (pctxt, &pvalue->nohref);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.nohrefPresent = TRUE;
            break;

         case 4: /* name */
            stat = XmlDec_Ns13_Name (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 5: /* target-frame-name */
            pvalue->target_frame_name
                = rtxMemAllocType (pctxt, Ns13_Target_frame_name);

            if (pvalue->target_frame_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Target_frame_name ((Ns13_Target_frame_name*)pvalue->
               target_frame_name);

            stat = XmlDec_Ns13_Target_frame_name (pctxt, pvalue->
               target_frame_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.target_frame_namePresent = TRUE;
            break;

         case 6: /* cx */
            stat = XmlDec_Cx (pctxt, &pvalue->cx);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 7: /* cy */
            stat = XmlDec_Cy (pctxt, &pvalue->cy);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 8: /* r */
            stat = XmlDec_R (pctxt, &pvalue->r);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Area_circle");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Area_circle");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("desc"), 4}, 0}, 0 },
      {{{OSUTF8("event-listeners"), 15}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* desc */
         stat = XmlDec_Desc (pctxt, &pvalue->desc);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.descPresent = TRUE;
         break;
      }
      case 1: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Area_polygon_show                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Area_polygon_show (OSCTXT* pctxt, 
   Ns3_Area_polygon_show *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Area_polygon_show (OSCTXT* pctxt, Ns3_Area_polygon_show* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Area_polygon_show_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Area_polygon_nohref                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Area_polygon_nohref (OSCTXT* pctxt, 
   Ns3_Area_polygon_nohref *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Area_polygon_nohref (OSCTXT* pctxt, 
   Ns3_Area_polygon_nohref* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Area_polygon_nohref_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Area_polygon                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Area_polygon (OSCTXT* pctxt, Ns3_Area_polygon *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode href */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Href (pctxt, 
               &pvalue->href, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.hrefPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode show */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Area_polygon_show (pctxt, 
               &pvalue->show, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.showPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Type (pctxt, 
               &pvalue->type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.typePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode nohref */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Area_polygon_nohref (pctxt, 
               &pvalue->nohref, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.nohrefPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode points */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->points, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Name (pctxt, 
               (Ns13_Name*)&pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode target_frame_name */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->target_frame_name
                = rtxMemAllocType (pctxt, Ns13_Target_frame_name);

            if (pvalue->target_frame_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Target_frame_name ((Ns13_Target_frame_name*)pvalue->target_frame_name);
            asn1Init_Ns13_Target_frame_name ((Ns13_Target_frame_name*)pvalue->target_frame_name);

            stat = asn1D_Ns13_Target_frame_name (pctxt, 
               (Ns13_Target_frame_name*)pvalue->target_frame_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.target_frame_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode height */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->height, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.heightPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode viewBox */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_ViewBox (pctxt, 
               (ViewBox*)&pvalue->viewBox, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 9:
         /* decode width */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->width, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.widthPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode x */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.xPresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode y */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.yPresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode desc */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Desc (pctxt, 
               (Desc*)&pvalue->desc, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descPresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_CONS|13):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Area_polygon (OSCTXT* pctxt, Ns3_Area_polygon* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("href"), 4}, 0 },
         { {OSUTF8("show"), 4}, 0 },
         { {OSUTF8("type"), 4}, 0 },
         { {OSUTF8("nohref"), 6}, 0 },
         { {OSUTF8("points"), 6}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("target-frame-name"), 17}, 0 },
         { {OSUTF8("height"), 6}, 0 },
         { {OSUTF8("viewBox"), 7}, 0 },
         { {OSUTF8("width"), 5}, 0 },
         { {OSUTF8("x"), 1}, 0 },
         { {OSUTF8("y"), 1}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 12, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* href */
            stat = XmlDec_Xlink_Href (pctxt, &pvalue->href);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.hrefPresent = TRUE;
            break;

         case 1: /* show */
            stat = XmlDec_Ns3_Area_polygon_show (pctxt, &pvalue->show);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.showPresent = TRUE;
            break;

         case 2: /* type */
            stat = XmlDec_Xlink_Type (pctxt, &pvalue->type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.typePresent = TRUE;
            break;

         case 3: /* nohref */
            stat = XmlDec_Ns3_Area_polygon_nohref (pctxt, &pvalue->nohref);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.nohrefPresent = TRUE;
            break;

         case 4: /* points */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->points);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* name */
            stat = XmlDec_Ns13_Name (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 6: /* target-frame-name */
            pvalue->target_frame_name
                = rtxMemAllocType (pctxt, Ns13_Target_frame_name);

            if (pvalue->target_frame_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Target_frame_name ((Ns13_Target_frame_name*)pvalue->
               target_frame_name);

            stat = XmlDec_Ns13_Target_frame_name (pctxt, pvalue->
               target_frame_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.target_frame_namePresent = TRUE;
            break;

         case 7: /* height */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->height);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.heightPresent = TRUE;
            break;

         case 8: /* viewBox */
            rtxDListInit (&pvalue->viewBox);
            rtXmlpSetListMode (pctxt);

            while (rtXmlpListHasItem(pctxt)) {
               ViewBox_element* pdata1 = rtxMemAllocType (pctxt, 
                  ViewBox_element);
               if (0 == pdata1) LOG_RTERR (pctxt, RTERR_NOMEM);

               stat = XmlDec_ViewBox_element (pctxt, pdata1);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               if (0 == rtxDListAppend (pctxt, &pvalue->viewBox, pdata1)) {
                  return LOG_RTERR (pctxt, RTERR_NOMEM);
               }
            }
            break;

         case 9: /* width */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->width);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.widthPresent = TRUE;
            break;

         case 10: /* x */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.xPresent = TRUE;
            break;

         case 11: /* y */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.yPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Area_polygon");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Area_polygon");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("desc"), 4}, 0}, 0 },
      {{{OSUTF8("event-listeners"), 15}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* desc */
         stat = XmlDec_Desc (pctxt, &pvalue->desc);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.descPresent = TRUE;
         break;
      }
      case 1: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Image_map_element                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Image_map_element (OSCTXT* pctxt, 
   Ns3_Image_map_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.area_rectangle
             = rtxMemAllocType (pctxt, Ns3_Area_rectangle);

         if (pvalue->u.area_rectangle == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Area_rectangle (pvalue->u.area_rectangle);
         stat = asn1D_Ns3_Area_rectangle (pctxt, 
            pvalue->u.area_rectangle, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.area_circle = rtxMemAllocType (pctxt, Ns3_Area_circle);

         if (pvalue->u.area_circle == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Area_circle (pvalue->u.area_circle);
         stat = asn1D_Ns3_Area_circle (pctxt, 
            pvalue->u.area_circle, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.area_polygon = rtxMemAllocType (pctxt, Ns3_Area_polygon);

         if (pvalue->u.area_polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Area_polygon (pvalue->u.area_polygon);
         stat = asn1D_Ns3_Area_polygon (pctxt, 
            pvalue->u.area_polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Image_map_element (OSCTXT* pctxt, Ns3_Image_map_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("area-rectangle"), 14}, 0}, 0 },
      {{{OSUTF8("area-circle"), 11}, 0}, 1 },
      {{{OSUTF8("area-polygon"), 12}, 0}, 2 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* area-rectangle */
      pvalue->u.area_rectangle = rtxMemAllocType (pctxt, Ns3_Area_rectangle);

      if (pvalue->u.area_rectangle == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Area_rectangle (pvalue->u.area_rectangle);

      stat = XmlDec_Ns3_Area_rectangle (pctxt, pvalue->u.area_rectangle);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* area-circle */
      pvalue->u.area_circle = rtxMemAllocType (pctxt, Ns3_Area_circle);

      if (pvalue->u.area_circle == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Area_circle (pvalue->u.area_circle);

      stat = XmlDec_Ns3_Area_circle (pctxt, pvalue->u.area_circle);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* area-polygon */
      pvalue->u.area_polygon = rtxMemAllocType (pctxt, Ns3_Area_polygon);

      if (pvalue->u.area_polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Area_polygon (pvalue->u.area_polygon);

      stat = XmlDec_Ns3_Area_polygon (pctxt, pvalue->u.area_polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Image_map                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Image_map (OSCTXT* pctxt, Ns3_Image_map *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   Ns3_Image_map_element* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (XD_PEEKTAG (pctxt, 0x30)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_UNIV|TM_CONS|16));

   if (XD_PEEKTAG (pctxt, 0xa0)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_CTXT|TM_CONS|0));

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      rtxDListAllocNodeAndData (pctxt, Ns3_Image_map_element, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Image_map_element (pdata1);

      stat = asn1D_Ns3_Image_map_element (pctxt, 
         pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

int XmlDec_Ns3_Image_map (OSCTXT* pctxt, Ns3_Image_map* pvalue)
{
   int stat = 0;

   { int elemID;
   Ns3_Image_map_element* pdata1;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("area-rectangle"), 14}, 0}, 0 },
      {{{OSUTF8("area-circle"), 11}, 0}, 0 },
      {{{OSUTF8("area-polygon"), 12}, 0}, 0 }
   } ;

   rtxDListInit (pvalue);
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, FALSE);
      if (elemID < 0 || elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0:
         rtXmlpMarkLastEventActive (pctxt);

         pdata1 = rtxMemAllocType (pctxt, Ns3_Image_map_element);

         if (pdata1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Image_map_element (pdata1);

         stat = XmlDec_Ns3_Image_map_element (pctxt, pdata1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         break;

      }
   }

   if (elemID == RTERR_UNEXPELEM || elemID == XML_OK_EOB) {
      stat = 0;
   }
   else return LOG_RTERR (pctxt, elemID);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Contour_polygon_recreate_on_edit                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Contour_polygon_recreate_on_edit (OSCTXT* pctxt, 
   Ns3_Contour_polygon_recreate_on_edit *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Contour_polygon_recreate_on_edit (OSCTXT* pctxt, 
   Ns3_Contour_polygon_recreate_on_edit* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Contour_polygon_recreate_on_edit_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Contour_polygon                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Contour_polygon (OSCTXT* pctxt, 
   Ns3_Contour_polygon *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode points */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->points, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode recreate_on_edit */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Contour_polygon_recreate_on_edit (pctxt, 
               &pvalue->recreate_on_edit, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode height */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->height, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.heightPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode viewBox */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_ViewBox (pctxt, 
               (ViewBox*)&pvalue->viewBox, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode width */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->width, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.widthPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Contour_polygon (OSCTXT* pctxt, Ns3_Contour_polygon* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("points"), 6}, 0 },
         { {OSUTF8("recreate-on-edit"), 16}, 0 },
         { {OSUTF8("height"), 6}, 0 },
         { {OSUTF8("viewBox"), 7}, 0 },
         { {OSUTF8("width"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* points */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->points);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* recreate-on-edit */
            stat = XmlDec_Ns3_Contour_polygon_recreate_on_edit (pctxt, &pvalue
               ->recreate_on_edit);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* height */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->height);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.heightPresent = TRUE;
            break;

         case 3: /* viewBox */
            rtxDListInit (&pvalue->viewBox);
            rtXmlpSetListMode (pctxt);

            while (rtXmlpListHasItem(pctxt)) {
               ViewBox_element* pdata1 = rtxMemAllocType (pctxt, 
                  ViewBox_element);
               if (0 == pdata1) LOG_RTERR (pctxt, RTERR_NOMEM);

               stat = XmlDec_ViewBox_element (pctxt, pdata1);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               if (0 == rtxDListAppend (pctxt, &pvalue->viewBox, pdata1)) {
                  return LOG_RTERR (pctxt, RTERR_NOMEM);
               }
            }
            break;

         case 4: /* width */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->width);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.widthPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Contour_polygon");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Contour_polygon");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Contour_path_recreate_on_edit                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Contour_path_recreate_on_edit (OSCTXT* pctxt, 
   Ns3_Contour_path_recreate_on_edit *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Contour_path_recreate_on_edit (OSCTXT* pctxt, 
   Ns3_Contour_path_recreate_on_edit* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Contour_path_recreate_on_edit_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Contour_path                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Contour_path (OSCTXT* pctxt, Ns3_Contour_path *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode recreate_on_edit */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Contour_path_recreate_on_edit (pctxt, 
               &pvalue->recreate_on_edit, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode d */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_D (pctxt, 
               (D*)&pvalue->d, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode height */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->height, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.heightPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode viewBox */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_ViewBox (pctxt, 
               (ViewBox*)&pvalue->viewBox, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode width */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->width, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.widthPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Contour_path (OSCTXT* pctxt, Ns3_Contour_path* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("recreate-on-edit"), 16}, 0 },
         { {OSUTF8("d"), 1}, 0 },
         { {OSUTF8("height"), 6}, 0 },
         { {OSUTF8("viewBox"), 7}, 0 },
         { {OSUTF8("width"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* recreate-on-edit */
            stat = XmlDec_Ns3_Contour_path_recreate_on_edit (pctxt, &pvalue->
               recreate_on_edit);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* d */
            stat = XmlDec_D (pctxt, &pvalue->d);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* height */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->height);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.heightPresent = TRUE;
            break;

         case 3: /* viewBox */
            rtxDListInit (&pvalue->viewBox);
            rtXmlpSetListMode (pctxt);

            while (rtXmlpListHasItem(pctxt)) {
               ViewBox_element* pdata1 = rtxMemAllocType (pctxt, 
                  ViewBox_element);
               if (0 == pdata1) LOG_RTERR (pctxt, RTERR_NOMEM);

               stat = XmlDec_ViewBox_element (pctxt, pdata1);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               if (0 == rtxDListAppend (pctxt, &pvalue->viewBox, pdata1)) {
                  return LOG_RTERR (pctxt, RTERR_NOMEM);
               }
            }
            break;

         case 4: /* width */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->width);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.widthPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Contour_path");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Contour_path");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Frame_choice_1                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Frame_choice_1 (OSCTXT* pctxt, 
   Ns3_Frame_choice_1 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.contour_polygon
             = rtxMemAllocType (pctxt, Ns3_Contour_polygon);

         if (pvalue->u.contour_polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Contour_polygon (pvalue->u.contour_polygon);
         stat = asn1D_Ns3_Contour_polygon (pctxt, 
            pvalue->u.contour_polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.contour_path = rtxMemAllocType (pctxt, Ns3_Contour_path);

         if (pvalue->u.contour_path == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Contour_path (pvalue->u.contour_path);
         stat = asn1D_Ns3_Contour_path (pctxt, 
            pvalue->u.contour_path, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Frame_choice_1 (OSCTXT* pctxt, Ns3_Frame_choice_1* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("contour-polygon"), 15}, 0}, 0 },
      {{{OSUTF8("contour-path"), 12}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* contour-polygon */
      pvalue->u.contour_polygon
          = rtxMemAllocType (pctxt, Ns3_Contour_polygon);

      if (pvalue->u.contour_polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Contour_polygon (pvalue->u.contour_polygon);

      stat = XmlDec_Ns3_Contour_polygon (pctxt, pvalue->u.contour_polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* contour-path */
      pvalue->u.contour_path = rtxMemAllocType (pctxt, Ns3_Contour_path);

      if (pvalue->u.contour_path == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Contour_path (pvalue->u.contour_path);

      stat = XmlDec_Ns3_Contour_path (pctxt, pvalue->u.contour_path);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Frame                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Frame (OSCTXT* pctxt, Ns3_Frame *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode class_names */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_namesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode copy_of */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->copy_of, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.copy_ofPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Id (pctxt, 
               &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode layer */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Layer_1 (pctxt, 
               &pvalue->layer, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.layerPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode text_style_name */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Text_style_name (pctxt, 
               &pvalue->text_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.text_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode transform */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Transform (pctxt, 
               &pvalue->transform, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.transformPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode z_index */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Z_index (pctxt, 
               &pvalue->z_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.z_indexPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode class_ */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns10_Class (pctxt, 
               (Ns10_Class*)&pvalue->class_, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_Present = TRUE;
            }
         }
         break;

      case 10:
         /* decode class_names_1 */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Class_names (pctxt, 
               &pvalue->class_names_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_names_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 11:
         /* decode placeholder */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns10_Placeholder_1 (pctxt, 
               (Ns10_Placeholder_1*)&pvalue->placeholder, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.placeholderPresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode style_name_1 */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_name_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 13:
         /* decode user_transformed */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns10_User_transformed (pctxt, 
               (Ns10_User_transformed*)&pvalue->user_transformed, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.user_transformedPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode rel_height */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->rel_height = rtxMemAllocType (pctxt, Ns8_Rel_height);

            if (pvalue->rel_height == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Rel_height ((Ns8_Rel_height*)pvalue->rel_height);
            asn1Init_Ns8_Rel_height ((Ns8_Rel_height*)pvalue->rel_height);

            stat = asn1D_Ns8_Rel_height (pctxt, 
               (Ns8_Rel_height*)pvalue->rel_height, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.rel_heightPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 15:
         /* decode rel_width */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->rel_width = rtxMemAllocType (pctxt, Ns8_Rel_width);

            if (pvalue->rel_width == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Rel_width ((Ns8_Rel_width*)pvalue->rel_width);
            asn1Init_Ns8_Rel_width ((Ns8_Rel_width*)pvalue->rel_width);

            stat = asn1D_Ns8_Rel_width (pctxt, 
               (Ns8_Rel_width*)pvalue->rel_width, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.rel_widthPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 16:
         /* decode height */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->height, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.heightPresent = TRUE;
            }
         }
         break;

      case 17:
         /* decode width */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->width, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.widthPresent = TRUE;
            }
         }
         break;

      case 18:
         /* decode x */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.xPresent = TRUE;
            }
         }
         break;

      case 19:
         /* decode y */
         if (XD_PEEKTAG (pctxt, 0x93)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.yPresent = TRUE;
            }
         }
         break;

      case 20:
         /* decode end_cell_address */
         if (XD_PEEKTAG (pctxt, 0x94)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_cell_address (pctxt, 
               (End_cell_address*)&pvalue->end_cell_address, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_cell_addressPresent = TRUE;
            }
         }
         break;

      case 21:
         /* decode end_x */
         if (XD_PEEKTAG (pctxt, 0x95)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_x (pctxt, 
               (End_x*)&pvalue->end_x, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_xPresent = TRUE;
            }
         }
         break;

      case 22:
         /* decode end_y */
         if (XD_PEEKTAG (pctxt, 0x96)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_End_y (pctxt, 
               (End_y*)&pvalue->end_y, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.end_yPresent = TRUE;
            }
         }
         break;

      case 23:
         /* decode table_background */
         if (XD_PEEKTAG (pctxt, 0x97)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Table_background (pctxt, 
               (Table_background*)&pvalue->table_background, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.table_backgroundPresent = TRUE;
            }
         }
         break;

      case 24:
         /* decode anchor_page_number */
         if (XD_PEEKTAG (pctxt, 0x98)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_page_number (pctxt, 
               (Odf_Anchor_page_number*)&pvalue->anchor_page_number, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_page_numberPresent = TRUE;
            }
         }
         break;

      case 25:
         /* decode anchor_type */
         if (XD_PEEKTAG (pctxt, 0x99)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Odf_Anchor_type (pctxt, 
               (Odf_Anchor_type*)&pvalue->anchor_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.anchor_typePresent = TRUE;
            }
         }
         break;

      case 26:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x9a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Frame_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Frame_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Frame_element (pdata2);

                  stat = asn1D_Ns3_Frame_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 27:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x9b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 28:
         /* decode glue_point_list */
         if (XD_PEEKTAG (pctxt, 0x9c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Glue_point* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->glue_point_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Glue_point, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Glue_point (pdata2);

                  stat = asn1D_Ns3_Glue_point (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->glue_point_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 29:
         /* decode image_map */
         if (XD_PEEKTAG (pctxt, 0x9d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Image_map (pctxt, 
               &pvalue->image_map, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.image_mapPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 30:
         /* decode desc */
         if (XD_PEEKTAG (pctxt, 0x9e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Desc (pctxt, 
               (Desc*)&pvalue->desc, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descPresent = TRUE;
            }
         }
         break;

      case 31:
         /* decode choice_1 */
         if ((stat = xd_match (pctxt, TM_CTXT|TM_CONS|31, &length, XM_ADVANCE)) == 0) {
            stat = asn1D_Ns3_Frame_choice_1 (pctxt, 
               &pvalue->choice_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choice_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         else if (stat == RTERR_IDNOTFOU) {
            stat = rtxErrReset (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_PRIM|16):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_PRIM|17):
         case (TM_CTXT|TM_CONS|17):
         case (TM_CTXT|TM_PRIM|18):
         case (TM_CTXT|TM_CONS|18):
         case (TM_CTXT|TM_PRIM|19):
         case (TM_CTXT|TM_CONS|19):
         case (TM_CTXT|TM_PRIM|20):
         case (TM_CTXT|TM_CONS|20):
         case (TM_CTXT|TM_PRIM|21):
         case (TM_CTXT|TM_CONS|21):
         case (TM_CTXT|TM_PRIM|22):
         case (TM_CTXT|TM_CONS|22):
         case (TM_CTXT|TM_PRIM|23):
         case (TM_CTXT|TM_PRIM|24):
         case (TM_CTXT|TM_PRIM|25):
         case (TM_CTXT|TM_CONS|26):
         case (TM_CTXT|TM_CONS|27):
         case (TM_CTXT|TM_CONS|28):
         case (TM_CTXT|TM_CONS|29):
         case (TM_CTXT|TM_PRIM|30):
         case (TM_CTXT|TM_CONS|30):
         case (TM_CTXT|TM_CONS|31):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Frame (OSCTXT* pctxt, Ns3_Frame* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("copy-of"), 7}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("layer"), 5}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("text-style-name"), 15}, 0 },
         { {OSUTF8("transform"), 9}, 0 },
         { {OSUTF8("z-index"), 7}, 0 },
         { {OSUTF8("class"), 5}, 0 },
         { {OSUTF8("class-names"), 11}, 0 },
         { {OSUTF8("placeholder"), 11}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("user-transformed"), 16}, 0 },
         { {OSUTF8("rel-height"), 10}, 0 },
         { {OSUTF8("rel-width"), 9}, 0 },
         { {OSUTF8("height"), 6}, 0 },
         { {OSUTF8("width"), 5}, 0 },
         { {OSUTF8("x"), 1}, 0 },
         { {OSUTF8("y"), 1}, 0 },
         { {OSUTF8("end-cell-address"), 16}, 0 },
         { {OSUTF8("end-x"), 5}, 0 },
         { {OSUTF8("end-y"), 5}, 0 },
         { {OSUTF8("table-background"), 16}, 0 },
         { {OSUTF8("anchor-page-number"), 18}, 0 },
         { {OSUTF8("anchor-type"), 11}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 26, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* class-names */
            rtxDListInit (&pvalue->class_names);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_namesPresent = TRUE;
            break;

         case 1: /* copy-of */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->copy_of);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.copy_ofPresent = TRUE;
            break;

         case 2: /* id */
            stat = XmlDec_Ns3_Id (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 3: /* layer */
            stat = XmlDec_Ns3_Layer_1 (pctxt, &pvalue->layer);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.layerPresent = TRUE;
            break;

         case 4: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 5: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         case 6: /* text-style-name */
            stat = XmlDec_Ns3_Text_style_name (pctxt, &pvalue->text_style_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.text_style_namePresent = TRUE;
            break;

         case 7: /* transform */
            stat = XmlDec_Ns3_Transform (pctxt, &pvalue->transform);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.transformPresent = TRUE;
            break;

         case 8: /* z-index */
            stat = XmlDec_Ns3_Z_index (pctxt, &pvalue->z_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.z_indexPresent = TRUE;
            break;

         case 9: /* class */
            stat = XmlDec_Ns10_Class (pctxt, &pvalue->class_);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_Present = TRUE;
            break;

         case 10: /* class-names */
            rtxDListInit (&pvalue->class_names_1);

            stat = rtXmlpDecStrList (pctxt, &pvalue->class_names_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_names_1Present = TRUE;
            break;

         case 11: /* placeholder */
            stat = XmlDec_Ns10_Placeholder_1 (pctxt, &pvalue->placeholder);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.placeholderPresent = TRUE;
            break;

         case 12: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name_1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_name_1Present = TRUE;
            break;

         case 13: /* user-transformed */
            stat = XmlDec_Ns10_User_transformed (pctxt, &pvalue->
               user_transformed);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.user_transformedPresent = TRUE;
            break;

         case 14: /* rel-height */
            pvalue->rel_height = rtxMemAllocType (pctxt, Ns8_Rel_height);

            if (pvalue->rel_height == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Rel_height ((Ns8_Rel_height*)pvalue->rel_height);

            stat = XmlDec_Ns8_Rel_height (pctxt, pvalue->rel_height);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.rel_heightPresent = TRUE;
            break;

         case 15: /* rel-width */
            pvalue->rel_width = rtxMemAllocType (pctxt, Ns8_Rel_width);

            if (pvalue->rel_width == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns8_Rel_width ((Ns8_Rel_width*)pvalue->rel_width);

            stat = XmlDec_Ns8_Rel_width (pctxt, pvalue->rel_width);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.rel_widthPresent = TRUE;
            break;

         case 16: /* height */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->height);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.heightPresent = TRUE;
            break;

         case 17: /* width */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->width);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.widthPresent = TRUE;
            break;

         case 18: /* x */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.xPresent = TRUE;
            break;

         case 19: /* y */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.yPresent = TRUE;
            break;

         case 20: /* end-cell-address */
            stat = XmlDec_End_cell_address (pctxt, &pvalue->end_cell_address);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_cell_addressPresent = TRUE;
            break;

         case 21: /* end-x */
            stat = XmlDec_End_x (pctxt, &pvalue->end_x);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_xPresent = TRUE;
            break;

         case 22: /* end-y */
            stat = XmlDec_End_y (pctxt, &pvalue->end_y);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.end_yPresent = TRUE;
            break;

         case 23: /* table-background */
            stat = XmlDec_Table_background (pctxt, &pvalue->table_background);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.table_backgroundPresent = TRUE;
            break;

         case 24: /* anchor-page-number */
            stat = XmlDec_Odf_Anchor_page_number (pctxt, &pvalue->
               anchor_page_number);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_page_numberPresent = TRUE;
            break;

         case 25: /* anchor-type */
            stat = XmlDec_Odf_Anchor_type (pctxt, &pvalue->anchor_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.anchor_typePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Frame");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Frame");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("text-box"), 8}, 0}, 0 },
      {{{OSUTF8("image"), 5}, 0}, 0 },
      {{{OSUTF8("object"), 6}, 0}, 0 },
      {{{OSUTF8("object-ole"), 10}, 0}, 0 },
      {{{OSUTF8("applet"), 6}, 0}, 0 },
      {{{OSUTF8("floating-frame"), 14}, 0}, 0 },
      {{{OSUTF8("plugin"), 6}, 0}, 0 },
      {{{OSUTF8("event-listeners"), 15}, 0}, 1 },
      {{{OSUTF8("glue-point"), 10}, 0}, 2 },
      {{{OSUTF8("image-map"), 9}, 0}, 3 },
      {{{OSUTF8("desc"), 4}, 0}, 4 },
      {{{OSUTF8("contour-polygon"), 15}, 0}, 5 },
      {{{OSUTF8("contour-path"), 12}, 0}, 5 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 13, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 6; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Ns3_Frame_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Frame_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Frame_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns3_Frame_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 7, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 1: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      case 2: {
         Ns3_Glue_point* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Glue_point);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Glue_point (pdata1);

            stat = XmlDec_Ns3_Glue_point (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->glue_point_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 8, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 3: { /* image-map */
         stat = XmlDec_Ns3_Image_map (pctxt, &pvalue->image_map);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.image_mapPresent = TRUE;
         break;
      }
      case 4: { /* desc */
         stat = XmlDec_Desc (pctxt, &pvalue->desc);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.descPresent = TRUE;
         break;
      }
      case 5: { /*  */
         stat = XmlDec_Ns3_Frame_choice_1 (pctxt, &pvalue->choice_1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choice_1Present = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Layer_display                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Layer_display (OSCTXT* pctxt, Ns3_Layer_display *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Layer_display (OSCTXT* pctxt, Ns3_Layer_display* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Layer_display_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Layer_protected_                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Layer_protected_ (OSCTXT* pctxt, 
   Ns3_Layer_protected_ *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Layer_protected_ (OSCTXT* pctxt, Ns3_Layer_protected_* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Layer_protected__ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Layer                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Layer (OSCTXT* pctxt, Ns3_Layer *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode display */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Layer_display (pctxt, 
               &pvalue->display, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.displayPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode protected_ */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Layer_protected_ (pctxt, 
               &pvalue->protected_, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.protected_Present = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Layer (OSCTXT* pctxt, Ns3_Layer* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("display"), 7}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("protected"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 3, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* display */
            stat = XmlDec_Ns3_Layer_display (pctxt, &pvalue->display);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.displayPresent = TRUE;
            break;

         case 1: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* protected */
            stat = XmlDec_Ns3_Layer_protected_ (pctxt, &pvalue->protected_);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.protected_Present = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Layer");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Layer");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Layer_set                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Layer_set (OSCTXT* pctxt, Ns3_Layer_set *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode layer_list */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Layer* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->layer_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Layer, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Layer (pdata2);

                  stat = asn1D_Ns3_Layer (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->layer_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Layer_set (OSCTXT* pctxt, Ns3_Layer_set* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("layer"), 5}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Ns3_Layer* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Layer);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Layer (pdata1);

            stat = XmlDec_Ns3_Layer (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->layer_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Page_master_page_name                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Page_master_page_name (OSCTXT* pctxt, 
   Ns3_Page_master_page_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Page_master_page_name (OSCTXT* pctxt, 
   Ns3_Page_master_page_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Page_element                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Page_element (OSCTXT* pctxt, Ns3_Page_element *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

         if (pvalue->u.rect == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Rect (pvalue->u.rect);
         stat = asn1D_Ns3_Rect (pctxt, 
            pvalue->u.rect, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

         if (pvalue->u.line == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Line (pvalue->u.line);
         stat = asn1D_Ns3_Line (pctxt, 
            pvalue->u.line, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

         if (pvalue->u.polyline == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polyline (pvalue->u.polyline);
         stat = asn1D_Ns3_Polyline (pctxt, 
            pvalue->u.polyline, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

         if (pvalue->u.polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polygon (pvalue->u.polygon);
         stat = asn1D_Ns3_Polygon (pctxt, 
            pvalue->u.polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.regular_polygon
             = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

         if (pvalue->u.regular_polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Regular_polygon (pvalue->u.regular_polygon);
         stat = asn1D_Ns3_Regular_polygon (pctxt, 
            pvalue->u.regular_polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

         if (pvalue->u.path == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Path (pvalue->u.path);
         stat = asn1D_Ns3_Path (pctxt, 
            pvalue->u.path, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

         if (pvalue->u.circle == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Circle (pvalue->u.circle);
         stat = asn1D_Ns3_Circle (pctxt, 
            pvalue->u.circle, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

         if (pvalue->u.ellipse == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Ellipse (pvalue->u.ellipse);
         stat = asn1D_Ns3_Ellipse (pctxt, 
            pvalue->u.ellipse, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

         if (pvalue->u.g == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_G (pvalue->u.g);
         stat = asn1D_Ns3_G (pctxt, 
            pvalue->u.g, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.page_thumbnail
             = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

         if (pvalue->u.page_thumbnail == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Page_thumbnail (pvalue->u.page_thumbnail);
         stat = asn1D_Ns3_Page_thumbnail (pctxt, 
            pvalue->u.page_thumbnail, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

         if (pvalue->u.frame == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Frame (pvalue->u.frame);
         stat = asn1D_Ns3_Frame (pctxt, 
            pvalue->u.frame, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

         if (pvalue->u.measure == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Measure (pvalue->u.measure);
         stat = asn1D_Ns3_Measure (pctxt, 
            pvalue->u.measure, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

         if (pvalue->u.caption == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Caption (pvalue->u.caption);
         stat = asn1D_Ns3_Caption (pctxt, 
            pvalue->u.caption, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

         if (pvalue->u.connector == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Connector (pvalue->u.connector);
         stat = asn1D_Ns3_Connector (pctxt, 
            pvalue->u.connector, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

         if (pvalue->u.control == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Control (pvalue->u.control);
         stat = asn1D_Ns3_Control (pctxt, 
            pvalue->u.control, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

         if (pvalue->u.scene == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);
         stat = asn1D_Ns7_Scene (pctxt, 
            (Ns7_Scene*)pvalue->u.scene, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

         if (pvalue->u.custom_shape == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Custom_shape (pvalue->u.custom_shape);
         stat = asn1D_Ns3_Custom_shape (pctxt, 
            pvalue->u.custom_shape, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Page_element (OSCTXT* pctxt, Ns3_Page_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("rect"), 4}, 0}, 0 },
      {{{OSUTF8("line"), 4}, 0}, 1 },
      {{{OSUTF8("polyline"), 8}, 0}, 2 },
      {{{OSUTF8("polygon"), 7}, 0}, 3 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 4 },
      {{{OSUTF8("path"), 4}, 0}, 5 },
      {{{OSUTF8("circle"), 6}, 0}, 6 },
      {{{OSUTF8("ellipse"), 7}, 0}, 7 },
      {{{OSUTF8("g"), 1}, 0}, 8 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 9 },
      {{{OSUTF8("frame"), 5}, 0}, 10 },
      {{{OSUTF8("measure"), 7}, 0}, 11 },
      {{{OSUTF8("caption"), 7}, 0}, 12 },
      {{{OSUTF8("connector"), 9}, 0}, 13 },
      {{{OSUTF8("control"), 7}, 0}, 14 },
      {{{OSUTF8("scene"), 5}, 0}, 15 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 16 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 17, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* rect */
      pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

      if (pvalue->u.rect == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Rect (pvalue->u.rect);

      stat = XmlDec_Ns3_Rect (pctxt, pvalue->u.rect);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* line */
      pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

      if (pvalue->u.line == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Line (pvalue->u.line);

      stat = XmlDec_Ns3_Line (pctxt, pvalue->u.line);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* polyline */
      pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

      if (pvalue->u.polyline == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polyline (pvalue->u.polyline);

      stat = XmlDec_Ns3_Polyline (pctxt, pvalue->u.polyline);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* polygon */
      pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

      if (pvalue->u.polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polygon (pvalue->u.polygon);

      stat = XmlDec_Ns3_Polygon (pctxt, pvalue->u.polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* regular-polygon */
      pvalue->u.regular_polygon
          = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

      if (pvalue->u.regular_polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Regular_polygon (pvalue->u.regular_polygon);

      stat = XmlDec_Ns3_Regular_polygon (pctxt, pvalue->u.regular_polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* path */
      pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

      if (pvalue->u.path == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Path (pvalue->u.path);

      stat = XmlDec_Ns3_Path (pctxt, pvalue->u.path);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* circle */
      pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

      if (pvalue->u.circle == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Circle (pvalue->u.circle);

      stat = XmlDec_Ns3_Circle (pctxt, pvalue->u.circle);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* ellipse */
      pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

      if (pvalue->u.ellipse == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Ellipse (pvalue->u.ellipse);

      stat = XmlDec_Ns3_Ellipse (pctxt, pvalue->u.ellipse);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* g */
      pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

      if (pvalue->u.g == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_G (pvalue->u.g);

      stat = XmlDec_Ns3_G (pctxt, pvalue->u.g);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* page-thumbnail */
      pvalue->u.page_thumbnail = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

      if (pvalue->u.page_thumbnail == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Page_thumbnail (pvalue->u.page_thumbnail);

      stat = XmlDec_Ns3_Page_thumbnail (pctxt, pvalue->u.page_thumbnail);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* frame */
      pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

      if (pvalue->u.frame == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Frame (pvalue->u.frame);

      stat = XmlDec_Ns3_Frame (pctxt, pvalue->u.frame);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* measure */
      pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

      if (pvalue->u.measure == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Measure (pvalue->u.measure);

      stat = XmlDec_Ns3_Measure (pctxt, pvalue->u.measure);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* caption */
      pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

      if (pvalue->u.caption == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Caption (pvalue->u.caption);

      stat = XmlDec_Ns3_Caption (pctxt, pvalue->u.caption);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* connector */
      pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

      if (pvalue->u.connector == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Connector (pvalue->u.connector);

      stat = XmlDec_Ns3_Connector (pctxt, pvalue->u.connector);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* control */
      pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

      if (pvalue->u.control == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Control (pvalue->u.control);

      stat = XmlDec_Ns3_Control (pctxt, pvalue->u.control);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* scene */
      pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

      if (pvalue->u.scene == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);

      stat = XmlDec_Ns7_Scene (pctxt, pvalue->u.scene);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* custom-shape */
      pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

      if (pvalue->u.custom_shape == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Custom_shape (pvalue->u.custom_shape);

      stat = XmlDec_Ns3_Custom_shape (pctxt, pvalue->u.custom_shape);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Shape_id                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Shape_id (OSCTXT* pctxt, Ns3_Shape_id *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Shape_id (OSCTXT* pctxt, Ns3_Shape_id* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Page_choice_1                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Page_choice_1 (OSCTXT* pctxt, Ns3_Page_choice_1 *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.animations = rtxMemAllocType (pctxt, Ns10_Animations);

         if (pvalue->u.animations == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns10_Animations ((Ns10_Animations*)pvalue->u.animations);
         stat = asn1D_Ns10_Animations (pctxt, 
            (Ns10_Animations*)pvalue->u.animations, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.animate = rtxMemAllocType (pctxt, Animate);

         if (pvalue->u.animate == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Animate ((Animate*)pvalue->u.animate);
         stat = asn1D_Animate (pctxt, 
            (Animate*)pvalue->u.animate, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.set = rtxMemAllocType (pctxt, Set);

         if (pvalue->u.set == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Set ((Set*)pvalue->u.set);
         stat = asn1D_Set (pctxt, 
            (Set*)pvalue->u.set, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.animateMotion = rtxMemAllocType (pctxt, AnimateMotion);

         if (pvalue->u.animateMotion == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AnimateMotion ((AnimateMotion*)pvalue->u.animateMotion);
         stat = asn1D_AnimateMotion (pctxt, 
            (AnimateMotion*)pvalue->u.animateMotion, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.animateColor = rtxMemAllocType (pctxt, AnimateColor);

         if (pvalue->u.animateColor == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AnimateColor ((AnimateColor*)pvalue->u.animateColor);
         stat = asn1D_AnimateColor (pctxt, 
            (AnimateColor*)pvalue->u.animateColor, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.animateTransform
             = rtxMemAllocType (pctxt, AnimateTransform);

         if (pvalue->u.animateTransform == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AnimateTransform ((AnimateTransform*)pvalue->u.animateTransform);
         stat = asn1D_AnimateTransform (pctxt, 
            (AnimateTransform*)pvalue->u.animateTransform, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.transitionFilter
             = rtxMemAllocType (pctxt, TransitionFilter);

         if (pvalue->u.transitionFilter == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TransitionFilter ((TransitionFilter*)pvalue->u.transitionFilter);
         stat = asn1D_TransitionFilter (pctxt, 
            (TransitionFilter*)pvalue->u.transitionFilter, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.par = rtxMemAllocType (pctxt, Par);

         if (pvalue->u.par == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Par ((Par*)pvalue->u.par);
         stat = asn1D_Par (pctxt, 
            (Par*)pvalue->u.par, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.seq = rtxMemAllocType (pctxt, Seq);

         if (pvalue->u.seq == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Seq ((Seq*)pvalue->u.seq);
         stat = asn1D_Seq (pctxt, 
            (Seq*)pvalue->u.seq, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.iterate = rtxMemAllocType (pctxt, Iterate);

         if (pvalue->u.iterate == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Iterate ((Iterate*)pvalue->u.iterate);
         stat = asn1D_Iterate (pctxt, 
            (Iterate*)pvalue->u.iterate, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.audio = rtxMemAllocType (pctxt, Audio);

         if (pvalue->u.audio == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Audio ((Audio*)pvalue->u.audio);
         stat = asn1D_Audio (pctxt, 
            (Audio*)pvalue->u.audio, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.command = rtxMemAllocType (pctxt, Command);

         if (pvalue->u.command == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Command ((Command*)pvalue->u.command);
         stat = asn1D_Command (pctxt, 
            (Command*)pvalue->u.command, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Page_choice_1 (OSCTXT* pctxt, Ns3_Page_choice_1* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("animations"), 10}, 0}, 0 },
      {{{OSUTF8("animate"), 7}, 0}, 1 },
      {{{OSUTF8("set"), 3}, 0}, 2 },
      {{{OSUTF8("animateMotion"), 13}, 0}, 3 },
      {{{OSUTF8("animateColor"), 12}, 0}, 4 },
      {{{OSUTF8("animateTransform"), 16}, 0}, 5 },
      {{{OSUTF8("transitionFilter"), 16}, 0}, 6 },
      {{{OSUTF8("par"), 3}, 0}, 7 },
      {{{OSUTF8("seq"), 3}, 0}, 8 },
      {{{OSUTF8("iterate"), 7}, 0}, 9 },
      {{{OSUTF8("audio"), 5}, 0}, 10 },
      {{{OSUTF8("command"), 7}, 0}, 11 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 12, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* animations */
      pvalue->u.animations = rtxMemAllocType (pctxt, Ns10_Animations);

      if (pvalue->u.animations == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns10_Animations ((Ns10_Animations*)pvalue->u.animations);

      stat = XmlDec_Ns10_Animations (pctxt, pvalue->u.animations);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* animate */
      pvalue->u.animate = rtxMemAllocType (pctxt, Animate);

      if (pvalue->u.animate == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Animate ((Animate*)pvalue->u.animate);

      stat = XmlDec_Animate (pctxt, pvalue->u.animate);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* set */
      pvalue->u.set = rtxMemAllocType (pctxt, Set);

      if (pvalue->u.set == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Set ((Set*)pvalue->u.set);

      stat = XmlDec_Set (pctxt, pvalue->u.set);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* animateMotion */
      pvalue->u.animateMotion = rtxMemAllocType (pctxt, AnimateMotion);

      if (pvalue->u.animateMotion == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AnimateMotion ((AnimateMotion*)pvalue->u.animateMotion);

      stat = XmlDec_AnimateMotion (pctxt, pvalue->u.animateMotion);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* animateColor */
      pvalue->u.animateColor = rtxMemAllocType (pctxt, AnimateColor);

      if (pvalue->u.animateColor == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AnimateColor ((AnimateColor*)pvalue->u.animateColor);

      stat = XmlDec_AnimateColor (pctxt, pvalue->u.animateColor);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* animateTransform */
      pvalue->u.animateTransform = rtxMemAllocType (pctxt, AnimateTransform);

      if (pvalue->u.animateTransform == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AnimateTransform ((AnimateTransform*)pvalue->u.animateTransform
         );

      stat = XmlDec_AnimateTransform (pctxt, pvalue->u.animateTransform);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* transitionFilter */
      pvalue->u.transitionFilter = rtxMemAllocType (pctxt, TransitionFilter);

      if (pvalue->u.transitionFilter == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TransitionFilter ((TransitionFilter*)pvalue->u.transitionFilter
         );

      stat = XmlDec_TransitionFilter (pctxt, pvalue->u.transitionFilter);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* par */
      pvalue->u.par = rtxMemAllocType (pctxt, Par);

      if (pvalue->u.par == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Par ((Par*)pvalue->u.par);

      stat = XmlDec_Par (pctxt, pvalue->u.par);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* seq */
      pvalue->u.seq = rtxMemAllocType (pctxt, Seq);

      if (pvalue->u.seq == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Seq ((Seq*)pvalue->u.seq);

      stat = XmlDec_Seq (pctxt, pvalue->u.seq);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* iterate */
      pvalue->u.iterate = rtxMemAllocType (pctxt, Iterate);

      if (pvalue->u.iterate == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Iterate ((Iterate*)pvalue->u.iterate);

      stat = XmlDec_Iterate (pctxt, pvalue->u.iterate);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* audio */
      pvalue->u.audio = rtxMemAllocType (pctxt, Audio);

      if (pvalue->u.audio == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Audio ((Audio*)pvalue->u.audio);

      stat = XmlDec_Audio (pctxt, pvalue->u.audio);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* command */
      pvalue->u.command = rtxMemAllocType (pctxt, Command);

      if (pvalue->u.command == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Command ((Command*)pvalue->u.command);

      stat = XmlDec_Command (pctxt, pvalue->u.command);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Page                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Page (OSCTXT* pctxt, Ns3_Page *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Id (pctxt, 
               &pvalue->id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode master_page_name */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Page_master_page_name (pctxt, 
               &pvalue->master_page_name, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode style_name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Style_name (pctxt, 
               &pvalue->style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode presentation_page_layout_name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->presentation_page_layout_name
                = rtxMemAllocType (pctxt, Ns10_Presentation_page_layout_name);

            if (pvalue->presentation_page_layout_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns10_Presentation_page_layout_name ((Ns10_Presentation_page_layout_name*)pvalue->presentation_page_layout_name);
            asn1Init_Ns10_Presentation_page_layout_name ((Ns10_Presentation_page_layout_name*)pvalue->presentation_page_layout_name);

            stat = asn1D_Ns10_Presentation_page_layout_name (pctxt, 
               (Ns10_Presentation_page_layout_name*)pvalue->presentation_page_layout_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.presentation_page_layout_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode use_date_time_name */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns10_Use_date_time_name (pctxt, 
               (Ns10_Use_date_time_name*)&pvalue->use_date_time_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.use_date_time_namePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode use_footer_name */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns10_Use_footer_name (pctxt, 
               (Ns10_Use_footer_name*)&pvalue->use_footer_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.use_footer_namePresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode use_header_name */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns10_Use_header_name (pctxt, 
               (Ns10_Use_header_name*)&pvalue->use_header_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.use_header_namePresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode forms */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->forms = rtxMemAllocType (pctxt, Ns13_Forms);

            if (pvalue->forms == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Forms ((Ns13_Forms*)pvalue->forms);
            asn1Init_Ns13_Forms ((Ns13_Forms*)pvalue->forms);

            stat = asn1D_Ns13_Forms (pctxt, 
               (Ns13_Forms*)pvalue->forms, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.formsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Page_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Page_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Page_element (pdata2);

                  stat = asn1D_Ns3_Page_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 10:
         /* decode choice_1 */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Page_choice_1 (pctxt, 
               &pvalue->choice_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choice_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 11:
         /* decode notes */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->notes = rtxMemAllocType (pctxt, Ns10_Notes);

            if (pvalue->notes == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns10_Notes ((Ns10_Notes*)pvalue->notes);
            asn1Init_Ns10_Notes ((Ns10_Notes*)pvalue->notes);

            stat = asn1D_Ns10_Notes (pctxt, 
               (Ns10_Notes*)pvalue->notes, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.notesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_CONS|11):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Page (OSCTXT* pctxt, Ns3_Page* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("master-page-name"), 16}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("style-name"), 10}, 0 },
         { {OSUTF8("presentation-page-layout-name"), 29}, 0 },
         { {OSUTF8("use-date-time-name"), 18}, 0 },
         { {OSUTF8("use-footer-name"), 15}, 0 },
         { {OSUTF8("use-header-name"), 15}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 8, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* id */
            stat = XmlDec_Ns3_Id (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.idPresent = TRUE;
            break;

         case 1: /* master-page-name */
            stat = XmlDec_Ns3_Page_master_page_name (pctxt, &pvalue->
               master_page_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 3: /* style-name */
            stat = XmlDec_Ns3_Style_name (pctxt, &pvalue->style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.style_namePresent = TRUE;
            break;

         case 4: /* presentation-page-layout-name */
            pvalue->presentation_page_layout_name
                = rtxMemAllocType (pctxt, Ns10_Presentation_page_layout_name);

            if (pvalue->presentation_page_layout_name == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns10_Presentation_page_layout_name (
               (Ns10_Presentation_page_layout_name*)pvalue->
               presentation_page_layout_name);

            stat = XmlDec_Ns10_Presentation_page_layout_name (pctxt, pvalue->
               presentation_page_layout_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.presentation_page_layout_namePresent = TRUE;
            break;

         case 5: /* use-date-time-name */
            stat = XmlDec_Ns10_Use_date_time_name (pctxt, &pvalue->
               use_date_time_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.use_date_time_namePresent = TRUE;
            break;

         case 6: /* use-footer-name */
            stat = XmlDec_Ns10_Use_footer_name (pctxt, &pvalue->use_footer_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.use_footer_namePresent = TRUE;
            break;

         case 7: /* use-header-name */
            stat = XmlDec_Ns10_Use_header_name (pctxt, &pvalue->use_header_name
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.use_header_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Page");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Page");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("forms"), 5}, 0}, 0 },
      {{{OSUTF8("rect"), 4}, 0}, 1 },
      {{{OSUTF8("line"), 4}, 0}, 1 },
      {{{OSUTF8("polyline"), 8}, 0}, 1 },
      {{{OSUTF8("polygon"), 7}, 0}, 1 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 1 },
      {{{OSUTF8("path"), 4}, 0}, 1 },
      {{{OSUTF8("circle"), 6}, 0}, 1 },
      {{{OSUTF8("ellipse"), 7}, 0}, 1 },
      {{{OSUTF8("g"), 1}, 0}, 1 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 1 },
      {{{OSUTF8("frame"), 5}, 0}, 1 },
      {{{OSUTF8("measure"), 7}, 0}, 1 },
      {{{OSUTF8("caption"), 7}, 0}, 1 },
      {{{OSUTF8("connector"), 9}, 0}, 1 },
      {{{OSUTF8("control"), 7}, 0}, 1 },
      {{{OSUTF8("scene"), 5}, 0}, 1 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 1 },
      {{{OSUTF8("animations"), 10}, 0}, 2 },
      {{{OSUTF8("animate"), 7}, 0}, 2 },
      {{{OSUTF8("set"), 3}, 0}, 2 },
      {{{OSUTF8("animateMotion"), 13}, 0}, 2 },
      {{{OSUTF8("animateColor"), 12}, 0}, 2 },
      {{{OSUTF8("animateTransform"), 16}, 0}, 2 },
      {{{OSUTF8("transitionFilter"), 16}, 0}, 2 },
      {{{OSUTF8("par"), 3}, 0}, 2 },
      {{{OSUTF8("seq"), 3}, 0}, 2 },
      {{{OSUTF8("iterate"), 7}, 0}, 2 },
      {{{OSUTF8("audio"), 5}, 0}, 2 },
      {{{OSUTF8("command"), 7}, 0}, 2 },
      {{{OSUTF8("notes"), 5}, 0}, 3 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 31, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 4; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* forms */
         pvalue->forms = rtxMemAllocType (pctxt, Ns13_Forms);

         if (pvalue->forms == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Forms ((Ns13_Forms*)pvalue->forms);

         stat = XmlDec_Ns13_Forms (pctxt, pvalue->forms);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.formsPresent = TRUE;
         break;
      }
      case 1: {
         Ns3_Page_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Page_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Page_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Ns3_Page_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 17, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 2: { /*  */
         stat = XmlDec_Ns3_Page_choice_1 (pctxt, &pvalue->choice_1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choice_1Present = TRUE;
         break;
      }
      case 3: { /* notes */
         pvalue->notes = rtxMemAllocType (pctxt, Ns10_Notes);

         if (pvalue->notes == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns10_Notes ((Ns10_Notes*)pvalue->notes);

         stat = XmlDec_Ns10_Notes (pctxt, pvalue->notes);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.notesPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Object_choice                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Object_choice (OSCTXT* pctxt, Ns3_Object_choice *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.document = rtxMemAllocType (pctxt, Ns13_Document);

         if (pvalue->u.document == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns13_Document ((Ns13_Document*)pvalue->u.document);
         stat = asn1D_Ns13_Document (pctxt, 
            (Ns13_Document*)pvalue->u.document, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.math = rtxMemAllocType (pctxt, Math);

         if (pvalue->u.math == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Math ((Math*)pvalue->u.math);
         stat = asn1D_Math (pctxt, 
            (Math*)pvalue->u.math, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Object_choice (OSCTXT* pctxt, Ns3_Object_choice* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("document"), 8}, 0}, 0 },
      {{{OSUTF8("math"), 4}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* document */
      pvalue->u.document = rtxMemAllocType (pctxt, Ns13_Document);

      if (pvalue->u.document == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns13_Document ((Ns13_Document*)pvalue->u.document);

      stat = XmlDec_Ns13_Document (pctxt, pvalue->u.document);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* math */
      pvalue->u.math = rtxMemAllocType (pctxt, Math);

      if (pvalue->u.math == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Math ((Math*)pvalue->u.math);

      stat = XmlDec_Math (pctxt, pvalue->u.math);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Object                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Object (OSCTXT* pctxt, Ns3_Object *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode actuate */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Object_actuate (pctxt, 
               &pvalue->actuate, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.actuatePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode href */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Href (pctxt, 
               &pvalue->href, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.hrefPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode show */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Object_show (pctxt, 
               &pvalue->show, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.showPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Type (pctxt, 
               &pvalue->type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.typePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode notify_on_update_of_ranges */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->notify_on_update_of_ranges, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.notify_on_update_of_rangesPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Object_choice (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choicePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Object (OSCTXT* pctxt, Ns3_Object* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("actuate"), 7}, 0 },
         { {OSUTF8("href"), 4}, 0 },
         { {OSUTF8("show"), 4}, 0 },
         { {OSUTF8("type"), 4}, 0 },
         { {OSUTF8("notify-on-update-of-ranges"), 26}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* actuate */
            stat = XmlDec_Ns3_Object_actuate (pctxt, &pvalue->actuate);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.actuatePresent = TRUE;
            break;

         case 1: /* href */
            stat = XmlDec_Xlink_Href (pctxt, &pvalue->href);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.hrefPresent = TRUE;
            break;

         case 2: /* show */
            stat = XmlDec_Ns3_Object_show (pctxt, &pvalue->show);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.showPresent = TRUE;
            break;

         case 3: /* type */
            stat = XmlDec_Xlink_Type (pctxt, &pvalue->type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.typePresent = TRUE;
            break;

         case 4: /* notify-on-update-of-ranges */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->
               notify_on_update_of_ranges);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.notify_on_update_of_rangesPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Object");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Object");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("document"), 8}, 0}, 0 },
      {{{OSUTF8("math"), 4}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /*  */
         stat = XmlDec_Ns3_Object_choice (pctxt, &pvalue->choice);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choicePresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Object_ole_actuate                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Object_ole_actuate (OSCTXT* pctxt, 
   Ns3_Object_ole_actuate *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Object_ole_actuate (OSCTXT* pctxt, 
   Ns3_Object_ole_actuate* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Object_ole_actuate_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Object_ole_show                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Object_ole_show (OSCTXT* pctxt, 
   Ns3_Object_ole_show *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Object_ole_show (OSCTXT* pctxt, Ns3_Object_ole_show* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Object_ole_show_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Object_ole                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Object_ole (OSCTXT* pctxt, Ns3_Object_ole *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode actuate */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Object_ole_actuate (pctxt, 
               &pvalue->actuate, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.actuatePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode href */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Href (pctxt, 
               &pvalue->href, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.hrefPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode show */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Object_ole_show (pctxt, 
               &pvalue->show, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.showPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Type (pctxt, 
               &pvalue->type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.typePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode class_id */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->class_id, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.class_idPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode binary_data */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Binary_data (pctxt, 
               (Ns13_Binary_data*)&pvalue->binary_data, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.binary_dataPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Object_ole (OSCTXT* pctxt, Ns3_Object_ole* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("actuate"), 7}, 0 },
         { {OSUTF8("href"), 4}, 0 },
         { {OSUTF8("show"), 4}, 0 },
         { {OSUTF8("type"), 4}, 0 },
         { {OSUTF8("class-id"), 8}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* actuate */
            stat = XmlDec_Ns3_Object_ole_actuate (pctxt, &pvalue->actuate);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.actuatePresent = TRUE;
            break;

         case 1: /* href */
            stat = XmlDec_Xlink_Href (pctxt, &pvalue->href);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.hrefPresent = TRUE;
            break;

         case 2: /* show */
            stat = XmlDec_Ns3_Object_ole_show (pctxt, &pvalue->show);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.showPresent = TRUE;
            break;

         case 3: /* type */
            stat = XmlDec_Xlink_Type (pctxt, &pvalue->type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.typePresent = TRUE;
            break;

         case 4: /* class-id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->class_id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.class_idPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Object_ole");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Object_ole");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("binary-data"), 11}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* binary-data */
         stat = XmlDec_Ns13_Binary_data (pctxt, &pvalue->binary_data);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.binary_dataPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Applet_actuate                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Applet_actuate (OSCTXT* pctxt, 
   Ns3_Applet_actuate *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Applet_actuate (OSCTXT* pctxt, Ns3_Applet_actuate* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Applet_actuate_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Applet_show                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Applet_show (OSCTXT* pctxt, Ns3_Applet_show *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Applet_show (OSCTXT* pctxt, Ns3_Applet_show* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Applet_show_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Applet_may_script                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Applet_may_script (OSCTXT* pctxt, 
   Ns3_Applet_may_script *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Applet_may_script (OSCTXT* pctxt, Ns3_Applet_may_script* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Applet_may_script_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Param                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Param (OSCTXT* pctxt, Ns3_Param *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.valuePresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Param (OSCTXT* pctxt, Ns3_Param* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 1: /* value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.valuePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Param");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Param");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Applet                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Applet (OSCTXT* pctxt, Ns3_Applet *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode actuate */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Applet_actuate (pctxt, 
               &pvalue->actuate, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.actuatePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode href */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Href (pctxt, 
               &pvalue->href, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.hrefPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode show */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Applet_show (pctxt, 
               &pvalue->show, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.showPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Type (pctxt, 
               &pvalue->type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.typePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode archive */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->archive, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.archivePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode code */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->code, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.codePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode may_script */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Applet_may_script (pctxt, 
               &pvalue->may_script, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.may_scriptPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode object */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->object, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.objectPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode param_list */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Param* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->param_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Param, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Param (pdata2);

                  stat = asn1D_Ns3_Param (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->param_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Applet (OSCTXT* pctxt, Ns3_Applet* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("actuate"), 7}, 0 },
         { {OSUTF8("href"), 4}, 0 },
         { {OSUTF8("show"), 4}, 0 },
         { {OSUTF8("type"), 4}, 0 },
         { {OSUTF8("archive"), 7}, 0 },
         { {OSUTF8("code"), 4}, 0 },
         { {OSUTF8("may-script"), 10}, 0 },
         { {OSUTF8("object"), 6}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 8, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* actuate */
            stat = XmlDec_Ns3_Applet_actuate (pctxt, &pvalue->actuate);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.actuatePresent = TRUE;
            break;

         case 1: /* href */
            stat = XmlDec_Xlink_Href (pctxt, &pvalue->href);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.hrefPresent = TRUE;
            break;

         case 2: /* show */
            stat = XmlDec_Ns3_Applet_show (pctxt, &pvalue->show);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.showPresent = TRUE;
            break;

         case 3: /* type */
            stat = XmlDec_Xlink_Type (pctxt, &pvalue->type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.typePresent = TRUE;
            break;

         case 4: /* archive */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->archive);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.archivePresent = TRUE;
            break;

         case 5: /* code */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->code);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.codePresent = TRUE;
            break;

         case 6: /* may-script */
            stat = XmlDec_Ns3_Applet_may_script (pctxt, &pvalue->may_script);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.may_scriptPresent = TRUE;
            break;

         case 7: /* object */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->object);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.objectPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Applet");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Applet");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("param"), 5}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Ns3_Param* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Param);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Param (pdata1);

            stat = XmlDec_Ns3_Param (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->param_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Floating_frame_actuate                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Floating_frame_actuate (OSCTXT* pctxt, 
   Ns3_Floating_frame_actuate *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Floating_frame_actuate (OSCTXT* pctxt, 
   Ns3_Floating_frame_actuate* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Floating_frame_actuate_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Floating_frame_show                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Floating_frame_show (OSCTXT* pctxt, 
   Ns3_Floating_frame_show *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Floating_frame_show (OSCTXT* pctxt, 
   Ns3_Floating_frame_show* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Floating_frame_show_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Floating_frame                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Floating_frame (OSCTXT* pctxt, 
   Ns3_Floating_frame *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode actuate */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Floating_frame_actuate (pctxt, 
               &pvalue->actuate, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.actuatePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode href */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Href (pctxt, 
               &pvalue->href, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode show */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Floating_frame_show (pctxt, 
               &pvalue->show, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.showPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Type (pctxt, 
               &pvalue->type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.typePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode frame_name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->frame_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.frame_namePresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Floating_frame (OSCTXT* pctxt, Ns3_Floating_frame* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("actuate"), 7}, 0 },
         { {OSUTF8("href"), 4}, 0 },
         { {OSUTF8("show"), 4}, 0 },
         { {OSUTF8("type"), 4}, 0 },
         { {OSUTF8("frame-name"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* actuate */
            stat = XmlDec_Ns3_Floating_frame_actuate (pctxt, &pvalue->actuate
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.actuatePresent = TRUE;
            break;

         case 1: /* href */
            stat = XmlDec_Xlink_Href (pctxt, &pvalue->href);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* show */
            stat = XmlDec_Ns3_Floating_frame_show (pctxt, &pvalue->show);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.showPresent = TRUE;
            break;

         case 3: /* type */
            stat = XmlDec_Xlink_Type (pctxt, &pvalue->type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.typePresent = TRUE;
            break;

         case 4: /* frame-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->frame_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.frame_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Floating_frame");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Floating_frame");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Plugin_actuate                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Plugin_actuate (OSCTXT* pctxt, 
   Ns3_Plugin_actuate *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Plugin_actuate (OSCTXT* pctxt, Ns3_Plugin_actuate* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Plugin_actuate_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Plugin_show                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Plugin_show (OSCTXT* pctxt, Ns3_Plugin_show *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Ns3_Plugin_show (OSCTXT* pctxt, Ns3_Plugin_show* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Ns3_Plugin_show_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Plugin                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Plugin (OSCTXT* pctxt, Ns3_Plugin *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode actuate */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Plugin_actuate (pctxt, 
               &pvalue->actuate, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.actuatePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode href */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Href (pctxt, 
               &pvalue->href, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode show */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns3_Plugin_show (pctxt, 
               &pvalue->show, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.showPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Type (pctxt, 
               &pvalue->type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.typePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode mime_type */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->mime_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.mime_typePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode param_list */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Ns3_Param* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->param_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Ns3_Param, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Ns3_Param (pdata2);

                  stat = asn1D_Ns3_Param (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->param_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns3_Plugin (OSCTXT* pctxt, Ns3_Plugin* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("actuate"), 7}, 0 },
         { {OSUTF8("href"), 4}, 0 },
         { {OSUTF8("show"), 4}, 0 },
         { {OSUTF8("type"), 4}, 0 },
         { {OSUTF8("mime-type"), 9}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* actuate */
            stat = XmlDec_Ns3_Plugin_actuate (pctxt, &pvalue->actuate);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.actuatePresent = TRUE;
            break;

         case 1: /* href */
            stat = XmlDec_Xlink_Href (pctxt, &pvalue->href);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 2: /* show */
            stat = XmlDec_Ns3_Plugin_show (pctxt, &pvalue->show);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.showPresent = TRUE;
            break;

         case 3: /* type */
            stat = XmlDec_Xlink_Type (pctxt, &pvalue->type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.typePresent = TRUE;
            break;

         case 4: /* mime-type */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->mime_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.mime_typePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns3_Plugin");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns3_Plugin");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("param"), 5}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Ns3_Param* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Ns3_Param);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns3_Param (pdata1);

            stat = XmlDec_Ns3_Param (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->param_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Frame_element                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_Frame_element (OSCTXT* pctxt, Ns3_Frame_element *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.text_box = rtxMemAllocType (pctxt, Ns3_Text_box);

         if (pvalue->u.text_box == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Text_box (pvalue->u.text_box);
         stat = asn1D_Ns3_Text_box (pctxt, 
            pvalue->u.text_box, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.image = rtxMemAllocType (pctxt, Ns3_Image);

         if (pvalue->u.image == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Image (pvalue->u.image);
         stat = asn1D_Ns3_Image (pctxt, 
            pvalue->u.image, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.object = rtxMemAllocType (pctxt, Ns3_Object);

         if (pvalue->u.object == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Object (pvalue->u.object);
         stat = asn1D_Ns3_Object (pctxt, 
            pvalue->u.object, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.object_ole = rtxMemAllocType (pctxt, Ns3_Object_ole);

         if (pvalue->u.object_ole == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Object_ole (pvalue->u.object_ole);
         stat = asn1D_Ns3_Object_ole (pctxt, 
            pvalue->u.object_ole, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.applet = rtxMemAllocType (pctxt, Ns3_Applet);

         if (pvalue->u.applet == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Applet (pvalue->u.applet);
         stat = asn1D_Ns3_Applet (pctxt, 
            pvalue->u.applet, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.floating_frame
             = rtxMemAllocType (pctxt, Ns3_Floating_frame);

         if (pvalue->u.floating_frame == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Floating_frame (pvalue->u.floating_frame);
         stat = asn1D_Ns3_Floating_frame (pctxt, 
            pvalue->u.floating_frame, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.plugin = rtxMemAllocType (pctxt, Ns3_Plugin);

         if (pvalue->u.plugin == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Plugin (pvalue->u.plugin);
         stat = asn1D_Ns3_Plugin (pctxt, 
            pvalue->u.plugin, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_Frame_element (OSCTXT* pctxt, Ns3_Frame_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("text-box"), 8}, 0}, 0 },
      {{{OSUTF8("image"), 5}, 0}, 1 },
      {{{OSUTF8("object"), 6}, 0}, 2 },
      {{{OSUTF8("object-ole"), 10}, 0}, 3 },
      {{{OSUTF8("applet"), 6}, 0}, 4 },
      {{{OSUTF8("floating-frame"), 14}, 0}, 5 },
      {{{OSUTF8("plugin"), 6}, 0}, 6 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 7, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* text-box */
      pvalue->u.text_box = rtxMemAllocType (pctxt, Ns3_Text_box);

      if (pvalue->u.text_box == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Text_box (pvalue->u.text_box);

      stat = XmlDec_Ns3_Text_box (pctxt, pvalue->u.text_box);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* image */
      pvalue->u.image = rtxMemAllocType (pctxt, Ns3_Image);

      if (pvalue->u.image == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Image (pvalue->u.image);

      stat = XmlDec_Ns3_Image (pctxt, pvalue->u.image);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* object */
      pvalue->u.object = rtxMemAllocType (pctxt, Ns3_Object);

      if (pvalue->u.object == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Object (pvalue->u.object);

      stat = XmlDec_Ns3_Object (pctxt, pvalue->u.object);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* object-ole */
      pvalue->u.object_ole = rtxMemAllocType (pctxt, Ns3_Object_ole);

      if (pvalue->u.object_ole == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Object_ole (pvalue->u.object_ole);

      stat = XmlDec_Ns3_Object_ole (pctxt, pvalue->u.object_ole);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* applet */
      pvalue->u.applet = rtxMemAllocType (pctxt, Ns3_Applet);

      if (pvalue->u.applet == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Applet (pvalue->u.applet);

      stat = XmlDec_Ns3_Applet (pctxt, pvalue->u.applet);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* floating-frame */
      pvalue->u.floating_frame = rtxMemAllocType (pctxt, Ns3_Floating_frame);

      if (pvalue->u.floating_frame == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Floating_frame (pvalue->u.floating_frame);

      stat = XmlDec_Ns3_Floating_frame (pctxt, pvalue->u.floating_frame);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* plugin */
      pvalue->u.plugin = rtxMemAllocType (pctxt, Ns3_Plugin);

      if (pvalue->u.plugin == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Plugin (pvalue->u.plugin);

      stat = XmlDec_Ns3_Plugin (pctxt, pvalue->u.plugin);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  G_element                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns3_G_element (OSCTXT* pctxt, Ns3_G_element *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

         if (pvalue->u.rect == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Rect (pvalue->u.rect);
         stat = asn1D_Ns3_Rect (pctxt, 
            pvalue->u.rect, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

         if (pvalue->u.line == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Line (pvalue->u.line);
         stat = asn1D_Ns3_Line (pctxt, 
            pvalue->u.line, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

         if (pvalue->u.polyline == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polyline (pvalue->u.polyline);
         stat = asn1D_Ns3_Polyline (pctxt, 
            pvalue->u.polyline, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

         if (pvalue->u.polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Polygon (pvalue->u.polygon);
         stat = asn1D_Ns3_Polygon (pctxt, 
            pvalue->u.polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.regular_polygon
             = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

         if (pvalue->u.regular_polygon == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Regular_polygon (pvalue->u.regular_polygon);
         stat = asn1D_Ns3_Regular_polygon (pctxt, 
            pvalue->u.regular_polygon, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

         if (pvalue->u.path == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Path (pvalue->u.path);
         stat = asn1D_Ns3_Path (pctxt, 
            pvalue->u.path, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

         if (pvalue->u.circle == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Circle (pvalue->u.circle);
         stat = asn1D_Ns3_Circle (pctxt, 
            pvalue->u.circle, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

         if (pvalue->u.ellipse == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Ellipse (pvalue->u.ellipse);
         stat = asn1D_Ns3_Ellipse (pctxt, 
            pvalue->u.ellipse, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

         if (pvalue->u.g == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);
         stat = asn1D_Ns3_G (pctxt, 
            (Ns3_G*)pvalue->u.g, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.page_thumbnail
             = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

         if (pvalue->u.page_thumbnail == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Page_thumbnail (pvalue->u.page_thumbnail);
         stat = asn1D_Ns3_Page_thumbnail (pctxt, 
            pvalue->u.page_thumbnail, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

         if (pvalue->u.frame == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Frame (pvalue->u.frame);
         stat = asn1D_Ns3_Frame (pctxt, 
            pvalue->u.frame, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

         if (pvalue->u.measure == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Measure (pvalue->u.measure);
         stat = asn1D_Ns3_Measure (pctxt, 
            pvalue->u.measure, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

         if (pvalue->u.caption == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Caption (pvalue->u.caption);
         stat = asn1D_Ns3_Caption (pctxt, 
            pvalue->u.caption, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

         if (pvalue->u.connector == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Connector (pvalue->u.connector);
         stat = asn1D_Ns3_Connector (pctxt, 
            pvalue->u.connector, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

         if (pvalue->u.control == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Control (pvalue->u.control);
         stat = asn1D_Ns3_Control (pctxt, 
            pvalue->u.control, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

         if (pvalue->u.scene == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);
         stat = asn1D_Ns7_Scene (pctxt, 
            (Ns7_Scene*)pvalue->u.scene, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

         if (pvalue->u.custom_shape == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns3_Custom_shape (pvalue->u.custom_shape);
         stat = asn1D_Ns3_Custom_shape (pctxt, 
            pvalue->u.custom_shape, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Ns3_G_element (OSCTXT* pctxt, Ns3_G_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("rect"), 4}, 0}, 0 },
      {{{OSUTF8("line"), 4}, 0}, 1 },
      {{{OSUTF8("polyline"), 8}, 0}, 2 },
      {{{OSUTF8("polygon"), 7}, 0}, 3 },
      {{{OSUTF8("regular-polygon"), 15}, 0}, 4 },
      {{{OSUTF8("path"), 4}, 0}, 5 },
      {{{OSUTF8("circle"), 6}, 0}, 6 },
      {{{OSUTF8("ellipse"), 7}, 0}, 7 },
      {{{OSUTF8("g"), 1}, 0}, 8 },
      {{{OSUTF8("page-thumbnail"), 14}, 0}, 9 },
      {{{OSUTF8("frame"), 5}, 0}, 10 },
      {{{OSUTF8("measure"), 7}, 0}, 11 },
      {{{OSUTF8("caption"), 7}, 0}, 12 },
      {{{OSUTF8("connector"), 9}, 0}, 13 },
      {{{OSUTF8("control"), 7}, 0}, 14 },
      {{{OSUTF8("scene"), 5}, 0}, 15 },
      {{{OSUTF8("custom-shape"), 12}, 0}, 16 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 17, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* rect */
      pvalue->u.rect = rtxMemAllocType (pctxt, Ns3_Rect);

      if (pvalue->u.rect == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Rect (pvalue->u.rect);

      stat = XmlDec_Ns3_Rect (pctxt, pvalue->u.rect);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* line */
      pvalue->u.line = rtxMemAllocType (pctxt, Ns3_Line);

      if (pvalue->u.line == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Line (pvalue->u.line);

      stat = XmlDec_Ns3_Line (pctxt, pvalue->u.line);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* polyline */
      pvalue->u.polyline = rtxMemAllocType (pctxt, Ns3_Polyline);

      if (pvalue->u.polyline == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polyline (pvalue->u.polyline);

      stat = XmlDec_Ns3_Polyline (pctxt, pvalue->u.polyline);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* polygon */
      pvalue->u.polygon = rtxMemAllocType (pctxt, Ns3_Polygon);

      if (pvalue->u.polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Polygon (pvalue->u.polygon);

      stat = XmlDec_Ns3_Polygon (pctxt, pvalue->u.polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* regular-polygon */
      pvalue->u.regular_polygon
          = rtxMemAllocType (pctxt, Ns3_Regular_polygon);

      if (pvalue->u.regular_polygon == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Regular_polygon (pvalue->u.regular_polygon);

      stat = XmlDec_Ns3_Regular_polygon (pctxt, pvalue->u.regular_polygon);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* path */
      pvalue->u.path = rtxMemAllocType (pctxt, Ns3_Path);

      if (pvalue->u.path == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Path (pvalue->u.path);

      stat = XmlDec_Ns3_Path (pctxt, pvalue->u.path);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* circle */
      pvalue->u.circle = rtxMemAllocType (pctxt, Ns3_Circle);

      if (pvalue->u.circle == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Circle (pvalue->u.circle);

      stat = XmlDec_Ns3_Circle (pctxt, pvalue->u.circle);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* ellipse */
      pvalue->u.ellipse = rtxMemAllocType (pctxt, Ns3_Ellipse);

      if (pvalue->u.ellipse == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Ellipse (pvalue->u.ellipse);

      stat = XmlDec_Ns3_Ellipse (pctxt, pvalue->u.ellipse);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* g */
      pvalue->u.g = rtxMemAllocType (pctxt, Ns3_G);

      if (pvalue->u.g == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_G ((Ns3_G*)pvalue->u.g);

      stat = XmlDec_Ns3_G (pctxt, pvalue->u.g);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* page-thumbnail */
      pvalue->u.page_thumbnail = rtxMemAllocType (pctxt, Ns3_Page_thumbnail);

      if (pvalue->u.page_thumbnail == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Page_thumbnail (pvalue->u.page_thumbnail);

      stat = XmlDec_Ns3_Page_thumbnail (pctxt, pvalue->u.page_thumbnail);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* frame */
      pvalue->u.frame = rtxMemAllocType (pctxt, Ns3_Frame);

      if (pvalue->u.frame == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Frame (pvalue->u.frame);

      stat = XmlDec_Ns3_Frame (pctxt, pvalue->u.frame);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* measure */
      pvalue->u.measure = rtxMemAllocType (pctxt, Ns3_Measure);

      if (pvalue->u.measure == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Measure (pvalue->u.measure);

      stat = XmlDec_Ns3_Measure (pctxt, pvalue->u.measure);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* caption */
      pvalue->u.caption = rtxMemAllocType (pctxt, Ns3_Caption);

      if (pvalue->u.caption == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Caption (pvalue->u.caption);

      stat = XmlDec_Ns3_Caption (pctxt, pvalue->u.caption);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* connector */
      pvalue->u.connector = rtxMemAllocType (pctxt, Ns3_Connector);

      if (pvalue->u.connector == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Connector (pvalue->u.connector);

      stat = XmlDec_Ns3_Connector (pctxt, pvalue->u.connector);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* control */
      pvalue->u.control = rtxMemAllocType (pctxt, Ns3_Control);

      if (pvalue->u.control == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Control (pvalue->u.control);

      stat = XmlDec_Ns3_Control (pctxt, pvalue->u.control);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* scene */
      pvalue->u.scene = rtxMemAllocType (pctxt, Ns7_Scene);

      if (pvalue->u.scene == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns7_Scene ((Ns7_Scene*)pvalue->u.scene);

      stat = XmlDec_Ns7_Scene (pctxt, pvalue->u.scene);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* custom-shape */
      pvalue->u.custom_shape = rtxMemAllocType (pctxt, Ns3_Custom_shape);

      if (pvalue->u.custom_shape == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns3_Custom_shape (pvalue->u.custom_shape);

      stat = XmlDec_Ns3_Custom_shape (pctxt, pvalue->u.custom_shape);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

