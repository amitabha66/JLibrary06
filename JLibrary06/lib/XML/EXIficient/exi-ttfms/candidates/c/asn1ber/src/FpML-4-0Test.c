/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 18-Oct-2006.
 */
#include "FpML-4-0.h"
#include "Xmldsig.h"
#include "libxml/parser.h"
#include "rtxmlsrc/osrtxml.h"
#include "rtxsrc/rtxCommon.h"

int DOMTest_ProductType (OSCTXT* pctxt, ProductType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("productTypeScheme"))) {
            pvalue->m.productTypeSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->productTypeScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->productTypeScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_ProductId (OSCTXT* pctxt, ProductId* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_PartyReference (OSCTXT* pctxt, PartyReference* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->href = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->href = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_BuyerSeller_model (OSCTXT* pctxt, BuyerSeller_model* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("buyerPartyReference"))) {
            DOMTest_PartyReference (pctxt, &pvalue->buyerPartyReference, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("sellerPartyReference"))) {
            DOMTest_PartyReference (pctxt, &pvalue->sellerPartyReference, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_BusinessCenter (OSCTXT* pctxt, BusinessCenter* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("businessCenterScheme"))) {
            pvalue->m.businessCenterSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->businessCenterScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->businessCenterScheme = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_BusinessCenterTime (OSCTXT* pctxt, BusinessCenterTime* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("hourMinuteTime"))) {
            if (0 != pXmlNode->children) {
               pvalue->hourMinuteTime = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->hourMinuteTime = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessCenter"))) {
            DOMTest_BusinessCenter (pctxt, &pvalue->businessCenter, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_CutName (OSCTXT* pctxt, CutName* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("cutNameScheme"))) {
            pvalue->m.cutNameSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->cutNameScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->cutNameScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_ExpiryDateTime (OSCTXT* pctxt, ExpiryDateTime* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("expiryDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->expiryDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->expiryDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("expiryTime"))) {
            DOMTest_BusinessCenterTime (pctxt, &pvalue->expiryTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("cutName"))) {
            pvalue->m.cutNamePresent = 1;
            DOMTest_CutName (pctxt, &pvalue->cutName, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_PayerReceiver_model (OSCTXT* pctxt, PayerReceiver_model* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("payerPartyReference"))) {
            DOMTest_PartyReference (pctxt, &pvalue->payerPartyReference, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("receiverPartyReference"))) {
            DOMTest_PartyReference (pctxt, &pvalue->receiverPartyReference, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Currency (OSCTXT* pctxt, Currency* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("currencyScheme"))) {
            pvalue->m.currencySchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->currencyScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->currencyScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_Money (OSCTXT* pctxt, Money* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            DOMTest_Currency (pctxt, &pvalue->currency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amount"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->amount);
            }
         }
      }
   }

   return 0;
}

int DOMTest_SettlementMethod (OSCTXT* pctxt, SettlementMethod* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("settlementMethodScheme"))) {
            pvalue->m.settlementMethodSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->settlementMethodScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->settlementMethodScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_RoutingId (OSCTXT* pctxt, RoutingId* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("routingIdScheme"))) {
            pvalue->m.routingIdSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->routingIdScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->routingIdScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_RoutingIds (OSCTXT* pctxt, RoutingIds* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   RoutingId* pdata1;
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("routingId"))) {
            pdata1 = rtxMemAllocType (pctxt, RoutingId);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RoutingId (pdata1);
            DOMTest_RoutingId (pctxt, pdata1, pXmlNode, TRUE);
            if (0 != pdata1)
               rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         }
      }
   }

   return 0;
}

int DOMTest_StreetAddress (OSCTXT* pctxt, StreetAddress* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* pdata1 = 0;
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("streetLine"))) {
            if (0 != pXmlNode->children) {
               pdata1 = pXmlNode->children->content;
            }
            else {
               pdata1 = (const OSUTF8CHAR*)"";
            }
            if (0 != pdata1)
               rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         }
      }
   }

   return 0;
}

int DOMTest_Country (OSCTXT* pctxt, Country* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("countryScheme"))) {
            pvalue->m.countrySchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->countryScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->countryScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_Address (OSCTXT* pctxt, Address* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("streetAddress"))) {
            pvalue->m.streetAddressPresent = 1;
            DOMTest_StreetAddress (pctxt, &pvalue->streetAddress, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("city"))) {
            pvalue->m.cityPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->city = pXmlNode->children->content;
            }
            else {
               pvalue->city = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("state"))) {
            pvalue->m.statePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->state = pXmlNode->children->content;
            }
            else {
               pvalue->state = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("country"))) {
            pvalue->m.countryPresent = 1;
            DOMTest_Country (pctxt, &pvalue->country, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("postalCode"))) {
            pvalue->m.postalCodePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->postalCode = pXmlNode->children->content;
            }
            else {
               pvalue->postalCode = (const OSUTF8CHAR*)"";
            }
         }
      }
   }

   return 0;
}

int DOMTest_RoutingExplicitDetails (OSCTXT* pctxt, 
   RoutingExplicitDetails* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("routingName"))) {
            if (0 != pXmlNode->children) {
               pvalue->routingName = pXmlNode->children->content;
            }
            else {
               pvalue->routingName = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("routingAddress"))) {
            pvalue->m.routingAddressPresent = 1;
            DOMTest_Address (pctxt, &pvalue->routingAddress, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("routingAccountNumber"))) {
            pvalue->m.routingAccountNumberPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->routingAccountNumber = pXmlNode->children->content;
            }
            else {
               pvalue->routingAccountNumber = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("routingReferenceText"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            else {
               pdata2 = (const OSUTF8CHAR*)"";
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->routingReferenceText_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_RoutingIdsAndExplicitDetails (OSCTXT* pctxt, 
   RoutingIdsAndExplicitDetails* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("routingIds"))) {
            { RoutingIds* pdata2;
            pdata2 = rtxMemAllocType (pctxt, RoutingIds);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RoutingIds (pdata2);
            DOMTest_RoutingIds (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->routingIds_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("routingName"))) {
            if (0 != pXmlNode->children) {
               pvalue->routingName = pXmlNode->children->content;
            }
            else {
               pvalue->routingName = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("routingAddress"))) {
            pvalue->m.routingAddressPresent = 1;
            DOMTest_Address (pctxt, &pvalue->routingAddress, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("routingAccountNumber"))) {
            pvalue->m.routingAccountNumberPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->routingAccountNumber = pXmlNode->children->content;
            }
            else {
               pvalue->routingAccountNumber = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("routingReferenceText"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            else {
               pdata2 = (const OSUTF8CHAR*)"";
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->routingReferenceText_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_Routing (OSCTXT* pctxt, Routing* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("routingIds"))) {
            pvalue->t = 1;
            pvalue->u.routingIds = rtxMemAllocType (pctxt, RoutingIds);

            if (pvalue->u.routingIds == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RoutingIds (pvalue->u.routingIds);
            DOMTest_RoutingIds (pctxt, pvalue->u.routingIds, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("routingExplicitDetails"))) {
            pvalue->t = 2;
            pvalue->u.routingExplicitDetails
                = rtxMemAllocType (pctxt, RoutingExplicitDetails);

            if (pvalue->u.routingExplicitDetails == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RoutingExplicitDetails (pvalue->u.routingExplicitDetails);
            DOMTest_RoutingExplicitDetails (pctxt, pvalue->u.routingExplicitDetails, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("routingIdsAndExplicitDetails"))) {
            pvalue->t = 3;
            pvalue->u.routingIdsAndExplicitDetails
                = rtxMemAllocType (pctxt, RoutingIdsAndExplicitDetails);

            if (pvalue->u.routingIdsAndExplicitDetails == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RoutingIdsAndExplicitDetails (pvalue->u.routingIdsAndExplicitDetails);
            DOMTest_RoutingIdsAndExplicitDetails (pctxt, pvalue->u.routingIdsAndExplicitDetails, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_IntermediaryInformation_choice (OSCTXT* pctxt, 
   IntermediaryInformation_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("routingIds"))) {
            pvalue->t = 1;
            pvalue->u.routingIds = rtxMemAllocType (pctxt, RoutingIds);

            if (pvalue->u.routingIds == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RoutingIds (pvalue->u.routingIds);
            DOMTest_RoutingIds (pctxt, pvalue->u.routingIds, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("routingExplicitDetails"))) {
            pvalue->t = 2;
            pvalue->u.routingExplicitDetails
                = rtxMemAllocType (pctxt, RoutingExplicitDetails);

            if (pvalue->u.routingExplicitDetails == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RoutingExplicitDetails (pvalue->u.routingExplicitDetails);
            DOMTest_RoutingExplicitDetails (pctxt, pvalue->u.routingExplicitDetails, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("routingIdsAndExplicitDetails"))) {
            pvalue->t = 3;
            pvalue->u.routingIdsAndExplicitDetails
                = rtxMemAllocType (pctxt, RoutingIdsAndExplicitDetails);

            if (pvalue->u.routingIdsAndExplicitDetails == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RoutingIdsAndExplicitDetails (pvalue->u.routingIdsAndExplicitDetails);
            DOMTest_RoutingIdsAndExplicitDetails (pctxt, pvalue->u.routingIdsAndExplicitDetails, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_IntermediaryInformation (OSCTXT* pctxt, 
   IntermediaryInformation* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("routingIds")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("routingExplicitDetails")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("routingIdsAndExplicitDetails"))) {
            DOMTest_IntermediaryInformation_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("intermediarySequenceNumber"))) {
            if (0 != pXmlNode->children) {
               pvalue->intermediarySequenceNumber = atoi ((const char*)pXmlNode->children->content);
            }
         }
      }
   }

   return 0;
}

int DOMTest_SplitSettlement (OSCTXT* pctxt, SplitSettlement* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("splitSettlementAmount"))) {
            pvalue->splitSettlementAmount
                = rtxMemAllocType (pctxt, Money_derivations);

            if (pvalue->splitSettlementAmount == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Money_derivations ((Money_derivations*)pvalue->splitSettlementAmount);
            DOMTest_Money_derivations (pctxt, (Money_derivations*)pvalue->splitSettlementAmount, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("beneficiaryBank"))) {
            pvalue->m.beneficiaryBankPresent = 1;
            DOMTest_Routing (pctxt, &pvalue->beneficiaryBank, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("beneficiary"))) {
            DOMTest_Routing (pctxt, &pvalue->beneficiary, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_SettlementInstruction (OSCTXT* pctxt, 
   SettlementInstruction* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("settlementMethod"))) {
            pvalue->m.settlementMethodPresent = 1;
            DOMTest_SettlementMethod (pctxt, &pvalue->settlementMethod, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("correspondentInformation"))) {
            pvalue->m.correspondentInformationPresent = 1;
            DOMTest_Routing (pctxt, &pvalue->correspondentInformation, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("intermediaryInformation"))) {
            { IntermediaryInformation* pdata2;
            pdata2 = rtxMemAllocType (pctxt, IntermediaryInformation);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_IntermediaryInformation (pdata2);
            DOMTest_IntermediaryInformation (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->intermediaryInformation_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("beneficiaryBank"))) {
            pvalue->m.beneficiaryBankPresent = 1;
            DOMTest_Routing (pctxt, &pvalue->beneficiaryBank, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("beneficiary"))) {
            DOMTest_Routing (pctxt, &pvalue->beneficiary, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("splitSettlement"))) {
            { SplitSettlement* pdata2;
            pdata2 = rtxMemAllocType (pctxt, SplitSettlement);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SplitSettlement (pdata2);
            DOMTest_SplitSettlement (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->splitSettlement_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_SettlementInformation (OSCTXT* pctxt, 
   SettlementInformation* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("standardSettlementStyle"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               StandardSettlementStyleEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->u.standardSettlementStyle);
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("settlementInstruction"))) {
            pvalue->t = 2;
            pvalue->u.settlementInstruction
                = rtxMemAllocType (pctxt, SettlementInstruction);

            if (pvalue->u.settlementInstruction == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SettlementInstruction (pvalue->u.settlementInstruction);
            DOMTest_SettlementInstruction (pctxt, pvalue->u.settlementInstruction, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_FXOptionPayout (OSCTXT* pctxt, FXOptionPayout* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            DOMTest_Currency (pctxt, &pvalue->currency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amount"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->amount);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("payoutStyle"))) {
            if (0 != pXmlNode->children) {
               PayoutEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->payoutStyle);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("settlementInformation"))) {
            pvalue->m.settlementInformationPresent = 1;
            DOMTest_SettlementInformation (pctxt, &pvalue->settlementInformation, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Money_derivations (OSCTXT* pctxt, Money_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("Money");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("Money")))
   {
      pvalue->t = 1;
      pvalue->u.money = rtxMemAllocType (pctxt, Money);

      if (pvalue->u.money == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Money (pvalue->u.money);
      DOMTest_Money (pctxt, pvalue->u.money, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("FXOptionPayout")))
   {
      pvalue->t = 2;
      pvalue->u.fXOptionPayout = rtxMemAllocType (pctxt, FXOptionPayout);

      if (pvalue->u.fXOptionPayout == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_FXOptionPayout (pvalue->u.fXOptionPayout);
      DOMTest_FXOptionPayout (pctxt, pvalue->u.fXOptionPayout, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_PremiumQuote (OSCTXT* pctxt, PremiumQuote* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("premiumValue"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->premiumValue);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("premiumQuoteBasis"))) {
            if (0 != pXmlNode->children) {
               PremiumQuoteBasisEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->premiumQuoteBasis);
            }
         }
      }
   }

   return 0;
}

int DOMTest_FXOptionPremium (OSCTXT* pctxt, FXOptionPremium* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("payerPartyReference"))) {
            DOMTest_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("premiumAmount"))) {
            DOMTest_Money_derivations (pctxt, &pvalue->premiumAmount, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("premiumSettlementDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->premiumSettlementDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->premiumSettlementDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("settlementInformation"))) {
            pvalue->m.settlementInformationPresent = 1;
            DOMTest_SettlementInformation (pctxt, &pvalue->settlementInformation, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("premiumQuote"))) {
            pvalue->m.premiumQuotePresent = 1;
            DOMTest_PremiumQuote (pctxt, &pvalue->premiumQuote, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_FXStrikePrice (OSCTXT* pctxt, FXStrikePrice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("rate"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->rate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("strikeQuoteBasis"))) {
            if (0 != pXmlNode->children) {
               StrikeQuoteBasisEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->strikeQuoteBasis);
            }
         }
      }
   }

   return 0;
}

int DOMTest_InformationProvider (OSCTXT* pctxt, InformationProvider* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("informationProviderScheme"))) {
            pvalue->m.informationProviderSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->informationProviderScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->informationProviderScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_RateSourcePage (OSCTXT* pctxt, RateSourcePage* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("rateSourcePageScheme"))) {
            pvalue->m.rateSourcePageSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->rateSourcePageScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->rateSourcePageScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_InformationSource (OSCTXT* pctxt, InformationSource* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("rateSource"))) {
            DOMTest_InformationProvider (pctxt, &pvalue->rateSource, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("rateSourcePage"))) {
            pvalue->m.rateSourcePagePresent = 1;
            DOMTest_RateSourcePage (pctxt, &pvalue->rateSourcePage, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("rateSourcePageHeading"))) {
            pvalue->m.rateSourcePageHeadingPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->rateSourcePageHeading = pXmlNode->children->content;
            }
            else {
               pvalue->rateSourcePageHeading = (const OSUTF8CHAR*)"";
            }
         }
      }
   }

   return 0;
}

int DOMTest_CalculationPeriodFrequency (OSCTXT* pctxt, 
   CalculationPeriodFrequency* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("periodMultiplier"))) {
            if (0 != pXmlNode->children) {
               pvalue->periodMultiplier = atoi ((const char*)pXmlNode->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("period"))) {
            if (0 != pXmlNode->children) {
               PeriodEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->period);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("rollConvention"))) {
            if (0 != pXmlNode->children) {
               RollConventionEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->rollConvention);
            }
         }
      }
   }

   return 0;
}

int DOMTest_FXAverageRateObservationSchedule (OSCTXT* pctxt, 
   FXAverageRateObservationSchedule* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("observationStartDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->observationStartDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->observationStartDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("observationEndDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->observationEndDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->observationEndDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationPeriodFrequency"))) {
            DOMTest_CalculationPeriodFrequency (pctxt, &pvalue->calculationPeriodFrequency, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_FXAverageRateObservationDate (OSCTXT* pctxt, 
   FXAverageRateObservationDate* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("observationDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->observationDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->observationDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("averageRateWeightingFactor"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->averageRateWeightingFactor);
            }
         }
      }
   }

   return 0;
}

int DOMTest_FXAverageRateOption_choice (OSCTXT* pctxt, 
   FXAverageRateOption_choice* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("averageRateObservationSchedule"))) {
            pvalue->t = 1;
            pvalue->u.averageRateObservationSchedule
                = rtxMemAllocType (pctxt, FXAverageRateObservationSchedule);

            if (pvalue->u.averageRateObservationSchedule == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FXAverageRateObservationSchedule (pvalue->u.averageRateObservationSchedule);
            DOMTest_FXAverageRateObservationSchedule (pctxt, pvalue->u.averageRateObservationSchedule, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("averageRateObservationDate"))) {
            pvalue->t = 2;
            pvalue->u.averageRateObservationDate_list
                = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.averageRateObservationDate_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.averageRateObservationDate_list);
            {
            FXAverageRateObservationDate* pdata2;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("averageRateObservationDate"))) {
                     pdata2
                         = rtxMemAllocType (pctxt, FXAverageRateObservationDate);

                     if (pdata2 == NULL)
                        return LOG_RTERR (pctxt, RTERR_NOMEM);

                     asn1Init_FXAverageRateObservationDate (pdata2);
                     DOMTest_FXAverageRateObservationDate (pctxt, pdata2, pXmlNode, TRUE);
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, pvalue->u.averageRateObservationDate_list, (void*)pdata2);
                  }
               }
            }
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_ObservedRates (OSCTXT* pctxt, ObservedRates* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("observationDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->observationDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->observationDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("observedRate"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->observedRate);
            }
         }
      }
   }

   return 0;
}

int DOMTest_FXAverageRateOption (OSCTXT* pctxt, FXAverageRateOption* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productType"))) {
            pvalue->m.productTypePresent = 1;
            DOMTest_ProductType (pctxt, &pvalue->productType, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productId"))) {
            { ProductId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ProductId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ProductId (pdata2);
            DOMTest_ProductId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->productId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("buyerPartyReference"))) {
            DOMTest_BuyerSeller_model (pctxt, &pvalue->buyerSeller_model, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("expiryDateTime"))) {
            DOMTest_ExpiryDateTime (pctxt, &pvalue->expiryDateTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exerciseStyle"))) {
            if (0 != pXmlNode->children) {
               ExerciseStyleEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->exerciseStyle);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxOptionPremium"))) {
            { FXOptionPremium* pdata2;
            pdata2 = rtxMemAllocType (pctxt, FXOptionPremium);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FXOptionPremium (pdata2);
            DOMTest_FXOptionPremium (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->fxOptionPremium_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valueDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->valueDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->valueDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("putCurrencyAmount"))) {
            DOMTest_Money_derivations (pctxt, &pvalue->putCurrencyAmount, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("callCurrencyAmount"))) {
            DOMTest_Money_derivations (pctxt, &pvalue->callCurrencyAmount, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxStrikePrice"))) {
            DOMTest_FXStrikePrice (pctxt, &pvalue->fxStrikePrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("spotRate"))) {
            pvalue->m.spotRatePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->spotRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("payoutCurrency"))) {
            DOMTest_Currency (pctxt, &pvalue->payoutCurrency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("averageRateQuoteBasis"))) {
            if (0 != pXmlNode->children) {
               StrikeQuoteBasisEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->averageRateQuoteBasis);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("precision"))) {
            pvalue->m.precisionPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->precision = atoi ((const char*)pXmlNode->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("payoutFormula"))) {
            pvalue->m.payoutFormulaPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->payoutFormula = pXmlNode->children->content;
            }
            else {
               pvalue->payoutFormula = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("primaryRateSource"))) {
            DOMTest_InformationSource (pctxt, &pvalue->primaryRateSource, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("secondaryRateSource"))) {
            pvalue->m.secondaryRateSourcePresent = 1;
            DOMTest_InformationSource (pctxt, &pvalue->secondaryRateSource, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fixingTime"))) {
            DOMTest_BusinessCenterTime (pctxt, &pvalue->fixingTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("averageRateObservationSchedule")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("averageRateObservationDate"))) {
            DOMTest_FXAverageRateOption_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("observedRates"))) {
            { ObservedRates* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ObservedRates);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ObservedRates (pdata2);
            DOMTest_ObservedRates (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->observedRates_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_FxAverageRateOption (OSCTXT* pctxt, FxAverageRateOption* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_FXAverageRateOption (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_QuotedCurrencyPair (OSCTXT* pctxt, QuotedCurrencyPair* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency1"))) {
            DOMTest_Currency (pctxt, &pvalue->currency1, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency2"))) {
            DOMTest_Currency (pctxt, &pvalue->currency2, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("quoteBasis"))) {
            if (0 != pXmlNode->children) {
               QuoteBasisEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->quoteBasis);
            }
         }
      }
   }

   return 0;
}

int DOMTest_FXBarrier (OSCTXT* pctxt, FXBarrier* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxBarrierType"))) {
            pvalue->m.fxBarrierTypePresent = 1;
            if (0 != pXmlNode->children) {
               FxBarrierTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->fxBarrierType);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("quotedCurrencyPair"))) {
            DOMTest_QuotedCurrencyPair (pctxt, &pvalue->quotedCurrencyPair, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("triggerRate"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->triggerRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("informationSource"))) {
            { InformationSource* pdata2;
            pdata2 = rtxMemAllocType (pctxt, InformationSource);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InformationSource (pdata2);
            DOMTest_InformationSource (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->informationSource_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("observationStartDate"))) {
            pvalue->m.observationStartDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->observationStartDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->observationStartDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("observationEndDate"))) {
            pvalue->m.observationEndDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->observationEndDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->observationEndDate = "";
            }
         }
      }
   }

   return 0;
}

int DOMTest_FXBarrierOption (OSCTXT* pctxt, FXBarrierOption* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productType"))) {
            pvalue->m.productTypePresent = 1;
            DOMTest_ProductType (pctxt, &pvalue->productType, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productId"))) {
            { ProductId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ProductId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ProductId (pdata2);
            DOMTest_ProductId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->productId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("spotRate"))) {
            pvalue->m.spotRatePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->spotRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxBarrier"))) {
            { FXBarrier* pdata2;
            pdata2 = rtxMemAllocType (pctxt, FXBarrier);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FXBarrier (pdata2);
            DOMTest_FXBarrier (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->fxBarrier_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("triggerPayout"))) {
            pvalue->m.triggerPayoutPresent = 1;
            DOMTest_FXOptionPayout (pctxt, &pvalue->triggerPayout, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_FxBarrierOption (OSCTXT* pctxt, FxBarrierOption* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_FXBarrierOption (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_FXEuropeanTrigger (OSCTXT* pctxt, FXEuropeanTrigger* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("triggerCondition"))) {
            if (0 != pXmlNode->children) {
               TriggerConditionEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->triggerCondition);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("quotedCurrencyPair"))) {
            DOMTest_QuotedCurrencyPair (pctxt, &pvalue->quotedCurrencyPair, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("triggerRate"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->triggerRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("informationSource"))) {
            { InformationSource* pdata2;
            pdata2 = rtxMemAllocType (pctxt, InformationSource);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InformationSource (pdata2);
            DOMTest_InformationSource (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->informationSource_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_FXAmericanTrigger (OSCTXT* pctxt, FXAmericanTrigger* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("touchCondition"))) {
            if (0 != pXmlNode->children) {
               TouchConditionEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->touchCondition);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("quotedCurrencyPair"))) {
            DOMTest_QuotedCurrencyPair (pctxt, &pvalue->quotedCurrencyPair, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("triggerRate"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->triggerRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("informationSource"))) {
            { InformationSource* pdata2;
            pdata2 = rtxMemAllocType (pctxt, InformationSource);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InformationSource (pdata2);
            DOMTest_InformationSource (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->informationSource_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("observationStartDate"))) {
            pvalue->m.observationStartDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->observationStartDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->observationStartDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("observationEndDate"))) {
            pvalue->m.observationEndDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->observationEndDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->observationEndDate = "";
            }
         }
      }
   }

   return 0;
}

int DOMTest_FXDigitalOption_choice (OSCTXT* pctxt, 
   FXDigitalOption_choice* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxEuropeanTrigger"))) {
            pvalue->t = 1;
            pvalue->u.fxEuropeanTrigger_list
                = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.fxEuropeanTrigger_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.fxEuropeanTrigger_list);
            {
            FXEuropeanTrigger* pdata2;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxEuropeanTrigger"))) {
                     pdata2 = rtxMemAllocType (pctxt, FXEuropeanTrigger);

                     if (pdata2 == NULL)
                        return LOG_RTERR (pctxt, RTERR_NOMEM);

                     asn1Init_FXEuropeanTrigger (pdata2);
                     DOMTest_FXEuropeanTrigger (pctxt, pdata2, pXmlNode, TRUE);
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, pvalue->u.fxEuropeanTrigger_list, (void*)pdata2);
                  }
               }
            }
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxAmericanTrigger"))) {
            pvalue->t = 2;
            pvalue->u.fxAmericanTrigger_list
                = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.fxAmericanTrigger_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.fxAmericanTrigger_list);
            {
            FXAmericanTrigger* pdata2;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxAmericanTrigger"))) {
                     pdata2 = rtxMemAllocType (pctxt, FXAmericanTrigger);

                     if (pdata2 == NULL)
                        return LOG_RTERR (pctxt, RTERR_NOMEM);

                     asn1Init_FXAmericanTrigger (pdata2);
                     DOMTest_FXAmericanTrigger (pctxt, pdata2, pXmlNode, TRUE);
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, pvalue->u.fxAmericanTrigger_list, (void*)pdata2);
                  }
               }
            }
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_FXDigitalOption (OSCTXT* pctxt, FXDigitalOption* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productType"))) {
            pvalue->m.productTypePresent = 1;
            DOMTest_ProductType (pctxt, &pvalue->productType, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productId"))) {
            { ProductId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ProductId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ProductId (pdata2);
            DOMTest_ProductId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->productId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("buyerPartyReference"))) {
            DOMTest_BuyerSeller_model (pctxt, &pvalue->buyerSeller_model, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("expiryDateTime"))) {
            DOMTest_ExpiryDateTime (pctxt, &pvalue->expiryDateTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxOptionPremium"))) {
            { FXOptionPremium* pdata2;
            pdata2 = rtxMemAllocType (pctxt, FXOptionPremium);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FXOptionPremium (pdata2);
            DOMTest_FXOptionPremium (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->fxOptionPremium_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valueDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->valueDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->valueDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("quotedCurrencyPair"))) {
            DOMTest_QuotedCurrencyPair (pctxt, &pvalue->quotedCurrencyPair, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("spotRate"))) {
            pvalue->m.spotRatePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->spotRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxEuropeanTrigger")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxAmericanTrigger"))) {
            DOMTest_FXDigitalOption_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("triggerPayout"))) {
            DOMTest_FXOptionPayout (pctxt, &pvalue->triggerPayout, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_FxDigitalOption (OSCTXT* pctxt, FxDigitalOption* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_FXDigitalOption (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_FXFixing (OSCTXT* pctxt, FXFixing* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("primaryRateSource"))) {
            DOMTest_InformationSource (pctxt, &pvalue->primaryRateSource, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("secondaryRateSource"))) {
            pvalue->m.secondaryRateSourcePresent = 1;
            DOMTest_InformationSource (pctxt, &pvalue->secondaryRateSource, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fixingTime"))) {
            DOMTest_BusinessCenterTime (pctxt, &pvalue->fixingTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("quotedCurrencyPair"))) {
            DOMTest_QuotedCurrencyPair (pctxt, &pvalue->quotedCurrencyPair, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fixingDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->fixingDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->fixingDate = "";
            }
         }
      }
   }

   return 0;
}

int DOMTest_FXCashSettlement (OSCTXT* pctxt, FXCashSettlement* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("settlementCurrency"))) {
            DOMTest_Currency (pctxt, &pvalue->settlementCurrency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fixing"))) {
            { FXFixing* pdata2;
            pdata2 = rtxMemAllocType (pctxt, FXFixing);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FXFixing (pdata2);
            DOMTest_FXFixing (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->fixing_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_Interval (OSCTXT* pctxt, Interval* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("periodMultiplier"))) {
            if (0 != pXmlNode->children) {
               pvalue->periodMultiplier = atoi ((const char*)pXmlNode->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("period"))) {
            if (0 != pXmlNode->children) {
               PeriodEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->period);
            }
         }
      }
   }

   return 0;
}

int DOMTest_Offset (OSCTXT* pctxt, Offset* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("periodMultiplier"))) {
            if (0 != pXmlNode->children) {
               pvalue->periodMultiplier = atoi ((const char*)pXmlNode->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("period"))) {
            if (0 != pXmlNode->children) {
               PeriodEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->period);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dayType"))) {
            pvalue->m.dayTypePresent = 1;
            if (0 != pXmlNode->children) {
               DayTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->dayType);
            }
         }
      }
   }

   return 0;
}

int DOMTest_BusinessCentersReference (OSCTXT* pctxt, 
   BusinessCentersReference* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->href = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->href = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_BusinessCenters (OSCTXT* pctxt, BusinessCenters* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessCenter"))) {
            { BusinessCenter* pdata2;
            pdata2 = rtxMemAllocType (pctxt, BusinessCenter);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BusinessCenter (pdata2);
            DOMTest_BusinessCenter (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->businessCenter_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_BusinessCentersOrReference_model (OSCTXT* pctxt, 
   BusinessCentersOrReference_model* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessCentersReference"))) {
            pvalue->t = 1;
            pvalue->u.businessCentersReference
                = rtxMemAllocType (pctxt, BusinessCentersReference);

            if (pvalue->u.businessCentersReference == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BusinessCentersReference (pvalue->u.businessCentersReference);
            DOMTest_BusinessCentersReference (pctxt, pvalue->u.businessCentersReference, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessCenters"))) {
            pvalue->t = 2;
            pvalue->u.businessCenters
                = rtxMemAllocType (pctxt, BusinessCenters);

            if (pvalue->u.businessCenters == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BusinessCenters (pvalue->u.businessCenters);
            DOMTest_BusinessCenters (pctxt, pvalue->u.businessCenters, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_DateRelativeTo (OSCTXT* pctxt, DateRelativeTo* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->href = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->href = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_RelativeDateOffset (OSCTXT* pctxt, RelativeDateOffset* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("periodMultiplier"))) {
            if (0 != pXmlNode->children) {
               pvalue->periodMultiplier = atoi ((const char*)pXmlNode->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("period"))) {
            if (0 != pXmlNode->children) {
               PeriodEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->period);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessDayConvention"))) {
            if (0 != pXmlNode->children) {
               BusinessDayConventionEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->businessDayConvention);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessCentersReference")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessCenters"))) {
            pvalue->m.choicePresent = 1;
            DOMTest_BusinessCentersOrReference_model (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dateRelativeTo"))) {
            DOMTest_DateRelativeTo (pctxt, &pvalue->dateRelativeTo, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_DateRange (OSCTXT* pctxt, DateRange* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("unadjustedFirstDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->unadjustedFirstDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->unadjustedFirstDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("unadjustedLastDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->unadjustedLastDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->unadjustedLastDate = "";
            }
         }
      }
   }

   return 0;
}

int DOMTest_BusinessDateRange_choice (OSCTXT* pctxt, 
   BusinessDateRange_choice* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessCentersReference")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessCenters"))) {
            pvalue->t = 1;
            pvalue->u.choice
                = rtxMemAllocType (pctxt, BusinessCentersOrReference_model);

            if (pvalue->u.choice == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BusinessCentersOrReference_model (pvalue->u.choice);
            DOMTest_BusinessCentersOrReference_model (pctxt, pvalue->u.choice, pXmlNode, FALSE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_BusinessDateRange (OSCTXT* pctxt, BusinessDateRange* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("unadjustedFirstDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->unadjustedFirstDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->unadjustedFirstDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("unadjustedLastDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->unadjustedLastDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->unadjustedLastDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessDayConvention"))) {
            if (0 != pXmlNode->children) {
               BusinessDayConventionEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->businessDayConvention);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessCentersReference")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessCenters"))) {
            pvalue->m.choicePresent = 1;
            DOMTest_BusinessDateRange_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_DateRange_derivations (OSCTXT* pctxt, 
   DateRange_derivations* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("DateRange");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("DateRange")))
   {
      pvalue->t = 1;
      pvalue->u.dateRange = rtxMemAllocType (pctxt, DateRange);

      if (pvalue->u.dateRange == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DateRange (pvalue->u.dateRange);
      DOMTest_DateRange (pctxt, pvalue->u.dateRange, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("BusinessDateRange")))
   {
      pvalue->t = 2;
      pvalue->u.businessDateRange
          = rtxMemAllocType (pctxt, BusinessDateRange);

      if (pvalue->u.businessDateRange == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BusinessDateRange (pvalue->u.businessDateRange);
      DOMTest_BusinessDateRange (pctxt, pvalue->u.businessDateRange, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_RelativeDates (OSCTXT* pctxt, RelativeDates* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("periodMultiplier"))) {
            if (0 != pXmlNode->children) {
               pvalue->periodMultiplier = atoi ((const char*)pXmlNode->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("period"))) {
            if (0 != pXmlNode->children) {
               PeriodEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->period);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("periodSkip"))) {
            pvalue->m.periodSkipPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->periodSkip = atoi ((const char*)pXmlNode->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("scheduleBounds"))) {
            pvalue->m.scheduleBoundsPresent = 1;
            DOMTest_DateRange_derivations (pctxt, &pvalue->scheduleBounds, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_RelativeDateOffset_derivations (OSCTXT* pctxt, 
   RelativeDateOffset_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("RelativeDateOffset");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("RelativeDateOffset")))
   {
      pvalue->t = 1;
      pvalue->u.relativeDateOffset
          = rtxMemAllocType (pctxt, RelativeDateOffset);

      if (pvalue->u.relativeDateOffset == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RelativeDateOffset (pvalue->u.relativeDateOffset);
      DOMTest_RelativeDateOffset (pctxt, pvalue->u.relativeDateOffset, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("RelativeDates")))
   {
      pvalue->t = 2;
      pvalue->u.relativeDates = rtxMemAllocType (pctxt, RelativeDates);

      if (pvalue->u.relativeDates == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RelativeDates (pvalue->u.relativeDates);
      DOMTest_RelativeDates (pctxt, pvalue->u.relativeDates, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_Offset_derivations (OSCTXT* pctxt, Offset_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("Offset");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("Offset")))
   {
      pvalue->t = 1;
      pvalue->u.offset = rtxMemAllocType (pctxt, Offset);

      if (pvalue->u.offset == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Offset (pvalue->u.offset);
      DOMTest_Offset (pctxt, pvalue->u.offset, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("RelativeDateOffset"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("RelativeDates")))
   {
      pvalue->t = 2;
      pvalue->u.relativeDateOffset
          = rtxMemAllocType (pctxt, RelativeDateOffset_derivations);

      if (pvalue->u.relativeDateOffset == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RelativeDateOffset_derivations (pvalue->u.relativeDateOffset);
      DOMTest_RelativeDateOffset_derivations (pctxt, pvalue->u.relativeDateOffset, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_ResetFrequency (OSCTXT* pctxt, ResetFrequency* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("periodMultiplier"))) {
            if (0 != pXmlNode->children) {
               pvalue->periodMultiplier = atoi ((const char*)pXmlNode->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("period"))) {
            if (0 != pXmlNode->children) {
               PeriodEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->period);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("weeklyRollConvention"))) {
            pvalue->m.weeklyRollConventionPresent = 1;
            if (0 != pXmlNode->children) {
               WeeklyRollConventionEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->weeklyRollConvention);
            }
         }
      }
   }

   return 0;
}

int DOMTest_Interval_derivations (OSCTXT* pctxt, Interval_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("Interval");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("Interval")))
   {
      pvalue->t = 1;
      pvalue->u.interval = rtxMemAllocType (pctxt, Interval);

      if (pvalue->u.interval == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Interval (pvalue->u.interval);
      DOMTest_Interval (pctxt, pvalue->u.interval, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("Offset"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("RelativeDateOffset"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("RelativeDates")))
   {
      pvalue->t = 2;
      pvalue->u.offset = rtxMemAllocType (pctxt, Offset_derivations);

      if (pvalue->u.offset == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Offset_derivations (pvalue->u.offset);
      DOMTest_Offset_derivations (pctxt, pvalue->u.offset, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("CalculationPeriodFrequency")))
   {
      pvalue->t = 3;
      pvalue->u.calculationPeriodFrequency
          = rtxMemAllocType (pctxt, CalculationPeriodFrequency);

      if (pvalue->u.calculationPeriodFrequency == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CalculationPeriodFrequency (pvalue->u.calculationPeriodFrequency);
      DOMTest_CalculationPeriodFrequency (pctxt, pvalue->u.calculationPeriodFrequency, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("ResetFrequency")))
   {
      pvalue->t = 4;
      pvalue->u.resetFrequency = rtxMemAllocType (pctxt, ResetFrequency);

      if (pvalue->u.resetFrequency == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ResetFrequency (pvalue->u.resetFrequency);
      DOMTest_ResetFrequency (pctxt, pvalue->u.resetFrequency, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_QuotedAs (OSCTXT* pctxt, QuotedAs* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("optionOnCurrency"))) {
            DOMTest_Currency (pctxt, &pvalue->optionOnCurrency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("faceOnCurrency"))) {
            DOMTest_Currency (pctxt, &pvalue->faceOnCurrency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("quotedTenor"))) {
            pvalue->m.quotedTenorPresent = 1;
            DOMTest_Interval_derivations (pctxt, &pvalue->quotedTenor, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_FXOptionLeg (OSCTXT* pctxt, FXOptionLeg* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productType"))) {
            pvalue->m.productTypePresent = 1;
            DOMTest_ProductType (pctxt, &pvalue->productType, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productId"))) {
            { ProductId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ProductId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ProductId (pdata2);
            DOMTest_ProductId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->productId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("buyerPartyReference"))) {
            DOMTest_BuyerSeller_model (pctxt, &pvalue->buyerSeller_model, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("expiryDateTime"))) {
            DOMTest_ExpiryDateTime (pctxt, &pvalue->expiryDateTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exerciseStyle"))) {
            if (0 != pXmlNode->children) {
               ExerciseStyleEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->exerciseStyle);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxOptionPremium"))) {
            { FXOptionPremium* pdata2;
            pdata2 = rtxMemAllocType (pctxt, FXOptionPremium);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FXOptionPremium (pdata2);
            DOMTest_FXOptionPremium (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->fxOptionPremium_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valueDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->valueDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->valueDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("cashSettlementTerms"))) {
            pvalue->m.cashSettlementTermsPresent = 1;
            DOMTest_FXCashSettlement (pctxt, &pvalue->cashSettlementTerms, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("putCurrencyAmount"))) {
            DOMTest_Money_derivations (pctxt, &pvalue->putCurrencyAmount, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("callCurrencyAmount"))) {
            DOMTest_Money_derivations (pctxt, &pvalue->callCurrencyAmount, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxStrikePrice"))) {
            DOMTest_FXStrikePrice (pctxt, &pvalue->fxStrikePrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("quotedAs"))) {
            pvalue->m.quotedAsPresent = 1;
            DOMTest_QuotedAs (pctxt, &pvalue->quotedAs, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_FXOptionLeg_derivations (OSCTXT* pctxt, 
   FXOptionLeg_derivations* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("FXOptionLeg");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("FXOptionLeg")))
   {
      pvalue->t = 1;
      pvalue->u.fXOptionLeg = rtxMemAllocType (pctxt, FXOptionLeg);

      if (pvalue->u.fXOptionLeg == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_FXOptionLeg (pvalue->u.fXOptionLeg);
      DOMTest_FXOptionLeg (pctxt, pvalue->u.fXOptionLeg, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("FXBarrierOption")))
   {
      pvalue->t = 2;
      pvalue->u.fXBarrierOption = rtxMemAllocType (pctxt, FXBarrierOption);

      if (pvalue->u.fXBarrierOption == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_FXBarrierOption (pvalue->u.fXBarrierOption);
      DOMTest_FXBarrierOption (pctxt, pvalue->u.fXBarrierOption, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_FxSimpleOption (OSCTXT* pctxt, FxSimpleOption* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_FXOptionLeg_derivations (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_AdjustableDate_unadjustedDate (OSCTXT* pctxt, 
   AdjustableDate_unadjustedDate* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = (const char*)pXmlNode->children->content;
   }
   else {
      pvalue->base = "";
   }

   return 0;
}

int DOMTest_BusinessDayAdjustments_choice (OSCTXT* pctxt, 
   BusinessDayAdjustments_choice* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessCentersReference")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessCenters"))) {
            pvalue->t = 1;
            pvalue->u.choice
                = rtxMemAllocType (pctxt, BusinessCentersOrReference_model);

            if (pvalue->u.choice == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BusinessCentersOrReference_model (pvalue->u.choice);
            DOMTest_BusinessCentersOrReference_model (pctxt, pvalue->u.choice, pXmlNode, FALSE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_BusinessDayAdjustments (OSCTXT* pctxt, 
   BusinessDayAdjustments* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessDayConvention"))) {
            if (0 != pXmlNode->children) {
               BusinessDayConventionEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->businessDayConvention);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessCentersReference")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessCenters"))) {
            pvalue->m.choicePresent = 1;
            DOMTest_BusinessDayAdjustments_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_AdjustableDate (OSCTXT* pctxt, AdjustableDate* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("unadjustedDate"))) {
            DOMTest_AdjustableDate_unadjustedDate (pctxt, &pvalue->unadjustedDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dateAdjustments"))) {
            DOMTest_BusinessDayAdjustments (pctxt, &pvalue->dateAdjustments, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_PaymentType (OSCTXT* pctxt, PaymentType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("paymentTypeScheme"))) {
            pvalue->m.paymentTypeSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->paymentTypeScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->paymentTypeScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_Payment (OSCTXT* pctxt, Payment* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("payerPartyReference"))) {
            DOMTest_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("paymentAmount"))) {
            DOMTest_Money_derivations (pctxt, &pvalue->paymentAmount, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("paymentDate"))) {
            pvalue->m.paymentDatePresent = 1;
            DOMTest_AdjustableDate (pctxt, &pvalue->paymentDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedPaymentDate"))) {
            pvalue->m.adjustedPaymentDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->adjustedPaymentDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->adjustedPaymentDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("paymentType"))) {
            pvalue->m.paymentTypePresent = 1;
            DOMTest_PaymentType (pctxt, &pvalue->paymentType, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("settlementInformation"))) {
            pvalue->m.settlementInformationPresent = 1;
            DOMTest_SettlementInformation (pctxt, &pvalue->settlementInformation, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_FXLeg_sequence (OSCTXT* pctxt, FXLeg_sequence* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency1ValueDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->currency1ValueDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->currency1ValueDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency2ValueDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->currency2ValueDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->currency2ValueDate = "";
            }
         }
      }
   }

   return 0;
}

int DOMTest_FXLeg_choice (OSCTXT* pctxt, FXLeg_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valueDate"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               pvalue->u.valueDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->u.valueDate = "";
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency1ValueDate"))) {
            pvalue->t = 2;
            pvalue->u.sequence = rtxMemAllocType (pctxt, FXLeg_sequence);

            if (pvalue->u.sequence == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FXLeg_sequence (pvalue->u.sequence);
            DOMTest_FXLeg_sequence (pctxt, pvalue->u.sequence, pXmlNode, FALSE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_SideRate (OSCTXT* pctxt, SideRate* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            DOMTest_Currency (pctxt, &pvalue->currency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("sideRateBasis"))) {
            if (0 != pXmlNode->children) {
               SideRateBasisEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->sideRateBasis);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("rate"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->rate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("spotRate"))) {
            pvalue->m.spotRatePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->spotRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("forwardPoints"))) {
            pvalue->m.forwardPointsPresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->forwardPoints);
            }
         }
      }
   }

   return 0;
}

int DOMTest_SideRates (OSCTXT* pctxt, SideRates* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("baseCurrency"))) {
            DOMTest_Currency (pctxt, &pvalue->baseCurrency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency1SideRate"))) {
            pvalue->m.currency1SideRatePresent = 1;
            DOMTest_SideRate (pctxt, &pvalue->currency1SideRate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency2SideRate"))) {
            pvalue->m.currency2SideRatePresent = 1;
            DOMTest_SideRate (pctxt, &pvalue->currency2SideRate, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_ExchangeRate (OSCTXT* pctxt, ExchangeRate* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("quotedCurrencyPair"))) {
            DOMTest_QuotedCurrencyPair (pctxt, &pvalue->quotedCurrencyPair, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("rate"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->rate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("spotRate"))) {
            pvalue->m.spotRatePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->spotRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("forwardPoints"))) {
            pvalue->m.forwardPointsPresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->forwardPoints);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("sideRates"))) {
            pvalue->m.sideRatesPresent = 1;
            DOMTest_SideRates (pctxt, &pvalue->sideRates, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_FXLeg (OSCTXT* pctxt, FXLeg* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productType"))) {
            pvalue->m.productTypePresent = 1;
            DOMTest_ProductType (pctxt, &pvalue->productType, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productId"))) {
            { ProductId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ProductId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ProductId (pdata2);
            DOMTest_ProductId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->productId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exchangedCurrency1"))) {
            DOMTest_Payment (pctxt, &pvalue->exchangedCurrency1, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exchangedCurrency2"))) {
            DOMTest_Payment (pctxt, &pvalue->exchangedCurrency2, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valueDate")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency1ValueDate"))) {
            DOMTest_FXLeg_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exchangeRate"))) {
            DOMTest_ExchangeRate (pctxt, &pvalue->exchangeRate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("nonDeliverableForward"))) {
            pvalue->m.nonDeliverableForwardPresent = 1;
            DOMTest_FXCashSettlement (pctxt, &pvalue->nonDeliverableForward, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("confirmationSenderPartyReference"))) {
            pvalue->m.confirmationSenderPartyReferencePresent = 1;
            DOMTest_PartyReference (pctxt, &pvalue->confirmationSenderPartyReference, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_FxSingleLeg (OSCTXT* pctxt, FxSingleLeg* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_FXLeg (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_FXSwap (OSCTXT* pctxt, FXSwap* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productType"))) {
            pvalue->m.productTypePresent = 1;
            DOMTest_ProductType (pctxt, &pvalue->productType, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productId"))) {
            { ProductId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ProductId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ProductId (pdata2);
            DOMTest_ProductId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->productId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxSingleLeg"))) {
            { FxSingleLeg* pdata2;
            pdata2 = rtxMemAllocType (pctxt, FxSingleLeg);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FxSingleLeg (pdata2);
            DOMTest_FxSingleLeg (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->fxSingleLeg_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_FxSwap (OSCTXT* pctxt, FxSwap* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_FXSwap (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_QuotablePayment_payerPartyReference (OSCTXT* pctxt, 
   QuotablePayment_payerPartyReference* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->href = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->href = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_QuotablePayment_receiverPartyReference (OSCTXT* pctxt, 
   QuotablePayment_receiverPartyReference* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->href = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->href = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_QuotablePayment (OSCTXT* pctxt, QuotablePayment* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("payerPartyReference"))) {
            pvalue->m.payerPartyReferencePresent = 1;
            DOMTest_QuotablePayment_payerPartyReference (pctxt, &pvalue->payerPartyReference, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("receiverPartyReference"))) {
            pvalue->m.receiverPartyReferencePresent = 1;
            DOMTest_QuotablePayment_receiverPartyReference (pctxt, &pvalue->receiverPartyReference, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("paymentAmount"))) {
            pvalue->m.paymentAmountPresent = 1;
            DOMTest_Money_derivations (pctxt, &pvalue->paymentAmount, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("paymentDate"))) {
            pvalue->m.paymentDatePresent = 1;
            DOMTest_AdjustableDate (pctxt, &pvalue->paymentDate, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_QuotableFXRate (OSCTXT* pctxt, QuotableFXRate* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_QuotedCurrencyPair (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_QuotableFXLeg (OSCTXT* pctxt, QuotableFXLeg* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productType"))) {
            pvalue->m.productTypePresent = 1;
            DOMTest_ProductType (pctxt, &pvalue->productType, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productId"))) {
            { ProductId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ProductId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ProductId (pdata2);
            DOMTest_ProductId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->productId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exchangedCurrency"))) {
            pvalue->m.exchangedCurrencyPresent = 1;
            DOMTest_QuotablePayment (pctxt, &pvalue->exchangedCurrency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exchangeRate"))) {
            DOMTest_QuotableFXRate (pctxt, &pvalue->exchangeRate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("nonDeliverableForward"))) {
            pvalue->m.nonDeliverableForwardPresent = 1;
            DOMTest_FXCashSettlement (pctxt, &pvalue->nonDeliverableForward, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_QuotableFxSingleLeg (OSCTXT* pctxt, QuotableFxSingleLeg* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_QuotableFXLeg (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_Validation (OSCTXT* pctxt, Validation* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("validationScheme"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->validationScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->validationScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_Validation_model (OSCTXT* pctxt, Validation_model* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   Validation* pdata1;
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("validation"))) {
            pdata1 = rtxMemAllocType (pctxt, Validation);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Validation (pdata1);
            DOMTest_Validation (pctxt, pdata1, pXmlNode, TRUE);
            if (0 != pdata1)
               rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         }
      }
   }

   return 0;
}

int DOMTest_TradeId (OSCTXT* pctxt, TradeId* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("tradeIdScheme"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->tradeIdScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->tradeIdScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_PartyTradeIdentifier_linkId (OSCTXT* pctxt, 
   PartyTradeIdentifier_linkId* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("linkIdScheme"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->linkIdScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->linkIdScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_PartyTradeIdentifier (OSCTXT* pctxt, PartyTradeIdentifier* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("partyReference"))) {
            DOMTest_PartyReference (pctxt, &pvalue->partyReference, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("tradeId"))) {
            { TradeId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TradeId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TradeId (pdata2);
            DOMTest_TradeId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->tradeId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("linkId"))) {
            { PartyTradeIdentifier_linkId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, PartyTradeIdentifier_linkId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PartyTradeIdentifier_linkId (pdata2);
            DOMTest_PartyTradeIdentifier_linkId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->linkId_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_PartyTradeInformation (OSCTXT* pctxt, 
   PartyTradeInformation* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("partyReference"))) {
            DOMTest_PartyReference (pctxt, &pvalue->partyReference, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("trader"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            else {
               pdata2 = (const OSUTF8CHAR*)"";
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->trader_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_TradeDate (OSCTXT* pctxt, TradeDate* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = (const char*)pXmlNode->children->content;
   }
   else {
      pvalue->base = "";
   }

   return 0;
}

int DOMTest_TradeHeader (OSCTXT* pctxt, TradeHeader* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("partyTradeIdentifier"))) {
            { PartyTradeIdentifier* pdata2;
            pdata2 = rtxMemAllocType (pctxt, PartyTradeIdentifier);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PartyTradeIdentifier (pdata2);
            DOMTest_PartyTradeIdentifier (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->partyTradeIdentifier_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("partyTradeInformation"))) {
            { PartyTradeInformation* pdata2;
            pdata2 = rtxMemAllocType (pctxt, PartyTradeInformation);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PartyTradeInformation (pdata2);
            DOMTest_PartyTradeInformation (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->partyTradeInformation_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("tradeDate"))) {
            DOMTest_TradeDate (pctxt, &pvalue->tradeDate, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_ProductReference (OSCTXT* pctxt, ProductReference* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->href = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->href = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_Strategy (OSCTXT* pctxt, Strategy* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productType"))) {
            pvalue->m.productTypePresent = 1;
            DOMTest_ProductType (pctxt, &pvalue->productType, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productId"))) {
            { ProductId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ProductId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ProductId (pdata2);
            DOMTest_ProductId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->productId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("premiumProductReference"))) {
            pvalue->m.premiumProductReferencePresent = 1;
            DOMTest_ProductReference (pctxt, &pvalue->premiumProductReference, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("strategy")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxAverageRateOption")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxBarrierOption")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxDigitalOption")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxSimpleOption")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxSingleLeg")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxSwap")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("termDeposit")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("bulletPayment")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("capFloor")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fra")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("swap")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("swaption")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityOption")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equitySwap")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("creditDefaultSwap"))) {
            { Product_group* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Product_group);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Product_group ((Product_group*)pdata2);
            DOMTest_Product_group (pctxt, (Product_group*)pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->product_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_TermDeposit (OSCTXT* pctxt, TermDeposit* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productType"))) {
            pvalue->m.productTypePresent = 1;
            DOMTest_ProductType (pctxt, &pvalue->productType, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productId"))) {
            { ProductId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ProductId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ProductId (pdata2);
            DOMTest_ProductId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->productId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("initialPayerReference"))) {
            DOMTest_PartyReference (pctxt, &pvalue->initialPayerReference, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("initialReceiverReference"))) {
            DOMTest_PartyReference (pctxt, &pvalue->initialReceiverReference, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("startDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->startDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->startDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("maturityDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->maturityDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->maturityDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dayCountFraction"))) {
            if (0 != pXmlNode->children) {
               DayCountFractionEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->dayCountFraction);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("principal"))) {
            DOMTest_Money_derivations (pctxt, &pvalue->principal, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fixedRate"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->fixedRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("interest"))) {
            pvalue->m.interestPresent = 1;
            DOMTest_Money_derivations (pctxt, &pvalue->interest, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("payment"))) {
            { Payment* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Payment);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Payment (pdata2);
            DOMTest_Payment (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->payment_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_BulletPayment (OSCTXT* pctxt, BulletPayment* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productType"))) {
            pvalue->m.productTypePresent = 1;
            DOMTest_ProductType (pctxt, &pvalue->productType, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productId"))) {
            { ProductId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ProductId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ProductId (pdata2);
            DOMTest_ProductId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->productId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("payment"))) {
            DOMTest_Payment (pctxt, &pvalue->payment, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_CalculationPeriodDates (OSCTXT* pctxt, 
   CalculationPeriodDates* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("effectiveDate"))) {
            DOMTest_AdjustableDate (pctxt, &pvalue->effectiveDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("terminationDate"))) {
            DOMTest_AdjustableDate (pctxt, &pvalue->terminationDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationPeriodDatesAdjustments"))) {
            DOMTest_BusinessDayAdjustments (pctxt, &pvalue->calculationPeriodDatesAdjustments, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("firstPeriodStartDate"))) {
            pvalue->m.firstPeriodStartDatePresent = 1;
            DOMTest_AdjustableDate (pctxt, &pvalue->firstPeriodStartDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("firstRegularPeriodStartDate"))) {
            pvalue->m.firstRegularPeriodStartDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->firstRegularPeriodStartDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->firstRegularPeriodStartDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("lastRegularPeriodEndDate"))) {
            pvalue->m.lastRegularPeriodEndDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->lastRegularPeriodEndDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->lastRegularPeriodEndDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationPeriodFrequency"))) {
            DOMTest_CalculationPeriodFrequency (pctxt, &pvalue->calculationPeriodFrequency, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_DateReference (OSCTXT* pctxt, DateReference* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->href = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->href = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_PaymentDates_choice (OSCTXT* pctxt, PaymentDates_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationPeriodDatesReference"))) {
            pvalue->t = 1;
            pvalue->u.calculationPeriodDatesReference
                = rtxMemAllocType (pctxt, DateReference);

            if (pvalue->u.calculationPeriodDatesReference == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_DateReference (pvalue->u.calculationPeriodDatesReference);
            DOMTest_DateReference (pctxt, pvalue->u.calculationPeriodDatesReference, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("resetDatesReference"))) {
            pvalue->t = 2;
            pvalue->u.resetDatesReference
                = rtxMemAllocType (pctxt, DateReference);

            if (pvalue->u.resetDatesReference == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_DateReference (pvalue->u.resetDatesReference);
            DOMTest_DateReference (pctxt, pvalue->u.resetDatesReference, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_PaymentDates (OSCTXT* pctxt, PaymentDates* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationPeriodDatesReference")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("resetDatesReference"))) {
            DOMTest_PaymentDates_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("paymentFrequency"))) {
            DOMTest_Interval_derivations (pctxt, &pvalue->paymentFrequency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("firstPaymentDate"))) {
            pvalue->m.firstPaymentDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->firstPaymentDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->firstPaymentDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("lastRegularPaymentDate"))) {
            pvalue->m.lastRegularPaymentDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->lastRegularPaymentDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->lastRegularPaymentDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("payRelativeTo"))) {
            if (0 != pXmlNode->children) {
               PayRelativeToEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->payRelativeTo);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("paymentDaysOffset"))) {
            pvalue->m.paymentDaysOffsetPresent = 1;
            DOMTest_Offset_derivations (pctxt, &pvalue->paymentDaysOffset, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("paymentDatesAdjustments"))) {
            DOMTest_BusinessDayAdjustments (pctxt, &pvalue->paymentDatesAdjustments, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_ResetDates (OSCTXT* pctxt, ResetDates* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationPeriodDatesReference"))) {
            DOMTest_DateReference (pctxt, &pvalue->calculationPeriodDatesReference, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("resetRelativeTo"))) {
            pvalue->m.resetRelativeToPresent = 1;
            if (0 != pXmlNode->children) {
               ResetRelativeToEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->resetRelativeTo);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("initialFixingDate"))) {
            pvalue->m.initialFixingDatePresent = 1;
            DOMTest_RelativeDateOffset_derivations (pctxt, &pvalue->initialFixingDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fixingDates"))) {
            DOMTest_RelativeDateOffset_derivations (pctxt, &pvalue->fixingDates, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("rateCutOffDaysOffset"))) {
            pvalue->m.rateCutOffDaysOffsetPresent = 1;
            DOMTest_Offset_derivations (pctxt, &pvalue->rateCutOffDaysOffset, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("resetFrequency"))) {
            DOMTest_ResetFrequency (pctxt, &pvalue->resetFrequency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("resetDatesAdjustments"))) {
            DOMTest_BusinessDayAdjustments (pctxt, &pvalue->resetDatesAdjustments, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Step (OSCTXT* pctxt, Step* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("stepDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->stepDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->stepDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("stepValue"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->stepValue);
            }
         }
      }
   }

   return 0;
}

int DOMTest_AmountSchedule (OSCTXT* pctxt, AmountSchedule* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("initialValue"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->initialValue);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("step"))) {
            { Step* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Step);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Step (pdata2);
            DOMTest_Step (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->step_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            DOMTest_Currency (pctxt, &pvalue->currency, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_NotionalStepRule_sequence (OSCTXT* pctxt, 
   NotionalStepRule_sequence* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notionalStepRate"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->notionalStepRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("stepRelativeTo"))) {
            if (0 != pXmlNode->children) {
               StepRelativeToEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->stepRelativeTo);
            }
         }
      }
   }

   return 0;
}

int DOMTest_NotionalStepRule_choice (OSCTXT* pctxt, 
   NotionalStepRule_choice* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notionalStepAmount"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->u.notionalStepAmount);
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notionalStepRate"))) {
            pvalue->t = 2;
            pvalue->u.sequence
                = rtxMemAllocType (pctxt, NotionalStepRule_sequence);

            if (pvalue->u.sequence == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NotionalStepRule_sequence (pvalue->u.sequence);
            DOMTest_NotionalStepRule_sequence (pctxt, pvalue->u.sequence, pXmlNode, FALSE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_NotionalStepRule (OSCTXT* pctxt, NotionalStepRule* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationPeriodDatesReference"))) {
            DOMTest_DateReference (pctxt, &pvalue->calculationPeriodDatesReference, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("stepFrequency"))) {
            DOMTest_Interval_derivations (pctxt, &pvalue->stepFrequency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("firstNotionalStepDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->firstNotionalStepDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->firstNotionalStepDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("lastNotionalStepDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->lastNotionalStepDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->lastNotionalStepDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notionalStepAmount")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notionalStepRate"))) {
            DOMTest_NotionalStepRule_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_Notional (OSCTXT* pctxt, Notional* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notionalStepSchedule"))) {
            DOMTest_AmountSchedule (pctxt, &pvalue->notionalStepSchedule, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notionalStepParameters"))) {
            pvalue->m.notionalStepParametersPresent = 1;
            DOMTest_NotionalStepRule (pctxt, &pvalue->notionalStepParameters, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_NotionalReference (OSCTXT* pctxt, NotionalReference* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->href = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->href = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_FxSpotRateSource (OSCTXT* pctxt, FxSpotRateSource* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("primaryRateSource"))) {
            DOMTest_InformationSource (pctxt, &pvalue->primaryRateSource, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("secondaryRateSource"))) {
            pvalue->m.secondaryRateSourcePresent = 1;
            DOMTest_InformationSource (pctxt, &pvalue->secondaryRateSource, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fixingTime"))) {
            DOMTest_BusinessCenterTime (pctxt, &pvalue->fixingTime, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_FxSpotRateSource_derivations (OSCTXT* pctxt, 
   FxSpotRateSource_derivations* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("FxSpotRateSource");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("FxSpotRateSource")))
   {
      pvalue->t = 1;
      pvalue->u.fxSpotRateSource = rtxMemAllocType (pctxt, FxSpotRateSource);

      if (pvalue->u.fxSpotRateSource == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_FxSpotRateSource (pvalue->u.fxSpotRateSource);
      DOMTest_FxSpotRateSource (pctxt, pvalue->u.fxSpotRateSource, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("FXFixing")))
   {
      pvalue->t = 2;
      pvalue->u.fXFixing = rtxMemAllocType (pctxt, FXFixing);

      if (pvalue->u.fXFixing == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_FXFixing (pvalue->u.fXFixing);
      DOMTest_FXFixing (pctxt, pvalue->u.fXFixing, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_FxLinkedNotionalSchedule (OSCTXT* pctxt, 
   FxLinkedNotionalSchedule* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("constantNotionalScheduleReference"))) {
            DOMTest_NotionalReference (pctxt, &pvalue->constantNotionalScheduleReference, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("initialValue"))) {
            pvalue->m.initialValuePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->initialValue);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("varyingNotionalCurrency"))) {
            if (0 != pXmlNode->children) {
               pvalue->varyingNotionalCurrency = pXmlNode->children->content;
            }
            else {
               pvalue->varyingNotionalCurrency = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("varyingNotionalFixingDates"))) {
            DOMTest_RelativeDateOffset_derivations (pctxt, &pvalue->varyingNotionalFixingDates, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxSpotRateSource"))) {
            DOMTest_FxSpotRateSource_derivations (pctxt, &pvalue->fxSpotRateSource, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("varyingNotionalInterimExchangePaymentDates"))) {
            DOMTest_RelativeDateOffset_derivations (pctxt, &pvalue->varyingNotionalInterimExchangePaymentDates, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Calculation_choice (OSCTXT* pctxt, Calculation_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notionalSchedule"))) {
            pvalue->t = 1;
            pvalue->u.notionalSchedule = rtxMemAllocType (pctxt, Notional);

            if (pvalue->u.notionalSchedule == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Notional (pvalue->u.notionalSchedule);
            DOMTest_Notional (pctxt, pvalue->u.notionalSchedule, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxLinkedNotionalSchedule"))) {
            pvalue->t = 2;
            pvalue->u.fxLinkedNotionalSchedule
                = rtxMemAllocType (pctxt, FxLinkedNotionalSchedule);

            if (pvalue->u.fxLinkedNotionalSchedule == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FxLinkedNotionalSchedule (pvalue->u.fxLinkedNotionalSchedule);
            DOMTest_FxLinkedNotionalSchedule (pctxt, pvalue->u.fxLinkedNotionalSchedule, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_Schedule (OSCTXT* pctxt, Schedule* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("initialValue"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->initialValue);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("step"))) {
            { Step* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Step);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Step (pdata2);
            DOMTest_Step (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->step_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_StrikeSchedule_buyer (OSCTXT* pctxt, StrikeSchedule_buyer* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      PayerReceiverEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->base);
   }

   return 0;
}

int DOMTest_StrikeSchedule_seller (OSCTXT* pctxt, 
   StrikeSchedule_seller* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      PayerReceiverEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->base);
   }

   return 0;
}

int DOMTest_StrikeSchedule (OSCTXT* pctxt, StrikeSchedule* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("initialValue"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->initialValue);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("step"))) {
            { Step* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Step);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Step (pdata2);
            DOMTest_Step (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->step_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("buyer"))) {
            pvalue->m.buyerPresent = 1;
            DOMTest_StrikeSchedule_buyer (pctxt, &pvalue->buyer, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("seller"))) {
            pvalue->m.sellerPresent = 1;
            DOMTest_StrikeSchedule_seller (pctxt, &pvalue->seller, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Schedule_derivations (OSCTXT* pctxt, Schedule_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("Schedule");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("Schedule")))
   {
      pvalue->t = 1;
      pvalue->u.schedule = rtxMemAllocType (pctxt, Schedule);

      if (pvalue->u.schedule == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Schedule (pvalue->u.schedule);
      DOMTest_Schedule (pctxt, pvalue->u.schedule, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("AmountSchedule")))
   {
      pvalue->t = 2;
      pvalue->u.amountSchedule = rtxMemAllocType (pctxt, AmountSchedule);

      if (pvalue->u.amountSchedule == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AmountSchedule (pvalue->u.amountSchedule);
      DOMTest_AmountSchedule (pctxt, pvalue->u.amountSchedule, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("StrikeSchedule")))
   {
      pvalue->t = 3;
      pvalue->u.strikeSchedule = rtxMemAllocType (pctxt, StrikeSchedule);

      if (pvalue->u.strikeSchedule == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_StrikeSchedule (pvalue->u.strikeSchedule);
      DOMTest_StrikeSchedule (pctxt, pvalue->u.strikeSchedule, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_FloatingRateIndex (OSCTXT* pctxt, FloatingRateIndex* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("floatingRateIndexScheme"))) {
            pvalue->m.floatingRateIndexSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->floatingRateIndexScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->floatingRateIndexScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_Rounding (OSCTXT* pctxt, Rounding* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("roundingDirection"))) {
            if (0 != pXmlNode->children) {
               RoundingDirectionEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->roundingDirection);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("precision"))) {
            if (0 != pXmlNode->children) {
               pvalue->precision = atoi ((const char*)pXmlNode->children->content);
            }
         }
      }
   }

   return 0;
}

int DOMTest_FloatingRateCalculation (OSCTXT* pctxt, 
   FloatingRateCalculation* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("floatingRateIndex"))) {
            DOMTest_FloatingRateIndex (pctxt, &pvalue->floatingRateIndex, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("indexTenor"))) {
            pvalue->m.indexTenorPresent = 1;
            DOMTest_Interval_derivations (pctxt, &pvalue->indexTenor, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("floatingRateMultiplierSchedule"))) {
            pvalue->m.floatingRateMultiplierSchedulePresent = 1;
            DOMTest_Schedule_derivations (pctxt, &pvalue->floatingRateMultiplierSchedule, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("spreadSchedule"))) {
            pvalue->m.spreadSchedulePresent = 1;
            DOMTest_Schedule_derivations (pctxt, &pvalue->spreadSchedule, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("rateTreatment"))) {
            pvalue->m.rateTreatmentPresent = 1;
            if (0 != pXmlNode->children) {
               RateTreatmentEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->rateTreatment);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("capRateSchedule"))) {
            { StrikeSchedule* pdata2;
            pdata2 = rtxMemAllocType (pctxt, StrikeSchedule);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_StrikeSchedule (pdata2);
            DOMTest_StrikeSchedule (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->capRateSchedule_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("floorRateSchedule"))) {
            { StrikeSchedule* pdata2;
            pdata2 = rtxMemAllocType (pctxt, StrikeSchedule);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_StrikeSchedule (pdata2);
            DOMTest_StrikeSchedule (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->floorRateSchedule_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("initialRate"))) {
            pvalue->m.initialRatePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->initialRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("finalRateRounding"))) {
            pvalue->m.finalRateRoundingPresent = 1;
            DOMTest_Rounding (pctxt, &pvalue->finalRateRounding, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("averagingMethod"))) {
            pvalue->m.averagingMethodPresent = 1;
            if (0 != pXmlNode->children) {
               AveragingMethodEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->averagingMethod);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("negativeInterestRateTreatment"))) {
            pvalue->m.negativeInterestRateTreatmentPresent = 1;
            if (0 != pXmlNode->children) {
               NegativeInterestRateTreatmentEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->negativeInterestRateTreatment);
            }
         }
      }
   }

   return 0;
}

int DOMTest_Calculation_choice_1 (OSCTXT* pctxt, Calculation_choice_1* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fixedRateSchedule"))) {
            pvalue->t = 1;
            pvalue->u.fixedRateSchedule
                = rtxMemAllocType (pctxt, Schedule_derivations);

            if (pvalue->u.fixedRateSchedule == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Schedule_derivations (pvalue->u.fixedRateSchedule);
            DOMTest_Schedule_derivations (pctxt, pvalue->u.fixedRateSchedule, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("floatingRateCalculation"))) {
            pvalue->t = 2;
            pvalue->u.floatingRateCalculation
                = rtxMemAllocType (pctxt, FloatingRateCalculation);

            if (pvalue->u.floatingRateCalculation == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FloatingRateCalculation (pvalue->u.floatingRateCalculation);
            DOMTest_FloatingRateCalculation (pctxt, pvalue->u.floatingRateCalculation, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_Discounting (OSCTXT* pctxt, Discounting* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("discountingType"))) {
            if (0 != pXmlNode->children) {
               DiscountingTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->discountingType);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("discountRate"))) {
            pvalue->m.discountRatePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->discountRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("discountRateDayCountFraction"))) {
            pvalue->m.discountRateDayCountFractionPresent = 1;
            if (0 != pXmlNode->children) {
               DayCountFractionEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->discountRateDayCountFraction);
            }
         }
      }
   }

   return 0;
}

int DOMTest_Calculation (OSCTXT* pctxt, Calculation* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notionalSchedule")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxLinkedNotionalSchedule"))) {
            DOMTest_Calculation_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fixedRateSchedule")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("floatingRateCalculation"))) {
            DOMTest_Calculation_choice_1 (pctxt, &pvalue->choice_1, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dayCountFraction"))) {
            if (0 != pXmlNode->children) {
               DayCountFractionEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->dayCountFraction);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("discounting"))) {
            pvalue->m.discountingPresent = 1;
            DOMTest_Discounting (pctxt, &pvalue->discounting, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("compoundingMethod"))) {
            pvalue->m.compoundingMethodPresent = 1;
            if (0 != pXmlNode->children) {
               CompoundingMethodEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->compoundingMethod);
            }
         }
      }
   }

   return 0;
}

int DOMTest_CalculationPeriodAmount (OSCTXT* pctxt, 
   CalculationPeriodAmount* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculation"))) {
            pvalue->t = 1;
            pvalue->u.calculation = rtxMemAllocType (pctxt, Calculation);

            if (pvalue->u.calculation == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Calculation (pvalue->u.calculation);
            DOMTest_Calculation (pctxt, pvalue->u.calculation, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("knownAmountSchedule"))) {
            pvalue->t = 2;
            pvalue->u.knownAmountSchedule
                = rtxMemAllocType (pctxt, AmountSchedule);

            if (pvalue->u.knownAmountSchedule == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountSchedule (pvalue->u.knownAmountSchedule);
            DOMTest_AmountSchedule (pctxt, pvalue->u.knownAmountSchedule, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_FloatingRate (OSCTXT* pctxt, FloatingRate* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("floatingRateIndex"))) {
            DOMTest_FloatingRateIndex (pctxt, &pvalue->floatingRateIndex, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("indexTenor"))) {
            pvalue->m.indexTenorPresent = 1;
            DOMTest_Interval_derivations (pctxt, &pvalue->indexTenor, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("floatingRateMultiplierSchedule"))) {
            pvalue->m.floatingRateMultiplierSchedulePresent = 1;
            DOMTest_Schedule_derivations (pctxt, &pvalue->floatingRateMultiplierSchedule, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("spreadSchedule"))) {
            pvalue->m.spreadSchedulePresent = 1;
            DOMTest_Schedule_derivations (pctxt, &pvalue->spreadSchedule, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("rateTreatment"))) {
            pvalue->m.rateTreatmentPresent = 1;
            if (0 != pXmlNode->children) {
               RateTreatmentEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->rateTreatment);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("capRateSchedule"))) {
            { StrikeSchedule* pdata2;
            pdata2 = rtxMemAllocType (pctxt, StrikeSchedule);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_StrikeSchedule (pdata2);
            DOMTest_StrikeSchedule (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->capRateSchedule_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("floorRateSchedule"))) {
            { StrikeSchedule* pdata2;
            pdata2 = rtxMemAllocType (pctxt, StrikeSchedule);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_StrikeSchedule (pdata2);
            DOMTest_StrikeSchedule (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->floorRateSchedule_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_FloatingRate_derivations (OSCTXT* pctxt, 
   FloatingRate_derivations* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("FloatingRate");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("FloatingRate")))
   {
      pvalue->t = 1;
      pvalue->u.floatingRate = rtxMemAllocType (pctxt, FloatingRate);

      if (pvalue->u.floatingRate == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_FloatingRate (pvalue->u.floatingRate);
      DOMTest_FloatingRate (pctxt, pvalue->u.floatingRate, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("FloatingRateCalculation")))
   {
      pvalue->t = 2;
      pvalue->u.floatingRateCalculation
          = rtxMemAllocType (pctxt, FloatingRateCalculation);

      if (pvalue->u.floatingRateCalculation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_FloatingRateCalculation (pvalue->u.floatingRateCalculation);
      DOMTest_FloatingRateCalculation (pctxt, pvalue->u.floatingRateCalculation, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_Stub (OSCTXT* pctxt, Stub* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("floatingRate"))) {
            pvalue->t = 1;
            pvalue->u.floatingRate_list = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.floatingRate_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.floatingRate_list);
            {
            FloatingRate_derivations* pdata2;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("floatingRate"))) {
                     pdata2
                         = rtxMemAllocType (pctxt, FloatingRate_derivations);

                     if (pdata2 == NULL)
                        return LOG_RTERR (pctxt, RTERR_NOMEM);

                     asn1Init_FloatingRate_derivations (pdata2);
                     DOMTest_FloatingRate_derivations (pctxt, pdata2, pXmlNode, TRUE);
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, pvalue->u.floatingRate_list, (void*)pdata2);
                  }
               }
            }
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("stubRate"))) {
            pvalue->t = 2;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->u.stubRate);
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("stubAmount"))) {
            pvalue->t = 3;
            pvalue->u.stubAmount = rtxMemAllocType (pctxt, Money_derivations);

            if (pvalue->u.stubAmount == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Money_derivations (pvalue->u.stubAmount);
            DOMTest_Money_derivations (pctxt, pvalue->u.stubAmount, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_StubCalculationPeriodAmount (OSCTXT* pctxt, 
   StubCalculationPeriodAmount* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationPeriodDatesReference"))) {
            DOMTest_DateReference (pctxt, &pvalue->calculationPeriodDatesReference, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("initialStub"))) {
            pvalue->m.initialStubPresent = 1;
            DOMTest_Stub (pctxt, &pvalue->initialStub, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("finalStub"))) {
            pvalue->m.finalStubPresent = 1;
            DOMTest_Stub (pctxt, &pvalue->finalStub, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_PrincipalExchanges (OSCTXT* pctxt, PrincipalExchanges* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("initialExchange"))) {
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->initialExchange);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("finalExchange"))) {
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->finalExchange);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("intermediateExchange"))) {
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->intermediateExchange);
            }
         }
      }
   }

   return 0;
}

int DOMTest_PrincipalExchange (OSCTXT* pctxt, PrincipalExchange* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("unadjustedPrincipalExchangeDate"))) {
            pvalue->m.unadjustedPrincipalExchangeDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->unadjustedPrincipalExchangeDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->unadjustedPrincipalExchangeDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedPrincipalExchangeDate"))) {
            pvalue->m.adjustedPrincipalExchangeDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->adjustedPrincipalExchangeDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->adjustedPrincipalExchangeDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("principalExchangeAmount"))) {
            pvalue->m.principalExchangeAmountPresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->principalExchangeAmount);
            }
         }
      }
   }

   return 0;
}

int DOMTest_FxLinkedNotionalAmount (OSCTXT* pctxt, 
   FxLinkedNotionalAmount* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("resetDate"))) {
            pvalue->m.resetDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->resetDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->resetDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedFxSpotFixingDate"))) {
            pvalue->m.adjustedFxSpotFixingDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->adjustedFxSpotFixingDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->adjustedFxSpotFixingDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("observedFxSpotRate"))) {
            pvalue->m.observedFxSpotRatePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->observedFxSpotRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notionalAmount"))) {
            pvalue->m.notionalAmountPresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->notionalAmount);
            }
         }
      }
   }

   return 0;
}

int DOMTest_CalculationPeriod_choice (OSCTXT* pctxt, 
   CalculationPeriod_choice* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notionalAmount"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->u.notionalAmount);
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxLinkedNotionalAmount"))) {
            pvalue->t = 2;
            pvalue->u.fxLinkedNotionalAmount
                = rtxMemAllocType (pctxt, FxLinkedNotionalAmount);

            if (pvalue->u.fxLinkedNotionalAmount == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FxLinkedNotionalAmount (pvalue->u.fxLinkedNotionalAmount);
            DOMTest_FxLinkedNotionalAmount (pctxt, pvalue->u.fxLinkedNotionalAmount, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_IntradocumentReference (OSCTXT* pctxt, 
   IntradocumentReference* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->href = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->href = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_RateObservation (OSCTXT* pctxt, RateObservation* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("resetDate"))) {
            pvalue->m.resetDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->resetDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->resetDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedFixingDate"))) {
            pvalue->m.adjustedFixingDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->adjustedFixingDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->adjustedFixingDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("observedRate"))) {
            pvalue->m.observedRatePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->observedRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("treatedRate"))) {
            pvalue->m.treatedRatePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->treatedRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("observationWeight"))) {
            if (0 != pXmlNode->children) {
               pvalue->observationWeight = atoi ((const char*)pXmlNode->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("rateReference"))) {
            pvalue->m.rateReferencePresent = 1;
            DOMTest_IntradocumentReference (pctxt, &pvalue->rateReference, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Strike_buyer (OSCTXT* pctxt, Strike_buyer* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      PayerReceiverEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->base);
   }

   return 0;
}

int DOMTest_Strike_seller (OSCTXT* pctxt, Strike_seller* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      PayerReceiverEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->base);
   }

   return 0;
}

int DOMTest_Strike (OSCTXT* pctxt, Strike* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("strikeRate"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->strikeRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("buyer"))) {
            pvalue->m.buyerPresent = 1;
            DOMTest_Strike_buyer (pctxt, &pvalue->buyer, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("seller"))) {
            pvalue->m.sellerPresent = 1;
            DOMTest_Strike_seller (pctxt, &pvalue->seller, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_FloatingRateDefinition (OSCTXT* pctxt, 
   FloatingRateDefinition* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculatedRate"))) {
            pvalue->m.calculatedRatePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->calculatedRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("rateObservation"))) {
            { RateObservation* pdata2;
            pdata2 = rtxMemAllocType (pctxt, RateObservation);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RateObservation (pdata2);
            DOMTest_RateObservation (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->rateObservation_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("floatingRateMultiplier"))) {
            pvalue->m.floatingRateMultiplierPresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->floatingRateMultiplier);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("spread"))) {
            pvalue->m.spreadPresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->spread);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("capRate"))) {
            { Strike* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Strike);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Strike (pdata2);
            DOMTest_Strike (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->capRate_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("floorRate"))) {
            { Strike* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Strike);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Strike (pdata2);
            DOMTest_Strike (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->floorRate_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_CalculationPeriod_choice_1 (OSCTXT* pctxt, 
   CalculationPeriod_choice_1* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("floatingRateDefinition"))) {
            pvalue->t = 1;
            pvalue->u.floatingRateDefinition
                = rtxMemAllocType (pctxt, FloatingRateDefinition);

            if (pvalue->u.floatingRateDefinition == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FloatingRateDefinition (pvalue->u.floatingRateDefinition);
            DOMTest_FloatingRateDefinition (pctxt, pvalue->u.floatingRateDefinition, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fixedRate"))) {
            pvalue->t = 2;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->u.fixedRate);
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_CalculationPeriod (OSCTXT* pctxt, CalculationPeriod* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("unadjustedStartDate"))) {
            pvalue->m.unadjustedStartDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->unadjustedStartDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->unadjustedStartDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("unadjustedEndDate"))) {
            pvalue->m.unadjustedEndDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->unadjustedEndDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->unadjustedEndDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedStartDate"))) {
            pvalue->m.adjustedStartDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->adjustedStartDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->adjustedStartDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedEndDate"))) {
            pvalue->m.adjustedEndDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->adjustedEndDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->adjustedEndDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationPeriodNumberOfDays"))) {
            pvalue->m.calculationPeriodNumberOfDaysPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->calculationPeriodNumberOfDays = atoi ((const char*)pXmlNode->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notionalAmount")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxLinkedNotionalAmount"))) {
            DOMTest_CalculationPeriod_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("floatingRateDefinition")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fixedRate"))) {
            DOMTest_CalculationPeriod_choice_1 (pctxt, &pvalue->choice_1, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_PaymentCalculationPeriod_choice (OSCTXT* pctxt, 
   PaymentCalculationPeriod_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationPeriod"))) {
            pvalue->t = 1;
            pvalue->u.calculationPeriod_list
                = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.calculationPeriod_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.calculationPeriod_list);
            {
            CalculationPeriod* pdata2;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationPeriod"))) {
                     pdata2 = rtxMemAllocType (pctxt, CalculationPeriod);

                     if (pdata2 == NULL)
                        return LOG_RTERR (pctxt, RTERR_NOMEM);

                     asn1Init_CalculationPeriod (pdata2);
                     DOMTest_CalculationPeriod (pctxt, pdata2, pXmlNode, TRUE);
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, pvalue->u.calculationPeriod_list, (void*)pdata2);
                  }
               }
            }
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fixedPaymentAmount"))) {
            pvalue->t = 2;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->u.fixedPaymentAmount);
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_PaymentCalculationPeriod (OSCTXT* pctxt, 
   PaymentCalculationPeriod* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("unadjustedPaymentDate"))) {
            pvalue->m.unadjustedPaymentDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->unadjustedPaymentDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->unadjustedPaymentDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedPaymentDate"))) {
            pvalue->m.adjustedPaymentDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->adjustedPaymentDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->adjustedPaymentDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationPeriod")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fixedPaymentAmount"))) {
            DOMTest_PaymentCalculationPeriod_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_Cashflows (OSCTXT* pctxt, Cashflows* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("cashflowsMatchParameters"))) {
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->cashflowsMatchParameters);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("principalExchange"))) {
            { PrincipalExchange* pdata2;
            pdata2 = rtxMemAllocType (pctxt, PrincipalExchange);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PrincipalExchange (pdata2);
            DOMTest_PrincipalExchange (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->principalExchange_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("paymentCalculationPeriod"))) {
            { PaymentCalculationPeriod* pdata2;
            pdata2 = rtxMemAllocType (pctxt, PaymentCalculationPeriod);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PaymentCalculationPeriod (pdata2);
            DOMTest_PaymentCalculationPeriod (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->paymentCalculationPeriod_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_InterestRateStream (OSCTXT* pctxt, InterestRateStream* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("payerPartyReference"))) {
            DOMTest_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationPeriodDates"))) {
            DOMTest_CalculationPeriodDates (pctxt, &pvalue->calculationPeriodDates, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("paymentDates"))) {
            DOMTest_PaymentDates (pctxt, &pvalue->paymentDates, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("resetDates"))) {
            pvalue->m.resetDatesPresent = 1;
            DOMTest_ResetDates (pctxt, &pvalue->resetDates, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationPeriodAmount"))) {
            DOMTest_CalculationPeriodAmount (pctxt, &pvalue->calculationPeriodAmount, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("stubCalculationPeriodAmount"))) {
            pvalue->m.stubCalculationPeriodAmountPresent = 1;
            DOMTest_StubCalculationPeriodAmount (pctxt, &pvalue->stubCalculationPeriodAmount, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("principalExchanges"))) {
            pvalue->m.principalExchangesPresent = 1;
            DOMTest_PrincipalExchanges (pctxt, &pvalue->principalExchanges, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("cashflows"))) {
            pvalue->m.cashflowsPresent = 1;
            DOMTest_Cashflows (pctxt, &pvalue->cashflows, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_CapFloor (OSCTXT* pctxt, CapFloor* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productType"))) {
            pvalue->m.productTypePresent = 1;
            DOMTest_ProductType (pctxt, &pvalue->productType, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productId"))) {
            { ProductId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ProductId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ProductId (pdata2);
            DOMTest_ProductId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->productId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("capFloorStream"))) {
            DOMTest_InterestRateStream (pctxt, &pvalue->capFloorStream, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("premium"))) {
            { Payment* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Payment);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Payment (pdata2);
            DOMTest_Payment (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->premium_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("additionalPayment"))) {
            { Payment* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Payment);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Payment (pdata2);
            DOMTest_Payment (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->additionalPayment_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_Fra_adjustedEffectiveDate (OSCTXT* pctxt, 
   Fra_adjustedEffectiveDate* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = (const char*)pXmlNode->children->content;
   }
   else {
      pvalue->base = "";
   }

   return 0;
}

int DOMTest_Fra (OSCTXT* pctxt, Fra* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productType"))) {
            pvalue->m.productTypePresent = 1;
            DOMTest_ProductType (pctxt, &pvalue->productType, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productId"))) {
            { ProductId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ProductId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ProductId (pdata2);
            DOMTest_ProductId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->productId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("buyerPartyReference"))) {
            DOMTest_BuyerSeller_model (pctxt, &pvalue->buyerSeller_model, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedEffectiveDate"))) {
            DOMTest_Fra_adjustedEffectiveDate (pctxt, &pvalue->adjustedEffectiveDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedTerminationDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->adjustedTerminationDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->adjustedTerminationDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("paymentDate"))) {
            DOMTest_AdjustableDate (pctxt, &pvalue->paymentDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fixingDateOffset"))) {
            DOMTest_RelativeDateOffset_derivations (pctxt, &pvalue->fixingDateOffset, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dayCountFraction"))) {
            if (0 != pXmlNode->children) {
               DayCountFractionEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->dayCountFraction);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationPeriodNumberOfDays"))) {
            if (0 != pXmlNode->children) {
               pvalue->calculationPeriodNumberOfDays = atoi ((const char*)pXmlNode->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notional"))) {
            DOMTest_Money_derivations (pctxt, &pvalue->notional, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fixedRate"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->fixedRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("floatingRateIndex"))) {
            DOMTest_FloatingRateIndex (pctxt, &pvalue->floatingRateIndex, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("indexTenor"))) {
            pvalue->m.indexTenorPresent = 1;
            DOMTest_Interval_derivations (pctxt, &pvalue->indexTenor, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fraDiscounting"))) {
            if (0 != pXmlNode->children) {
               FraDiscountingEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->fraDiscounting);
            }
         }
      }
   }

   return 0;
}

int DOMTest_CalculationAgent (OSCTXT* pctxt, CalculationAgent* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationAgentPartyReference"))) {
            pvalue->t = 1;
            pvalue->u.calculationAgentPartyReference_list
                = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.calculationAgentPartyReference_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.calculationAgentPartyReference_list);
            {
            PartyReference* pdata2;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationAgentPartyReference"))) {
                     pdata2 = rtxMemAllocType (pctxt, PartyReference);

                     if (pdata2 == NULL)
                        return LOG_RTERR (pctxt, RTERR_NOMEM);

                     asn1Init_PartyReference (pdata2);
                     DOMTest_PartyReference (pctxt, pdata2, pXmlNode, TRUE);
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, pvalue->u.calculationAgentPartyReference_list, (void*)pdata2);
                  }
               }
            }
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationAgentParty"))) {
            pvalue->t = 2;
            if (0 != pXmlNode->children) {
               CalculationAgentPartyEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->u.calculationAgentParty);
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_AdjustableDates_unadjustedDate (OSCTXT* pctxt, 
   AdjustableDates_unadjustedDate* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = (const char*)pXmlNode->children->content;
   }
   else {
      pvalue->base = "";
   }

   return 0;
}

int DOMTest_AdjustableDates (OSCTXT* pctxt, AdjustableDates* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("unadjustedDate"))) {
            { AdjustableDates_unadjustedDate* pdata2;
            pdata2 = rtxMemAllocType (pctxt, AdjustableDates_unadjustedDate);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AdjustableDates_unadjustedDate (pdata2);
            DOMTest_AdjustableDates_unadjustedDate (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->unadjustedDate_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dateAdjustments"))) {
            DOMTest_BusinessDayAdjustments (pctxt, &pvalue->dateAdjustments, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_CashSettlementPaymentDate_choice (OSCTXT* pctxt, 
   CashSettlementPaymentDate_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustableDates"))) {
            pvalue->t = 1;
            pvalue->u.adjustableDates
                = rtxMemAllocType (pctxt, AdjustableDates);

            if (pvalue->u.adjustableDates == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AdjustableDates (pvalue->u.adjustableDates);
            DOMTest_AdjustableDates (pctxt, pvalue->u.adjustableDates, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relativeDate"))) {
            pvalue->t = 2;
            pvalue->u.relativeDate
                = rtxMemAllocType (pctxt, RelativeDateOffset_derivations);

            if (pvalue->u.relativeDate == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RelativeDateOffset_derivations (pvalue->u.relativeDate);
            DOMTest_RelativeDateOffset_derivations (pctxt, pvalue->u.relativeDate, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessDateRange"))) {
            pvalue->t = 3;
            pvalue->u.businessDateRange
                = rtxMemAllocType (pctxt, BusinessDateRange);

            if (pvalue->u.businessDateRange == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BusinessDateRange (pvalue->u.businessDateRange);
            DOMTest_BusinessDateRange (pctxt, pvalue->u.businessDateRange, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_CashSettlementPaymentDate (OSCTXT* pctxt, 
   CashSettlementPaymentDate* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustableDates")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relativeDate")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessDateRange"))) {
            DOMTest_CashSettlementPaymentDate_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_ReferenceBankId (OSCTXT* pctxt, ReferenceBankId* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("referenceBankIdScheme"))) {
            pvalue->m.referenceBankIdSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->referenceBankIdScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->referenceBankIdScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_ReferenceBank (OSCTXT* pctxt, ReferenceBank* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("referenceBankId"))) {
            DOMTest_ReferenceBankId (pctxt, &pvalue->referenceBankId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("referenceBankName"))) {
            pvalue->m.referenceBankNamePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->referenceBankName = pXmlNode->children->content;
            }
            else {
               pvalue->referenceBankName = (const OSUTF8CHAR*)"";
            }
         }
      }
   }

   return 0;
}

int DOMTest_CashSettlementReferenceBanks (OSCTXT* pctxt, 
   CashSettlementReferenceBanks* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("referenceBank"))) {
            { ReferenceBank* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ReferenceBank);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ReferenceBank (pdata2);
            DOMTest_ReferenceBank (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->referenceBank_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_CashPriceMethod (OSCTXT* pctxt, CashPriceMethod* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("cashSettlementReferenceBanks"))) {
            pvalue->m.cashSettlementReferenceBanksPresent = 1;
            DOMTest_CashSettlementReferenceBanks (pctxt, &pvalue->cashSettlementReferenceBanks, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("cashSettlementCurrency"))) {
            DOMTest_Currency (pctxt, &pvalue->cashSettlementCurrency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("quotationRateType"))) {
            if (0 != pXmlNode->children) {
               QuotationRateTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->quotationRateType);
            }
         }
      }
   }

   return 0;
}

int DOMTest_SettlementRateSource (OSCTXT* pctxt, SettlementRateSource* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("informationSource"))) {
            pvalue->t = 1;
            pvalue->u.informationSource
                = rtxMemAllocType (pctxt, InformationSource);

            if (pvalue->u.informationSource == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InformationSource (pvalue->u.informationSource);
            DOMTest_InformationSource (pctxt, pvalue->u.informationSource, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("cashSettlementReferenceBanks"))) {
            pvalue->t = 2;
            pvalue->u.cashSettlementReferenceBanks
                = rtxMemAllocType (pctxt, CashSettlementReferenceBanks);

            if (pvalue->u.cashSettlementReferenceBanks == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CashSettlementReferenceBanks (pvalue->u.cashSettlementReferenceBanks);
            DOMTest_CashSettlementReferenceBanks (pctxt, pvalue->u.cashSettlementReferenceBanks, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_YieldCurveMethod (OSCTXT* pctxt, YieldCurveMethod* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("settlementRateSource"))) {
            pvalue->m.settlementRateSourcePresent = 1;
            DOMTest_SettlementRateSource (pctxt, &pvalue->settlementRateSource, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("quotationRateType"))) {
            if (0 != pXmlNode->children) {
               QuotationRateTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->quotationRateType);
            }
         }
      }
   }

   return 0;
}

int DOMTest_CashSettlement_choice (OSCTXT* pctxt, 
   CashSettlement_choice* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("cashPriceMethod"))) {
            pvalue->t = 1;
            pvalue->u.cashPriceMethod
                = rtxMemAllocType (pctxt, CashPriceMethod);

            if (pvalue->u.cashPriceMethod == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CashPriceMethod (pvalue->u.cashPriceMethod);
            DOMTest_CashPriceMethod (pctxt, pvalue->u.cashPriceMethod, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("cashPriceAlternateMethod"))) {
            pvalue->t = 2;
            pvalue->u.cashPriceAlternateMethod
                = rtxMemAllocType (pctxt, CashPriceMethod);

            if (pvalue->u.cashPriceAlternateMethod == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CashPriceMethod (pvalue->u.cashPriceAlternateMethod);
            DOMTest_CashPriceMethod (pctxt, pvalue->u.cashPriceAlternateMethod, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("parYieldCurveAdjustedMethod"))) {
            pvalue->t = 3;
            pvalue->u.parYieldCurveAdjustedMethod
                = rtxMemAllocType (pctxt, YieldCurveMethod);

            if (pvalue->u.parYieldCurveAdjustedMethod == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_YieldCurveMethod (pvalue->u.parYieldCurveAdjustedMethod);
            DOMTest_YieldCurveMethod (pctxt, pvalue->u.parYieldCurveAdjustedMethod, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("zeroCouponYieldAdjustedMethod"))) {
            pvalue->t = 4;
            pvalue->u.zeroCouponYieldAdjustedMethod
                = rtxMemAllocType (pctxt, YieldCurveMethod);

            if (pvalue->u.zeroCouponYieldAdjustedMethod == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_YieldCurveMethod (pvalue->u.zeroCouponYieldAdjustedMethod);
            DOMTest_YieldCurveMethod (pctxt, pvalue->u.zeroCouponYieldAdjustedMethod, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("parYieldCurveUnadjustedMethod"))) {
            pvalue->t = 5;
            pvalue->u.parYieldCurveUnadjustedMethod
                = rtxMemAllocType (pctxt, YieldCurveMethod);

            if (pvalue->u.parYieldCurveUnadjustedMethod == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_YieldCurveMethod (pvalue->u.parYieldCurveUnadjustedMethod);
            DOMTest_YieldCurveMethod (pctxt, pvalue->u.parYieldCurveUnadjustedMethod, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_CashSettlement (OSCTXT* pctxt, CashSettlement* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("cashSettlementValuationTime"))) {
            DOMTest_BusinessCenterTime (pctxt, &pvalue->cashSettlementValuationTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("cashSettlementValuationDate"))) {
            DOMTest_RelativeDateOffset_derivations (pctxt, &pvalue->cashSettlementValuationDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("cashSettlementPaymentDate"))) {
            pvalue->m.cashSettlementPaymentDatePresent = 1;
            DOMTest_CashSettlementPaymentDate (pctxt, &pvalue->cashSettlementPaymentDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("cashPriceMethod")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("cashPriceAlternateMethod")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("parYieldCurveAdjustedMethod")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("zeroCouponYieldAdjustedMethod")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("parYieldCurveUnadjustedMethod"))) {
            DOMTest_CashSettlement_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_MandatoryEarlyTerminationAdjustedDates (OSCTXT* pctxt, 
   MandatoryEarlyTerminationAdjustedDates* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedEarlyTerminationDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->adjustedEarlyTerminationDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->adjustedEarlyTerminationDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedCashSettlementValuationDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->adjustedCashSettlementValuationDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->adjustedCashSettlementValuationDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedCashSettlementPaymentDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->adjustedCashSettlementPaymentDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->adjustedCashSettlementPaymentDate = "";
            }
         }
      }
   }

   return 0;
}

int DOMTest_MandatoryEarlyTermination (OSCTXT* pctxt, 
   MandatoryEarlyTermination* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("mandatoryEarlyTerminationDate"))) {
            DOMTest_AdjustableDate (pctxt, &pvalue->mandatoryEarlyTerminationDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationAgent"))) {
            DOMTest_CalculationAgent (pctxt, &pvalue->calculationAgent, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("cashSettlement"))) {
            DOMTest_CashSettlement (pctxt, &pvalue->cashSettlement, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("mandatoryEarlyTerminationAdjustedDates"))) {
            pvalue->m.mandatoryEarlyTerminationAdjustedDatesPresent = 1;
            DOMTest_MandatoryEarlyTerminationAdjustedDates (pctxt, &pvalue->mandatoryEarlyTerminationAdjustedDates, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_SinglePartyOption (OSCTXT* pctxt, SinglePartyOption* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_BuyerSeller_model (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_AdjustableOrRelativeDate_choice (OSCTXT* pctxt, 
   AdjustableOrRelativeDate_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustableDate"))) {
            pvalue->t = 1;
            pvalue->u.adjustableDate
                = rtxMemAllocType (pctxt, AdjustableDate);

            if (pvalue->u.adjustableDate == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AdjustableDate (pvalue->u.adjustableDate);
            DOMTest_AdjustableDate (pctxt, pvalue->u.adjustableDate, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relativeDate"))) {
            pvalue->t = 2;
            pvalue->u.relativeDate
                = rtxMemAllocType (pctxt, RelativeDateOffset_derivations);

            if (pvalue->u.relativeDate == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RelativeDateOffset_derivations (pvalue->u.relativeDate);
            DOMTest_RelativeDateOffset_derivations (pctxt, pvalue->u.relativeDate, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_AdjustableOrRelativeDate (OSCTXT* pctxt, 
   AdjustableOrRelativeDate* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustableDate")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relativeDate"))) {
            DOMTest_AdjustableOrRelativeDate_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_AdjustableOrRelativeDates_choice (OSCTXT* pctxt, 
   AdjustableOrRelativeDates_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustableDates"))) {
            pvalue->t = 1;
            pvalue->u.adjustableDates
                = rtxMemAllocType (pctxt, AdjustableDates);

            if (pvalue->u.adjustableDates == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AdjustableDates (pvalue->u.adjustableDates);
            DOMTest_AdjustableDates (pctxt, pvalue->u.adjustableDates, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relativeDates"))) {
            pvalue->t = 2;
            pvalue->u.relativeDates = rtxMemAllocType (pctxt, RelativeDates);

            if (pvalue->u.relativeDates == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RelativeDates (pvalue->u.relativeDates);
            DOMTest_RelativeDates (pctxt, pvalue->u.relativeDates, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_AdjustableOrRelativeDates (OSCTXT* pctxt, 
   AdjustableOrRelativeDates* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustableDates")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relativeDates"))) {
            DOMTest_AdjustableOrRelativeDates_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_MultipleExercise (OSCTXT* pctxt, MultipleExercise* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notionalReference"))) {
            { NotionalReference* pdata2;
            pdata2 = rtxMemAllocType (pctxt, NotionalReference);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NotionalReference (pdata2);
            DOMTest_NotionalReference (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->notionalReference_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("integralMultipleAmount"))) {
            pvalue->m.integralMultipleAmountPresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->integralMultipleAmount);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("minimumNotionalAmount"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->minimumNotionalAmount);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("maximumNotionalAmount"))) {
            pvalue->m.maximumNotionalAmountPresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->maximumNotionalAmount);
            }
         }
      }
   }

   return 0;
}

int DOMTest_ExerciseFeeSchedule_choice (OSCTXT* pctxt, 
   ExerciseFeeSchedule_choice* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("feeAmountSchedule"))) {
            pvalue->t = 1;
            pvalue->u.feeAmountSchedule
                = rtxMemAllocType (pctxt, AmountSchedule);

            if (pvalue->u.feeAmountSchedule == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountSchedule (pvalue->u.feeAmountSchedule);
            DOMTest_AmountSchedule (pctxt, pvalue->u.feeAmountSchedule, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("feeRateSchedule"))) {
            pvalue->t = 2;
            pvalue->u.feeRateSchedule
                = rtxMemAllocType (pctxt, Schedule_derivations);

            if (pvalue->u.feeRateSchedule == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Schedule_derivations (pvalue->u.feeRateSchedule);
            DOMTest_Schedule_derivations (pctxt, pvalue->u.feeRateSchedule, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_ExerciseFeeSchedule (OSCTXT* pctxt, ExerciseFeeSchedule* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("payerPartyReference"))) {
            DOMTest_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notionalReference"))) {
            DOMTest_NotionalReference (pctxt, &pvalue->notionalReference, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("feeAmountSchedule")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("feeRateSchedule"))) {
            DOMTest_ExerciseFeeSchedule_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("feePaymentDate"))) {
            DOMTest_RelativeDateOffset_derivations (pctxt, &pvalue->feePaymentDate, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_AmericanExercise (OSCTXT* pctxt, AmericanExercise* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("commencementDate"))) {
            DOMTest_AdjustableOrRelativeDate (pctxt, &pvalue->commencementDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("expirationDate"))) {
            DOMTest_AdjustableOrRelativeDate (pctxt, &pvalue->expirationDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relevantUnderlyingDate"))) {
            pvalue->m.relevantUnderlyingDatePresent = 1;
            DOMTest_AdjustableOrRelativeDates (pctxt, &pvalue->relevantUnderlyingDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("earliestExerciseTime"))) {
            DOMTest_BusinessCenterTime (pctxt, &pvalue->earliestExerciseTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("latestExerciseTime"))) {
            pvalue->m.latestExerciseTimePresent = 1;
            DOMTest_BusinessCenterTime (pctxt, &pvalue->latestExerciseTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("expirationTime"))) {
            DOMTest_BusinessCenterTime (pctxt, &pvalue->expirationTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("multipleExercise"))) {
            pvalue->m.multipleExercisePresent = 1;
            DOMTest_MultipleExercise (pctxt, &pvalue->multipleExercise, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exerciseFeeSchedule"))) {
            pvalue->m.exerciseFeeSchedulePresent = 1;
            DOMTest_ExerciseFeeSchedule (pctxt, &pvalue->exerciseFeeSchedule, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_BermudaExercise (OSCTXT* pctxt, BermudaExercise* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("bermudaExerciseDates"))) {
            DOMTest_AdjustableOrRelativeDates (pctxt, &pvalue->bermudaExerciseDates, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relevantUnderlyingDate"))) {
            pvalue->m.relevantUnderlyingDatePresent = 1;
            DOMTest_AdjustableOrRelativeDates (pctxt, &pvalue->relevantUnderlyingDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("earliestExerciseTime"))) {
            DOMTest_BusinessCenterTime (pctxt, &pvalue->earliestExerciseTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("latestExerciseTime"))) {
            pvalue->m.latestExerciseTimePresent = 1;
            DOMTest_BusinessCenterTime (pctxt, &pvalue->latestExerciseTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("expirationTime"))) {
            DOMTest_BusinessCenterTime (pctxt, &pvalue->expirationTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("multipleExercise"))) {
            pvalue->m.multipleExercisePresent = 1;
            DOMTest_MultipleExercise (pctxt, &pvalue->multipleExercise, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exerciseFeeSchedule"))) {
            pvalue->m.exerciseFeeSchedulePresent = 1;
            DOMTest_ExerciseFeeSchedule (pctxt, &pvalue->exerciseFeeSchedule, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_PartialExercise (OSCTXT* pctxt, PartialExercise* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notionalReference"))) {
            { NotionalReference* pdata2;
            pdata2 = rtxMemAllocType (pctxt, NotionalReference);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NotionalReference (pdata2);
            DOMTest_NotionalReference (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->notionalReference_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("integralMultipleAmount"))) {
            pvalue->m.integralMultipleAmountPresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->integralMultipleAmount);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("minimumNotionalAmount"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->minimumNotionalAmount);
            }
         }
      }
   }

   return 0;
}

int DOMTest_PartialExercise_derivations (OSCTXT* pctxt, 
   PartialExercise_derivations* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("PartialExercise");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("PartialExercise")))
   {
      pvalue->t = 1;
      pvalue->u.partialExercise = rtxMemAllocType (pctxt, PartialExercise);

      if (pvalue->u.partialExercise == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PartialExercise (pvalue->u.partialExercise);
      DOMTest_PartialExercise (pctxt, pvalue->u.partialExercise, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("MultipleExercise")))
   {
      pvalue->t = 2;
      pvalue->u.multipleExercise = rtxMemAllocType (pctxt, MultipleExercise);

      if (pvalue->u.multipleExercise == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MultipleExercise (pvalue->u.multipleExercise);
      DOMTest_MultipleExercise (pctxt, pvalue->u.multipleExercise, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_ExerciseFee_choice (OSCTXT* pctxt, ExerciseFee_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("feeAmount"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->u.feeAmount);
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("feeRate"))) {
            pvalue->t = 2;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->u.feeRate);
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_ExerciseFee (OSCTXT* pctxt, ExerciseFee* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("payerPartyReference"))) {
            DOMTest_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notionalReference"))) {
            DOMTest_NotionalReference (pctxt, &pvalue->notionalReference, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("feeAmount")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("feeRate"))) {
            DOMTest_ExerciseFee_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("feePaymentDate"))) {
            DOMTest_RelativeDateOffset_derivations (pctxt, &pvalue->feePaymentDate, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EuropeanExercise (OSCTXT* pctxt, EuropeanExercise* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("expirationDate"))) {
            DOMTest_AdjustableOrRelativeDate (pctxt, &pvalue->expirationDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relevantUnderlyingDate"))) {
            pvalue->m.relevantUnderlyingDatePresent = 1;
            DOMTest_AdjustableOrRelativeDates (pctxt, &pvalue->relevantUnderlyingDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("earliestExerciseTime"))) {
            DOMTest_BusinessCenterTime (pctxt, &pvalue->earliestExerciseTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("expirationTime"))) {
            DOMTest_BusinessCenterTime (pctxt, &pvalue->expirationTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("partialExercise"))) {
            pvalue->m.partialExercisePresent = 1;
            DOMTest_PartialExercise_derivations (pctxt, &pvalue->partialExercise, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exerciseFee"))) {
            pvalue->m.exerciseFeePresent = 1;
            DOMTest_ExerciseFee (pctxt, &pvalue->exerciseFee, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Exercise_group (OSCTXT* pctxt, Exercise_group* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("americanExercise"))) {
            pvalue->t = 1;
            pvalue->u.americanExercise
                = rtxMemAllocType (pctxt, AmericanExercise);

            if (pvalue->u.americanExercise == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmericanExercise (pvalue->u.americanExercise);
            DOMTest_AmericanExercise (pctxt, pvalue->u.americanExercise, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("bermudaExercise"))) {
            pvalue->t = 2;
            pvalue->u.bermudaExercise
                = rtxMemAllocType (pctxt, BermudaExercise);

            if (pvalue->u.bermudaExercise == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BermudaExercise (pvalue->u.bermudaExercise);
            DOMTest_BermudaExercise (pctxt, pvalue->u.bermudaExercise, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("europeanExercise"))) {
            pvalue->t = 3;
            pvalue->u.europeanExercise
                = rtxMemAllocType (pctxt, EuropeanExercise);

            if (pvalue->u.europeanExercise == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_EuropeanExercise (pvalue->u.europeanExercise);
            DOMTest_EuropeanExercise (pctxt, pvalue->u.europeanExercise, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_ExerciseNotice (OSCTXT* pctxt, ExerciseNotice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("partyReference"))) {
            DOMTest_PartyReference (pctxt, &pvalue->partyReference, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exerciseNoticePartyReference"))) {
            pvalue->m.exerciseNoticePartyReferencePresent = 1;
            DOMTest_PartyReference (pctxt, &pvalue->exerciseNoticePartyReference, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessCenter"))) {
            DOMTest_BusinessCenter (pctxt, &pvalue->businessCenter, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EarlyTerminationEvent (OSCTXT* pctxt, 
   EarlyTerminationEvent* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedExerciseDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->adjustedExerciseDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->adjustedExerciseDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedEarlyTerminationDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->adjustedEarlyTerminationDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->adjustedEarlyTerminationDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedCashSettlementValuationDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->adjustedCashSettlementValuationDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->adjustedCashSettlementValuationDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedCashSettlementPaymentDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->adjustedCashSettlementPaymentDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->adjustedCashSettlementPaymentDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedExerciseFeePaymentDate"))) {
            pvalue->m.adjustedExerciseFeePaymentDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->adjustedExerciseFeePaymentDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->adjustedExerciseFeePaymentDate = "";
            }
         }
      }
   }

   return 0;
}

int DOMTest_OptionalEarlyTerminationAdjustedDates (OSCTXT* pctxt, 
   OptionalEarlyTerminationAdjustedDates* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   EarlyTerminationEvent* pdata1;
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("earlyTerminationEvent"))) {
            pdata1 = rtxMemAllocType (pctxt, EarlyTerminationEvent);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_EarlyTerminationEvent (pdata1);
            DOMTest_EarlyTerminationEvent (pctxt, pdata1, pXmlNode, TRUE);
            if (0 != pdata1)
               rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         }
      }
   }

   return 0;
}

int DOMTest_OptionalEarlyTermination (OSCTXT* pctxt, 
   OptionalEarlyTermination* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("singlePartyOption"))) {
            pvalue->m.singlePartyOptionPresent = 1;
            DOMTest_SinglePartyOption (pctxt, &pvalue->singlePartyOption, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("americanExercise")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("bermudaExercise")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("europeanExercise"))) {
            DOMTest_Exercise_group (pctxt, &pvalue->exercise, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exerciseNotice"))) {
            { ExerciseNotice* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ExerciseNotice);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ExerciseNotice (pdata2);
            DOMTest_ExerciseNotice (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->exerciseNotice_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("followUpConfirmation"))) {
            pvalue->m.followUpConfirmationPresent = 1;
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->followUpConfirmation);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationAgent"))) {
            DOMTest_CalculationAgent (pctxt, &pvalue->calculationAgent, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("cashSettlement"))) {
            DOMTest_CashSettlement (pctxt, &pvalue->cashSettlement, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("optionalEarlyTerminationAdjustedDates"))) {
            pvalue->m.optionalEarlyTerminationAdjustedDatesPresent = 1;
            DOMTest_OptionalEarlyTerminationAdjustedDates (pctxt, &pvalue->optionalEarlyTerminationAdjustedDates, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EarlyTerminationProvision_choice (OSCTXT* pctxt, 
   EarlyTerminationProvision_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("mandatoryEarlyTermination"))) {
            pvalue->t = 1;
            pvalue->u.mandatoryEarlyTermination
                = rtxMemAllocType (pctxt, MandatoryEarlyTermination);

            if (pvalue->u.mandatoryEarlyTermination == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MandatoryEarlyTermination (pvalue->u.mandatoryEarlyTermination);
            DOMTest_MandatoryEarlyTermination (pctxt, pvalue->u.mandatoryEarlyTermination, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("optionalEarlyTermination"))) {
            pvalue->t = 2;
            pvalue->u.optionalEarlyTermination
                = rtxMemAllocType (pctxt, OptionalEarlyTermination);

            if (pvalue->u.optionalEarlyTermination == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_OptionalEarlyTermination (pvalue->u.optionalEarlyTermination);
            DOMTest_OptionalEarlyTermination (pctxt, pvalue->u.optionalEarlyTermination, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EarlyTerminationProvision (OSCTXT* pctxt, 
   EarlyTerminationProvision* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("mandatoryEarlyTermination")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("optionalEarlyTermination"))) {
            DOMTest_EarlyTerminationProvision_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_CancellationEvent (OSCTXT* pctxt, CancellationEvent* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedExerciseDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->adjustedExerciseDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->adjustedExerciseDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedEarlyTerminationDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->adjustedEarlyTerminationDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->adjustedEarlyTerminationDate = "";
            }
         }
      }
   }

   return 0;
}

int DOMTest_CancelableProvisionAdjustedDates (OSCTXT* pctxt, 
   CancelableProvisionAdjustedDates* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   CancellationEvent* pdata1;
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("cancellationEvent"))) {
            pdata1 = rtxMemAllocType (pctxt, CancellationEvent);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CancellationEvent (pdata1);
            DOMTest_CancellationEvent (pctxt, pdata1, pXmlNode, TRUE);
            if (0 != pdata1)
               rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         }
      }
   }

   return 0;
}

int DOMTest_CancelableProvision (OSCTXT* pctxt, CancelableProvision* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("buyerPartyReference"))) {
            DOMTest_BuyerSeller_model (pctxt, &pvalue->buyerSeller_model, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("americanExercise")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("bermudaExercise")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("europeanExercise"))) {
            DOMTest_Exercise_group (pctxt, &pvalue->exercise, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exerciseNotice"))) {
            pvalue->m.exerciseNoticePresent = 1;
            DOMTest_ExerciseNotice (pctxt, &pvalue->exerciseNotice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("followUpConfirmation"))) {
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->followUpConfirmation);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("cancelableProvisionAdjustedDates"))) {
            pvalue->m.cancelableProvisionAdjustedDatesPresent = 1;
            DOMTest_CancelableProvisionAdjustedDates (pctxt, &pvalue->cancelableProvisionAdjustedDates, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_ExtensionEvent (OSCTXT* pctxt, ExtensionEvent* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedExerciseDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->adjustedExerciseDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->adjustedExerciseDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedExtendedTerminationDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->adjustedExtendedTerminationDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->adjustedExtendedTerminationDate = "";
            }
         }
      }
   }

   return 0;
}

int DOMTest_ExtendibleProvisionAdjustedDates (OSCTXT* pctxt, 
   ExtendibleProvisionAdjustedDates* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   ExtensionEvent* pdata1;
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("extensionEvent"))) {
            pdata1 = rtxMemAllocType (pctxt, ExtensionEvent);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ExtensionEvent (pdata1);
            DOMTest_ExtensionEvent (pctxt, pdata1, pXmlNode, TRUE);
            if (0 != pdata1)
               rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         }
      }
   }

   return 0;
}

int DOMTest_ExtendibleProvision (OSCTXT* pctxt, ExtendibleProvision* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("buyerPartyReference"))) {
            DOMTest_BuyerSeller_model (pctxt, &pvalue->buyerSeller_model, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("americanExercise")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("bermudaExercise")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("europeanExercise"))) {
            DOMTest_Exercise_group (pctxt, &pvalue->exercise, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exerciseNotice"))) {
            pvalue->m.exerciseNoticePresent = 1;
            DOMTest_ExerciseNotice (pctxt, &pvalue->exerciseNotice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("followUpConfirmation"))) {
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->followUpConfirmation);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("extendibleProvisionAdjustedDates"))) {
            pvalue->m.extendibleProvisionAdjustedDatesPresent = 1;
            DOMTest_ExtendibleProvisionAdjustedDates (pctxt, &pvalue->extendibleProvisionAdjustedDates, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Swap (OSCTXT* pctxt, Swap* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productType"))) {
            pvalue->m.productTypePresent = 1;
            DOMTest_ProductType (pctxt, &pvalue->productType, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productId"))) {
            { ProductId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ProductId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ProductId (pdata2);
            DOMTest_ProductId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->productId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("swapStream"))) {
            { InterestRateStream* pdata2;
            pdata2 = rtxMemAllocType (pctxt, InterestRateStream);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InterestRateStream (pdata2);
            DOMTest_InterestRateStream (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->swapStream_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("earlyTerminationProvision"))) {
            pvalue->m.earlyTerminationProvisionPresent = 1;
            DOMTest_EarlyTerminationProvision (pctxt, &pvalue->earlyTerminationProvision, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("cancelableProvision"))) {
            pvalue->m.cancelableProvisionPresent = 1;
            DOMTest_CancelableProvision (pctxt, &pvalue->cancelableProvision, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("extendibleProvision"))) {
            pvalue->m.extendibleProvisionPresent = 1;
            DOMTest_ExtendibleProvision (pctxt, &pvalue->extendibleProvision, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("additionalPayment"))) {
            { Payment* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Payment);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Payment (pdata2);
            DOMTest_Payment (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->additionalPayment_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_ManualExercise (OSCTXT* pctxt, ManualExercise* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exerciseNotice"))) {
            pvalue->m.exerciseNoticePresent = 1;
            DOMTest_ExerciseNotice (pctxt, &pvalue->exerciseNotice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fallbackExercise"))) {
            pvalue->m.fallbackExercisePresent = 1;
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->fallbackExercise);
            }
         }
      }
   }

   return 0;
}

int DOMTest_ExerciseProcedure_choice (OSCTXT* pctxt, 
   ExerciseProcedure_choice* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("manualExercise"))) {
            pvalue->t = 1;
            pvalue->u.manualExercise
                = rtxMemAllocType (pctxt, ManualExercise);

            if (pvalue->u.manualExercise == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ManualExercise (pvalue->u.manualExercise);
            DOMTest_ManualExercise (pctxt, pvalue->u.manualExercise, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("automaticExercise"))) {
            pvalue->t = 2;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->u.automaticExercise);
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_ExerciseProcedure (OSCTXT* pctxt, ExerciseProcedure* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("manualExercise")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("automaticExercise"))) {
            DOMTest_ExerciseProcedure_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("followUpConfirmation"))) {
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->followUpConfirmation);
            }
         }
      }
   }

   return 0;
}

int DOMTest_ExerciseEvent (OSCTXT* pctxt, ExerciseEvent* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedExerciseDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->adjustedExerciseDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->adjustedExerciseDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedRelevantSwapEffectiveDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->adjustedRelevantSwapEffectiveDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->adjustedRelevantSwapEffectiveDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedCashSettlementValuationDate"))) {
            pvalue->m.adjustedCashSettlementValuationDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->adjustedCashSettlementValuationDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->adjustedCashSettlementValuationDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedCashSettlementPaymentDate"))) {
            pvalue->m.adjustedCashSettlementPaymentDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->adjustedCashSettlementPaymentDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->adjustedCashSettlementPaymentDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedExerciseFeePaymentDate"))) {
            pvalue->m.adjustedExerciseFeePaymentDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->adjustedExerciseFeePaymentDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->adjustedExerciseFeePaymentDate = "";
            }
         }
      }
   }

   return 0;
}

int DOMTest_SwaptionAdjustedDates (OSCTXT* pctxt, 
   SwaptionAdjustedDates* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   ExerciseEvent* pdata1;
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exerciseEvent"))) {
            pdata1 = rtxMemAllocType (pctxt, ExerciseEvent);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ExerciseEvent (pdata1);
            DOMTest_ExerciseEvent (pctxt, pdata1, pXmlNode, TRUE);
            if (0 != pdata1)
               rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         }
      }
   }

   return 0;
}

int DOMTest_Swaption (OSCTXT* pctxt, Swaption* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productType"))) {
            pvalue->m.productTypePresent = 1;
            DOMTest_ProductType (pctxt, &pvalue->productType, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productId"))) {
            { ProductId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ProductId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ProductId (pdata2);
            DOMTest_ProductId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->productId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("buyerPartyReference"))) {
            DOMTest_BuyerSeller_model (pctxt, &pvalue->buyerSeller_model, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("premium"))) {
            { Payment* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Payment);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Payment (pdata2);
            DOMTest_Payment (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->premium_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("americanExercise")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("bermudaExercise")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("europeanExercise"))) {
            DOMTest_Exercise_group (pctxt, &pvalue->exercise, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exerciseProcedure"))) {
            DOMTest_ExerciseProcedure (pctxt, &pvalue->exerciseProcedure, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationAgentPartyReference"))) {
            { PartyReference* pdata2;
            pdata2 = rtxMemAllocType (pctxt, PartyReference);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PartyReference (pdata2);
            DOMTest_PartyReference (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->calculationAgentPartyReference_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("cashSettlement"))) {
            pvalue->m.cashSettlementPresent = 1;
            DOMTest_CashSettlement (pctxt, &pvalue->cashSettlement, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("swaptionStraddle"))) {
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->swaptionStraddle);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("swaptionAdjustedDates"))) {
            pvalue->m.swaptionAdjustedDatesPresent = 1;
            DOMTest_SwaptionAdjustedDates (pctxt, &pvalue->swaptionAdjustedDates, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("swap"))) {
            DOMTest_Swap (pctxt, &pvalue->swap, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_InstrumentId (OSCTXT* pctxt, InstrumentId* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("instrumentIdScheme"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->instrumentIdScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->instrumentIdScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_ExchangeId (OSCTXT* pctxt, ExchangeId* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("exchangeIdScheme"))) {
            pvalue->m.exchangeIdSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->exchangeIdScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->exchangeIdScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_ClearanceSystem (OSCTXT* pctxt, ClearanceSystem* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("clearanceSystemIdScheme"))) {
            pvalue->m.clearanceSystemIdSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->clearanceSystemIdScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->clearanceSystemIdScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_Bond (OSCTXT* pctxt, Bond* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("instrumentId"))) {
            { InstrumentId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, InstrumentId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InstrumentId (pdata2);
            DOMTest_InstrumentId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->instrumentId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->description = pXmlNode->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            pvalue->m.currencyPresent = 1;
            DOMTest_Currency (pctxt, &pvalue->currency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exchangeId"))) {
            pvalue->m.exchangeIdPresent = 1;
            DOMTest_ExchangeId (pctxt, &pvalue->exchangeId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("clearanceSystem"))) {
            pvalue->m.clearanceSystemPresent = 1;
            DOMTest_ClearanceSystem (pctxt, &pvalue->clearanceSystem, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relatedExchangeId"))) {
            pvalue->m.relatedExchangeIdPresent = 1;
            DOMTest_ExchangeId (pctxt, &pvalue->relatedExchangeId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("issuerName"))) {
            pvalue->m.issuerNamePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->issuerName = pXmlNode->children->content;
            }
            else {
               pvalue->issuerName = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("couponRate"))) {
            pvalue->m.couponRatePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->couponRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("maturity"))) {
            pvalue->m.maturityPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->maturity = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->maturity = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("parValue"))) {
            pvalue->m.parValuePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->parValue);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("faceAmount"))) {
            pvalue->m.faceAmountPresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->faceAmount);
            }
         }
      }
   }

   return 0;
}

int DOMTest_UnderlyingAsset_1 (OSCTXT* pctxt, UnderlyingAsset_1* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("instrumentId"))) {
            { InstrumentId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, InstrumentId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InstrumentId (pdata2);
            DOMTest_InstrumentId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->instrumentId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->description = pXmlNode->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            pvalue->m.currencyPresent = 1;
            DOMTest_Currency (pctxt, &pvalue->currency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exchangeId"))) {
            pvalue->m.exchangeIdPresent = 1;
            DOMTest_ExchangeId (pctxt, &pvalue->exchangeId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("clearanceSystem"))) {
            pvalue->m.clearanceSystemPresent = 1;
            DOMTest_ClearanceSystem (pctxt, &pvalue->clearanceSystem, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_UnderlyingAsset_derivations_bond (OSCTXT* pctxt, 
   UnderlyingAsset_derivations_bond* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("instrumentId"))) {
            { InstrumentId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, InstrumentId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InstrumentId (pdata2);
            DOMTest_InstrumentId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->instrumentId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->description = pXmlNode->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            pvalue->m.currencyPresent = 1;
            DOMTest_Currency (pctxt, &pvalue->currency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exchangeId"))) {
            pvalue->m.exchangeIdPresent = 1;
            DOMTest_ExchangeId (pctxt, &pvalue->exchangeId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("clearanceSystem"))) {
            pvalue->m.clearanceSystemPresent = 1;
            DOMTest_ClearanceSystem (pctxt, &pvalue->clearanceSystem, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relatedExchangeId"))) {
            pvalue->m.relatedExchangeIdPresent = 1;
            DOMTest_ExchangeId (pctxt, &pvalue->relatedExchangeId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("issuerName"))) {
            pvalue->m.issuerNamePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->issuerName = pXmlNode->children->content;
            }
            else {
               pvalue->issuerName = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("couponRate"))) {
            pvalue->m.couponRatePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->couponRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("maturity"))) {
            pvalue->m.maturityPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->maturity = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->maturity = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("parValue"))) {
            pvalue->m.parValuePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->parValue);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("faceAmount"))) {
            pvalue->m.faceAmountPresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->faceAmount);
            }
         }
      }
   }

   return 0;
}

int DOMTest_UnderlyingAsset_derivations_convertibleBond (OSCTXT* pctxt, 
   UnderlyingAsset_derivations_convertibleBond* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("instrumentId"))) {
            { InstrumentId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, InstrumentId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InstrumentId (pdata2);
            DOMTest_InstrumentId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->instrumentId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->description = pXmlNode->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            pvalue->m.currencyPresent = 1;
            DOMTest_Currency (pctxt, &pvalue->currency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exchangeId"))) {
            pvalue->m.exchangeIdPresent = 1;
            DOMTest_ExchangeId (pctxt, &pvalue->exchangeId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("clearanceSystem"))) {
            pvalue->m.clearanceSystemPresent = 1;
            DOMTest_ClearanceSystem (pctxt, &pvalue->clearanceSystem, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relatedExchangeId"))) {
            { ExchangeId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ExchangeId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ExchangeId (pdata2);
            DOMTest_ExchangeId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->relatedExchangeId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("issuerName"))) {
            pvalue->m.issuerNamePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->issuerName = pXmlNode->children->content;
            }
            else {
               pvalue->issuerName = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("couponRate"))) {
            pvalue->m.couponRatePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->couponRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("maturity"))) {
            pvalue->m.maturityPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->maturity = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->maturity = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("parValue"))) {
            pvalue->m.parValuePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->parValue);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("faceAmount"))) {
            pvalue->m.faceAmountPresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->faceAmount);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("underlyingEquity"))) {
            pvalue->underlyingEquity
                = rtxMemAllocType (pctxt, UnderlyingAsset_derivations);

            if (pvalue->underlyingEquity == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_UnderlyingAsset_derivations ((UnderlyingAsset_derivations*)pvalue->underlyingEquity);
            DOMTest_UnderlyingAsset_derivations (pctxt, (UnderlyingAsset_derivations*)pvalue->underlyingEquity, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_UnderlyingAsset_derivations_equity (OSCTXT* pctxt, 
   UnderlyingAsset_derivations_equity* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("instrumentId"))) {
            { InstrumentId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, InstrumentId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InstrumentId (pdata2);
            DOMTest_InstrumentId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->instrumentId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->description = pXmlNode->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            pvalue->m.currencyPresent = 1;
            DOMTest_Currency (pctxt, &pvalue->currency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exchangeId"))) {
            pvalue->m.exchangeIdPresent = 1;
            DOMTest_ExchangeId (pctxt, &pvalue->exchangeId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("clearanceSystem"))) {
            pvalue->m.clearanceSystemPresent = 1;
            DOMTest_ClearanceSystem (pctxt, &pvalue->clearanceSystem, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relatedExchangeId"))) {
            { ExchangeId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ExchangeId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ExchangeId (pdata2);
            DOMTest_ExchangeId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->relatedExchangeId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("optionsExchangeId"))) {
            pvalue->m.optionsExchangeIdPresent = 1;
            DOMTest_ExchangeId (pctxt, &pvalue->optionsExchangeId, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_UnderlyingAsset_derivations_exchangeTradedFund (OSCTXT* pctxt, 
   UnderlyingAsset_derivations_exchangeTradedFund* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("instrumentId"))) {
            { InstrumentId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, InstrumentId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InstrumentId (pdata2);
            DOMTest_InstrumentId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->instrumentId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->description = pXmlNode->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            pvalue->m.currencyPresent = 1;
            DOMTest_Currency (pctxt, &pvalue->currency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exchangeId"))) {
            pvalue->m.exchangeIdPresent = 1;
            DOMTest_ExchangeId (pctxt, &pvalue->exchangeId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("clearanceSystem"))) {
            pvalue->m.clearanceSystemPresent = 1;
            DOMTest_ClearanceSystem (pctxt, &pvalue->clearanceSystem, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relatedExchangeId"))) {
            pvalue->m.relatedExchangeIdPresent = 1;
            DOMTest_ExchangeId (pctxt, &pvalue->relatedExchangeId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("optionsExchangeId"))) {
            pvalue->m.optionsExchangeIdPresent = 1;
            DOMTest_ExchangeId (pctxt, &pvalue->optionsExchangeId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fundManager"))) {
            pvalue->m.fundManagerPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->fundManager = pXmlNode->children->content;
            }
            else {
               pvalue->fundManager = (const OSUTF8CHAR*)"";
            }
         }
      }
   }

   return 0;
}

int DOMTest_UnderlyingAsset_derivations_future (OSCTXT* pctxt, 
   UnderlyingAsset_derivations_future* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("instrumentId"))) {
            { InstrumentId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, InstrumentId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InstrumentId (pdata2);
            DOMTest_InstrumentId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->instrumentId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->description = pXmlNode->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            pvalue->m.currencyPresent = 1;
            DOMTest_Currency (pctxt, &pvalue->currency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exchangeId"))) {
            pvalue->m.exchangeIdPresent = 1;
            DOMTest_ExchangeId (pctxt, &pvalue->exchangeId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("clearanceSystem"))) {
            pvalue->m.clearanceSystemPresent = 1;
            DOMTest_ClearanceSystem (pctxt, &pvalue->clearanceSystem, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relatedExchangeId"))) {
            pvalue->m.relatedExchangeIdPresent = 1;
            DOMTest_ExchangeId (pctxt, &pvalue->relatedExchangeId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("optionsExchangeId"))) {
            pvalue->m.optionsExchangeIdPresent = 1;
            DOMTest_ExchangeId (pctxt, &pvalue->optionsExchangeId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("multiplier"))) {
            pvalue->m.multiplierPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->multiplier = atoi ((const char*)pXmlNode->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("futureContractReference"))) {
            pvalue->m.futureContractReferencePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->futureContractReference = pXmlNode->children->content;
            }
            else {
               pvalue->futureContractReference = (const OSUTF8CHAR*)"";
            }
         }
      }
   }

   return 0;
}

int DOMTest_UnderlyingAsset_derivations_index_futureId (OSCTXT* pctxt, 
   UnderlyingAsset_derivations_index_futureId* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("futureIdScheme"))) {
            pvalue->m.futureIdSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->futureIdScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->futureIdScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_UnderlyingAsset_derivations_index (OSCTXT* pctxt, 
   UnderlyingAsset_derivations_index* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("instrumentId"))) {
            { InstrumentId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, InstrumentId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InstrumentId (pdata2);
            DOMTest_InstrumentId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->instrumentId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->description = pXmlNode->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            pvalue->m.currencyPresent = 1;
            DOMTest_Currency (pctxt, &pvalue->currency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exchangeId"))) {
            pvalue->m.exchangeIdPresent = 1;
            DOMTest_ExchangeId (pctxt, &pvalue->exchangeId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("clearanceSystem"))) {
            pvalue->m.clearanceSystemPresent = 1;
            DOMTest_ClearanceSystem (pctxt, &pvalue->clearanceSystem, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relatedExchangeId"))) {
            { ExchangeId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ExchangeId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ExchangeId (pdata2);
            DOMTest_ExchangeId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->relatedExchangeId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("futureId"))) {
            pvalue->m.futureIdPresent = 1;
            DOMTest_UnderlyingAsset_derivations_index_futureId (pctxt, &pvalue->futureId, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_UnderlyingAsset_derivations_mutualFund (OSCTXT* pctxt, 
   UnderlyingAsset_derivations_mutualFund* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("instrumentId"))) {
            { InstrumentId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, InstrumentId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InstrumentId (pdata2);
            DOMTest_InstrumentId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->instrumentId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->description = pXmlNode->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            pvalue->m.currencyPresent = 1;
            DOMTest_Currency (pctxt, &pvalue->currency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exchangeId"))) {
            pvalue->m.exchangeIdPresent = 1;
            DOMTest_ExchangeId (pctxt, &pvalue->exchangeId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("clearanceSystem"))) {
            pvalue->m.clearanceSystemPresent = 1;
            DOMTest_ClearanceSystem (pctxt, &pvalue->clearanceSystem, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("openEndedFund"))) {
            pvalue->m.openEndedFundPresent = 1;
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->openEndedFund);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fundManager"))) {
            pvalue->m.fundManagerPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->fundManager = pXmlNode->children->content;
            }
            else {
               pvalue->fundManager = (const OSUTF8CHAR*)"";
            }
         }
      }
   }

   return 0;
}

int DOMTest_UnderlyingAsset_derivations (OSCTXT* pctxt, 
   UnderlyingAsset_derivations* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("UnderlyingAsset");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("UnderlyingAsset")))
   {
      pvalue->t = 1;
      pvalue->u.underlyingAsset = rtxMemAllocType (pctxt, UnderlyingAsset_1);

      if (pvalue->u.underlyingAsset == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UnderlyingAsset_1 (pvalue->u.underlyingAsset);
      DOMTest_UnderlyingAsset_1 (pctxt, pvalue->u.underlyingAsset, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("_bond")))
   {
      pvalue->t = 2;
      pvalue->u.bond
          = rtxMemAllocType (pctxt, UnderlyingAsset_derivations_bond);

      if (pvalue->u.bond == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UnderlyingAsset_derivations_bond (pvalue->u.bond);
      DOMTest_UnderlyingAsset_derivations_bond (pctxt, pvalue->u.bond, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("_convertibleBond")))
   {
      pvalue->t = 3;
      pvalue->u.convertibleBond
          = rtxMemAllocType (pctxt, UnderlyingAsset_derivations_convertibleBond);

      if (pvalue->u.convertibleBond == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UnderlyingAsset_derivations_convertibleBond (pvalue->u.convertibleBond);
      DOMTest_UnderlyingAsset_derivations_convertibleBond (pctxt, pvalue->u.convertibleBond, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("_equity")))
   {
      pvalue->t = 4;
      pvalue->u.equity
          = rtxMemAllocType (pctxt, UnderlyingAsset_derivations_equity);

      if (pvalue->u.equity == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UnderlyingAsset_derivations_equity (pvalue->u.equity);
      DOMTest_UnderlyingAsset_derivations_equity (pctxt, pvalue->u.equity, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("_exchangeTradedFund")))
   {
      pvalue->t = 5;
      pvalue->u.exchangeTradedFund
          = rtxMemAllocType (pctxt, UnderlyingAsset_derivations_exchangeTradedFund);

      if (pvalue->u.exchangeTradedFund == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UnderlyingAsset_derivations_exchangeTradedFund (pvalue->u.exchangeTradedFund);
      DOMTest_UnderlyingAsset_derivations_exchangeTradedFund (pctxt, pvalue->u.exchangeTradedFund, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("_future")))
   {
      pvalue->t = 6;
      pvalue->u.future
          = rtxMemAllocType (pctxt, UnderlyingAsset_derivations_future);

      if (pvalue->u.future == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UnderlyingAsset_derivations_future (pvalue->u.future);
      DOMTest_UnderlyingAsset_derivations_future (pctxt, pvalue->u.future, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("_index")))
   {
      pvalue->t = 7;
      pvalue->u.index
          = rtxMemAllocType (pctxt, UnderlyingAsset_derivations_index);

      if (pvalue->u.index == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UnderlyingAsset_derivations_index (pvalue->u.index);
      DOMTest_UnderlyingAsset_derivations_index (pctxt, pvalue->u.index, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("_mutualFund")))
   {
      pvalue->t = 8;
      pvalue->u.mutualFund
          = rtxMemAllocType (pctxt, UnderlyingAsset_derivations_mutualFund);

      if (pvalue->u.mutualFund == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_UnderlyingAsset_derivations_mutualFund (pvalue->u.mutualFund);
      DOMTest_UnderlyingAsset_derivations_mutualFund (pctxt, pvalue->u.mutualFund, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_ConvertibleBond (OSCTXT* pctxt, ConvertibleBond* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("instrumentId"))) {
            { InstrumentId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, InstrumentId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InstrumentId (pdata2);
            DOMTest_InstrumentId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->instrumentId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->description = pXmlNode->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            pvalue->m.currencyPresent = 1;
            DOMTest_Currency (pctxt, &pvalue->currency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exchangeId"))) {
            pvalue->m.exchangeIdPresent = 1;
            DOMTest_ExchangeId (pctxt, &pvalue->exchangeId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("clearanceSystem"))) {
            pvalue->m.clearanceSystemPresent = 1;
            DOMTest_ClearanceSystem (pctxt, &pvalue->clearanceSystem, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relatedExchangeId"))) {
            { ExchangeId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ExchangeId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ExchangeId (pdata2);
            DOMTest_ExchangeId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->relatedExchangeId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("issuerName"))) {
            pvalue->m.issuerNamePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->issuerName = pXmlNode->children->content;
            }
            else {
               pvalue->issuerName = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("couponRate"))) {
            pvalue->m.couponRatePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->couponRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("maturity"))) {
            pvalue->m.maturityPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->maturity = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->maturity = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("parValue"))) {
            pvalue->m.parValuePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->parValue);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("faceAmount"))) {
            pvalue->m.faceAmountPresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->faceAmount);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("underlyingEquity"))) {
            DOMTest_UnderlyingAsset_derivations (pctxt, &pvalue->underlyingEquity, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Equity (OSCTXT* pctxt, Equity* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("instrumentId"))) {
            { InstrumentId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, InstrumentId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InstrumentId (pdata2);
            DOMTest_InstrumentId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->instrumentId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->description = pXmlNode->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            pvalue->m.currencyPresent = 1;
            DOMTest_Currency (pctxt, &pvalue->currency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exchangeId"))) {
            pvalue->m.exchangeIdPresent = 1;
            DOMTest_ExchangeId (pctxt, &pvalue->exchangeId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("clearanceSystem"))) {
            pvalue->m.clearanceSystemPresent = 1;
            DOMTest_ClearanceSystem (pctxt, &pvalue->clearanceSystem, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relatedExchangeId"))) {
            { ExchangeId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ExchangeId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ExchangeId (pdata2);
            DOMTest_ExchangeId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->relatedExchangeId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("optionsExchangeId"))) {
            pvalue->m.optionsExchangeIdPresent = 1;
            DOMTest_ExchangeId (pctxt, &pvalue->optionsExchangeId, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_ExchangeTradedFund (OSCTXT* pctxt, ExchangeTradedFund* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("instrumentId"))) {
            { InstrumentId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, InstrumentId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InstrumentId (pdata2);
            DOMTest_InstrumentId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->instrumentId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->description = pXmlNode->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            pvalue->m.currencyPresent = 1;
            DOMTest_Currency (pctxt, &pvalue->currency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exchangeId"))) {
            pvalue->m.exchangeIdPresent = 1;
            DOMTest_ExchangeId (pctxt, &pvalue->exchangeId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("clearanceSystem"))) {
            pvalue->m.clearanceSystemPresent = 1;
            DOMTest_ClearanceSystem (pctxt, &pvalue->clearanceSystem, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relatedExchangeId"))) {
            pvalue->m.relatedExchangeIdPresent = 1;
            DOMTest_ExchangeId (pctxt, &pvalue->relatedExchangeId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("optionsExchangeId"))) {
            pvalue->m.optionsExchangeIdPresent = 1;
            DOMTest_ExchangeId (pctxt, &pvalue->optionsExchangeId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fundManager"))) {
            pvalue->m.fundManagerPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->fundManager = pXmlNode->children->content;
            }
            else {
               pvalue->fundManager = (const OSUTF8CHAR*)"";
            }
         }
      }
   }

   return 0;
}

int DOMTest_Future (OSCTXT* pctxt, Future* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("instrumentId"))) {
            { InstrumentId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, InstrumentId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InstrumentId (pdata2);
            DOMTest_InstrumentId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->instrumentId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->description = pXmlNode->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            pvalue->m.currencyPresent = 1;
            DOMTest_Currency (pctxt, &pvalue->currency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exchangeId"))) {
            pvalue->m.exchangeIdPresent = 1;
            DOMTest_ExchangeId (pctxt, &pvalue->exchangeId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("clearanceSystem"))) {
            pvalue->m.clearanceSystemPresent = 1;
            DOMTest_ClearanceSystem (pctxt, &pvalue->clearanceSystem, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relatedExchangeId"))) {
            pvalue->m.relatedExchangeIdPresent = 1;
            DOMTest_ExchangeId (pctxt, &pvalue->relatedExchangeId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("optionsExchangeId"))) {
            pvalue->m.optionsExchangeIdPresent = 1;
            DOMTest_ExchangeId (pctxt, &pvalue->optionsExchangeId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("multiplier"))) {
            pvalue->m.multiplierPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->multiplier = atoi ((const char*)pXmlNode->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("futureContractReference"))) {
            pvalue->m.futureContractReferencePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->futureContractReference = pXmlNode->children->content;
            }
            else {
               pvalue->futureContractReference = (const OSUTF8CHAR*)"";
            }
         }
      }
   }

   return 0;
}

int DOMTest_Index_futureId (OSCTXT* pctxt, Index_futureId* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("futureIdScheme"))) {
            pvalue->m.futureIdSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->futureIdScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->futureIdScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_Index (OSCTXT* pctxt, Index* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("instrumentId"))) {
            { InstrumentId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, InstrumentId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InstrumentId (pdata2);
            DOMTest_InstrumentId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->instrumentId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->description = pXmlNode->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            pvalue->m.currencyPresent = 1;
            DOMTest_Currency (pctxt, &pvalue->currency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exchangeId"))) {
            pvalue->m.exchangeIdPresent = 1;
            DOMTest_ExchangeId (pctxt, &pvalue->exchangeId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("clearanceSystem"))) {
            pvalue->m.clearanceSystemPresent = 1;
            DOMTest_ClearanceSystem (pctxt, &pvalue->clearanceSystem, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relatedExchangeId"))) {
            { ExchangeId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ExchangeId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ExchangeId (pdata2);
            DOMTest_ExchangeId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->relatedExchangeId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("futureId"))) {
            pvalue->m.futureIdPresent = 1;
            DOMTest_Index_futureId (pctxt, &pvalue->futureId, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_MutualFund (OSCTXT* pctxt, MutualFund* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("instrumentId"))) {
            { InstrumentId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, InstrumentId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InstrumentId (pdata2);
            DOMTest_InstrumentId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->instrumentId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->description = pXmlNode->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            pvalue->m.currencyPresent = 1;
            DOMTest_Currency (pctxt, &pvalue->currency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exchangeId"))) {
            pvalue->m.exchangeIdPresent = 1;
            DOMTest_ExchangeId (pctxt, &pvalue->exchangeId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("clearanceSystem"))) {
            pvalue->m.clearanceSystemPresent = 1;
            DOMTest_ClearanceSystem (pctxt, &pvalue->clearanceSystem, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("openEndedFund"))) {
            pvalue->m.openEndedFundPresent = 1;
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->openEndedFund);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fundManager"))) {
            pvalue->m.fundManagerPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->fundManager = pXmlNode->children->content;
            }
            else {
               pvalue->fundManager = (const OSUTF8CHAR*)"";
            }
         }
      }
   }

   return 0;
}

int DOMTest_UnderlyingAsset_group (OSCTXT* pctxt, 
   UnderlyingAsset_group* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("bond"))) {
            pvalue->t = 1;
            pvalue->u.bond = rtxMemAllocType (pctxt, Bond);

            if (pvalue->u.bond == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Bond (pvalue->u.bond);
            DOMTest_Bond (pctxt, pvalue->u.bond, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("convertibleBond"))) {
            pvalue->t = 2;
            pvalue->u.convertibleBond
                = rtxMemAllocType (pctxt, ConvertibleBond);

            if (pvalue->u.convertibleBond == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ConvertibleBond (pvalue->u.convertibleBond);
            DOMTest_ConvertibleBond (pctxt, pvalue->u.convertibleBond, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equity"))) {
            pvalue->t = 3;
            pvalue->u.equity = rtxMemAllocType (pctxt, Equity);

            if (pvalue->u.equity == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Equity (pvalue->u.equity);
            DOMTest_Equity (pctxt, pvalue->u.equity, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exchangeTradedFund"))) {
            pvalue->t = 4;
            pvalue->u.exchangeTradedFund
                = rtxMemAllocType (pctxt, ExchangeTradedFund);

            if (pvalue->u.exchangeTradedFund == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ExchangeTradedFund (pvalue->u.exchangeTradedFund);
            DOMTest_ExchangeTradedFund (pctxt, pvalue->u.exchangeTradedFund, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("future"))) {
            pvalue->t = 5;
            pvalue->u.future = rtxMemAllocType (pctxt, Future);

            if (pvalue->u.future == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Future (pvalue->u.future);
            DOMTest_Future (pctxt, pvalue->u.future, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("index"))) {
            pvalue->t = 6;
            pvalue->u.index = rtxMemAllocType (pctxt, Index);

            if (pvalue->u.index == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Index (pvalue->u.index);
            DOMTest_Index (pctxt, pvalue->u.index, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("mutualFund"))) {
            pvalue->t = 7;
            pvalue->u.mutualFund = rtxMemAllocType (pctxt, MutualFund);

            if (pvalue->u.mutualFund == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MutualFund (pvalue->u.mutualFund);
            DOMTest_MutualFund (pctxt, pvalue->u.mutualFund, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_DividendPayout (OSCTXT* pctxt, DividendPayout* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dividendPayoutRatio"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->u.dividendPayoutRatio);
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dividendPayoutConditions"))) {
            pvalue->t = 2;
            if (0 != pXmlNode->children) {
               pvalue->u.dividendPayoutConditions = pXmlNode->children->content;
            }
            else {
               pvalue->u.dividendPayoutConditions = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_SingleUnderlyer (OSCTXT* pctxt, SingleUnderlyer* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("bond")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("convertibleBond")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equity")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exchangeTradedFund")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("future")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("index")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("mutualFund"))) {
            DOMTest_UnderlyingAsset_group (pctxt, &pvalue->underlyingAsset, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("openUnits"))) {
            pvalue->m.openUnitsPresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->openUnits);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dividendPayout"))) {
            pvalue->m.dividendPayoutPresent = 1;
            DOMTest_DividendPayout (pctxt, &pvalue->dividendPayout, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_ConstituentWeight (OSCTXT* pctxt, ConstituentWeight* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("openUnits"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->openUnits);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("basketPercentage"))) {
            pvalue->m.basketPercentagePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->basketPercentage);
            }
         }
      }
   }

   return 0;
}

int DOMTest_Commission (OSCTXT* pctxt, Commission* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("commissionDenomination"))) {
            if (0 != pXmlNode->children) {
               CommissionDenominationEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->commissionDenomination);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("commissionAmount"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->commissionAmount);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            pvalue->m.currencyPresent = 1;
            DOMTest_Currency (pctxt, &pvalue->currency, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_AmountRelativeTo (OSCTXT* pctxt, AmountRelativeTo* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->href = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->href = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_ActualPrice (OSCTXT* pctxt, ActualPrice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            pvalue->m.currencyPresent = 1;
            DOMTest_Currency (pctxt, &pvalue->currency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amount"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->amount);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("priceExpression"))) {
            if (0 != pXmlNode->children) {
               PriceExpressionEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->priceExpression);
            }
         }
      }
   }

   return 0;
}

int DOMTest_FxRate (OSCTXT* pctxt, FxRate* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("quotedCurrencyPair"))) {
            DOMTest_QuotedCurrencyPair (pctxt, &pvalue->quotedCurrencyPair, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("rate"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->rate);
            }
         }
      }
   }

   return 0;
}

int DOMTest_FxRate_derivations (OSCTXT* pctxt, FxRate_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("FxRate");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("FxRate")))
   {
      pvalue->t = 1;
      pvalue->u.fxRate = rtxMemAllocType (pctxt, FxRate);

      if (pvalue->u.fxRate == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_FxRate (pvalue->u.fxRate);
      DOMTest_FxRate (pctxt, pvalue->u.fxRate, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("ExchangeRate")))
   {
      pvalue->t = 2;
      pvalue->u.exchangeRate = rtxMemAllocType (pctxt, ExchangeRate);

      if (pvalue->u.exchangeRate == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ExchangeRate (pvalue->u.exchangeRate);
      DOMTest_ExchangeRate (pctxt, pvalue->u.exchangeRate, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_Price_sequence_fxConversion (OSCTXT* pctxt, 
   Price_sequence_fxConversion* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 1;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxRate"))) {
            pvalue->t = 2;
            pvalue->u.fxRate_list = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.fxRate_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.fxRate_list);
            {
            FxRate_derivations* pdata2;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxRate"))) {
                     pdata2 = rtxMemAllocType (pctxt, FxRate_derivations);

                     if (pdata2 == NULL)
                        return LOG_RTERR (pctxt, RTERR_NOMEM);

                     asn1Init_FxRate_derivations (pdata2);
                     DOMTest_FxRate_derivations (pctxt, pdata2, pXmlNode, TRUE);
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, pvalue->u.fxRate_list, (void*)pdata2);
                  }
               }
            }
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_Price_sequence (OSCTXT* pctxt, Price_sequence* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice"))) {
            pvalue->m.grossPricePresent = 1;
            DOMTest_ActualPrice (pctxt, &pvalue->grossPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            DOMTest_ActualPrice (pctxt, &pvalue->netPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("accruedInterestPrice"))) {
            pvalue->m.accruedInterestPricePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->accruedInterestPrice);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxConversion"))) {
            pvalue->m.fxConversionPresent = 1;
            DOMTest_Price_sequence_fxConversion (pctxt, &pvalue->fxConversion, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Price_choice (OSCTXT* pctxt, Price_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               pvalue->u.determinationMethod = pXmlNode->children->content;
            }
            else {
               pvalue->u.determinationMethod = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 2;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            pvalue->t = 3;
            pvalue->u.sequence = rtxMemAllocType (pctxt, Price_sequence);

            if (pvalue->u.sequence == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Price_sequence (pvalue->u.sequence);
            DOMTest_Price_sequence (pctxt, pvalue->u.sequence, pXmlNode, FALSE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_Price (OSCTXT* pctxt, Price* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("commission"))) {
            pvalue->m.commissionPresent = 1;
            DOMTest_Commission (pctxt, &pvalue->commission, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            DOMTest_Price_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_Price_derivations_equitySwapValuation_initialPrice_sequence_fxConversion (OSCTXT* pctxt, 
   Price_derivations_equitySwapValuation_initialPrice_sequence_fxConversion* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 1;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxRate"))) {
            pvalue->t = 2;
            pvalue->u.fxRate_list = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.fxRate_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.fxRate_list);
            {
            FxRate_derivations* pdata2;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxRate"))) {
                     pdata2 = rtxMemAllocType (pctxt, FxRate_derivations);

                     if (pdata2 == NULL)
                        return LOG_RTERR (pctxt, RTERR_NOMEM);

                     asn1Init_FxRate_derivations (pdata2);
                     DOMTest_FxRate_derivations (pctxt, pdata2, pXmlNode, TRUE);
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, pvalue->u.fxRate_list, (void*)pdata2);
                  }
               }
            }
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_Price_derivations_equitySwapValuation_initialPrice_sequence (OSCTXT* pctxt, 
   Price_derivations_equitySwapValuation_initialPrice_sequence* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice"))) {
            pvalue->m.grossPricePresent = 1;
            DOMTest_ActualPrice (pctxt, &pvalue->grossPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            DOMTest_ActualPrice (pctxt, &pvalue->netPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("accruedInterestPrice"))) {
            pvalue->m.accruedInterestPricePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->accruedInterestPrice);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxConversion"))) {
            pvalue->m.fxConversionPresent = 1;
            DOMTest_Price_derivations_equitySwapValuation_initialPrice_sequence_fxConversion (pctxt, &pvalue->fxConversion, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Price_derivations_equitySwapValuation_initialPrice_choice (OSCTXT* pctxt, 
   Price_derivations_equitySwapValuation_initialPrice_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               pvalue->u.determinationMethod = pXmlNode->children->content;
            }
            else {
               pvalue->u.determinationMethod = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 2;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            pvalue->t = 3;
            pvalue->u.sequence
                = rtxMemAllocType (pctxt, Price_derivations_equitySwapValuation_initialPrice_sequence);

            if (pvalue->u.sequence == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Price_derivations_equitySwapValuation_initialPrice_sequence (pvalue->u.sequence);
            DOMTest_Price_derivations_equitySwapValuation_initialPrice_sequence (pctxt, pvalue->u.sequence, pXmlNode, FALSE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_RelativeDateSequence_dateOffset (OSCTXT* pctxt, 
   RelativeDateSequence_dateOffset* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("periodMultiplier"))) {
            if (0 != pXmlNode->children) {
               pvalue->periodMultiplier = atoi ((const char*)pXmlNode->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("period"))) {
            if (0 != pXmlNode->children) {
               PeriodEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->period);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dayType"))) {
            pvalue->m.dayTypePresent = 1;
            if (0 != pXmlNode->children) {
               DayTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->dayType);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessDayConvention"))) {
            if (0 != pXmlNode->children) {
               BusinessDayConventionEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->businessDayConvention);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("sequence"))) {
            pvalue->m.sequencePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->sequence = atoi ((const char*)pXmlNode->children->content);
            }
         }
      }
   }

   return 0;
}

int DOMTest_RelativeDateSequence_choice (OSCTXT* pctxt, 
   RelativeDateSequence_choice* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessCentersReference"))) {
            pvalue->t = 1;
            pvalue->u.businessCentersReference
                = rtxMemAllocType (pctxt, BusinessCentersReference);

            if (pvalue->u.businessCentersReference == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BusinessCentersReference (pvalue->u.businessCentersReference);
            DOMTest_BusinessCentersReference (pctxt, pvalue->u.businessCentersReference, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessCenters"))) {
            pvalue->t = 2;
            pvalue->u.businessCenters
                = rtxMemAllocType (pctxt, BusinessCenters);

            if (pvalue->u.businessCenters == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BusinessCenters (pvalue->u.businessCenters);
            DOMTest_BusinessCenters (pctxt, pvalue->u.businessCenters, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_RelativeDateSequence (OSCTXT* pctxt, RelativeDateSequence* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dateRelativeTo"))) {
            DOMTest_DateRelativeTo (pctxt, &pvalue->dateRelativeTo, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dateOffset"))) {
            { RelativeDateSequence_dateOffset* pdata2;
            pdata2 = rtxMemAllocType (pctxt, RelativeDateSequence_dateOffset);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RelativeDateSequence_dateOffset (pdata2);
            DOMTest_RelativeDateSequence_dateOffset (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->dateOffset_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessCentersReference")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessCenters"))) {
            pvalue->m.choicePresent = 1;
            DOMTest_RelativeDateSequence_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_Price_derivations_equitySwapValuation_initialPrice_equityValuationDate (OSCTXT* pctxt, 
   Price_derivations_equitySwapValuation_initialPrice_equityValuationDate* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustableDate"))) {
            pvalue->t = 1;
            pvalue->u.adjustableDate
                = rtxMemAllocType (pctxt, AdjustableDate);

            if (pvalue->u.adjustableDate == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AdjustableDate (pvalue->u.adjustableDate);
            DOMTest_AdjustableDate (pctxt, pvalue->u.adjustableDate, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relativeDateSequence"))) {
            pvalue->t = 2;
            pvalue->u.relativeDateSequence
                = rtxMemAllocType (pctxt, RelativeDateSequence);

            if (pvalue->u.relativeDateSequence == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RelativeDateSequence (pvalue->u.relativeDateSequence);
            DOMTest_RelativeDateSequence (pctxt, pvalue->u.relativeDateSequence, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_Price_derivations_equitySwapValuation_initialPrice (OSCTXT* pctxt, 
   Price_derivations_equitySwapValuation_initialPrice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("commission"))) {
            pvalue->m.commissionPresent = 1;
            DOMTest_Commission (pctxt, &pvalue->commission, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            DOMTest_Price_derivations_equitySwapValuation_initialPrice_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationTimeType"))) {
            pvalue->m.valuationTimeTypePresent = 1;
            if (0 != pXmlNode->children) {
               TimeTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->valuationTimeType);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationTime"))) {
            pvalue->m.valuationTimePresent = 1;
            DOMTest_BusinessCenterTime (pctxt, &pvalue->valuationTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityValuationDate"))) {
            pvalue->m.equityValuationDatePresent = 1;
            DOMTest_Price_derivations_equitySwapValuation_initialPrice_equityValuationDate (pctxt, &pvalue->equityValuationDate, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Price_derivations_equitySwapValuation_valuationPriceInterim_sequence_fxConversion (OSCTXT* pctxt, 
   Price_derivations_equitySwapValuation_valuationPriceInterim_sequence_fxConversion* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 1;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxRate"))) {
            pvalue->t = 2;
            pvalue->u.fxRate_list = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.fxRate_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.fxRate_list);
            {
            FxRate_derivations* pdata2;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxRate"))) {
                     pdata2 = rtxMemAllocType (pctxt, FxRate_derivations);

                     if (pdata2 == NULL)
                        return LOG_RTERR (pctxt, RTERR_NOMEM);

                     asn1Init_FxRate_derivations (pdata2);
                     DOMTest_FxRate_derivations (pctxt, pdata2, pXmlNode, TRUE);
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, pvalue->u.fxRate_list, (void*)pdata2);
                  }
               }
            }
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_Price_derivations_equitySwapValuation_valuationPriceInterim_sequence (OSCTXT* pctxt, 
   Price_derivations_equitySwapValuation_valuationPriceInterim_sequence* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice"))) {
            pvalue->m.grossPricePresent = 1;
            DOMTest_ActualPrice (pctxt, &pvalue->grossPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            DOMTest_ActualPrice (pctxt, &pvalue->netPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("accruedInterestPrice"))) {
            pvalue->m.accruedInterestPricePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->accruedInterestPrice);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxConversion"))) {
            pvalue->m.fxConversionPresent = 1;
            DOMTest_Price_derivations_equitySwapValuation_valuationPriceInterim_sequence_fxConversion (pctxt, &pvalue->fxConversion, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Price_derivations_equitySwapValuation_valuationPriceInterim_choice (OSCTXT* pctxt, 
   Price_derivations_equitySwapValuation_valuationPriceInterim_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               pvalue->u.determinationMethod = pXmlNode->children->content;
            }
            else {
               pvalue->u.determinationMethod = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 2;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            pvalue->t = 3;
            pvalue->u.sequence
                = rtxMemAllocType (pctxt, Price_derivations_equitySwapValuation_valuationPriceInterim_sequence);

            if (pvalue->u.sequence == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Price_derivations_equitySwapValuation_valuationPriceInterim_sequence (pvalue->u.sequence);
            DOMTest_Price_derivations_equitySwapValuation_valuationPriceInterim_sequence (pctxt, pvalue->u.sequence, pXmlNode, FALSE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_AdjustableRelativeOrPeriodicDates_periodicDates (OSCTXT* pctxt, 
   AdjustableRelativeOrPeriodicDates_periodicDates* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationStartDate"))) {
            DOMTest_AdjustableOrRelativeDate (pctxt, &pvalue->calculationStartDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationEndDate"))) {
            pvalue->m.calculationEndDatePresent = 1;
            DOMTest_AdjustableOrRelativeDate (pctxt, &pvalue->calculationEndDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationPeriodFrequency"))) {
            DOMTest_CalculationPeriodFrequency (pctxt, &pvalue->calculationPeriodFrequency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationPeriodDatesAdjustments"))) {
            DOMTest_BusinessDayAdjustments (pctxt, &pvalue->calculationPeriodDatesAdjustments, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_AdjustableRelativeOrPeriodicDates_choice (OSCTXT* pctxt, 
   AdjustableRelativeOrPeriodicDates_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustableDates"))) {
            pvalue->t = 1;
            pvalue->u.adjustableDates
                = rtxMemAllocType (pctxt, AdjustableDates);

            if (pvalue->u.adjustableDates == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AdjustableDates (pvalue->u.adjustableDates);
            DOMTest_AdjustableDates (pctxt, pvalue->u.adjustableDates, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relativeDateSequence"))) {
            pvalue->t = 2;
            pvalue->u.relativeDateSequence
                = rtxMemAllocType (pctxt, RelativeDateSequence);

            if (pvalue->u.relativeDateSequence == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RelativeDateSequence (pvalue->u.relativeDateSequence);
            DOMTest_RelativeDateSequence (pctxt, pvalue->u.relativeDateSequence, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("periodicDates"))) {
            pvalue->t = 3;
            pvalue->u.periodicDates
                = rtxMemAllocType (pctxt, AdjustableRelativeOrPeriodicDates_periodicDates);

            if (pvalue->u.periodicDates == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AdjustableRelativeOrPeriodicDates_periodicDates (pvalue->u.periodicDates);
            DOMTest_AdjustableRelativeOrPeriodicDates_periodicDates (pctxt, pvalue->u.periodicDates, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_AdjustableRelativeOrPeriodicDates (OSCTXT* pctxt, 
   AdjustableRelativeOrPeriodicDates* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustableDates")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relativeDateSequence")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("periodicDates"))) {
            DOMTest_AdjustableRelativeOrPeriodicDates_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_Price_derivations_equitySwapValuation_valuationPriceInterim (OSCTXT* pctxt, 
   Price_derivations_equitySwapValuation_valuationPriceInterim* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("commission"))) {
            pvalue->m.commissionPresent = 1;
            DOMTest_Commission (pctxt, &pvalue->commission, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            DOMTest_Price_derivations_equitySwapValuation_valuationPriceInterim_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationTimeType"))) {
            if (0 != pXmlNode->children) {
               TimeTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->valuationTimeType);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationTime"))) {
            pvalue->m.valuationTimePresent = 1;
            DOMTest_BusinessCenterTime (pctxt, &pvalue->valuationTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityValuationDates"))) {
            DOMTest_AdjustableRelativeOrPeriodicDates (pctxt, &pvalue->equityValuationDates, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Price_derivations_equitySwapValuation_valuationPriceFinal_sequence_fxConversion (OSCTXT* pctxt, 
   Price_derivations_equitySwapValuation_valuationPriceFinal_sequence_fxConversion* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 1;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxRate"))) {
            pvalue->t = 2;
            pvalue->u.fxRate_list = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.fxRate_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.fxRate_list);
            {
            FxRate_derivations* pdata2;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxRate"))) {
                     pdata2 = rtxMemAllocType (pctxt, FxRate_derivations);

                     if (pdata2 == NULL)
                        return LOG_RTERR (pctxt, RTERR_NOMEM);

                     asn1Init_FxRate_derivations (pdata2);
                     DOMTest_FxRate_derivations (pctxt, pdata2, pXmlNode, TRUE);
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, pvalue->u.fxRate_list, (void*)pdata2);
                  }
               }
            }
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_Price_derivations_equitySwapValuation_valuationPriceFinal_sequence (OSCTXT* pctxt, 
   Price_derivations_equitySwapValuation_valuationPriceFinal_sequence* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice"))) {
            pvalue->m.grossPricePresent = 1;
            DOMTest_ActualPrice (pctxt, &pvalue->grossPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            DOMTest_ActualPrice (pctxt, &pvalue->netPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("accruedInterestPrice"))) {
            pvalue->m.accruedInterestPricePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->accruedInterestPrice);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxConversion"))) {
            pvalue->m.fxConversionPresent = 1;
            DOMTest_Price_derivations_equitySwapValuation_valuationPriceFinal_sequence_fxConversion (pctxt, &pvalue->fxConversion, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Price_derivations_equitySwapValuation_valuationPriceFinal_choice (OSCTXT* pctxt, 
   Price_derivations_equitySwapValuation_valuationPriceFinal_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               pvalue->u.determinationMethod = pXmlNode->children->content;
            }
            else {
               pvalue->u.determinationMethod = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 2;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            pvalue->t = 3;
            pvalue->u.sequence
                = rtxMemAllocType (pctxt, Price_derivations_equitySwapValuation_valuationPriceFinal_sequence);

            if (pvalue->u.sequence == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Price_derivations_equitySwapValuation_valuationPriceFinal_sequence (pvalue->u.sequence);
            DOMTest_Price_derivations_equitySwapValuation_valuationPriceFinal_sequence (pctxt, pvalue->u.sequence, pXmlNode, FALSE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_Price_derivations_equitySwapValuation_valuationPriceFinal_equityValuationDate (OSCTXT* pctxt, 
   Price_derivations_equitySwapValuation_valuationPriceFinal_equityValuationDate* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustableDate"))) {
            pvalue->t = 1;
            pvalue->u.adjustableDate
                = rtxMemAllocType (pctxt, AdjustableDate);

            if (pvalue->u.adjustableDate == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AdjustableDate (pvalue->u.adjustableDate);
            DOMTest_AdjustableDate (pctxt, pvalue->u.adjustableDate, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relativeDateSequence"))) {
            pvalue->t = 2;
            pvalue->u.relativeDateSequence
                = rtxMemAllocType (pctxt, RelativeDateSequence);

            if (pvalue->u.relativeDateSequence == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RelativeDateSequence (pvalue->u.relativeDateSequence);
            DOMTest_RelativeDateSequence (pctxt, pvalue->u.relativeDateSequence, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_Price_derivations_equitySwapValuation_valuationPriceFinal (OSCTXT* pctxt, 
   Price_derivations_equitySwapValuation_valuationPriceFinal* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("commission"))) {
            pvalue->m.commissionPresent = 1;
            DOMTest_Commission (pctxt, &pvalue->commission, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            DOMTest_Price_derivations_equitySwapValuation_valuationPriceFinal_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationTimeType"))) {
            pvalue->m.valuationTimeTypePresent = 1;
            if (0 != pXmlNode->children) {
               TimeTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->valuationTimeType);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationTime"))) {
            pvalue->m.valuationTimePresent = 1;
            DOMTest_BusinessCenterTime (pctxt, &pvalue->valuationTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityValuationDate"))) {
            DOMTest_Price_derivations_equitySwapValuation_valuationPriceFinal_equityValuationDate (pctxt, &pvalue->equityValuationDate, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Price_derivations (OSCTXT* pctxt, Price_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("Price");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("Price")))
   {
      pvalue->t = 1;
      pvalue->u.price = rtxMemAllocType (pctxt, Price);

      if (pvalue->u.price == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Price (pvalue->u.price);
      DOMTest_Price (pctxt, pvalue->u.price, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("EquitySwapValuation_initialPrice")))
   {
      pvalue->t = 2;
      pvalue->u.equitySwapValuation_initialPrice
          = rtxMemAllocType (pctxt, Price_derivations_equitySwapValuation_initialPrice);

      if (pvalue->u.equitySwapValuation_initialPrice == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Price_derivations_equitySwapValuation_initialPrice (pvalue->u.equitySwapValuation_initialPrice);
      DOMTest_Price_derivations_equitySwapValuation_initialPrice (pctxt, pvalue->u.equitySwapValuation_initialPrice, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("EquitySwapValuation_valuationPriceInterim")))
   {
      pvalue->t = 3;
      pvalue->u.equitySwapValuation_valuationPriceInterim
          = rtxMemAllocType (pctxt, Price_derivations_equitySwapValuation_valuationPriceInterim);

      if (pvalue->u.equitySwapValuation_valuationPriceInterim == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Price_derivations_equitySwapValuation_valuationPriceInterim (pvalue->u.equitySwapValuation_valuationPriceInterim);
      DOMTest_Price_derivations_equitySwapValuation_valuationPriceInterim (pctxt, pvalue->u.equitySwapValuation_valuationPriceInterim, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("EquitySwapValuation_valuationPriceFinal")))
   {
      pvalue->t = 4;
      pvalue->u.equitySwapValuation_valuationPriceFinal
          = rtxMemAllocType (pctxt, Price_derivations_equitySwapValuation_valuationPriceFinal);

      if (pvalue->u.equitySwapValuation_valuationPriceFinal == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Price_derivations_equitySwapValuation_valuationPriceFinal (pvalue->u.equitySwapValuation_valuationPriceFinal);
      DOMTest_Price_derivations_equitySwapValuation_valuationPriceFinal (pctxt, pvalue->u.equitySwapValuation_valuationPriceFinal, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_BasketConstituent (OSCTXT* pctxt, BasketConstituent* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("bond")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("convertibleBond")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equity")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exchangeTradedFund")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("future")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("index")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("mutualFund"))) {
            DOMTest_UnderlyingAsset_group (pctxt, &pvalue->underlyingAsset, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("constituentWeight"))) {
            pvalue->m.constituentWeightPresent = 1;
            DOMTest_ConstituentWeight (pctxt, &pvalue->constituentWeight, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dividendPayout"))) {
            pvalue->m.dividendPayoutPresent = 1;
            DOMTest_DividendPayout (pctxt, &pvalue->dividendPayout, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("underlyerPrice"))) {
            pvalue->m.underlyerPricePresent = 1;
            DOMTest_Price_derivations (pctxt, &pvalue->underlyerPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("underlyerNotional"))) {
            pvalue->m.underlyerNotionalPresent = 1;
            DOMTest_Money_derivations (pctxt, &pvalue->underlyerNotional, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Basket (OSCTXT* pctxt, Basket* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("openUnits"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->openUnits);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("basketConstituent"))) {
            { BasketConstituent* pdata2;
            pdata2 = rtxMemAllocType (pctxt, BasketConstituent);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BasketConstituent (pdata2);
            DOMTest_BasketConstituent (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->basketConstituent_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_Underlyer (OSCTXT* pctxt, Underlyer* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("singleUnderlyer"))) {
            pvalue->t = 1;
            pvalue->u.singleUnderlyer
                = rtxMemAllocType (pctxt, SingleUnderlyer);

            if (pvalue->u.singleUnderlyer == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SingleUnderlyer (pvalue->u.singleUnderlyer);
            DOMTest_SingleUnderlyer (pctxt, pvalue->u.singleUnderlyer, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("basket"))) {
            pvalue->t = 2;
            pvalue->u.basket = rtxMemAllocType (pctxt, Basket);

            if (pvalue->u.basket == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Basket (pvalue->u.basket);
            DOMTest_Basket (pctxt, pvalue->u.basket, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquityStrike_choice (OSCTXT* pctxt, EquityStrike_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("strikePrice"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->u.strikePrice);
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("strikePercentage"))) {
            pvalue->t = 2;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->u.strikePercentage);
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquityStrike (OSCTXT* pctxt, EquityStrike* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("strikePrice")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("strikePercentage"))) {
            DOMTest_EquityStrike_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            pvalue->m.currencyPresent = 1;
            DOMTest_Currency (pctxt, &pvalue->currency, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquityEuropeanExercise (OSCTXT* pctxt, 
   EquityEuropeanExercise* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("expirationDate"))) {
            DOMTest_AdjustableOrRelativeDate (pctxt, &pvalue->expirationDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityExpirationTimeType"))) {
            if (0 != pXmlNode->children) {
               TimeTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->equityExpirationTimeType);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityExpirationTime"))) {
            pvalue->m.equityExpirationTimePresent = 1;
            DOMTest_BusinessCenterTime (pctxt, &pvalue->equityExpirationTime, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquityMultipleExercise (OSCTXT* pctxt, 
   EquityMultipleExercise* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("integralMultipleExercise"))) {
            pvalue->m.integralMultipleExercisePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->integralMultipleExercise);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("minimumNumberOfOptions"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->minimumNumberOfOptions);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("maximumNumberOfOptions"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->maximumNumberOfOptions);
            }
         }
      }
   }

   return 0;
}

int DOMTest_EquityAmericanExercise (OSCTXT* pctxt, 
   EquityAmericanExercise* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("latestExerciseTimeType"))) {
            if (0 != pXmlNode->children) {
               TimeTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->latestExerciseTimeType);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityExpirationTimeType"))) {
            if (0 != pXmlNode->children) {
               TimeTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->equityExpirationTimeType);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityExpirationTime"))) {
            pvalue->m.equityExpirationTimePresent = 1;
            DOMTest_BusinessCenterTime (pctxt, &pvalue->equityExpirationTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityMultipleExercise"))) {
            pvalue->m.equityMultipleExercisePresent = 1;
            DOMTest_EquityMultipleExercise (pctxt, &pvalue->equityMultipleExercise, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_DateList (OSCTXT* pctxt, DateList* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const char* pdata1 = 0;
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("date"))) {
            if (0 != pXmlNode->children) {
               pdata1 = (const char*)pXmlNode->children->content;
            }
            else {
               pdata1 = "";
            }
            if (0 != pdata1)
               rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         }
      }
   }

   return 0;
}

int DOMTest_EquityBermudanExercise (OSCTXT* pctxt, 
   EquityBermudanExercise* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("commencementDate"))) {
            DOMTest_AdjustableOrRelativeDate (pctxt, &pvalue->commencementDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("expirationDate"))) {
            DOMTest_AdjustableOrRelativeDate (pctxt, &pvalue->expirationDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("latestExerciseTime"))) {
            pvalue->m.latestExerciseTimePresent = 1;
            DOMTest_BusinessCenterTime (pctxt, &pvalue->latestExerciseTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("bermudanExerciseDates"))) {
            DOMTest_DateList (pctxt, &pvalue->bermudanExerciseDates, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("latestExerciseTimeType"))) {
            if (0 != pXmlNode->children) {
               TimeTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->latestExerciseTimeType);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityExpirationTimeType"))) {
            if (0 != pXmlNode->children) {
               TimeTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->equityExpirationTimeType);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityExpirationTime"))) {
            pvalue->m.equityExpirationTimePresent = 1;
            DOMTest_BusinessCenterTime (pctxt, &pvalue->equityExpirationTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityMultipleExercise"))) {
            pvalue->m.equityMultipleExercisePresent = 1;
            DOMTest_EquityMultipleExercise (pctxt, &pvalue->equityMultipleExercise, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquityExercise_choice (OSCTXT* pctxt, 
   EquityExercise_choice* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityEuropeanExercise"))) {
            pvalue->t = 1;
            pvalue->u.equityEuropeanExercise
                = rtxMemAllocType (pctxt, EquityEuropeanExercise);

            if (pvalue->u.equityEuropeanExercise == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_EquityEuropeanExercise (pvalue->u.equityEuropeanExercise);
            DOMTest_EquityEuropeanExercise (pctxt, pvalue->u.equityEuropeanExercise, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityAmericanExercise"))) {
            pvalue->t = 2;
            pvalue->u.equityAmericanExercise
                = rtxMemAllocType (pctxt, EquityAmericanExercise);

            if (pvalue->u.equityAmericanExercise == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_EquityAmericanExercise (pvalue->u.equityAmericanExercise);
            DOMTest_EquityAmericanExercise (pctxt, pvalue->u.equityAmericanExercise, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityBermudanExercise"))) {
            pvalue->t = 3;
            pvalue->u.equityBermudanExercise
                = rtxMemAllocType (pctxt, EquityBermudanExercise);

            if (pvalue->u.equityBermudanExercise == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_EquityBermudanExercise (pvalue->u.equityBermudanExercise);
            DOMTest_EquityBermudanExercise (pctxt, pvalue->u.equityBermudanExercise, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquityValuation (OSCTXT* pctxt, EquityValuation* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationDate"))) {
            pvalue->m.valuationDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->valuationDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->valuationDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationTimeType"))) {
            if (0 != pXmlNode->children) {
               TimeTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->valuationTimeType);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationTime"))) {
            pvalue->m.valuationTimePresent = 1;
            DOMTest_BusinessCenterTime (pctxt, &pvalue->valuationTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("futuresPriceValuationApplicable"))) {
            pvalue->m.futuresPriceValuationApplicablePresent = 1;
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->futuresPriceValuationApplicable);
            }
         }
      }
   }

   return 0;
}

int DOMTest_SettlementPriceSource (OSCTXT* pctxt, 
   SettlementPriceSource* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("settlementPriceSourceScheme"))) {
            pvalue->m.settlementPriceSourceSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->settlementPriceSourceScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->settlementPriceSourceScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_EquityExercise (OSCTXT* pctxt, EquityExercise* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityEuropeanExercise")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityAmericanExercise")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityBermudanExercise"))) {
            DOMTest_EquityExercise_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("automaticExerciseApplicable"))) {
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->automaticExerciseApplicable);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityValuation"))) {
            DOMTest_EquityValuation (pctxt, &pvalue->equityValuation, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("settlementDate"))) {
            pvalue->m.settlementDatePresent = 1;
            DOMTest_AdjustableOrRelativeDate (pctxt, &pvalue->settlementDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("settlementCurrency"))) {
            DOMTest_Currency (pctxt, &pvalue->settlementCurrency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("settlementPriceSource"))) {
            pvalue->m.settlementPriceSourcePresent = 1;
            DOMTest_SettlementPriceSource (pctxt, &pvalue->settlementPriceSource, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("settlementType"))) {
            if (0 != pXmlNode->children) {
               SettlementTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->settlementType);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("failureToDeliverApplicable"))) {
            pvalue->m.failureToDeliverApplicablePresent = 1;
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->failureToDeliverApplicable);
            }
         }
      }
   }

   return 0;
}

int DOMTest_FXFeature_fxFeatureType (OSCTXT* pctxt, 
   FXFeature_fxFeatureType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("fxFeatureTypeScheme"))) {
            pvalue->m.fxFeatureTypeSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->fxFeatureTypeScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->fxFeatureTypeScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_FXFeature (OSCTXT* pctxt, FXFeature* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxFeatureType"))) {
            DOMTest_FXFeature_fxFeatureType (pctxt, &pvalue->fxFeatureType, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxRate"))) {
            pvalue->m.fxRatePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->fxRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxSource"))) {
            pvalue->m.fxSourcePresent = 1;
            DOMTest_FxSpotRateSource_derivations (pctxt, &pvalue->fxSource, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquitySchedule (OSCTXT* pctxt, EquitySchedule* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("startDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->startDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->startDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("endDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->endDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->endDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("frequency"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->frequency);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("frequencyType"))) {
            if (0 != pXmlNode->children) {
               FrequencyTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->frequencyType);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("weekNumber"))) {
            pvalue->m.weekNumberPresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->weekNumber);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dayOfWeek"))) {
            pvalue->m.dayOfWeekPresent = 1;
            if (0 != pXmlNode->children) {
               WeeklyRollConventionEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->dayOfWeek);
            }
         }
      }
   }

   return 0;
}

int DOMTest_DateTimeList (OSCTXT* pctxt, DateTimeList* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const char* pdata1 = 0;
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dateTime"))) {
            if (0 != pXmlNode->children) {
               pdata1 = (const char*)pXmlNode->children->content;
            }
            else {
               pdata1 = "";
            }
            if (0 != pdata1)
               rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         }
      }
   }

   return 0;
}

int DOMTest_EquityAveragingPeriod_marketDisruption (OSCTXT* pctxt, 
   EquityAveragingPeriod_marketDisruption* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("marketDisruptionScheme"))) {
            pvalue->m.marketDisruptionSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->marketDisruptionScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->marketDisruptionScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_EquityAveragingPeriod (OSCTXT* pctxt, 
   EquityAveragingPeriod* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("schedule"))) {
            { EquitySchedule* pdata2;
            pdata2 = rtxMemAllocType (pctxt, EquitySchedule);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_EquitySchedule (pdata2);
            DOMTest_EquitySchedule (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->schedule_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("averagingDateTimes"))) {
            pvalue->m.averagingDateTimesPresent = 1;
            DOMTest_DateTimeList (pctxt, &pvalue->averagingDateTimes, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("marketDisruption"))) {
            DOMTest_EquityAveragingPeriod_marketDisruption (pctxt, &pvalue->marketDisruption, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Asian (OSCTXT* pctxt, Asian* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("averagingInOut"))) {
            if (0 != pXmlNode->children) {
               AveragingInOutEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->averagingInOut);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("strikeFactor"))) {
            pvalue->m.strikeFactorPresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->strikeFactor);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("averagingPeriodIn"))) {
            pvalue->m.averagingPeriodInPresent = 1;
            DOMTest_EquityAveragingPeriod (pctxt, &pvalue->averagingPeriodIn, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("averagingPeriodOut"))) {
            pvalue->m.averagingPeriodOutPresent = 1;
            DOMTest_EquityAveragingPeriod (pctxt, &pvalue->averagingPeriodOut, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Trigger (OSCTXT* pctxt, Trigger* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("level"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->u.level);
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("levelPercentage"))) {
            pvalue->t = 2;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->u.levelPercentage);
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_FeaturePayment_choice (OSCTXT* pctxt, 
   FeaturePayment_choice* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("levelPercentage"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->u.levelPercentage);
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amount"))) {
            pvalue->t = 2;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->u.amount);
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_FeaturePayment (OSCTXT* pctxt, FeaturePayment* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("payerPartyReference"))) {
            DOMTest_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("levelPercentage")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amount"))) {
            DOMTest_FeaturePayment_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("time"))) {
            pvalue->m.time_Present = 1;
            if (0 != pXmlNode->children) {
               TimeTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->time_);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            pvalue->m.currencyPresent = 1;
            DOMTest_Currency (pctxt, &pvalue->currency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("featurePaymentDate"))) {
            pvalue->m.featurePaymentDatePresent = 1;
            DOMTest_AdjustableOrRelativeDate (pctxt, &pvalue->featurePaymentDate, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_TriggerEvent (OSCTXT* pctxt, TriggerEvent* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("schedule"))) {
            { EquitySchedule* pdata2;
            pdata2 = rtxMemAllocType (pctxt, EquitySchedule);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_EquitySchedule (pdata2);
            DOMTest_EquitySchedule (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->schedule_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("triggerDates"))) {
            pvalue->m.triggerDatesPresent = 1;
            DOMTest_DateList (pctxt, &pvalue->triggerDates, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("trigger"))) {
            DOMTest_Trigger (pctxt, &pvalue->trigger, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("featurePayment"))) {
            pvalue->m.featurePaymentPresent = 1;
            DOMTest_FeaturePayment (pctxt, &pvalue->featurePayment, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Barrier (OSCTXT* pctxt, Barrier* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("barrierCap"))) {
            pvalue->m.barrierCapPresent = 1;
            DOMTest_TriggerEvent (pctxt, &pvalue->barrierCap, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("barrierFloor"))) {
            pvalue->m.barrierFloorPresent = 1;
            DOMTest_TriggerEvent (pctxt, &pvalue->barrierFloor, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Knock (OSCTXT* pctxt, Knock* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("knockIn"))) {
            pvalue->m.knockInPresent = 1;
            DOMTest_TriggerEvent (pctxt, &pvalue->knockIn, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("knockOut"))) {
            pvalue->m.knockOutPresent = 1;
            DOMTest_TriggerEvent (pctxt, &pvalue->knockOut, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquityOptionFeatures (OSCTXT* pctxt, EquityOptionFeatures* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("asian"))) {
            pvalue->m.asianPresent = 1;
            DOMTest_Asian (pctxt, &pvalue->asian, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("barrier"))) {
            pvalue->m.barrierPresent = 1;
            DOMTest_Barrier (pctxt, &pvalue->barrier, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("knock"))) {
            pvalue->m.knockPresent = 1;
            DOMTest_Knock (pctxt, &pvalue->knock, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquityPremium (OSCTXT* pctxt, EquityPremium* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("payerPartyReference"))) {
            DOMTest_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("paymentAmount"))) {
            pvalue->m.paymentAmountPresent = 1;
            DOMTest_Money_derivations (pctxt, &pvalue->paymentAmount, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("paymentDate"))) {
            pvalue->m.paymentDatePresent = 1;
            DOMTest_AdjustableDate (pctxt, &pvalue->paymentDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("swapPremium"))) {
            pvalue->m.swapPremiumPresent = 1;
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->swapPremium);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("pricePerOption"))) {
            pvalue->m.pricePerOptionPresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->pricePerOption);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("percentageOfNotional"))) {
            pvalue->m.percentageOfNotionalPresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->percentageOfNotional);
            }
         }
      }
   }

   return 0;
}

int DOMTest_MergerEvents (OSCTXT* pctxt, MergerEvents* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("shareForShare"))) {
            if (0 != pXmlNode->children) {
               ShareExtraordinaryEventEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->shareForShare);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("shareForOther"))) {
            if (0 != pXmlNode->children) {
               ShareExtraordinaryEventEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->shareForOther);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("shareForCombined"))) {
            if (0 != pXmlNode->children) {
               ShareExtraordinaryEventEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->shareForCombined);
            }
         }
      }
   }

   return 0;
}

int DOMTest_ExtraordinaryEvents (OSCTXT* pctxt, ExtraordinaryEvents* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("mergerEvents"))) {
            DOMTest_MergerEvents (pctxt, &pvalue->mergerEvents, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("nationalisationOrInsolvency"))) {
            if (0 != pXmlNode->children) {
               NationalisationOrInsolvencyOrDelistingEventEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->nationalisationOrInsolvency);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("delisting"))) {
            pvalue->m.delistingPresent = 1;
            if (0 != pXmlNode->children) {
               NationalisationOrInsolvencyOrDelistingEventEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->delisting);
            }
         }
      }
   }

   return 0;
}

int DOMTest_EquityOption (OSCTXT* pctxt, EquityOption* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productType"))) {
            pvalue->m.productTypePresent = 1;
            DOMTest_ProductType (pctxt, &pvalue->productType, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productId"))) {
            { ProductId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ProductId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ProductId (pdata2);
            DOMTest_ProductId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->productId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("buyerPartyReference"))) {
            DOMTest_BuyerSeller_model (pctxt, &pvalue->buyerSeller_model, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("optionType"))) {
            if (0 != pXmlNode->children) {
               OptionTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->optionType);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityEffectiveDate"))) {
            pvalue->m.equityEffectiveDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->equityEffectiveDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->equityEffectiveDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("underlyer"))) {
            DOMTest_Underlyer (pctxt, &pvalue->underlyer, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("strike"))) {
            pvalue->m.strikePresent = 1;
            DOMTest_EquityStrike (pctxt, &pvalue->strike, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("spotPrice"))) {
            pvalue->m.spotPricePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->spotPrice);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notional"))) {
            pvalue->m.notionalPresent = 1;
            DOMTest_Money_derivations (pctxt, &pvalue->notional, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("numberOfOptions"))) {
            pvalue->m.numberOfOptionsPresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->numberOfOptions);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("optionEntitlement"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->optionEntitlement);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityExercise"))) {
            DOMTest_EquityExercise (pctxt, &pvalue->equityExercise, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxFeature"))) {
            pvalue->m.fxFeaturePresent = 1;
            DOMTest_FXFeature (pctxt, &pvalue->fxFeature, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityOptionFeatures"))) {
            pvalue->m.equityOptionFeaturesPresent = 1;
            DOMTest_EquityOptionFeatures (pctxt, &pvalue->equityOptionFeatures, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityPremium"))) {
            DOMTest_EquityPremium (pctxt, &pvalue->equityPremium, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("methodOfAdjustment"))) {
            pvalue->m.methodOfAdjustmentPresent = 1;
            if (0 != pXmlNode->children) {
               MethodOfAdjustmentEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->methodOfAdjustment);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("extraordinaryEvents"))) {
            pvalue->m.extraordinaryEventsPresent = 1;
            DOMTest_ExtraordinaryEvents (pctxt, &pvalue->extraordinaryEvents, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquityLeg_valuation_initialPrice_sequence_fxConversion (OSCTXT* pctxt, 
   EquityLeg_valuation_initialPrice_sequence_fxConversion* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 1;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxRate"))) {
            pvalue->t = 2;
            pvalue->u.fxRate_list = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.fxRate_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.fxRate_list);
            {
            FxRate_derivations* pdata2;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxRate"))) {
                     pdata2 = rtxMemAllocType (pctxt, FxRate_derivations);

                     if (pdata2 == NULL)
                        return LOG_RTERR (pctxt, RTERR_NOMEM);

                     asn1Init_FxRate_derivations (pdata2);
                     DOMTest_FxRate_derivations (pctxt, pdata2, pXmlNode, TRUE);
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, pvalue->u.fxRate_list, (void*)pdata2);
                  }
               }
            }
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquityLeg_valuation_initialPrice_sequence (OSCTXT* pctxt, 
   EquityLeg_valuation_initialPrice_sequence* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice"))) {
            pvalue->m.grossPricePresent = 1;
            DOMTest_ActualPrice (pctxt, &pvalue->grossPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            DOMTest_ActualPrice (pctxt, &pvalue->netPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("accruedInterestPrice"))) {
            pvalue->m.accruedInterestPricePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->accruedInterestPrice);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxConversion"))) {
            pvalue->m.fxConversionPresent = 1;
            DOMTest_EquityLeg_valuation_initialPrice_sequence_fxConversion (pctxt, &pvalue->fxConversion, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquityLeg_valuation_initialPrice_choice (OSCTXT* pctxt, 
   EquityLeg_valuation_initialPrice_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               pvalue->u.determinationMethod = pXmlNode->children->content;
            }
            else {
               pvalue->u.determinationMethod = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 2;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            pvalue->t = 3;
            pvalue->u.sequence
                = rtxMemAllocType (pctxt, EquityLeg_valuation_initialPrice_sequence);

            if (pvalue->u.sequence == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_EquityLeg_valuation_initialPrice_sequence (pvalue->u.sequence);
            DOMTest_EquityLeg_valuation_initialPrice_sequence (pctxt, pvalue->u.sequence, pXmlNode, FALSE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquityLeg_valuation_initialPrice_equityValuationDate (OSCTXT* pctxt, 
   EquityLeg_valuation_initialPrice_equityValuationDate* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustableDate"))) {
            pvalue->t = 1;
            pvalue->u.adjustableDate
                = rtxMemAllocType (pctxt, AdjustableDate);

            if (pvalue->u.adjustableDate == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AdjustableDate (pvalue->u.adjustableDate);
            DOMTest_AdjustableDate (pctxt, pvalue->u.adjustableDate, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relativeDateSequence"))) {
            pvalue->t = 2;
            pvalue->u.relativeDateSequence
                = rtxMemAllocType (pctxt, RelativeDateSequence);

            if (pvalue->u.relativeDateSequence == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RelativeDateSequence (pvalue->u.relativeDateSequence);
            DOMTest_RelativeDateSequence (pctxt, pvalue->u.relativeDateSequence, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquityLeg_valuation_initialPrice (OSCTXT* pctxt, 
   EquityLeg_valuation_initialPrice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("commission"))) {
            pvalue->m.commissionPresent = 1;
            DOMTest_Commission (pctxt, &pvalue->commission, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            DOMTest_EquityLeg_valuation_initialPrice_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationTimeType"))) {
            pvalue->m.valuationTimeTypePresent = 1;
            if (0 != pXmlNode->children) {
               TimeTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->valuationTimeType);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationTime"))) {
            pvalue->m.valuationTimePresent = 1;
            DOMTest_BusinessCenterTime (pctxt, &pvalue->valuationTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityValuationDate"))) {
            pvalue->m.equityValuationDatePresent = 1;
            DOMTest_EquityLeg_valuation_initialPrice_equityValuationDate (pctxt, &pvalue->equityValuationDate, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquityLeg_valuation_valuationPriceInterim_sequence_fxConversion (OSCTXT* pctxt, 
   EquityLeg_valuation_valuationPriceInterim_sequence_fxConversion* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 1;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxRate"))) {
            pvalue->t = 2;
            pvalue->u.fxRate_list = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.fxRate_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.fxRate_list);
            {
            FxRate_derivations* pdata2;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxRate"))) {
                     pdata2 = rtxMemAllocType (pctxt, FxRate_derivations);

                     if (pdata2 == NULL)
                        return LOG_RTERR (pctxt, RTERR_NOMEM);

                     asn1Init_FxRate_derivations (pdata2);
                     DOMTest_FxRate_derivations (pctxt, pdata2, pXmlNode, TRUE);
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, pvalue->u.fxRate_list, (void*)pdata2);
                  }
               }
            }
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquityLeg_valuation_valuationPriceInterim_sequence (OSCTXT* pctxt, 
   EquityLeg_valuation_valuationPriceInterim_sequence* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice"))) {
            pvalue->m.grossPricePresent = 1;
            DOMTest_ActualPrice (pctxt, &pvalue->grossPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            DOMTest_ActualPrice (pctxt, &pvalue->netPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("accruedInterestPrice"))) {
            pvalue->m.accruedInterestPricePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->accruedInterestPrice);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxConversion"))) {
            pvalue->m.fxConversionPresent = 1;
            DOMTest_EquityLeg_valuation_valuationPriceInterim_sequence_fxConversion (pctxt, &pvalue->fxConversion, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquityLeg_valuation_valuationPriceInterim_choice (OSCTXT* pctxt, 
   EquityLeg_valuation_valuationPriceInterim_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               pvalue->u.determinationMethod = pXmlNode->children->content;
            }
            else {
               pvalue->u.determinationMethod = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 2;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            pvalue->t = 3;
            pvalue->u.sequence
                = rtxMemAllocType (pctxt, EquityLeg_valuation_valuationPriceInterim_sequence);

            if (pvalue->u.sequence == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_EquityLeg_valuation_valuationPriceInterim_sequence (pvalue->u.sequence);
            DOMTest_EquityLeg_valuation_valuationPriceInterim_sequence (pctxt, pvalue->u.sequence, pXmlNode, FALSE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquityLeg_valuation_valuationPriceInterim (OSCTXT* pctxt, 
   EquityLeg_valuation_valuationPriceInterim* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("commission"))) {
            pvalue->m.commissionPresent = 1;
            DOMTest_Commission (pctxt, &pvalue->commission, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            DOMTest_EquityLeg_valuation_valuationPriceInterim_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationTimeType"))) {
            if (0 != pXmlNode->children) {
               TimeTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->valuationTimeType);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationTime"))) {
            pvalue->m.valuationTimePresent = 1;
            DOMTest_BusinessCenterTime (pctxt, &pvalue->valuationTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityValuationDates"))) {
            DOMTest_AdjustableRelativeOrPeriodicDates (pctxt, &pvalue->equityValuationDates, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquityLeg_valuation_valuationPriceFinal_sequence_fxConversion (OSCTXT* pctxt, 
   EquityLeg_valuation_valuationPriceFinal_sequence_fxConversion* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 1;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxRate"))) {
            pvalue->t = 2;
            pvalue->u.fxRate_list = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.fxRate_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.fxRate_list);
            {
            FxRate_derivations* pdata2;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxRate"))) {
                     pdata2 = rtxMemAllocType (pctxt, FxRate_derivations);

                     if (pdata2 == NULL)
                        return LOG_RTERR (pctxt, RTERR_NOMEM);

                     asn1Init_FxRate_derivations (pdata2);
                     DOMTest_FxRate_derivations (pctxt, pdata2, pXmlNode, TRUE);
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, pvalue->u.fxRate_list, (void*)pdata2);
                  }
               }
            }
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquityLeg_valuation_valuationPriceFinal_sequence (OSCTXT* pctxt, 
   EquityLeg_valuation_valuationPriceFinal_sequence* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice"))) {
            pvalue->m.grossPricePresent = 1;
            DOMTest_ActualPrice (pctxt, &pvalue->grossPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            DOMTest_ActualPrice (pctxt, &pvalue->netPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("accruedInterestPrice"))) {
            pvalue->m.accruedInterestPricePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->accruedInterestPrice);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxConversion"))) {
            pvalue->m.fxConversionPresent = 1;
            DOMTest_EquityLeg_valuation_valuationPriceFinal_sequence_fxConversion (pctxt, &pvalue->fxConversion, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquityLeg_valuation_valuationPriceFinal_choice (OSCTXT* pctxt, 
   EquityLeg_valuation_valuationPriceFinal_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               pvalue->u.determinationMethod = pXmlNode->children->content;
            }
            else {
               pvalue->u.determinationMethod = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 2;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            pvalue->t = 3;
            pvalue->u.sequence
                = rtxMemAllocType (pctxt, EquityLeg_valuation_valuationPriceFinal_sequence);

            if (pvalue->u.sequence == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_EquityLeg_valuation_valuationPriceFinal_sequence (pvalue->u.sequence);
            DOMTest_EquityLeg_valuation_valuationPriceFinal_sequence (pctxt, pvalue->u.sequence, pXmlNode, FALSE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquityLeg_valuation_valuationPriceFinal_equityValuationDate (OSCTXT* pctxt, 
   EquityLeg_valuation_valuationPriceFinal_equityValuationDate* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustableDate"))) {
            pvalue->t = 1;
            pvalue->u.adjustableDate
                = rtxMemAllocType (pctxt, AdjustableDate);

            if (pvalue->u.adjustableDate == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AdjustableDate (pvalue->u.adjustableDate);
            DOMTest_AdjustableDate (pctxt, pvalue->u.adjustableDate, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relativeDateSequence"))) {
            pvalue->t = 2;
            pvalue->u.relativeDateSequence
                = rtxMemAllocType (pctxt, RelativeDateSequence);

            if (pvalue->u.relativeDateSequence == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RelativeDateSequence (pvalue->u.relativeDateSequence);
            DOMTest_RelativeDateSequence (pctxt, pvalue->u.relativeDateSequence, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquityLeg_valuation_valuationPriceFinal (OSCTXT* pctxt, 
   EquityLeg_valuation_valuationPriceFinal* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("commission"))) {
            pvalue->m.commissionPresent = 1;
            DOMTest_Commission (pctxt, &pvalue->commission, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            DOMTest_EquityLeg_valuation_valuationPriceFinal_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationTimeType"))) {
            pvalue->m.valuationTimeTypePresent = 1;
            if (0 != pXmlNode->children) {
               TimeTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->valuationTimeType);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationTime"))) {
            pvalue->m.valuationTimePresent = 1;
            DOMTest_BusinessCenterTime (pctxt, &pvalue->valuationTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityValuationDate"))) {
            DOMTest_EquityLeg_valuation_valuationPriceFinal_equityValuationDate (pctxt, &pvalue->equityValuationDate, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquityPaymentDates (OSCTXT* pctxt, EquityPaymentDates* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityPaymentDatesInterim"))) {
            pvalue->m.equityPaymentDatesInterimPresent = 1;
            DOMTest_AdjustableOrRelativeDates (pctxt, &pvalue->equityPaymentDatesInterim, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityPaymentDateFinal"))) {
            DOMTest_AdjustableOrRelativeDate (pctxt, &pvalue->equityPaymentDateFinal, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquityLeg_valuation (OSCTXT* pctxt, EquityLeg_valuation* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("initialPrice"))) {
            DOMTest_EquityLeg_valuation_initialPrice (pctxt, &pvalue->initialPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityNotionalReset"))) {
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->equityNotionalReset);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationPriceInterim"))) {
            pvalue->m.valuationPriceInterimPresent = 1;
            DOMTest_EquityLeg_valuation_valuationPriceInterim (pctxt, &pvalue->valuationPriceInterim, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationPriceFinal"))) {
            DOMTest_EquityLeg_valuation_valuationPriceFinal (pctxt, &pvalue->valuationPriceFinal, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityPaymentDates"))) {
            DOMTest_EquityPaymentDates (pctxt, &pvalue->equityPaymentDates, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquityLeg_notional (OSCTXT* pctxt, EquityLeg_notional* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               pvalue->u.determinationMethod = pXmlNode->children->content;
            }
            else {
               pvalue->u.determinationMethod = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notionalAmount"))) {
            pvalue->t = 2;
            pvalue->u.notionalAmount
                = rtxMemAllocType (pctxt, Money_derivations);

            if (pvalue->u.notionalAmount == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Money_derivations (pvalue->u.notionalAmount);
            DOMTest_Money_derivations (pctxt, pvalue->u.notionalAmount, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 3;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquityLeg_equityAmount_paymentCurrency_choice (OSCTXT* pctxt, 
   EquityLeg_equityAmount_paymentCurrency_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            pvalue->t = 1;
            pvalue->u.currency = rtxMemAllocType (pctxt, Currency);

            if (pvalue->u.currency == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Currency (pvalue->u.currency);
            DOMTest_Currency (pctxt, pvalue->u.currency, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod"))) {
            pvalue->t = 2;
            if (0 != pXmlNode->children) {
               pvalue->u.determinationMethod = pXmlNode->children->content;
            }
            else {
               pvalue->u.determinationMethod = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquityLeg_equityAmount_paymentCurrency (OSCTXT* pctxt, 
   EquityLeg_equityAmount_paymentCurrency* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            pvalue->m.hrefPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->href = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->href = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod"))) {
            pvalue->m.choicePresent = 1;
            DOMTest_EquityLeg_equityAmount_paymentCurrency_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_EquityLeg_equityAmount_referenceAmount (OSCTXT* pctxt, 
   EquityLeg_equityAmount_referenceAmount* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            pvalue->m.hrefPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->href = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->href = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_Formula_formulaComponent (OSCTXT* pctxt, 
   Formula_formulaComponent* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            pvalue->m.hrefPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->href = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->href = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("name"))) {
            pvalue->m.namePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->name = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->name = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("componentDescription"))) {
            if (0 != pXmlNode->children) {
               pvalue->componentDescription = pXmlNode->children->content;
            }
            else {
               pvalue->componentDescription = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("formula"))) {
            pvalue->m.formulaPresent = 1;
            pvalue->formula = rtxMemAllocType (pctxt, Formula);

            if (pvalue->formula == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Formula ((Formula*)pvalue->formula);
            DOMTest_Formula (pctxt, (Formula*)pvalue->formula, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Formula (OSCTXT* pctxt, Formula* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("formulaDescription"))) {
            pvalue->m.formulaDescriptionPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->formulaDescription = pXmlNode->children->content;
            }
            else {
               pvalue->formulaDescription = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("math"))) {
            pvalue->m.mathPresent = 1;
            { OSXSDAny* pdata2;
            pdata2 = rtxMemAllocTypeZ (pctxt, OSXSDAny);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            if (0 != pXmlNode->children) {
               pdata2->t = OSXSDAny_xmlText;
               pdata2->u.xmlText = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->math, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("formulaComponent"))) {
            { Formula_formulaComponent* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Formula_formulaComponent);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Formula_formulaComponent (pdata2);
            DOMTest_Formula_formulaComponent (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->formulaComponent_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_EquityLeg_equityAmount_choice (OSCTXT* pctxt, 
   EquityLeg_equityAmount_choice* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("referenceAmount"))) {
            pvalue->t = 1;
            pvalue->u.referenceAmount
                = rtxMemAllocType (pctxt, EquityLeg_equityAmount_referenceAmount);

            if (pvalue->u.referenceAmount == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_EquityLeg_equityAmount_referenceAmount (pvalue->u.referenceAmount);
            DOMTest_EquityLeg_equityAmount_referenceAmount (pctxt, pvalue->u.referenceAmount, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("formula"))) {
            pvalue->t = 2;
            pvalue->u.formula = rtxMemAllocType (pctxt, Formula);

            if (pvalue->u.formula == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Formula (pvalue->u.formula);
            DOMTest_Formula (pctxt, pvalue->u.formula, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("encodedDescription"))) {
            pvalue->t = 3;
            pvalue->u.encodedDescription
                = rtxMemAllocType (pctxt, ASN1DynOctStr);

            if (pvalue->u.encodedDescription == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            pvalue->u.encodedDescription->numocts = 0;
            pvalue->u.encodedDescription->data = 0;
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecDynBase64Str (pctxt, pvalue->u.encodedDescription);
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquityLeg_equityAmount (OSCTXT* pctxt, 
   EquityLeg_equityAmount* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("paymentCurrency"))) {
            DOMTest_EquityLeg_equityAmount_paymentCurrency (pctxt, &pvalue->paymentCurrency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("referenceAmount")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("formula")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("encodedDescription"))) {
            DOMTest_EquityLeg_equityAmount_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationDates"))) {
            pvalue->m.calculationDatesPresent = 1;
            DOMTest_AdjustableRelativeOrPeriodicDates (pctxt, &pvalue->calculationDates, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("cashSettlement"))) {
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->cashSettlement);
            }
         }
      }
   }

   return 0;
}

int DOMTest_DividendPaymentDate (OSCTXT* pctxt, DividendPaymentDate* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dividendDateReference"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               DividendDateReferenceEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->u.dividendDateReference);
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustableDate"))) {
            pvalue->t = 2;
            pvalue->u.adjustableDate
                = rtxMemAllocType (pctxt, AdjustableDate);

            if (pvalue->u.adjustableDate == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AdjustableDate (pvalue->u.adjustableDate);
            DOMTest_AdjustableDate (pctxt, pvalue->u.adjustableDate, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_DividendConditions_dividendPeriodEffectiveDate (OSCTXT* pctxt, 
   DividendConditions_dividendPeriodEffectiveDate* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->href = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->href = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_DividendConditions_dividendPeriodEndDate (OSCTXT* pctxt, 
   DividendConditions_dividendPeriodEndDate* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->href = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->href = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_DividendConditions_paymentCurrency_choice (OSCTXT* pctxt, 
   DividendConditions_paymentCurrency_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            pvalue->t = 1;
            pvalue->u.currency = rtxMemAllocType (pctxt, Currency);

            if (pvalue->u.currency == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Currency (pvalue->u.currency);
            DOMTest_Currency (pctxt, pvalue->u.currency, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod"))) {
            pvalue->t = 2;
            if (0 != pXmlNode->children) {
               pvalue->u.determinationMethod = pXmlNode->children->content;
            }
            else {
               pvalue->u.determinationMethod = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_DividendConditions_paymentCurrency (OSCTXT* pctxt, 
   DividendConditions_paymentCurrency* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            pvalue->m.hrefPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->href = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->href = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod"))) {
            pvalue->m.choicePresent = 1;
            DOMTest_DividendConditions_paymentCurrency_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_DividendConditions_interestAccrualsMethod_choice (OSCTXT* pctxt, 
   DividendConditions_interestAccrualsMethod_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("floatingRateCalculation"))) {
            pvalue->t = 1;
            pvalue->u.floatingRateCalculation
                = rtxMemAllocType (pctxt, FloatingRateCalculation);

            if (pvalue->u.floatingRateCalculation == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FloatingRateCalculation (pvalue->u.floatingRateCalculation);
            DOMTest_FloatingRateCalculation (pctxt, pvalue->u.floatingRateCalculation, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fixedRate"))) {
            pvalue->t = 2;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->u.fixedRate);
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_DividendConditions_interestAccrualsMethod (OSCTXT* pctxt, 
   DividendConditions_interestAccrualsMethod* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("floatingRateCalculation")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fixedRate"))) {
            DOMTest_DividendConditions_interestAccrualsMethod_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("compoundingMethod"))) {
            if (0 != pXmlNode->children) {
               CompoundingMethodEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->compoundingMethod);
            }
         }
      }
   }

   return 0;
}

int DOMTest_DividendConditions (OSCTXT* pctxt, DividendConditions* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dividendReinvestment"))) {
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->dividendReinvestment);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dividendEntitlement"))) {
            if (0 != pXmlNode->children) {
               DividendEntitlementEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->dividendEntitlement);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dividendPaymentDate"))) {
            pvalue->m.dividendPaymentDatePresent = 1;
            DOMTest_DividendPaymentDate (pctxt, &pvalue->dividendPaymentDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dividendPeriodEffectiveDate"))) {
            pvalue->m.dividendPeriodEffectiveDatePresent = 1;
            DOMTest_DividendConditions_dividendPeriodEffectiveDate (pctxt, &pvalue->dividendPeriodEffectiveDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dividendPeriodEndDate"))) {
            pvalue->m.dividendPeriodEndDatePresent = 1;
            DOMTest_DividendConditions_dividendPeriodEndDate (pctxt, &pvalue->dividendPeriodEndDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("paymentCurrency"))) {
            DOMTest_DividendConditions_paymentCurrency (pctxt, &pvalue->paymentCurrency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dividendFxTriggerDate"))) {
            pvalue->m.dividendFxTriggerDatePresent = 1;
            DOMTest_DividendPaymentDate (pctxt, &pvalue->dividendFxTriggerDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("interestAccrualsMethod"))) {
            pvalue->m.interestAccrualsMethodPresent = 1;
            DOMTest_DividendConditions_interestAccrualsMethod (pctxt, &pvalue->interestAccrualsMethod, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Return (OSCTXT* pctxt, Return* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("returnType"))) {
            if (0 != pXmlNode->children) {
               ReturnTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->returnType);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dividendConditions"))) {
            pvalue->m.dividendConditionsPresent = 1;
            DOMTest_DividendConditions (pctxt, &pvalue->dividendConditions, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquityLeg_fxTerms_quanto_referenceCurrency (OSCTXT* pctxt, 
   EquityLeg_fxTerms_quanto_referenceCurrency* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("currencyScheme"))) {
            pvalue->m.currencySchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->currencyScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->currencyScheme = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_EquityLeg_fxTerms_quanto (OSCTXT* pctxt, 
   EquityLeg_fxTerms_quanto* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("referenceCurrency"))) {
            DOMTest_EquityLeg_fxTerms_quanto_referenceCurrency (pctxt, &pvalue->referenceCurrency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxRate"))) {
            { FxRate_derivations* pdata2;
            pdata2 = rtxMemAllocType (pctxt, FxRate_derivations);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FxRate_derivations (pdata2);
            DOMTest_FxRate_derivations (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->fxRate_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_EquityLeg_fxTerms_compositeFx_referenceCurrency (OSCTXT* pctxt, 
   EquityLeg_fxTerms_compositeFx_referenceCurrency* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("currencyScheme"))) {
            pvalue->m.currencySchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->currencyScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->currencyScheme = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_EquityLeg_fxTerms_compositeFx (OSCTXT* pctxt, 
   EquityLeg_fxTerms_compositeFx* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("referenceCurrency"))) {
            DOMTest_EquityLeg_fxTerms_compositeFx_referenceCurrency (pctxt, &pvalue->referenceCurrency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod"))) {
            pvalue->m.determinationMethodPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->determinationMethod = pXmlNode->children->content;
            }
            else {
               pvalue->determinationMethod = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relativeDate"))) {
            pvalue->m.relativeDatePresent = 1;
            DOMTest_RelativeDateOffset_derivations (pctxt, &pvalue->relativeDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxDetermination"))) {
            pvalue->m.fxDeterminationPresent = 1;
            DOMTest_FxSpotRateSource_derivations (pctxt, &pvalue->fxDetermination, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquityLeg_fxTerms (OSCTXT* pctxt, EquityLeg_fxTerms* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("quanto"))) {
            pvalue->t = 1;
            pvalue->u.quanto
                = rtxMemAllocType (pctxt, EquityLeg_fxTerms_quanto);

            if (pvalue->u.quanto == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_EquityLeg_fxTerms_quanto (pvalue->u.quanto);
            DOMTest_EquityLeg_fxTerms_quanto (pctxt, pvalue->u.quanto, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("compositeFx"))) {
            pvalue->t = 2;
            pvalue->u.compositeFx
                = rtxMemAllocType (pctxt, EquityLeg_fxTerms_compositeFx);

            if (pvalue->u.compositeFx == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_EquityLeg_fxTerms_compositeFx (pvalue->u.compositeFx);
            DOMTest_EquityLeg_fxTerms_compositeFx (pctxt, pvalue->u.compositeFx, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquityLeg (OSCTXT* pctxt, EquityLeg* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("legIdentifier"))) {
            pvalue->m.legIdentifierPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->legIdentifier = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->legIdentifier = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("payerPartyReference"))) {
            DOMTest_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("effectiveDate"))) {
            DOMTest_AdjustableOrRelativeDate (pctxt, &pvalue->effectiveDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("terminationDate"))) {
            DOMTest_AdjustableOrRelativeDate (pctxt, &pvalue->terminationDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("underlyer"))) {
            DOMTest_Underlyer (pctxt, &pvalue->underlyer, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuation"))) {
            DOMTest_EquityLeg_valuation (pctxt, &pvalue->valuation, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notional"))) {
            DOMTest_EquityLeg_notional (pctxt, &pvalue->notional, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityAmount"))) {
            DOMTest_EquityLeg_equityAmount (pctxt, &pvalue->equityAmount, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("return"))) {
            DOMTest_Return (pctxt, &pvalue->return_, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notionalAdjustments"))) {
            if (0 != pXmlNode->children) {
               NotionalAdjustmentEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->notionalAdjustments);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxTerms"))) {
            pvalue->m.fxTermsPresent = 1;
            DOMTest_EquityLeg_fxTerms (pctxt, &pvalue->fxTerms, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_InterestLeg_interestLegCalculationPeriodDates_interestLegResetDates_calculationPeriodDatesReference (OSCTXT* pctxt, 
   InterestLeg_interestLegCalculationPeriodDates_interestLegResetDates_calculationPeriodDatesReference* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->href = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->href = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_InterestLeg_interestLegCalculationPeriodDates_interestLegResetDates_choice (OSCTXT* pctxt, 
   InterestLeg_interestLegCalculationPeriodDates_interestLegResetDates_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("resetRelativeTo"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               ResetRelativeToEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->u.resetRelativeTo);
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("resetFrequency"))) {
            pvalue->t = 2;
            pvalue->u.resetFrequency
                = rtxMemAllocType (pctxt, ResetFrequency);

            if (pvalue->u.resetFrequency == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ResetFrequency (pvalue->u.resetFrequency);
            DOMTest_ResetFrequency (pctxt, pvalue->u.resetFrequency, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_InterestLeg_interestLegCalculationPeriodDates_interestLegResetDates (OSCTXT* pctxt, 
   InterestLeg_interestLegCalculationPeriodDates_interestLegResetDates* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationPeriodDatesReference"))) {
            DOMTest_InterestLeg_interestLegCalculationPeriodDates_interestLegResetDates_calculationPeriodDatesReference (pctxt, &pvalue->calculationPeriodDatesReference, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("resetRelativeTo")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("resetFrequency"))) {
            DOMTest_InterestLeg_interestLegCalculationPeriodDates_interestLegResetDates_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_InterestLeg_interestLegCalculationPeriodDates (OSCTXT* pctxt, 
   InterestLeg_interestLegCalculationPeriodDates* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("effectiveDate"))) {
            DOMTest_AdjustableOrRelativeDate (pctxt, &pvalue->effectiveDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("terminationDate"))) {
            DOMTest_AdjustableOrRelativeDate (pctxt, &pvalue->terminationDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("interestLegResetDates"))) {
            DOMTest_InterestLeg_interestLegCalculationPeriodDates_interestLegResetDates (pctxt, &pvalue->interestLegResetDates, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("interestLegPaymentDates"))) {
            DOMTest_AdjustableOrRelativeDates (pctxt, &pvalue->interestLegPaymentDates, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_InterestLeg_notional (OSCTXT* pctxt, InterestLeg_notional* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               pvalue->u.determinationMethod = pXmlNode->children->content;
            }
            else {
               pvalue->u.determinationMethod = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notionalAmount"))) {
            pvalue->t = 2;
            pvalue->u.notionalAmount
                = rtxMemAllocType (pctxt, Money_derivations);

            if (pvalue->u.notionalAmount == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Money_derivations (pvalue->u.notionalAmount);
            DOMTest_Money_derivations (pctxt, pvalue->u.notionalAmount, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 3;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_LegAmount_paymentCurrency_choice (OSCTXT* pctxt, 
   LegAmount_paymentCurrency_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            pvalue->t = 1;
            pvalue->u.currency = rtxMemAllocType (pctxt, Currency);

            if (pvalue->u.currency == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Currency (pvalue->u.currency);
            DOMTest_Currency (pctxt, pvalue->u.currency, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod"))) {
            pvalue->t = 2;
            if (0 != pXmlNode->children) {
               pvalue->u.determinationMethod = pXmlNode->children->content;
            }
            else {
               pvalue->u.determinationMethod = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_LegAmount_paymentCurrency (OSCTXT* pctxt, 
   LegAmount_paymentCurrency* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            pvalue->m.hrefPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->href = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->href = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod"))) {
            pvalue->m.choicePresent = 1;
            DOMTest_LegAmount_paymentCurrency_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_LegAmount_referenceAmount (OSCTXT* pctxt, 
   LegAmount_referenceAmount* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            pvalue->m.hrefPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->href = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->href = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_LegAmount_choice (OSCTXT* pctxt, LegAmount_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("referenceAmount"))) {
            pvalue->t = 1;
            pvalue->u.referenceAmount
                = rtxMemAllocType (pctxt, LegAmount_referenceAmount);

            if (pvalue->u.referenceAmount == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_LegAmount_referenceAmount (pvalue->u.referenceAmount);
            DOMTest_LegAmount_referenceAmount (pctxt, pvalue->u.referenceAmount, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("formula"))) {
            pvalue->t = 2;
            pvalue->u.formula = rtxMemAllocType (pctxt, Formula);

            if (pvalue->u.formula == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Formula (pvalue->u.formula);
            DOMTest_Formula (pctxt, pvalue->u.formula, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("encodedDescription"))) {
            pvalue->t = 3;
            pvalue->u.encodedDescription
                = rtxMemAllocType (pctxt, ASN1DynOctStr);

            if (pvalue->u.encodedDescription == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            pvalue->u.encodedDescription->numocts = 0;
            pvalue->u.encodedDescription->data = 0;
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecDynBase64Str (pctxt, pvalue->u.encodedDescription);
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_LegAmount (OSCTXT* pctxt, LegAmount* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("paymentCurrency"))) {
            DOMTest_LegAmount_paymentCurrency (pctxt, &pvalue->paymentCurrency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("referenceAmount")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("formula")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("encodedDescription"))) {
            DOMTest_LegAmount_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationDates"))) {
            pvalue->m.calculationDatesPresent = 1;
            DOMTest_AdjustableRelativeOrPeriodicDates (pctxt, &pvalue->calculationDates, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_LegAmount_derivations_equityLeg_equityAmount_paymentCurrency_choice (OSCTXT* pctxt, 
   LegAmount_derivations_equityLeg_equityAmount_paymentCurrency_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            pvalue->t = 1;
            pvalue->u.currency = rtxMemAllocType (pctxt, Currency);

            if (pvalue->u.currency == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Currency (pvalue->u.currency);
            DOMTest_Currency (pctxt, pvalue->u.currency, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod"))) {
            pvalue->t = 2;
            if (0 != pXmlNode->children) {
               pvalue->u.determinationMethod = pXmlNode->children->content;
            }
            else {
               pvalue->u.determinationMethod = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_LegAmount_derivations_equityLeg_equityAmount_paymentCurrency (OSCTXT* pctxt, 
   LegAmount_derivations_equityLeg_equityAmount_paymentCurrency* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            pvalue->m.hrefPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->href = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->href = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod"))) {
            pvalue->m.choicePresent = 1;
            DOMTest_LegAmount_derivations_equityLeg_equityAmount_paymentCurrency_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_LegAmount_derivations_equityLeg_equityAmount_referenceAmount (OSCTXT* pctxt, 
   LegAmount_derivations_equityLeg_equityAmount_referenceAmount* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            pvalue->m.hrefPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->href = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->href = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_LegAmount_derivations_equityLeg_equityAmount_choice (OSCTXT* pctxt, 
   LegAmount_derivations_equityLeg_equityAmount_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("referenceAmount"))) {
            pvalue->t = 1;
            pvalue->u.referenceAmount
                = rtxMemAllocType (pctxt, LegAmount_derivations_equityLeg_equityAmount_referenceAmount);

            if (pvalue->u.referenceAmount == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_LegAmount_derivations_equityLeg_equityAmount_referenceAmount (pvalue->u.referenceAmount);
            DOMTest_LegAmount_derivations_equityLeg_equityAmount_referenceAmount (pctxt, pvalue->u.referenceAmount, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("formula"))) {
            pvalue->t = 2;
            pvalue->u.formula = rtxMemAllocType (pctxt, Formula);

            if (pvalue->u.formula == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Formula (pvalue->u.formula);
            DOMTest_Formula (pctxt, pvalue->u.formula, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("encodedDescription"))) {
            pvalue->t = 3;
            pvalue->u.encodedDescription
                = rtxMemAllocType (pctxt, ASN1DynOctStr);

            if (pvalue->u.encodedDescription == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            pvalue->u.encodedDescription->numocts = 0;
            pvalue->u.encodedDescription->data = 0;
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecDynBase64Str (pctxt, pvalue->u.encodedDescription);
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_LegAmount_derivations_equityLeg_equityAmount (OSCTXT* pctxt, 
   LegAmount_derivations_equityLeg_equityAmount* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("paymentCurrency"))) {
            DOMTest_LegAmount_derivations_equityLeg_equityAmount_paymentCurrency (pctxt, &pvalue->paymentCurrency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("referenceAmount")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("formula")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("encodedDescription"))) {
            DOMTest_LegAmount_derivations_equityLeg_equityAmount_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationDates"))) {
            pvalue->m.calculationDatesPresent = 1;
            DOMTest_AdjustableRelativeOrPeriodicDates (pctxt, &pvalue->calculationDates, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("cashSettlement"))) {
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->cashSettlement);
            }
         }
      }
   }

   return 0;
}

int DOMTest_LegAmount_derivations (OSCTXT* pctxt, 
   LegAmount_derivations* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("LegAmount");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("LegAmount")))
   {
      pvalue->t = 1;
      pvalue->u.legAmount = rtxMemAllocType (pctxt, LegAmount);

      if (pvalue->u.legAmount == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_LegAmount (pvalue->u.legAmount);
      DOMTest_LegAmount (pctxt, pvalue->u.legAmount, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("EquityLeg_equityAmount")))
   {
      pvalue->t = 2;
      pvalue->u.equityLeg_equityAmount
          = rtxMemAllocType (pctxt, LegAmount_derivations_equityLeg_equityAmount);

      if (pvalue->u.equityLeg_equityAmount == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_LegAmount_derivations_equityLeg_equityAmount (pvalue->u.equityLeg_equityAmount);
      DOMTest_LegAmount_derivations_equityLeg_equityAmount (pctxt, pvalue->u.equityLeg_equityAmount, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_InterestLeg_interestCalculation_choice (OSCTXT* pctxt, 
   InterestLeg_interestCalculation_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("floatingRateCalculation"))) {
            pvalue->t = 1;
            pvalue->u.floatingRateCalculation
                = rtxMemAllocType (pctxt, FloatingRateCalculation);

            if (pvalue->u.floatingRateCalculation == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FloatingRateCalculation (pvalue->u.floatingRateCalculation);
            DOMTest_FloatingRateCalculation (pctxt, pvalue->u.floatingRateCalculation, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fixedRate"))) {
            pvalue->t = 2;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->u.fixedRate);
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_InterestLeg_interestCalculation (OSCTXT* pctxt, 
   InterestLeg_interestCalculation* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("floatingRateCalculation")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fixedRate"))) {
            DOMTest_InterestLeg_interestCalculation_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dayCountFraction"))) {
            if (0 != pXmlNode->children) {
               DayCountFractionEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->dayCountFraction);
            }
         }
      }
   }

   return 0;
}

int DOMTest_InterestLeg (OSCTXT* pctxt, InterestLeg* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("legIdentifier"))) {
            pvalue->m.legIdentifierPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->legIdentifier = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->legIdentifier = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("payerPartyReference"))) {
            DOMTest_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("interestLegCalculationPeriodDates"))) {
            DOMTest_InterestLeg_interestLegCalculationPeriodDates (pctxt, &pvalue->interestLegCalculationPeriodDates, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notional"))) {
            DOMTest_InterestLeg_notional (pctxt, &pvalue->notional, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("interestAmount"))) {
            DOMTest_LegAmount_derivations (pctxt, &pvalue->interestAmount, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("interestCalculation"))) {
            DOMTest_InterestLeg_interestCalculation (pctxt, &pvalue->interestCalculation, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_PrincipalExchangeFeatures_principalExchangeDescriptions_principalExchangeAmount (OSCTXT* pctxt, 
   PrincipalExchangeFeatures_principalExchangeDescriptions_principalExchangeAmount* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 1;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod"))) {
            pvalue->t = 2;
            if (0 != pXmlNode->children) {
               pvalue->u.determinationMethod = pXmlNode->children->content;
            }
            else {
               pvalue->u.determinationMethod = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("principalAmount"))) {
            pvalue->t = 3;
            pvalue->u.principalAmount
                = rtxMemAllocType (pctxt, Money_derivations);

            if (pvalue->u.principalAmount == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Money_derivations (pvalue->u.principalAmount);
            DOMTest_Money_derivations (pctxt, pvalue->u.principalAmount, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_PrincipalExchangeFeatures_principalExchangeDescriptions (OSCTXT* pctxt, 
   PrincipalExchangeFeatures_principalExchangeDescriptions* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("payerPartyReference"))) {
            DOMTest_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("principalExchangeAmount"))) {
            DOMTest_PrincipalExchangeFeatures_principalExchangeDescriptions_principalExchangeAmount (pctxt, &pvalue->principalExchangeAmount, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("principalExchangeDate"))) {
            DOMTest_AdjustableOrRelativeDate (pctxt, &pvalue->principalExchangeDate, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_PrincipalExchangeFeatures (OSCTXT* pctxt, 
   PrincipalExchangeFeatures* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("principalExchanges"))) {
            DOMTest_PrincipalExchanges (pctxt, &pvalue->principalExchanges, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("principalExchangeDescriptions"))) {
            { PrincipalExchangeFeatures_principalExchangeDescriptions* pdata2;
            pdata2
                = rtxMemAllocType (pctxt, PrincipalExchangeFeatures_principalExchangeDescriptions);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PrincipalExchangeFeatures_principalExchangeDescriptions (pdata2);
            DOMTest_PrincipalExchangeFeatures_principalExchangeDescriptions (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->principalExchangeDescriptions_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapAdditionalPayment_additionalPaymentAmount (OSCTXT* pctxt, 
   EquitySwapAdditionalPayment_additionalPaymentAmount* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("paymentAmount"))) {
            pvalue->m.paymentAmountPresent = 1;
            DOMTest_Money_derivations (pctxt, &pvalue->paymentAmount, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("formula"))) {
            pvalue->m.formulaPresent = 1;
            DOMTest_Formula (pctxt, &pvalue->formula, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapAdditionalPayment_additionalPaymentDate (OSCTXT* pctxt, 
   EquitySwapAdditionalPayment_additionalPaymentDate* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustableDate"))) {
            pvalue->t = 1;
            pvalue->u.adjustableDate
                = rtxMemAllocType (pctxt, AdjustableDate);

            if (pvalue->u.adjustableDate == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AdjustableDate (pvalue->u.adjustableDate);
            DOMTest_AdjustableDate (pctxt, pvalue->u.adjustableDate, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relativeDate"))) {
            pvalue->t = 2;
            pvalue->u.relativeDate
                = rtxMemAllocType (pctxt, RelativeDateOffset_derivations);

            if (pvalue->u.relativeDate == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RelativeDateOffset_derivations (pvalue->u.relativeDate);
            DOMTest_RelativeDateOffset_derivations (pctxt, pvalue->u.relativeDate, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapAdditionalPayment (OSCTXT* pctxt, 
   EquitySwapAdditionalPayment* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("payerPartyReference"))) {
            DOMTest_PayerReceiver_model (pctxt, &pvalue->payerReceiver_model, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("additionalPaymentAmount"))) {
            DOMTest_EquitySwapAdditionalPayment_additionalPaymentAmount (pctxt, &pvalue->additionalPaymentAmount, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("additionalPaymentDate"))) {
            DOMTest_EquitySwapAdditionalPayment_additionalPaymentDate (pctxt, &pvalue->additionalPaymentDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("paymentType"))) {
            pvalue->m.paymentTypePresent = 1;
            DOMTest_PaymentType (pctxt, &pvalue->paymentType, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapEarlyTerminationType_startingDate (OSCTXT* pctxt, 
   EquitySwapEarlyTerminationType_startingDate* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dateRelativeTo"))) {
            pvalue->t = 1;
            pvalue->u.dateRelativeTo
                = rtxMemAllocType (pctxt, DateRelativeTo);

            if (pvalue->u.dateRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_DateRelativeTo (pvalue->u.dateRelativeTo);
            DOMTest_DateRelativeTo (pctxt, pvalue->u.dateRelativeTo, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustableDate"))) {
            pvalue->t = 2;
            pvalue->u.adjustableDate
                = rtxMemAllocType (pctxt, AdjustableDate);

            if (pvalue->u.adjustableDate == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AdjustableDate (pvalue->u.adjustableDate);
            DOMTest_AdjustableDate (pctxt, pvalue->u.adjustableDate, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapEarlyTerminationType (OSCTXT* pctxt, 
   EquitySwapEarlyTerminationType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("partyReference"))) {
            DOMTest_PartyReference (pctxt, &pvalue->partyReference, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("startingDate"))) {
            DOMTest_EquitySwapEarlyTerminationType_startingDate (pctxt, &pvalue->startingDate, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwap (OSCTXT* pctxt, EquitySwap* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productType"))) {
            pvalue->m.productTypePresent = 1;
            DOMTest_ProductType (pctxt, &pvalue->productType, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productId"))) {
            { ProductId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ProductId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ProductId (pdata2);
            DOMTest_ProductId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->productId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityLeg"))) {
            { EquityLeg* pdata2;
            pdata2 = rtxMemAllocType (pctxt, EquityLeg);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_EquityLeg (pdata2);
            DOMTest_EquityLeg (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->equityLeg_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("interestLeg"))) {
            { InterestLeg* pdata2;
            pdata2 = rtxMemAllocType (pctxt, InterestLeg);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InterestLeg (pdata2);
            DOMTest_InterestLeg (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->interestLeg_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("principalExchangeFeatures"))) {
            pvalue->m.principalExchangeFeaturesPresent = 1;
            DOMTest_PrincipalExchangeFeatures (pctxt, &pvalue->principalExchangeFeatures, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("additionalPayment"))) {
            { EquitySwapAdditionalPayment* pdata2;
            pdata2 = rtxMemAllocType (pctxt, EquitySwapAdditionalPayment);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_EquitySwapAdditionalPayment (pdata2);
            DOMTest_EquitySwapAdditionalPayment (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->additionalPayment_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("earlyTermination"))) {
            { EquitySwapEarlyTerminationType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, EquitySwapEarlyTerminationType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_EquitySwapEarlyTerminationType (pdata2);
            DOMTest_EquitySwapEarlyTerminationType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->earlyTermination_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_AdjustableDate2_unadjustedDate (OSCTXT* pctxt, 
   AdjustableDate2_unadjustedDate* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = (const char*)pXmlNode->children->content;
   }
   else {
      pvalue->base = "";
   }

   return 0;
}

int DOMTest_BusinessDayAdjustmentsReference (OSCTXT* pctxt, 
   BusinessDayAdjustmentsReference* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->href = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->href = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_AdjustableDate2_choice (OSCTXT* pctxt, 
   AdjustableDate2_choice* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dateAdjustments"))) {
            pvalue->t = 1;
            pvalue->u.dateAdjustments
                = rtxMemAllocType (pctxt, BusinessDayAdjustments);

            if (pvalue->u.dateAdjustments == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BusinessDayAdjustments (pvalue->u.dateAdjustments);
            DOMTest_BusinessDayAdjustments (pctxt, pvalue->u.dateAdjustments, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dateAdjustmentsReference"))) {
            pvalue->t = 2;
            pvalue->u.dateAdjustmentsReference
                = rtxMemAllocType (pctxt, BusinessDayAdjustmentsReference);

            if (pvalue->u.dateAdjustmentsReference == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BusinessDayAdjustmentsReference (pvalue->u.dateAdjustmentsReference);
            DOMTest_BusinessDayAdjustmentsReference (pctxt, pvalue->u.dateAdjustmentsReference, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_AdjustableDate2 (OSCTXT* pctxt, AdjustableDate2* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("unadjustedDate"))) {
            DOMTest_AdjustableDate2_unadjustedDate (pctxt, &pvalue->unadjustedDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dateAdjustments")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dateAdjustmentsReference"))) {
            pvalue->m.choicePresent = 1;
            DOMTest_AdjustableDate2_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_ScheduledTerminationDate (OSCTXT* pctxt, 
   ScheduledTerminationDate* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustableDate"))) {
            pvalue->t = 1;
            pvalue->u.adjustableDate
                = rtxMemAllocType (pctxt, AdjustableDate2);

            if (pvalue->u.adjustableDate == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AdjustableDate2 (pvalue->u.adjustableDate);
            DOMTest_AdjustableDate2 (pctxt, pvalue->u.adjustableDate, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relativeDate"))) {
            pvalue->t = 2;
            pvalue->u.relativeDate
                = rtxMemAllocType (pctxt, Interval_derivations);

            if (pvalue->u.relativeDate == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Interval_derivations (pvalue->u.relativeDate);
            DOMTest_Interval_derivations (pctxt, pvalue->u.relativeDate, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EntityName (OSCTXT* pctxt, EntityName* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("entityNameScheme"))) {
            pvalue->m.entityNameSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->entityNameScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->entityNameScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_EntityId (OSCTXT* pctxt, EntityId* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("entityIdScheme"))) {
            pvalue->m.entityIdSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->entityIdScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->entityIdScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_LegalEntity_sequence (OSCTXT* pctxt, LegalEntity_sequence* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("entityName"))) {
            DOMTest_EntityName (pctxt, &pvalue->entityName, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("entityId"))) {
            { EntityId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, EntityId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_EntityId (pdata2);
            DOMTest_EntityId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->entityId_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_LegalEntity_choice (OSCTXT* pctxt, LegalEntity_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("entityName"))) {
            pvalue->t = 1;
            pvalue->u.sequence
                = rtxMemAllocType (pctxt, LegalEntity_sequence);

            if (pvalue->u.sequence == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_LegalEntity_sequence (pvalue->u.sequence);
            DOMTest_LegalEntity_sequence (pctxt, pvalue->u.sequence, pXmlNode, FALSE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("entityId"))) {
            pvalue->t = 2;
            pvalue->u.entityId_list = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.entityId_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.entityId_list);
            {
            EntityId* pdata2;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("entityId"))) {
                     pdata2 = rtxMemAllocType (pctxt, EntityId);

                     if (pdata2 == NULL)
                        return LOG_RTERR (pctxt, RTERR_NOMEM);

                     asn1Init_EntityId (pdata2);
                     DOMTest_EntityId (pctxt, pdata2, pXmlNode, TRUE);
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, pvalue->u.entityId_list, (void*)pdata2);
                  }
               }
            }
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_LegalEntity (OSCTXT* pctxt, LegalEntity* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("entityName")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("entityId"))) {
            DOMTest_LegalEntity_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_ReferenceObligation_choice (OSCTXT* pctxt, 
   ReferenceObligation_choice* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("bond"))) {
            pvalue->t = 1;
            pvalue->u.bond = rtxMemAllocType (pctxt, Bond);

            if (pvalue->u.bond == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Bond (pvalue->u.bond);
            DOMTest_Bond (pctxt, pvalue->u.bond, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("convertibleBond"))) {
            pvalue->t = 2;
            pvalue->u.convertibleBond
                = rtxMemAllocType (pctxt, ConvertibleBond);

            if (pvalue->u.convertibleBond == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ConvertibleBond (pvalue->u.convertibleBond);
            DOMTest_ConvertibleBond (pctxt, pvalue->u.convertibleBond, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_LegalEntityReference (OSCTXT* pctxt, LegalEntityReference* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->href = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->href = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_ReferenceObligation_choice_1 (OSCTXT* pctxt, 
   ReferenceObligation_choice_1* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("primaryObligor"))) {
            pvalue->t = 1;
            pvalue->u.primaryObligor = rtxMemAllocType (pctxt, LegalEntity);

            if (pvalue->u.primaryObligor == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_LegalEntity (pvalue->u.primaryObligor);
            DOMTest_LegalEntity (pctxt, pvalue->u.primaryObligor, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("primaryObligorReference"))) {
            pvalue->t = 2;
            pvalue->u.primaryObligorReference
                = rtxMemAllocType (pctxt, LegalEntityReference);

            if (pvalue->u.primaryObligorReference == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_LegalEntityReference (pvalue->u.primaryObligorReference);
            DOMTest_LegalEntityReference (pctxt, pvalue->u.primaryObligorReference, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_ReferenceObligation_element (OSCTXT* pctxt, 
   ReferenceObligation_element* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("guarantor"))) {
            pvalue->t = 1;
            pvalue->u.guarantor = rtxMemAllocType (pctxt, LegalEntity);

            if (pvalue->u.guarantor == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_LegalEntity (pvalue->u.guarantor);
            DOMTest_LegalEntity (pctxt, pvalue->u.guarantor, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("guarantorReference"))) {
            pvalue->t = 2;
            pvalue->u.guarantorReference
                = rtxMemAllocType (pctxt, LegalEntityReference);

            if (pvalue->u.guarantorReference == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_LegalEntityReference (pvalue->u.guarantorReference);
            DOMTest_LegalEntityReference (pctxt, pvalue->u.guarantorReference, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_ReferenceObligation (OSCTXT* pctxt, ReferenceObligation* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("bond")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("convertibleBond"))) {
            DOMTest_ReferenceObligation_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("primaryObligor")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("primaryObligorReference"))) {
            pvalue->m.choice_1Present = 1;
            DOMTest_ReferenceObligation_choice_1 (pctxt, &pvalue->choice_1, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("guarantor")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("guarantorReference"))) {
            { ReferenceObligation_element* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ReferenceObligation_element);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ReferenceObligation_element (pdata2);
            DOMTest_ReferenceObligation_element (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->choice_2_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_Empty (OSCTXT* pctxt, Empty* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_ReferenceInformation_choice (OSCTXT* pctxt, 
   ReferenceInformation_choice* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("referenceObligation"))) {
            pvalue->t = 1;
            pvalue->u.referenceObligation_list
                = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.referenceObligation_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.referenceObligation_list);
            {
            ReferenceObligation* pdata2;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("referenceObligation"))) {
                     pdata2 = rtxMemAllocType (pctxt, ReferenceObligation);

                     if (pdata2 == NULL)
                        return LOG_RTERR (pctxt, RTERR_NOMEM);

                     asn1Init_ReferenceObligation (pdata2);
                     DOMTest_ReferenceObligation (pctxt, pdata2, pXmlNode, TRUE);
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, pvalue->u.referenceObligation_list, (void*)pdata2);
                  }
               }
            }
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("noReferenceObligation"))) {
            pvalue->t = 2;
            pvalue->u.noReferenceObligation = rtxMemAllocType (pctxt, Empty);

            if (pvalue->u.noReferenceObligation == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Empty (pvalue->u.noReferenceObligation);
            DOMTest_Empty (pctxt, pvalue->u.noReferenceObligation, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("unknownReferenceObligation"))) {
            pvalue->t = 3;
            pvalue->u.unknownReferenceObligation
                = rtxMemAllocType (pctxt, Empty);

            if (pvalue->u.unknownReferenceObligation == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Empty (pvalue->u.unknownReferenceObligation);
            DOMTest_Empty (pctxt, pvalue->u.unknownReferenceObligation, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_ReferenceInformation (OSCTXT* pctxt, ReferenceInformation* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("referenceEntity"))) {
            DOMTest_LegalEntity (pctxt, &pvalue->referenceEntity, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("referenceObligation")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("noReferenceObligation")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("unknownReferenceObligation"))) {
            DOMTest_ReferenceInformation_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("allGuarantees"))) {
            pvalue->m.allGuaranteesPresent = 1;
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->allGuarantees);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("referencePrice"))) {
            pvalue->m.referencePricePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->referencePrice);
            }
         }
      }
   }

   return 0;
}

int DOMTest_AdditionalTerm (OSCTXT* pctxt, AdditionalTerm* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("additionalTermScheme"))) {
            pvalue->m.additionalTermSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->additionalTermScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->additionalTermScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_GeneralTerms (OSCTXT* pctxt, GeneralTerms* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("effectiveDate"))) {
            DOMTest_AdjustableDate2 (pctxt, &pvalue->effectiveDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("scheduledTerminationDate"))) {
            DOMTest_ScheduledTerminationDate (pctxt, &pvalue->scheduledTerminationDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("sellerPartyReference"))) {
            DOMTest_PartyReference (pctxt, &pvalue->sellerPartyReference, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("buyerPartyReference"))) {
            DOMTest_PartyReference (pctxt, &pvalue->buyerPartyReference, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dateAdjustments"))) {
            pvalue->m.dateAdjustmentsPresent = 1;
            DOMTest_BusinessDayAdjustments (pctxt, &pvalue->dateAdjustments, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("referenceInformation"))) {
            DOMTest_ReferenceInformation (pctxt, &pvalue->referenceInformation, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("additionalTerm"))) {
            { AdditionalTerm* pdata2;
            pdata2 = rtxMemAllocType (pctxt, AdditionalTerm);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AdditionalTerm (pdata2);
            DOMTest_AdditionalTerm (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->additionalTerm_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_SinglePayment (OSCTXT* pctxt, SinglePayment* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustablePaymentDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->adjustablePaymentDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->adjustablePaymentDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedPaymentDate"))) {
            pvalue->m.adjustedPaymentDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->adjustedPaymentDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->adjustedPaymentDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fixedAmount"))) {
            DOMTest_Money_derivations (pctxt, &pvalue->fixedAmount, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_FixedAmountCalculation (OSCTXT* pctxt, 
   FixedAmountCalculation* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationAmount"))) {
            pvalue->m.calculationAmountPresent = 1;
            DOMTest_Money_derivations (pctxt, &pvalue->calculationAmount, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fixedRate"))) {
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->fixedRate);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dayCountFraction"))) {
            pvalue->m.dayCountFractionPresent = 1;
            if (0 != pXmlNode->children) {
               DayCountFractionEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->dayCountFraction);
            }
         }
      }
   }

   return 0;
}

int DOMTest_PeriodicPayment_choice (OSCTXT* pctxt, 
   PeriodicPayment_choice* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fixedAmount"))) {
            pvalue->t = 1;
            pvalue->u.fixedAmount
                = rtxMemAllocType (pctxt, Money_derivations);

            if (pvalue->u.fixedAmount == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Money_derivations (pvalue->u.fixedAmount);
            DOMTest_Money_derivations (pctxt, pvalue->u.fixedAmount, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fixedAmountCalculation"))) {
            pvalue->t = 2;
            pvalue->u.fixedAmountCalculation
                = rtxMemAllocType (pctxt, FixedAmountCalculation);

            if (pvalue->u.fixedAmountCalculation == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FixedAmountCalculation (pvalue->u.fixedAmountCalculation);
            DOMTest_FixedAmountCalculation (pctxt, pvalue->u.fixedAmountCalculation, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_AdjustedPaymentDates (OSCTXT* pctxt, AdjustedPaymentDates* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedPaymentDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->adjustedPaymentDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->adjustedPaymentDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("paymentAmount"))) {
            DOMTest_Money_derivations (pctxt, &pvalue->paymentAmount, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_PeriodicPayment (OSCTXT* pctxt, PeriodicPayment* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("paymentFrequency"))) {
            DOMTest_Interval_derivations (pctxt, &pvalue->paymentFrequency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("firstPaymentDate"))) {
            pvalue->m.firstPaymentDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->firstPaymentDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->firstPaymentDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("lastRegularPaymentDate"))) {
            pvalue->m.lastRegularPaymentDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->lastRegularPaymentDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->lastRegularPaymentDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("rollConvention"))) {
            if (0 != pXmlNode->children) {
               RollConventionEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->rollConvention);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fixedAmount")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fixedAmountCalculation"))) {
            DOMTest_PeriodicPayment_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustedPaymentDates"))) {
            { AdjustedPaymentDates* pdata2;
            pdata2 = rtxMemAllocType (pctxt, AdjustedPaymentDates);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AdjustedPaymentDates (pdata2);
            DOMTest_AdjustedPaymentDates (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->adjustedPaymentDates_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_FeeLeg (OSCTXT* pctxt, FeeLeg* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("singlePayment"))) {
            { SinglePayment* pdata2;
            pdata2 = rtxMemAllocType (pctxt, SinglePayment);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SinglePayment (pdata2);
            DOMTest_SinglePayment (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->singlePayment_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("periodicPayment"))) {
            pvalue->m.periodicPaymentPresent = 1;
            DOMTest_PeriodicPayment (pctxt, &pvalue->periodicPayment, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_GracePeriodExtension (OSCTXT* pctxt, GracePeriodExtension* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_Offset_derivations (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_FailureToPay (OSCTXT* pctxt, FailureToPay* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("gracePeriodExtension"))) {
            pvalue->m.gracePeriodExtensionPresent = 1;
            DOMTest_GracePeriodExtension (pctxt, &pvalue->gracePeriodExtension, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("paymentRequirement"))) {
            pvalue->m.paymentRequirementPresent = 1;
            DOMTest_Money_derivations (pctxt, &pvalue->paymentRequirement, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_RestructuringType (OSCTXT* pctxt, RestructuringType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("restructuringScheme"))) {
            pvalue->m.restructuringSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->restructuringScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->restructuringScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_Restructuring (OSCTXT* pctxt, Restructuring* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("restructuringType"))) {
            pvalue->m.restructuringTypePresent = 1;
            DOMTest_RestructuringType (pctxt, &pvalue->restructuringType, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("multipleHolderObligation"))) {
            pvalue->m.multipleHolderObligationPresent = 1;
            DOMTest_Empty (pctxt, &pvalue->multipleHolderObligation, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("multipleCreditEventNotices"))) {
            pvalue->m.multipleCreditEventNoticesPresent = 1;
            DOMTest_Empty (pctxt, &pvalue->multipleCreditEventNotices, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_NotifyingParty (OSCTXT* pctxt, NotifyingParty* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("buyerPartyReference"))) {
            DOMTest_PartyReference (pctxt, &pvalue->buyerPartyReference, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("sellerPartyReference"))) {
            pvalue->m.sellerPartyReferencePresent = 1;
            DOMTest_PartyReference (pctxt, &pvalue->sellerPartyReference, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_PubliclyAvailableInformation (OSCTXT* pctxt, 
   PubliclyAvailableInformation* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("standardPublicSources"))) {
            pvalue->m.standardPublicSourcesPresent = 1;
            DOMTest_Empty (pctxt, &pvalue->standardPublicSources, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("publicSource"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            else {
               pdata2 = (const OSUTF8CHAR*)"";
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->publicSource_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("specifiedNumber"))) {
            pvalue->m.specifiedNumberPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->specifiedNumber = atoi ((const char*)pXmlNode->children->content);
            }
         }
      }
   }

   return 0;
}

int DOMTest_CreditEventNotice (OSCTXT* pctxt, CreditEventNotice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notifyingParty"))) {
            DOMTest_NotifyingParty (pctxt, &pvalue->notifyingParty, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessCenter"))) {
            pvalue->m.businessCenterPresent = 1;
            DOMTest_BusinessCenter (pctxt, &pvalue->businessCenter, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("publiclyAvailableInformation"))) {
            pvalue->m.publiclyAvailableInformationPresent = 1;
            DOMTest_PubliclyAvailableInformation (pctxt, &pvalue->publiclyAvailableInformation, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_CreditEvents (OSCTXT* pctxt, CreditEvents* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("bankruptcy"))) {
            pvalue->m.bankruptcyPresent = 1;
            DOMTest_Empty (pctxt, &pvalue->bankruptcy, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("failureToPay"))) {
            pvalue->m.failureToPayPresent = 1;
            DOMTest_FailureToPay (pctxt, &pvalue->failureToPay, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("obligationDefault"))) {
            pvalue->m.obligationDefaultPresent = 1;
            DOMTest_Empty (pctxt, &pvalue->obligationDefault, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("obligationAcceleration"))) {
            pvalue->m.obligationAccelerationPresent = 1;
            DOMTest_Empty (pctxt, &pvalue->obligationAcceleration, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("repudiationMoratorium"))) {
            pvalue->m.repudiationMoratoriumPresent = 1;
            DOMTest_Empty (pctxt, &pvalue->repudiationMoratorium, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("restructuring"))) {
            pvalue->m.restructuringPresent = 1;
            DOMTest_Restructuring (pctxt, &pvalue->restructuring, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("defaultRequirement"))) {
            pvalue->m.defaultRequirementPresent = 1;
            DOMTest_Money_derivations (pctxt, &pvalue->defaultRequirement, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("creditEventNotice"))) {
            pvalue->m.creditEventNoticePresent = 1;
            DOMTest_CreditEventNotice (pctxt, &pvalue->creditEventNotice, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_SpecifiedCurrency (OSCTXT* pctxt, SpecifiedCurrency* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   Currency* pdata1;
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            pdata1 = rtxMemAllocType (pctxt, Currency);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Currency (pdata1);
            DOMTest_Currency (pctxt, pdata1, pXmlNode, TRUE);
            if (0 != pdata1)
               rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         }
      }
   }

   return 0;
}

int DOMTest_NotDomesticCurrency (OSCTXT* pctxt, NotDomesticCurrency* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_Currency (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_Obligations (OSCTXT* pctxt, Obligations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("category"))) {
            if (0 != pXmlNode->children) {
               ObligationCategoryEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->category);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notSubordinated"))) {
            pvalue->m.notSubordinatedPresent = 1;
            DOMTest_Empty (pctxt, &pvalue->notSubordinated, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("specifiedCurrency"))) {
            pvalue->m.specifiedCurrencyPresent = 1;
            DOMTest_SpecifiedCurrency (pctxt, &pvalue->specifiedCurrency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notSovereignLender"))) {
            pvalue->m.notSovereignLenderPresent = 1;
            DOMTest_Empty (pctxt, &pvalue->notSovereignLender, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notDomesticCurrency"))) {
            pvalue->m.notDomesticCurrencyPresent = 1;
            DOMTest_NotDomesticCurrency (pctxt, &pvalue->notDomesticCurrency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notDomesticLaw"))) {
            pvalue->m.notDomesticLawPresent = 1;
            DOMTest_Empty (pctxt, &pvalue->notDomesticLaw, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("listed"))) {
            pvalue->m.listedPresent = 1;
            DOMTest_Empty (pctxt, &pvalue->listed, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notDomesticIssuance"))) {
            pvalue->m.notDomesticIssuancePresent = 1;
            DOMTest_Empty (pctxt, &pvalue->notDomesticIssuance, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notContingent"))) {
            pvalue->m.notContingentPresent = 1;
            DOMTest_Empty (pctxt, &pvalue->notContingent, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("excluded"))) {
            pvalue->m.excludedPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->excluded = pXmlNode->children->content;
            }
            else {
               pvalue->excluded = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("othReferenceEntityObligations"))) {
            pvalue->m.othReferenceEntityObligationsPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->othReferenceEntityObligations = pXmlNode->children->content;
            }
            else {
               pvalue->othReferenceEntityObligations = (const OSUTF8CHAR*)"";
            }
         }
      }
   }

   return 0;
}

int DOMTest_ProtectionTerms (OSCTXT* pctxt, ProtectionTerms* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationAmount"))) {
            DOMTest_Money_derivations (pctxt, &pvalue->calculationAmount, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("creditEvents"))) {
            pvalue->m.creditEventsPresent = 1;
            DOMTest_CreditEvents (pctxt, &pvalue->creditEvents, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("obligations"))) {
            pvalue->m.obligationsPresent = 1;
            DOMTest_Obligations (pctxt, &pvalue->obligations, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_MultipleValuationDates (OSCTXT* pctxt, 
   MultipleValuationDates* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessDays"))) {
            pvalue->m.businessDaysPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->businessDays = atoi ((const char*)pXmlNode->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessDaysThereafter"))) {
            pvalue->m.businessDaysThereafterPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->businessDaysThereafter = atoi ((const char*)pXmlNode->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("numberValuationDates"))) {
            pvalue->m.numberValuationDatesPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->numberValuationDates = atoi ((const char*)pXmlNode->children->content);
            }
         }
      }
   }

   return 0;
}

int DOMTest_SingleValuationDate_derivations (OSCTXT* pctxt, 
   SingleValuationDate_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("SingleValuationDate");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("SingleValuationDate")))
   {
      pvalue->t = 1;
      if (0 != pXmlNode->children) {
         pvalue->u.singleValuationDate = atoi ((const char*)pXmlNode->children->content);
      }
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("MultipleValuationDates")))
   {
      pvalue->t = 2;
      pvalue->u.multipleValuationDates
          = rtxMemAllocType (pctxt, MultipleValuationDates);

      if (pvalue->u.multipleValuationDates == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MultipleValuationDates (pvalue->u.multipleValuationDates);
      DOMTest_MultipleValuationDates (pctxt, pvalue->u.multipleValuationDates, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_ValuationDate (OSCTXT* pctxt, ValuationDate* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("singleValuationDate"))) {
            pvalue->t = 1;
            pvalue->u.singleValuationDate
                = rtxMemAllocType (pctxt, SingleValuationDate_derivations);

            if (pvalue->u.singleValuationDate == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SingleValuationDate_derivations (pvalue->u.singleValuationDate);
            DOMTest_SingleValuationDate_derivations (pctxt, pvalue->u.singleValuationDate, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("multipleValuationDates"))) {
            pvalue->t = 2;
            pvalue->u.multipleValuationDates
                = rtxMemAllocType (pctxt, MultipleValuationDates);

            if (pvalue->u.multipleValuationDates == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MultipleValuationDates (pvalue->u.multipleValuationDates);
            DOMTest_MultipleValuationDates (pctxt, pvalue->u.multipleValuationDates, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_CashSettlementTerms (OSCTXT* pctxt, CashSettlementTerms* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("settlementCurrency"))) {
            pvalue->m.settlementCurrencyPresent = 1;
            DOMTest_Currency (pctxt, &pvalue->settlementCurrency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationDate"))) {
            pvalue->m.valuationDatePresent = 1;
            DOMTest_ValuationDate (pctxt, &pvalue->valuationDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationTime"))) {
            pvalue->m.valuationTimePresent = 1;
            DOMTest_BusinessCenterTime (pctxt, &pvalue->valuationTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("quotationMethod"))) {
            pvalue->m.quotationMethodPresent = 1;
            if (0 != pXmlNode->children) {
               QuotationRateTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->quotationMethod);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("quotationAmount"))) {
            pvalue->m.quotationAmountPresent = 1;
            DOMTest_Money_derivations (pctxt, &pvalue->quotationAmount, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("minimumQuotationAmount"))) {
            pvalue->m.minimumQuotationAmountPresent = 1;
            DOMTest_Money_derivations (pctxt, &pvalue->minimumQuotationAmount, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("dealer"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            else {
               pdata2 = (const OSUTF8CHAR*)"";
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->dealer_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("cashSettlementBusinessDays"))) {
            pvalue->m.cashSettlementBusinessDaysPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->cashSettlementBusinessDays = atoi ((const char*)pXmlNode->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("cashSettlementAmount"))) {
            pvalue->m.cashSettlementAmountPresent = 1;
            DOMTest_Money_derivations (pctxt, &pvalue->cashSettlementAmount, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("accruedInterest"))) {
            pvalue->m.accruedInterestPresent = 1;
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->accruedInterest);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationMethod"))) {
            pvalue->m.valuationMethodPresent = 1;
            if (0 != pXmlNode->children) {
               ValuationMethodEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->valuationMethod);
            }
         }
      }
   }

   return 0;
}

int DOMTest_PhysicalSettlementPeriod (OSCTXT* pctxt, 
   PhysicalSettlementPeriod* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessDaysNotSpecified"))) {
            pvalue->t = 1;
            pvalue->u.businessDaysNotSpecified
                = rtxMemAllocType (pctxt, Empty);

            if (pvalue->u.businessDaysNotSpecified == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Empty (pvalue->u.businessDaysNotSpecified);
            DOMTest_Empty (pctxt, pvalue->u.businessDaysNotSpecified, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("businessDays"))) {
            pvalue->t = 2;
            if (0 != pXmlNode->children) {
               pvalue->u.businessDays = atoi ((const char*)pXmlNode->children->content);
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("maximumBusinessDays"))) {
            pvalue->t = 3;
            if (0 != pXmlNode->children) {
               pvalue->u.maximumBusinessDays = atoi ((const char*)pXmlNode->children->content);
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_PCDeliverableObligationCharac (OSCTXT* pctxt, 
   PCDeliverableObligationCharac* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_Empty (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_LoanParticipation (OSCTXT* pctxt, LoanParticipation* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("partialCashSettlement"))) {
            pvalue->m.partialCashSettlementPresent = 1;
            DOMTest_Empty (pctxt, &pvalue->partialCashSettlement, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("qualifyingParticipationSeller"))) {
            pvalue->m.qualifyingParticipationSellerPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->qualifyingParticipationSeller = pXmlNode->children->content;
            }
            else {
               pvalue->qualifyingParticipationSeller = (const OSUTF8CHAR*)"";
            }
         }
      }
   }

   return 0;
}

int DOMTest_PCDeliverableObligationCharac_derivations (OSCTXT* pctxt, 
   PCDeliverableObligationCharac_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("PCDeliverableObligationCharac");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("PCDeliverableObligationCharac")))
   {
      pvalue->t = 1;
      pvalue->u.pCDeliverableObligationCharac
          = rtxMemAllocType (pctxt, PCDeliverableObligationCharac);

      if (pvalue->u.pCDeliverableObligationCharac == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PCDeliverableObligationCharac (pvalue->u.pCDeliverableObligationCharac);
      DOMTest_PCDeliverableObligationCharac (pctxt, pvalue->u.pCDeliverableObligationCharac, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("LoanParticipation")))
   {
      pvalue->t = 2;
      pvalue->u.loanParticipation
          = rtxMemAllocType (pctxt, LoanParticipation);

      if (pvalue->u.loanParticipation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_LoanParticipation (pvalue->u.loanParticipation);
      DOMTest_LoanParticipation (pctxt, pvalue->u.loanParticipation, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_DeliverableObligations (OSCTXT* pctxt, 
   DeliverableObligations* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("accruedInterest"))) {
            pvalue->m.accruedInterestPresent = 1;
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->accruedInterest);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("category"))) {
            if (0 != pXmlNode->children) {
               ObligationCategoryEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->category);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notSubordinated"))) {
            pvalue->m.notSubordinatedPresent = 1;
            DOMTest_Empty (pctxt, &pvalue->notSubordinated, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("specifiedCurrency"))) {
            pvalue->m.specifiedCurrencyPresent = 1;
            DOMTest_SpecifiedCurrency (pctxt, &pvalue->specifiedCurrency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notSovereignLender"))) {
            pvalue->m.notSovereignLenderPresent = 1;
            DOMTest_Empty (pctxt, &pvalue->notSovereignLender, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notDomesticCurrency"))) {
            pvalue->m.notDomesticCurrencyPresent = 1;
            DOMTest_NotDomesticCurrency (pctxt, &pvalue->notDomesticCurrency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notDomesticLaw"))) {
            pvalue->m.notDomesticLawPresent = 1;
            DOMTest_Empty (pctxt, &pvalue->notDomesticLaw, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("listed"))) {
            pvalue->m.listedPresent = 1;
            DOMTest_Empty (pctxt, &pvalue->listed, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notContingent"))) {
            pvalue->m.notContingentPresent = 1;
            DOMTest_Empty (pctxt, &pvalue->notContingent, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notDomesticIssuance"))) {
            pvalue->m.notDomesticIssuancePresent = 1;
            DOMTest_Empty (pctxt, &pvalue->notDomesticIssuance, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("assignableLoan"))) {
            pvalue->m.assignableLoanPresent = 1;
            DOMTest_PCDeliverableObligationCharac_derivations (pctxt, &pvalue->assignableLoan, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("consentRequiredLoan"))) {
            pvalue->m.consentRequiredLoanPresent = 1;
            DOMTest_PCDeliverableObligationCharac_derivations (pctxt, &pvalue->consentRequiredLoan, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("directLoanParticipation"))) {
            pvalue->m.directLoanParticipationPresent = 1;
            DOMTest_LoanParticipation (pctxt, &pvalue->directLoanParticipation, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("transferable"))) {
            pvalue->m.transferablePresent = 1;
            DOMTest_Empty (pctxt, &pvalue->transferable, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("maximumMaturity"))) {
            pvalue->m.maximumMaturityPresent = 1;
            DOMTest_Interval_derivations (pctxt, &pvalue->maximumMaturity, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("acceleratedOrMatured"))) {
            pvalue->m.acceleratedOrMaturedPresent = 1;
            DOMTest_Empty (pctxt, &pvalue->acceleratedOrMatured, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("notBearer"))) {
            pvalue->m.notBearerPresent = 1;
            DOMTest_Empty (pctxt, &pvalue->notBearer, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("indirectLoanParticipation"))) {
            pvalue->m.indirectLoanParticipationPresent = 1;
            DOMTest_LoanParticipation (pctxt, &pvalue->indirectLoanParticipation, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("excluded"))) {
            pvalue->m.excludedPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->excluded = pXmlNode->children->content;
            }
            else {
               pvalue->excluded = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("othReferenceEntityObligations"))) {
            pvalue->m.othReferenceEntityObligationsPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->othReferenceEntityObligations = pXmlNode->children->content;
            }
            else {
               pvalue->othReferenceEntityObligations = (const OSUTF8CHAR*)"";
            }
         }
      }
   }

   return 0;
}

int DOMTest_PhysicalSettlementTerms (OSCTXT* pctxt, 
   PhysicalSettlementTerms* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("settlementCurrency"))) {
            pvalue->m.settlementCurrencyPresent = 1;
            DOMTest_Currency (pctxt, &pvalue->settlementCurrency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("physicalSettlementPeriod"))) {
            pvalue->m.physicalSettlementPeriodPresent = 1;
            DOMTest_PhysicalSettlementPeriod (pctxt, &pvalue->physicalSettlementPeriod, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("deliverableObligations"))) {
            DOMTest_DeliverableObligations (pctxt, &pvalue->deliverableObligations, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("escrow"))) {
            pvalue->m.escrowPresent = 1;
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->escrow);
            }
         }
      }
   }

   return 0;
}

int DOMTest_CreditDefaultSwap_choice (OSCTXT* pctxt, 
   CreditDefaultSwap_choice* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("cashSettlementTerms"))) {
            pvalue->t = 1;
            pvalue->u.cashSettlementTerms
                = rtxMemAllocType (pctxt, CashSettlementTerms);

            if (pvalue->u.cashSettlementTerms == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CashSettlementTerms (pvalue->u.cashSettlementTerms);
            DOMTest_CashSettlementTerms (pctxt, pvalue->u.cashSettlementTerms, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("physicalSettlementTerms"))) {
            pvalue->t = 2;
            pvalue->u.physicalSettlementTerms
                = rtxMemAllocType (pctxt, PhysicalSettlementTerms);

            if (pvalue->u.physicalSettlementTerms == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PhysicalSettlementTerms (pvalue->u.physicalSettlementTerms);
            DOMTest_PhysicalSettlementTerms (pctxt, pvalue->u.physicalSettlementTerms, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_CreditDefaultSwap (OSCTXT* pctxt, CreditDefaultSwap* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productType"))) {
            pvalue->m.productTypePresent = 1;
            DOMTest_ProductType (pctxt, &pvalue->productType, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productId"))) {
            { ProductId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ProductId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ProductId (pdata2);
            DOMTest_ProductId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->productId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("generalTerms"))) {
            DOMTest_GeneralTerms (pctxt, &pvalue->generalTerms, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("feeLeg"))) {
            DOMTest_FeeLeg (pctxt, &pvalue->feeLeg, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("protectionTerms"))) {
            DOMTest_ProtectionTerms (pctxt, &pvalue->protectionTerms, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("cashSettlementTerms")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("physicalSettlementTerms"))) {
            pvalue->m.choicePresent = 1;
            DOMTest_CreditDefaultSwap_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_Product_group (OSCTXT* pctxt, Product_group* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("strategy"))) {
            pvalue->t = 1;
            pvalue->u.strategy = rtxMemAllocType (pctxt, Strategy);

            if (pvalue->u.strategy == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Strategy (pvalue->u.strategy);
            DOMTest_Strategy (pctxt, pvalue->u.strategy, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxAverageRateOption"))) {
            pvalue->t = 2;
            pvalue->u.fxAverageRateOption
                = rtxMemAllocType (pctxt, FxAverageRateOption);

            if (pvalue->u.fxAverageRateOption == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FxAverageRateOption (pvalue->u.fxAverageRateOption);
            DOMTest_FxAverageRateOption (pctxt, pvalue->u.fxAverageRateOption, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxBarrierOption"))) {
            pvalue->t = 3;
            pvalue->u.fxBarrierOption
                = rtxMemAllocType (pctxt, FxBarrierOption);

            if (pvalue->u.fxBarrierOption == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FxBarrierOption (pvalue->u.fxBarrierOption);
            DOMTest_FxBarrierOption (pctxt, pvalue->u.fxBarrierOption, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxDigitalOption"))) {
            pvalue->t = 4;
            pvalue->u.fxDigitalOption
                = rtxMemAllocType (pctxt, FxDigitalOption);

            if (pvalue->u.fxDigitalOption == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FxDigitalOption (pvalue->u.fxDigitalOption);
            DOMTest_FxDigitalOption (pctxt, pvalue->u.fxDigitalOption, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxSimpleOption"))) {
            pvalue->t = 5;
            pvalue->u.fxSimpleOption
                = rtxMemAllocType (pctxt, FxSimpleOption);

            if (pvalue->u.fxSimpleOption == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FxSimpleOption (pvalue->u.fxSimpleOption);
            DOMTest_FxSimpleOption (pctxt, pvalue->u.fxSimpleOption, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxSingleLeg"))) {
            pvalue->t = 6;
            pvalue->u.fxSingleLeg = rtxMemAllocType (pctxt, FxSingleLeg);

            if (pvalue->u.fxSingleLeg == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FxSingleLeg (pvalue->u.fxSingleLeg);
            DOMTest_FxSingleLeg (pctxt, pvalue->u.fxSingleLeg, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxSwap"))) {
            pvalue->t = 7;
            pvalue->u.fxSwap = rtxMemAllocType (pctxt, FxSwap);

            if (pvalue->u.fxSwap == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FxSwap (pvalue->u.fxSwap);
            DOMTest_FxSwap (pctxt, pvalue->u.fxSwap, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("termDeposit"))) {
            pvalue->t = 8;
            pvalue->u.termDeposit = rtxMemAllocType (pctxt, TermDeposit);

            if (pvalue->u.termDeposit == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TermDeposit (pvalue->u.termDeposit);
            DOMTest_TermDeposit (pctxt, pvalue->u.termDeposit, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("bulletPayment"))) {
            pvalue->t = 9;
            pvalue->u.bulletPayment = rtxMemAllocType (pctxt, BulletPayment);

            if (pvalue->u.bulletPayment == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BulletPayment (pvalue->u.bulletPayment);
            DOMTest_BulletPayment (pctxt, pvalue->u.bulletPayment, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("capFloor"))) {
            pvalue->t = 10;
            pvalue->u.capFloor = rtxMemAllocType (pctxt, CapFloor);

            if (pvalue->u.capFloor == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CapFloor (pvalue->u.capFloor);
            DOMTest_CapFloor (pctxt, pvalue->u.capFloor, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fra"))) {
            pvalue->t = 11;
            pvalue->u.fra = rtxMemAllocType (pctxt, Fra);

            if (pvalue->u.fra == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Fra (pvalue->u.fra);
            DOMTest_Fra (pctxt, pvalue->u.fra, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("swap"))) {
            pvalue->t = 12;
            pvalue->u.swap = rtxMemAllocType (pctxt, Swap);

            if (pvalue->u.swap == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Swap (pvalue->u.swap);
            DOMTest_Swap (pctxt, pvalue->u.swap, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("swaption"))) {
            pvalue->t = 13;
            pvalue->u.swaption = rtxMemAllocType (pctxt, Swaption);

            if (pvalue->u.swaption == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Swaption (pvalue->u.swaption);
            DOMTest_Swaption (pctxt, pvalue->u.swaption, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityOption"))) {
            pvalue->t = 14;
            pvalue->u.equityOption = rtxMemAllocType (pctxt, EquityOption);

            if (pvalue->u.equityOption == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_EquityOption (pvalue->u.equityOption);
            DOMTest_EquityOption (pctxt, pvalue->u.equityOption, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equitySwap"))) {
            pvalue->t = 15;
            pvalue->u.equitySwap = rtxMemAllocType (pctxt, EquitySwap);

            if (pvalue->u.equitySwap == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_EquitySwap (pvalue->u.equitySwap);
            DOMTest_EquitySwap (pctxt, pvalue->u.equitySwap, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("creditDefaultSwap"))) {
            pvalue->t = 16;
            pvalue->u.creditDefaultSwap
                = rtxMemAllocType (pctxt, CreditDefaultSwap);

            if (pvalue->u.creditDefaultSwap == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CreditDefaultSwap (pvalue->u.creditDefaultSwap);
            DOMTest_CreditDefaultSwap (pctxt, pvalue->u.creditDefaultSwap, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_MasterAgreementType (OSCTXT* pctxt, MasterAgreementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("masterAgreementTypeScheme"))) {
            pvalue->m.masterAgreementTypeSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->masterAgreementTypeScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->masterAgreementTypeScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_MasterAgreement (OSCTXT* pctxt, MasterAgreement* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("masterAgreementType"))) {
            DOMTest_MasterAgreementType (pctxt, &pvalue->masterAgreementType, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("masterAgreementDate"))) {
            pvalue->m.masterAgreementDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->masterAgreementDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->masterAgreementDate = "";
            }
         }
      }
   }

   return 0;
}

int DOMTest_MasterConfirmationType (OSCTXT* pctxt, 
   MasterConfirmationType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("masterConfirmationTypeScheme"))) {
            pvalue->m.masterConfirmationTypeSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->masterConfirmationTypeScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->masterConfirmationTypeScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_MasterConfirmation (OSCTXT* pctxt, MasterConfirmation* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("masterConfirmationType"))) {
            DOMTest_MasterConfirmationType (pctxt, &pvalue->masterConfirmationType, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("masterConfirmationDate"))) {
            if (0 != pXmlNode->children) {
               pvalue->masterConfirmationDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->masterConfirmationDate = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("masterConfirmationAnnexDate"))) {
            pvalue->m.masterConfirmationAnnexDatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->masterConfirmationAnnexDate = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->masterConfirmationAnnexDate = "";
            }
         }
      }
   }

   return 0;
}

int DOMTest_ContractualDefinitions (OSCTXT* pctxt, 
   ContractualDefinitions* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("contractualDefinitionsScheme"))) {
            pvalue->m.contractualDefinitionsSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->contractualDefinitionsScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->contractualDefinitionsScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_ContractualSupplement (OSCTXT* pctxt, 
   ContractualSupplement* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("contractualSupplementScheme"))) {
            pvalue->m.contractualSupplementSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->contractualSupplementScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->contractualSupplementScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_Documentation (OSCTXT* pctxt, Documentation* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("masterAgreement"))) {
            pvalue->m.masterAgreementPresent = 1;
            DOMTest_MasterAgreement (pctxt, &pvalue->masterAgreement, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("masterConfirmation"))) {
            pvalue->m.masterConfirmationPresent = 1;
            DOMTest_MasterConfirmation (pctxt, &pvalue->masterConfirmation, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("contractualDefinitions"))) {
            { ContractualDefinitions* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ContractualDefinitions);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ContractualDefinitions (pdata2);
            DOMTest_ContractualDefinitions (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->contractualDefinitions_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("contractualSupplement"))) {
            { ContractualSupplement* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ContractualSupplement);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ContractualSupplement (pdata2);
            DOMTest_ContractualSupplement (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->contractualSupplement_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("creditSupportDocument"))) {
            pvalue->m.creditSupportDocumentPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->creditSupportDocument = pXmlNode->children->content;
            }
            else {
               pvalue->creditSupportDocument = (const OSUTF8CHAR*)"";
            }
         }
      }
   }

   return 0;
}

int DOMTest_GoverningLaw (OSCTXT* pctxt, GoverningLaw* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("governingLawScheme"))) {
            pvalue->m.governingLawSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->governingLawScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->governingLawScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_Trade (OSCTXT* pctxt, Trade* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("tradeHeader"))) {
            DOMTest_TradeHeader (pctxt, &pvalue->tradeHeader, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("strategy")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxAverageRateOption")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxBarrierOption")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxDigitalOption")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxSimpleOption")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxSingleLeg")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxSwap")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("termDeposit")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("bulletPayment")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("capFloor")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fra")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("swap")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("swaption")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityOption")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equitySwap")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("creditDefaultSwap"))) {
            DOMTest_Product_group (pctxt, &pvalue->product, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("otherPartyPayment"))) {
            { Payment* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Payment);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Payment (pdata2);
            DOMTest_Payment (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->otherPartyPayment_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("brokerPartyReference"))) {
            { PartyReference* pdata2;
            pdata2 = rtxMemAllocType (pctxt, PartyReference);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PartyReference (pdata2);
            DOMTest_PartyReference (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->brokerPartyReference_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationAgent"))) {
            pvalue->m.calculationAgentPresent = 1;
            DOMTest_CalculationAgent (pctxt, &pvalue->calculationAgent, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("calculationAgentBusinessCenter"))) {
            pvalue->m.calculationAgentBusinessCenterPresent = 1;
            DOMTest_BusinessCenter (pctxt, &pvalue->calculationAgentBusinessCenter, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("documentation"))) {
            pvalue->m.documentationPresent = 1;
            DOMTest_Documentation (pctxt, &pvalue->documentation, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("governingLaw"))) {
            pvalue->m.governingLawPresent = 1;
            DOMTest_GoverningLaw (pctxt, &pvalue->governingLaw, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_PortfolioName (OSCTXT* pctxt, PortfolioName* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("portfolioNameScheme"))) {
            pvalue->m.portfolioNameSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->portfolioNameScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->portfolioNameScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_PartyPortfolioName (OSCTXT* pctxt, PartyPortfolioName* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("partyReference"))) {
            DOMTest_PartyReference (pctxt, &pvalue->partyReference, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("portfolioName"))) {
            { PortfolioName* pdata2;
            pdata2 = rtxMemAllocType (pctxt, PortfolioName);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PortfolioName (pdata2);
            DOMTest_PortfolioName (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->portfolioName_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_Portfolio (OSCTXT* pctxt, Portfolio* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("partyPortfolioName"))) {
            pvalue->m.partyPortfolioNamePresent = 1;
            DOMTest_PartyPortfolioName (pctxt, &pvalue->partyPortfolioName, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("tradeId"))) {
            { TradeId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TradeId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TradeId (pdata2);
            DOMTest_TradeId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->tradeId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("portfolio"))) {
            { Portfolio* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Portfolio);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Portfolio ((Portfolio*)pdata2);
            DOMTest_Portfolio (pctxt, (Portfolio*)pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->portfolio_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_PartyId (OSCTXT* pctxt, PartyId* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("partyIdScheme"))) {
            pvalue->m.partyIdSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->partyIdScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->partyIdScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_Party (OSCTXT* pctxt, Party* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("partyId"))) {
            DOMTest_PartyId (pctxt, &pvalue->partyId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("partyName"))) {
            pvalue->m.partyNamePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->partyName = pXmlNode->children->content;
            }
            else {
               pvalue->partyName = (const OSUTF8CHAR*)"";
            }
         }
      }
   }

   return 0;
}

int DOMTest_DataDocument (OSCTXT* pctxt, DataDocument* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               DataDocument_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("validation"))) {
            pvalue->m.validation_modelPresent = 1;
            DOMTest_Validation_model (pctxt, &pvalue->validation_model, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("trade"))) {
            { Trade* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Trade);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Trade (pdata2);
            DOMTest_Trade (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->trade_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("portfolio"))) {
            { Portfolio* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Portfolio);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Portfolio (pdata2);
            DOMTest_Portfolio (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->portfolio_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            { Party* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Party);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Party (pdata2);
            DOMTest_Party (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->party_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_ConversationId (OSCTXT* pctxt, ConversationId* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("conversationIdScheme"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->conversationIdScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->conversationIdScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_MessageId (OSCTXT* pctxt, MessageId* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("messageIdScheme"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->messageIdScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->messageIdScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_NotificationMessageHeader (OSCTXT* pctxt, 
   NotificationMessageHeader* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("conversationId"))) {
            pvalue->m.conversationIdPresent = 1;
            DOMTest_ConversationId (pctxt, &pvalue->conversationId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("messageId"))) {
            DOMTest_MessageId (pctxt, &pvalue->messageId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("inReplyTo"))) {
            pvalue->m.inReplyToPresent = 1;
            DOMTest_MessageId (pctxt, &pvalue->inReplyTo, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("sentBy"))) {
            DOMTest_PartyId (pctxt, &pvalue->sentBy, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("sendTo"))) {
            { PartyId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, PartyId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PartyId (pdata2);
            DOMTest_PartyId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->sendTo_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("copyTo"))) {
            { PartyId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, PartyId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PartyId (pdata2);
            DOMTest_PartyId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->copyTo_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("creationTimestamp"))) {
            if (0 != pXmlNode->children) {
               pvalue->creationTimestamp = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->creationTimestamp = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("expiryTimestamp"))) {
            pvalue->m.expiryTimestampPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->expiryTimestamp = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->expiryTimestamp = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Signature"))) {
            { Signature* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Signature);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Signature (pdata2);
            DOMTest_Signature (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->signature_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_NotificationMessage (OSCTXT* pctxt, NotificationMessage* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               NotificationMessage_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("header"))) {
            DOMTest_NotificationMessageHeader (pctxt, &pvalue->header, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("validation"))) {
            pvalue->m.validation_modelPresent = 1;
            DOMTest_Validation_model (pctxt, &pvalue->validation_model, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_Reason_location (OSCTXT* pctxt, Reason_location* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("locationType"))) {
            pvalue->m.locationTypePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->locationType = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->locationType = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_Reason_validationRuleId (OSCTXT* pctxt, 
   Reason_validationRuleId* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("validationScheme"))) {
            pvalue->m.validationSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->validationScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->validationScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_Reason_additionalData (OSCTXT* pctxt, 
   Reason_additionalData* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("additionalDataType"))) {
            pvalue->m.additionalDataTypePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->additionalDataType = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->additionalDataType = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_Reason (OSCTXT* pctxt, Reason* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("reasonCode"))) {
            if (0 != pXmlNode->children) {
               pvalue->reasonCode = pXmlNode->children->content;
            }
            else {
               pvalue->reasonCode = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("location"))) {
            pvalue->m.locationPresent = 1;
            DOMTest_Reason_location (pctxt, &pvalue->location, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->description = pXmlNode->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("validationRuleId"))) {
            pvalue->m.validationRuleIdPresent = 1;
            DOMTest_Reason_validationRuleId (pctxt, &pvalue->validationRuleId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("additionalData"))) {
            { Reason_additionalData* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Reason_additionalData);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Reason_additionalData (pdata2);
            DOMTest_Reason_additionalData (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->additionalData_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_MessageRejected (OSCTXT* pctxt, MessageRejected* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               MessageRejected_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("reason"))) {
            { Reason* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Reason);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Reason (pdata2);
            DOMTest_Reason (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->reason_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("additionalData"))) {
            pvalue->m.additionalDataPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->additionalData = pXmlNode->children->content;
            }
            else {
               pvalue->additionalData = (const OSUTF8CHAR*)"";
            }
         }
      }
   }

   return 0;
}

int DOMTest_TradeAffirmation (OSCTXT* pctxt, TradeAffirmation* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               TradeAffirmation_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("trade"))) {
            DOMTest_Trade (pctxt, &pvalue->trade, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            { Party* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Party);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Party (pdata2);
            DOMTest_Party (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->party_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_TradeIdentifier (OSCTXT* pctxt, TradeIdentifier* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("partyReference"))) {
            DOMTest_PartyReference (pctxt, &pvalue->partyReference, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("tradeId"))) {
            { TradeId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TradeId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TradeId (pdata2);
            DOMTest_TradeId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->tradeId_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_TradeIdentifier_derivations (OSCTXT* pctxt, 
   TradeIdentifier_derivations* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("TradeIdentifier");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("TradeIdentifier")))
   {
      pvalue->t = 1;
      pvalue->u.tradeIdentifier = rtxMemAllocType (pctxt, TradeIdentifier);

      if (pvalue->u.tradeIdentifier == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TradeIdentifier (pvalue->u.tradeIdentifier);
      DOMTest_TradeIdentifier (pctxt, pvalue->u.tradeIdentifier, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("PartyTradeIdentifier")))
   {
      pvalue->t = 2;
      pvalue->u.partyTradeIdentifier
          = rtxMemAllocType (pctxt, PartyTradeIdentifier);

      if (pvalue->u.partyTradeIdentifier == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PartyTradeIdentifier (pvalue->u.partyTradeIdentifier);
      DOMTest_PartyTradeIdentifier (pctxt, pvalue->u.partyTradeIdentifier, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_TradeAlleged (OSCTXT* pctxt, TradeAlleged* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               TradeAlleged_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("tradeIdentifier"))) {
            DOMTest_TradeIdentifier_derivations (pctxt, &pvalue->tradeIdentifier, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("bestFitTradeId"))) {
            { TradeIdentifier_derivations* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TradeIdentifier_derivations);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TradeIdentifier_derivations (pdata2);
            DOMTest_TradeIdentifier_derivations (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->bestFitTradeId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            { Party* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Party);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Party (pdata2);
            DOMTest_Party (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->party_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_TradeConfirmed (OSCTXT* pctxt, TradeConfirmed* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               TradeConfirmed_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("trade"))) {
            DOMTest_Trade (pctxt, &pvalue->trade, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            { Party* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Party);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Party (pdata2);
            DOMTest_Party (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->party_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_TradeDifference (OSCTXT* pctxt, TradeDifference* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("differenceType"))) {
            if (0 != pXmlNode->children) {
               DifferenceTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->differenceType);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("differenceSeverity"))) {
            if (0 != pXmlNode->children) {
               DifferenceSeverityEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->differenceSeverity);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("element"))) {
            if (0 != pXmlNode->children) {
               pvalue->element = pXmlNode->children->content;
            }
            else {
               pvalue->element = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("basePath"))) {
            pvalue->m.basePathPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->basePath = pXmlNode->children->content;
            }
            else {
               pvalue->basePath = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("baseValue"))) {
            pvalue->m.baseValuePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->baseValue = pXmlNode->children->content;
            }
            else {
               pvalue->baseValue = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("otherPath"))) {
            pvalue->m.otherPathPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->otherPath = pXmlNode->children->content;
            }
            else {
               pvalue->otherPath = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("otherValue"))) {
            pvalue->m.otherValuePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->otherValue = pXmlNode->children->content;
            }
            else {
               pvalue->otherValue = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("missingElement"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            else {
               pdata2 = (const OSUTF8CHAR*)"";
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->missingElement_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("extraElement"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            else {
               pdata2 = (const OSUTF8CHAR*)"";
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->extraElement_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("message"))) {
            if (0 != pXmlNode->children) {
               pvalue->message = pXmlNode->children->content;
            }
            else {
               pvalue->message = (const OSUTF8CHAR*)"";
            }
         }
      }
   }

   return 0;
}

int DOMTest_TradeMatched (OSCTXT* pctxt, TradeMatched* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               TradeMatched_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("tradeIdentifier"))) {
            { TradeIdentifier_derivations* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TradeIdentifier_derivations);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TradeIdentifier_derivations (pdata2);
            DOMTest_TradeIdentifier_derivations (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->tradeIdentifier_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("differences"))) {
            { TradeDifference* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TradeDifference);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TradeDifference (pdata2);
            DOMTest_TradeDifference (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->differences_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            { Party* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Party);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Party (pdata2);
            DOMTest_Party (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->party_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_BestFitTrade (OSCTXT* pctxt, BestFitTrade* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("tradeIdentifier"))) {
            DOMTest_TradeIdentifier_derivations (pctxt, &pvalue->tradeIdentifier, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("differences"))) {
            { TradeDifference* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TradeDifference);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TradeDifference (pdata2);
            DOMTest_TradeDifference (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->differences_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_TradeMismatched (OSCTXT* pctxt, TradeMismatched* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               TradeMismatched_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("tradeIdentifier"))) {
            DOMTest_TradeIdentifier_derivations (pctxt, &pvalue->tradeIdentifier, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("bestFitTrade"))) {
            { BestFitTrade* pdata2;
            pdata2 = rtxMemAllocType (pctxt, BestFitTrade);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_BestFitTrade (pdata2);
            DOMTest_BestFitTrade (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->bestFitTrade_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            { Party* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Party);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Party (pdata2);
            DOMTest_Party (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->party_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_TradeUnmatched (OSCTXT* pctxt, TradeUnmatched* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               TradeUnmatched_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("tradeIdentifier"))) {
            DOMTest_TradeIdentifier_derivations (pctxt, &pvalue->tradeIdentifier, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("bestFitTradeId"))) {
            { TradeIdentifier_derivations* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TradeIdentifier_derivations);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TradeIdentifier_derivations (pdata2);
            DOMTest_TradeIdentifier_derivations (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->bestFitTradeId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            { Party* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Party);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Party (pdata2);
            DOMTest_Party (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->party_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_TradeCreated (OSCTXT* pctxt, TradeCreated* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               TradeCreated_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("trade"))) {
            DOMTest_Trade (pctxt, &pvalue->trade, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            { Party* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Party);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Party (pdata2);
            DOMTest_Party (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->party_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_TradeAmended (OSCTXT* pctxt, TradeAmended* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               TradeAmended_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("trade"))) {
            DOMTest_Trade (pctxt, &pvalue->trade, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            { Party* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Party);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Party (pdata2);
            DOMTest_Party (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->party_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_TradeCancelled (OSCTXT* pctxt, TradeCancelled* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               TradeCancelled_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("tradeIdentifier"))) {
            { TradeIdentifier_derivations* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TradeIdentifier_derivations);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TradeIdentifier_derivations (pdata2);
            DOMTest_TradeIdentifier_derivations (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->tradeIdentifier_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            { Party* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Party);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Party (pdata2);
            DOMTest_Party (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->party_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_NotificationMessage_derivations (OSCTXT* pctxt, 
   NotificationMessage_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("NotificationMessage");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("NotificationMessage")))
   {
      pvalue->t = 1;
      pvalue->u.notificationMessage
          = rtxMemAllocType (pctxt, NotificationMessage);

      if (pvalue->u.notificationMessage == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NotificationMessage (pvalue->u.notificationMessage);
      DOMTest_NotificationMessage (pctxt, pvalue->u.notificationMessage, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("MessageRejected")))
   {
      pvalue->t = 2;
      pvalue->u.messageRejected = rtxMemAllocType (pctxt, MessageRejected);

      if (pvalue->u.messageRejected == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MessageRejected (pvalue->u.messageRejected);
      DOMTest_MessageRejected (pctxt, pvalue->u.messageRejected, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("TradeAffirmation")))
   {
      pvalue->t = 3;
      pvalue->u.tradeAffirmation = rtxMemAllocType (pctxt, TradeAffirmation);

      if (pvalue->u.tradeAffirmation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TradeAffirmation (pvalue->u.tradeAffirmation);
      DOMTest_TradeAffirmation (pctxt, pvalue->u.tradeAffirmation, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("TradeAlleged")))
   {
      pvalue->t = 4;
      pvalue->u.tradeAlleged = rtxMemAllocType (pctxt, TradeAlleged);

      if (pvalue->u.tradeAlleged == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TradeAlleged (pvalue->u.tradeAlleged);
      DOMTest_TradeAlleged (pctxt, pvalue->u.tradeAlleged, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("TradeConfirmed")))
   {
      pvalue->t = 5;
      pvalue->u.tradeConfirmed = rtxMemAllocType (pctxt, TradeConfirmed);

      if (pvalue->u.tradeConfirmed == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TradeConfirmed (pvalue->u.tradeConfirmed);
      DOMTest_TradeConfirmed (pctxt, pvalue->u.tradeConfirmed, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("TradeMatched")))
   {
      pvalue->t = 6;
      pvalue->u.tradeMatched = rtxMemAllocType (pctxt, TradeMatched);

      if (pvalue->u.tradeMatched == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TradeMatched (pvalue->u.tradeMatched);
      DOMTest_TradeMatched (pctxt, pvalue->u.tradeMatched, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("TradeMismatched")))
   {
      pvalue->t = 7;
      pvalue->u.tradeMismatched = rtxMemAllocType (pctxt, TradeMismatched);

      if (pvalue->u.tradeMismatched == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TradeMismatched (pvalue->u.tradeMismatched);
      DOMTest_TradeMismatched (pctxt, pvalue->u.tradeMismatched, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("TradeUnmatched")))
   {
      pvalue->t = 8;
      pvalue->u.tradeUnmatched = rtxMemAllocType (pctxt, TradeUnmatched);

      if (pvalue->u.tradeUnmatched == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TradeUnmatched (pvalue->u.tradeUnmatched);
      DOMTest_TradeUnmatched (pctxt, pvalue->u.tradeUnmatched, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("TradeCreated")))
   {
      pvalue->t = 9;
      pvalue->u.tradeCreated = rtxMemAllocType (pctxt, TradeCreated);

      if (pvalue->u.tradeCreated == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TradeCreated (pvalue->u.tradeCreated);
      DOMTest_TradeCreated (pctxt, pvalue->u.tradeCreated, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("TradeAmended")))
   {
      pvalue->t = 10;
      pvalue->u.tradeAmended = rtxMemAllocType (pctxt, TradeAmended);

      if (pvalue->u.tradeAmended == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TradeAmended (pvalue->u.tradeAmended);
      DOMTest_TradeAmended (pctxt, pvalue->u.tradeAmended, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("TradeCancelled")))
   {
      pvalue->t = 11;
      pvalue->u.tradeCancelled = rtxMemAllocType (pctxt, TradeCancelled);

      if (pvalue->u.tradeCancelled == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TradeCancelled (pvalue->u.tradeCancelled);
      DOMTest_TradeCancelled (pctxt, pvalue->u.tradeCancelled, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_ModifyTradeConfirmation (OSCTXT* pctxt, 
   ModifyTradeConfirmation* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               ModifyTradeConfirmation_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("trade"))) {
            DOMTest_Trade (pctxt, &pvalue->trade, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            { Party* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Party);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Party (pdata2);
            DOMTest_Party (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->party_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_ModifyTradeMatch (OSCTXT* pctxt, ModifyTradeMatch* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               ModifyTradeMatch_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("trade"))) {
            DOMTest_Trade (pctxt, &pvalue->trade, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            { Party* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Party);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Party (pdata2);
            DOMTest_Party (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->party_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_RequestTradeConfirmation (OSCTXT* pctxt, 
   RequestTradeConfirmation* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               RequestTradeConfirmation_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("trade"))) {
            DOMTest_Trade (pctxt, &pvalue->trade, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            { Party* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Party);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Party (pdata2);
            DOMTest_Party (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->party_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_RequestTradeMatch (OSCTXT* pctxt, RequestTradeMatch* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               RequestTradeMatch_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("trade"))) {
            DOMTest_Trade (pctxt, &pvalue->trade, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            { Party* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Party);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Party (pdata2);
            DOMTest_Party (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->party_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_RequestTradeStatus (OSCTXT* pctxt, RequestTradeStatus* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               RequestTradeStatus_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("tradeIdentifier"))) {
            { TradeIdentifier_derivations* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TradeIdentifier_derivations);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TradeIdentifier_derivations (pdata2);
            DOMTest_TradeIdentifier_derivations (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->tradeIdentifier_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            { Party* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Party);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Party (pdata2);
            DOMTest_Party (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->party_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_CancelTradeMatch (OSCTXT* pctxt, CancelTradeMatch* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               CancelTradeMatch_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("partyTradeIdentifier"))) {
            DOMTest_PartyTradeIdentifier (pctxt, &pvalue->partyTradeIdentifier, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            DOMTest_Party (pctxt, &pvalue->party, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_CancelTradeConfirmation (OSCTXT* pctxt, 
   CancelTradeConfirmation* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               CancelTradeConfirmation_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("partyTradeIdentifier"))) {
            DOMTest_PartyTradeIdentifier (pctxt, &pvalue->partyTradeIdentifier, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            DOMTest_Party (pctxt, &pvalue->party, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_ConfirmTrade (OSCTXT* pctxt, ConfirmTrade* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               ConfirmTrade_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("partyTradeIdentifier"))) {
            DOMTest_PartyTradeIdentifier (pctxt, &pvalue->partyTradeIdentifier, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            DOMTest_Party (pctxt, &pvalue->party, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_QuotableProduct_1 (OSCTXT* pctxt, QuotableProduct_1* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productType"))) {
            pvalue->m.productTypePresent = 1;
            DOMTest_ProductType (pctxt, &pvalue->productType, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productId"))) {
            { ProductId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ProductId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ProductId (pdata2);
            DOMTest_ProductId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->productId_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_QuotableProduct_derivations (OSCTXT* pctxt, 
   QuotableProduct_derivations* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("QuotableProduct");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("QuotableProduct")))
   {
      pvalue->t = 1;
      pvalue->u.quotableProduct = rtxMemAllocType (pctxt, QuotableProduct_1);

      if (pvalue->u.quotableProduct == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QuotableProduct_1 (pvalue->u.quotableProduct);
      DOMTest_QuotableProduct_1 (pctxt, pvalue->u.quotableProduct, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("QuotableFXLeg")))
   {
      pvalue->t = 2;
      pvalue->u.quotableFXLeg = rtxMemAllocType (pctxt, QuotableFXLeg);

      if (pvalue->u.quotableFXLeg == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QuotableFXLeg (pvalue->u.quotableFXLeg);
      DOMTest_QuotableFXLeg (pctxt, pvalue->u.quotableFXLeg, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_QuotableProduct (OSCTXT* pctxt, QuotableProduct* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_QuotableProduct_derivations (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_QuotableProduct_group (OSCTXT* pctxt, 
   QuotableProduct_group* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("quotableProduct"))) {
            pvalue->t = 1;
            pvalue->u.quotableProduct
                = rtxMemAllocType (pctxt, QuotableProduct);

            if (pvalue->u.quotableProduct == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_QuotableProduct (pvalue->u.quotableProduct);
            DOMTest_QuotableProduct (pctxt, pvalue->u.quotableProduct, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("quotableFxSingleLeg"))) {
            pvalue->t = 2;
            pvalue->u.quotableFxSingleLeg
                = rtxMemAllocType (pctxt, QuotableFxSingleLeg);

            if (pvalue->u.quotableFxSingleLeg == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_QuotableFxSingleLeg (pvalue->u.quotableFxSingleLeg);
            DOMTest_QuotableFxSingleLeg (pctxt, pvalue->u.quotableFxSingleLeg, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_RequestQuote (OSCTXT* pctxt, RequestQuote* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               RequestQuote_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("quotableProduct")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("quotableFxSingleLeg"))) {
            { QuotableProduct_group* pdata2;
            pdata2 = rtxMemAllocType (pctxt, QuotableProduct_group);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_QuotableProduct_group (pdata2);
            DOMTest_QuotableProduct_group (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->quotableProduct_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            { Party* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Party);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Party (pdata2);
            DOMTest_Party (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->party_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_RequestMessage_derivations (OSCTXT* pctxt, 
   RequestMessage_derivations* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      return LOG_RTERR1 (pctxt, RTERR_ATTRMISRQ,
         rtxErrAddStrParm (pctxt, "xsi:type"));
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("ModifyTradeConfirmation")))
   {
      pvalue->t = 1;
      pvalue->u.modifyTradeConfirmation
          = rtxMemAllocType (pctxt, ModifyTradeConfirmation);

      if (pvalue->u.modifyTradeConfirmation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ModifyTradeConfirmation (pvalue->u.modifyTradeConfirmation);
      DOMTest_ModifyTradeConfirmation (pctxt, pvalue->u.modifyTradeConfirmation, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("ModifyTradeMatch")))
   {
      pvalue->t = 2;
      pvalue->u.modifyTradeMatch = rtxMemAllocType (pctxt, ModifyTradeMatch);

      if (pvalue->u.modifyTradeMatch == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ModifyTradeMatch (pvalue->u.modifyTradeMatch);
      DOMTest_ModifyTradeMatch (pctxt, pvalue->u.modifyTradeMatch, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("RequestTradeConfirmation")))
   {
      pvalue->t = 3;
      pvalue->u.requestTradeConfirmation
          = rtxMemAllocType (pctxt, RequestTradeConfirmation);

      if (pvalue->u.requestTradeConfirmation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RequestTradeConfirmation (pvalue->u.requestTradeConfirmation);
      DOMTest_RequestTradeConfirmation (pctxt, pvalue->u.requestTradeConfirmation, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("RequestTradeMatch")))
   {
      pvalue->t = 4;
      pvalue->u.requestTradeMatch
          = rtxMemAllocType (pctxt, RequestTradeMatch);

      if (pvalue->u.requestTradeMatch == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RequestTradeMatch (pvalue->u.requestTradeMatch);
      DOMTest_RequestTradeMatch (pctxt, pvalue->u.requestTradeMatch, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("RequestTradeStatus")))
   {
      pvalue->t = 5;
      pvalue->u.requestTradeStatus
          = rtxMemAllocType (pctxt, RequestTradeStatus);

      if (pvalue->u.requestTradeStatus == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RequestTradeStatus (pvalue->u.requestTradeStatus);
      DOMTest_RequestTradeStatus (pctxt, pvalue->u.requestTradeStatus, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("CancelTradeMatch")))
   {
      pvalue->t = 6;
      pvalue->u.cancelTradeMatch = rtxMemAllocType (pctxt, CancelTradeMatch);

      if (pvalue->u.cancelTradeMatch == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CancelTradeMatch (pvalue->u.cancelTradeMatch);
      DOMTest_CancelTradeMatch (pctxt, pvalue->u.cancelTradeMatch, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("CancelTradeConfirmation")))
   {
      pvalue->t = 7;
      pvalue->u.cancelTradeConfirmation
          = rtxMemAllocType (pctxt, CancelTradeConfirmation);

      if (pvalue->u.cancelTradeConfirmation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CancelTradeConfirmation (pvalue->u.cancelTradeConfirmation);
      DOMTest_CancelTradeConfirmation (pctxt, pvalue->u.cancelTradeConfirmation, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("ConfirmTrade")))
   {
      pvalue->t = 8;
      pvalue->u.confirmTrade = rtxMemAllocType (pctxt, ConfirmTrade);

      if (pvalue->u.confirmTrade == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ConfirmTrade (pvalue->u.confirmTrade);
      DOMTest_ConfirmTrade (pctxt, pvalue->u.confirmTrade, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("RequestQuote")))
   {
      pvalue->t = 9;
      pvalue->u.requestQuote = rtxMemAllocType (pctxt, RequestQuote);

      if (pvalue->u.requestQuote == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RequestQuote (pvalue->u.requestQuote);
      DOMTest_RequestQuote (pctxt, pvalue->u.requestQuote, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_ResponseMessageHeader (OSCTXT* pctxt, 
   ResponseMessageHeader* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("conversationId"))) {
            pvalue->m.conversationIdPresent = 1;
            DOMTest_ConversationId (pctxt, &pvalue->conversationId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("messageId"))) {
            DOMTest_MessageId (pctxt, &pvalue->messageId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("inReplyTo"))) {
            DOMTest_MessageId (pctxt, &pvalue->inReplyTo, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("sentBy"))) {
            DOMTest_PartyId (pctxt, &pvalue->sentBy, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("sendTo"))) {
            { PartyId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, PartyId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PartyId (pdata2);
            DOMTest_PartyId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->sendTo_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("copyTo"))) {
            { PartyId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, PartyId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PartyId (pdata2);
            DOMTest_PartyId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->copyTo_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("creationTimestamp"))) {
            if (0 != pXmlNode->children) {
               pvalue->creationTimestamp = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->creationTimestamp = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("expiryTimestamp"))) {
            pvalue->m.expiryTimestampPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->expiryTimestamp = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->expiryTimestamp = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Signature"))) {
            { Signature* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Signature);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Signature (pdata2);
            DOMTest_Signature (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->signature_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_ResponseMessage (OSCTXT* pctxt, ResponseMessage* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               ResponseMessage_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("header"))) {
            DOMTest_ResponseMessageHeader (pctxt, &pvalue->header, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("validation"))) {
            pvalue->m.validation_modelPresent = 1;
            DOMTest_Validation_model (pctxt, &pvalue->validation_model, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_TradeAffirmed (OSCTXT* pctxt, TradeAffirmed* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               TradeAffirmed_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("tradeIdentifier"))) {
            { TradeIdentifier_derivations* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TradeIdentifier_derivations);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TradeIdentifier_derivations (pdata2);
            DOMTest_TradeIdentifier_derivations (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->tradeIdentifier_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            { Party* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Party);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Party (pdata2);
            DOMTest_Party (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->party_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_TradeAlreadyMatched (OSCTXT* pctxt, TradeAlreadyMatched* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               TradeAlreadyMatched_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("tradeIdentifier"))) {
            DOMTest_TradeIdentifier_derivations (pctxt, &pvalue->tradeIdentifier, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            DOMTest_Party (pctxt, &pvalue->party, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_TradeAlreadySubmitted (OSCTXT* pctxt, 
   TradeAlreadySubmitted* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               TradeAlreadySubmitted_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("tradeIdentifier"))) {
            DOMTest_TradeIdentifier_derivations (pctxt, &pvalue->tradeIdentifier, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            DOMTest_Party (pctxt, &pvalue->party, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_TradeNotFound (OSCTXT* pctxt, TradeNotFound* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               TradeNotFound_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("tradeIdentifier"))) {
            DOMTest_TradeIdentifier_derivations (pctxt, &pvalue->tradeIdentifier, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            DOMTest_Party (pctxt, &pvalue->party, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_TradeStatusValue (OSCTXT* pctxt, TradeStatusValue* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("tradeStatusScheme"))) {
            pvalue->m.tradeStatusSchemePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->tradeStatusScheme = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->tradeStatusScheme = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_TradeStatusItem (OSCTXT* pctxt, TradeStatusItem* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("tradeIdentifier"))) {
            DOMTest_TradeIdentifier_derivations (pctxt, &pvalue->tradeIdentifier, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("tradeStatusValue"))) {
            DOMTest_TradeStatusValue (pctxt, &pvalue->tradeStatusValue, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_TradeStatus (OSCTXT* pctxt, TradeStatus* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               TradeStatus_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("tradeStatusItem"))) {
            { TradeStatusItem* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TradeStatusItem);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TradeStatusItem (pdata2);
            DOMTest_TradeStatusItem (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->tradeStatusItem_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            { Party* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Party);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Party (pdata2);
            DOMTest_Party (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->party_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_ConfirmationCancelled (OSCTXT* pctxt, 
   ConfirmationCancelled* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               ConfirmationCancelled_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("tradeIdentifier"))) {
            DOMTest_TradeIdentifier_derivations (pctxt, &pvalue->tradeIdentifier, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            DOMTest_Party (pctxt, &pvalue->party, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_RequestQuoteResponse (OSCTXT* pctxt, RequestQuoteResponse* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               RequestQuoteResponse_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("strategy")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxAverageRateOption")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxBarrierOption")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxDigitalOption")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxSimpleOption")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxSingleLeg")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxSwap")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("termDeposit")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("bulletPayment")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("capFloor")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fra")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("swap")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("swaption")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityOption")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equitySwap")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("creditDefaultSwap"))) {
            { Product_group* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Product_group);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Product_group (pdata2);
            DOMTest_Product_group (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->product_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            { Party* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Party);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Party (pdata2);
            DOMTest_Party (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->party_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_AcceptQuote (OSCTXT* pctxt, AcceptQuote* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               AcceptQuote_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("trade"))) {
            { Trade* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Trade);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Trade (pdata2);
            DOMTest_Trade (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->trade_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            { Party* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Party);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Party (pdata2);
            DOMTest_Party (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->party_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_QuoteAcceptanceConfirmed (OSCTXT* pctxt, 
   QuoteAcceptanceConfirmed* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               QuoteAcceptanceConfirmed_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("trade"))) {
            { Trade* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Trade);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Trade (pdata2);
            DOMTest_Trade (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->trade_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            { Party* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Party);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Party (pdata2);
            DOMTest_Party (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->party_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_QuoteUpdated (OSCTXT* pctxt, QuoteUpdated* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               QuoteUpdated_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("quotableProduct")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("quotableFxSingleLeg"))) {
            { QuotableProduct_group* pdata2;
            pdata2 = rtxMemAllocType (pctxt, QuotableProduct_group);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_QuotableProduct_group (pdata2);
            DOMTest_QuotableProduct_group (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->quotableProduct_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("party"))) {
            { Party* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Party);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Party (pdata2);
            DOMTest_Party (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->party_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_QuoteAlreadyExpired (OSCTXT* pctxt, QuoteAlreadyExpired* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               QuoteAlreadyExpired_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_ResponseMessage_derivations (OSCTXT* pctxt, 
   ResponseMessage_derivations* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("ResponseMessage");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("ResponseMessage")))
   {
      pvalue->t = 1;
      pvalue->u.responseMessage = rtxMemAllocType (pctxt, ResponseMessage);

      if (pvalue->u.responseMessage == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ResponseMessage (pvalue->u.responseMessage);
      DOMTest_ResponseMessage (pctxt, pvalue->u.responseMessage, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("TradeAffirmed")))
   {
      pvalue->t = 2;
      pvalue->u.tradeAffirmed = rtxMemAllocType (pctxt, TradeAffirmed);

      if (pvalue->u.tradeAffirmed == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TradeAffirmed (pvalue->u.tradeAffirmed);
      DOMTest_TradeAffirmed (pctxt, pvalue->u.tradeAffirmed, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("TradeAlreadyMatched")))
   {
      pvalue->t = 3;
      pvalue->u.tradeAlreadyMatched
          = rtxMemAllocType (pctxt, TradeAlreadyMatched);

      if (pvalue->u.tradeAlreadyMatched == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TradeAlreadyMatched (pvalue->u.tradeAlreadyMatched);
      DOMTest_TradeAlreadyMatched (pctxt, pvalue->u.tradeAlreadyMatched, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("TradeAlreadySubmitted")))
   {
      pvalue->t = 4;
      pvalue->u.tradeAlreadySubmitted
          = rtxMemAllocType (pctxt, TradeAlreadySubmitted);

      if (pvalue->u.tradeAlreadySubmitted == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TradeAlreadySubmitted (pvalue->u.tradeAlreadySubmitted);
      DOMTest_TradeAlreadySubmitted (pctxt, pvalue->u.tradeAlreadySubmitted, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("TradeNotFound")))
   {
      pvalue->t = 5;
      pvalue->u.tradeNotFound = rtxMemAllocType (pctxt, TradeNotFound);

      if (pvalue->u.tradeNotFound == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TradeNotFound (pvalue->u.tradeNotFound);
      DOMTest_TradeNotFound (pctxt, pvalue->u.tradeNotFound, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("TradeStatus")))
   {
      pvalue->t = 6;
      pvalue->u.tradeStatus = rtxMemAllocType (pctxt, TradeStatus);

      if (pvalue->u.tradeStatus == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TradeStatus (pvalue->u.tradeStatus);
      DOMTest_TradeStatus (pctxt, pvalue->u.tradeStatus, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("ConfirmationCancelled")))
   {
      pvalue->t = 7;
      pvalue->u.confirmationCancelled
          = rtxMemAllocType (pctxt, ConfirmationCancelled);

      if (pvalue->u.confirmationCancelled == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ConfirmationCancelled (pvalue->u.confirmationCancelled);
      DOMTest_ConfirmationCancelled (pctxt, pvalue->u.confirmationCancelled, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("RequestQuoteResponse")))
   {
      pvalue->t = 8;
      pvalue->u.requestQuoteResponse
          = rtxMemAllocType (pctxt, RequestQuoteResponse);

      if (pvalue->u.requestQuoteResponse == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RequestQuoteResponse (pvalue->u.requestQuoteResponse);
      DOMTest_RequestQuoteResponse (pctxt, pvalue->u.requestQuoteResponse, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("AcceptQuote")))
   {
      pvalue->t = 9;
      pvalue->u.acceptQuote = rtxMemAllocType (pctxt, AcceptQuote);

      if (pvalue->u.acceptQuote == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AcceptQuote (pvalue->u.acceptQuote);
      DOMTest_AcceptQuote (pctxt, pvalue->u.acceptQuote, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("QuoteAcceptanceConfirmed")))
   {
      pvalue->t = 10;
      pvalue->u.quoteAcceptanceConfirmed
          = rtxMemAllocType (pctxt, QuoteAcceptanceConfirmed);

      if (pvalue->u.quoteAcceptanceConfirmed == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QuoteAcceptanceConfirmed (pvalue->u.quoteAcceptanceConfirmed);
      DOMTest_QuoteAcceptanceConfirmed (pctxt, pvalue->u.quoteAcceptanceConfirmed, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("QuoteUpdated")))
   {
      pvalue->t = 11;
      pvalue->u.quoteUpdated = rtxMemAllocType (pctxt, QuoteUpdated);

      if (pvalue->u.quoteUpdated == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QuoteUpdated (pvalue->u.quoteUpdated);
      DOMTest_QuoteUpdated (pctxt, pvalue->u.quoteUpdated, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("QuoteAlreadyExpired")))
   {
      pvalue->t = 12;
      pvalue->u.quoteAlreadyExpired
          = rtxMemAllocType (pctxt, QuoteAlreadyExpired);

      if (pvalue->u.quoteAlreadyExpired == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_QuoteAlreadyExpired (pvalue->u.quoteAlreadyExpired);
      DOMTest_QuoteAlreadyExpired (pctxt, pvalue->u.quoteAlreadyExpired, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_Message_derivations (OSCTXT* pctxt, Message_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      return LOG_RTERR1 (pctxt, RTERR_ATTRMISRQ,
         rtxErrAddStrParm (pctxt, "xsi:type"));
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("NotificationMessage"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("MessageRejected"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TradeAffirmation"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TradeAlleged"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TradeConfirmed"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TradeMatched"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TradeMismatched"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TradeUnmatched"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TradeCreated"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TradeAmended"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TradeCancelled")))
   {
      pvalue->t = 1;
      pvalue->u.notificationMessage
          = rtxMemAllocType (pctxt, NotificationMessage_derivations);

      if (pvalue->u.notificationMessage == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NotificationMessage_derivations (pvalue->u.notificationMessage);
      DOMTest_NotificationMessage_derivations (pctxt, pvalue->u.notificationMessage, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("ModifyTradeConfirmation"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("ModifyTradeMatch"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("RequestTradeConfirmation"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("RequestTradeMatch"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("RequestTradeStatus"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("CancelTradeMatch"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("CancelTradeConfirmation"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("ConfirmTrade"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("RequestQuote")))
   {
      pvalue->t = 2;
      pvalue->u.requestMessage
          = rtxMemAllocType (pctxt, RequestMessage_derivations);

      if (pvalue->u.requestMessage == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RequestMessage_derivations (pvalue->u.requestMessage);
      DOMTest_RequestMessage_derivations (pctxt, pvalue->u.requestMessage, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("ResponseMessage"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TradeAffirmed"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TradeAlreadyMatched"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TradeAlreadySubmitted"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TradeNotFound"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TradeStatus"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("ConfirmationCancelled"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("RequestQuoteResponse"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("AcceptQuote"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("QuoteAcceptanceConfirmed"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("QuoteUpdated"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("QuoteAlreadyExpired")))
   {
      pvalue->t = 3;
      pvalue->u.responseMessage
          = rtxMemAllocType (pctxt, ResponseMessage_derivations);

      if (pvalue->u.responseMessage == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ResponseMessage_derivations (pvalue->u.responseMessage);
      DOMTest_ResponseMessage_derivations (pctxt, pvalue->u.responseMessage, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_Document_derivations (OSCTXT* pctxt, Document_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      return LOG_RTERR1 (pctxt, RTERR_ATTRMISRQ,
         rtxErrAddStrParm (pctxt, "xsi:type"));
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("DataDocument")))
   {
      pvalue->t = 1;
      pvalue->u.dataDocument = rtxMemAllocType (pctxt, DataDocument);

      if (pvalue->u.dataDocument == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DataDocument (pvalue->u.dataDocument);
      DOMTest_DataDocument (pctxt, pvalue->u.dataDocument, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("NotificationMessage"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("MessageRejected"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TradeAffirmation"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TradeAlleged"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TradeConfirmed"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TradeMatched"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TradeMismatched"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TradeUnmatched"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TradeCreated"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TradeAmended"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TradeCancelled"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("ModifyTradeConfirmation"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("ModifyTradeMatch"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("RequestTradeConfirmation"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("RequestTradeMatch"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("RequestTradeStatus"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("CancelTradeMatch"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("CancelTradeConfirmation"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("ConfirmTrade"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("RequestQuote"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("ResponseMessage"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TradeAffirmed"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TradeAlreadyMatched"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TradeAlreadySubmitted"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TradeNotFound"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TradeStatus"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("ConfirmationCancelled"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("RequestQuoteResponse"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("AcceptQuote"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("QuoteAcceptanceConfirmed"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("QuoteUpdated"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("QuoteAlreadyExpired")))
   {
      pvalue->t = 2;
      pvalue->u.message = rtxMemAllocType (pctxt, Message_derivations);

      if (pvalue->u.message == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Message_derivations (pvalue->u.message);
      DOMTest_Message_derivations (pctxt, pvalue->u.message, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_FpML (OSCTXT* pctxt, FpML* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_Document_derivations (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_Exercise_1 (OSCTXT* pctxt, Exercise_1* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_Exercise (OSCTXT* pctxt, Exercise* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_Exercise_1 (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_Product_1 (OSCTXT* pctxt, Product_1* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productType"))) {
            pvalue->m.productTypePresent = 1;
            DOMTest_ProductType (pctxt, &pvalue->productType, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("productId"))) {
            { ProductId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ProductId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ProductId (pdata2);
            DOMTest_ProductId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->productId_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_Product (OSCTXT* pctxt, Product* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_Product_1 (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_UnderlyingAsset (OSCTXT* pctxt, UnderlyingAsset* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_UnderlyingAsset_1 (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_SettlementTerms_1 (OSCTXT* pctxt, SettlementTerms_1* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_Currency (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_TradeReference (OSCTXT* pctxt, TradeReference* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->href = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->href = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_Document (OSCTXT* pctxt, Document* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               Document_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_SharedAmericanExercise (OSCTXT* pctxt, 
   SharedAmericanExercise* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("commencementDate"))) {
            DOMTest_AdjustableOrRelativeDate (pctxt, &pvalue->commencementDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("expirationDate"))) {
            DOMTest_AdjustableOrRelativeDate (pctxt, &pvalue->expirationDate, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("latestExerciseTime"))) {
            pvalue->m.latestExerciseTimePresent = 1;
            DOMTest_BusinessCenterTime (pctxt, &pvalue->latestExerciseTime, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_initialPrice_sequence_fxConversion (OSCTXT* pctxt, 
   EquitySwapValuation_initialPrice_sequence_fxConversion* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 1;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxRate"))) {
            pvalue->t = 2;
            pvalue->u.fxRate_list = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.fxRate_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.fxRate_list);
            {
            FxRate_derivations* pdata2;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxRate"))) {
                     pdata2 = rtxMemAllocType (pctxt, FxRate_derivations);

                     if (pdata2 == NULL)
                        return LOG_RTERR (pctxt, RTERR_NOMEM);

                     asn1Init_FxRate_derivations (pdata2);
                     DOMTest_FxRate_derivations (pctxt, pdata2, pXmlNode, TRUE);
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, pvalue->u.fxRate_list, (void*)pdata2);
                  }
               }
            }
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_initialPrice_sequence (OSCTXT* pctxt, 
   EquitySwapValuation_initialPrice_sequence* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice"))) {
            pvalue->m.grossPricePresent = 1;
            DOMTest_ActualPrice (pctxt, &pvalue->grossPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            DOMTest_ActualPrice (pctxt, &pvalue->netPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("accruedInterestPrice"))) {
            pvalue->m.accruedInterestPricePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->accruedInterestPrice);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxConversion"))) {
            pvalue->m.fxConversionPresent = 1;
            DOMTest_EquitySwapValuation_initialPrice_sequence_fxConversion (pctxt, &pvalue->fxConversion, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_initialPrice_choice (OSCTXT* pctxt, 
   EquitySwapValuation_initialPrice_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               pvalue->u.determinationMethod = pXmlNode->children->content;
            }
            else {
               pvalue->u.determinationMethod = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 2;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            pvalue->t = 3;
            pvalue->u.sequence
                = rtxMemAllocType (pctxt, EquitySwapValuation_initialPrice_sequence);

            if (pvalue->u.sequence == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_EquitySwapValuation_initialPrice_sequence (pvalue->u.sequence);
            DOMTest_EquitySwapValuation_initialPrice_sequence (pctxt, pvalue->u.sequence, pXmlNode, FALSE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_initialPrice_equityValuationDate (OSCTXT* pctxt, 
   EquitySwapValuation_initialPrice_equityValuationDate* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustableDate"))) {
            pvalue->t = 1;
            pvalue->u.adjustableDate
                = rtxMemAllocType (pctxt, AdjustableDate);

            if (pvalue->u.adjustableDate == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AdjustableDate (pvalue->u.adjustableDate);
            DOMTest_AdjustableDate (pctxt, pvalue->u.adjustableDate, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relativeDateSequence"))) {
            pvalue->t = 2;
            pvalue->u.relativeDateSequence
                = rtxMemAllocType (pctxt, RelativeDateSequence);

            if (pvalue->u.relativeDateSequence == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RelativeDateSequence (pvalue->u.relativeDateSequence);
            DOMTest_RelativeDateSequence (pctxt, pvalue->u.relativeDateSequence, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_initialPrice (OSCTXT* pctxt, 
   EquitySwapValuation_initialPrice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("commission"))) {
            pvalue->m.commissionPresent = 1;
            DOMTest_Commission (pctxt, &pvalue->commission, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            DOMTest_EquitySwapValuation_initialPrice_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationTimeType"))) {
            pvalue->m.valuationTimeTypePresent = 1;
            if (0 != pXmlNode->children) {
               TimeTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->valuationTimeType);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationTime"))) {
            pvalue->m.valuationTimePresent = 1;
            DOMTest_BusinessCenterTime (pctxt, &pvalue->valuationTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityValuationDate"))) {
            pvalue->m.equityValuationDatePresent = 1;
            DOMTest_EquitySwapValuation_initialPrice_equityValuationDate (pctxt, &pvalue->equityValuationDate, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_valuationPriceInterim_sequence_fxConversion (OSCTXT* pctxt, 
   EquitySwapValuation_valuationPriceInterim_sequence_fxConversion* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 1;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxRate"))) {
            pvalue->t = 2;
            pvalue->u.fxRate_list = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.fxRate_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.fxRate_list);
            {
            FxRate_derivations* pdata2;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxRate"))) {
                     pdata2 = rtxMemAllocType (pctxt, FxRate_derivations);

                     if (pdata2 == NULL)
                        return LOG_RTERR (pctxt, RTERR_NOMEM);

                     asn1Init_FxRate_derivations (pdata2);
                     DOMTest_FxRate_derivations (pctxt, pdata2, pXmlNode, TRUE);
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, pvalue->u.fxRate_list, (void*)pdata2);
                  }
               }
            }
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_valuationPriceInterim_sequence (OSCTXT* pctxt, 
   EquitySwapValuation_valuationPriceInterim_sequence* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice"))) {
            pvalue->m.grossPricePresent = 1;
            DOMTest_ActualPrice (pctxt, &pvalue->grossPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            DOMTest_ActualPrice (pctxt, &pvalue->netPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("accruedInterestPrice"))) {
            pvalue->m.accruedInterestPricePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->accruedInterestPrice);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxConversion"))) {
            pvalue->m.fxConversionPresent = 1;
            DOMTest_EquitySwapValuation_valuationPriceInterim_sequence_fxConversion (pctxt, &pvalue->fxConversion, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_valuationPriceInterim_choice (OSCTXT* pctxt, 
   EquitySwapValuation_valuationPriceInterim_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               pvalue->u.determinationMethod = pXmlNode->children->content;
            }
            else {
               pvalue->u.determinationMethod = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 2;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            pvalue->t = 3;
            pvalue->u.sequence
                = rtxMemAllocType (pctxt, EquitySwapValuation_valuationPriceInterim_sequence);

            if (pvalue->u.sequence == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_EquitySwapValuation_valuationPriceInterim_sequence (pvalue->u.sequence);
            DOMTest_EquitySwapValuation_valuationPriceInterim_sequence (pctxt, pvalue->u.sequence, pXmlNode, FALSE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_valuationPriceInterim (OSCTXT* pctxt, 
   EquitySwapValuation_valuationPriceInterim* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("commission"))) {
            pvalue->m.commissionPresent = 1;
            DOMTest_Commission (pctxt, &pvalue->commission, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            DOMTest_EquitySwapValuation_valuationPriceInterim_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationTimeType"))) {
            if (0 != pXmlNode->children) {
               TimeTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->valuationTimeType);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationTime"))) {
            pvalue->m.valuationTimePresent = 1;
            DOMTest_BusinessCenterTime (pctxt, &pvalue->valuationTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityValuationDates"))) {
            DOMTest_AdjustableRelativeOrPeriodicDates (pctxt, &pvalue->equityValuationDates, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_valuationPriceFinal_sequence_fxConversion (OSCTXT* pctxt, 
   EquitySwapValuation_valuationPriceFinal_sequence_fxConversion* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 1;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxRate"))) {
            pvalue->t = 2;
            pvalue->u.fxRate_list = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.fxRate_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.fxRate_list);
            {
            FxRate_derivations* pdata2;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxRate"))) {
                     pdata2 = rtxMemAllocType (pctxt, FxRate_derivations);

                     if (pdata2 == NULL)
                        return LOG_RTERR (pctxt, RTERR_NOMEM);

                     asn1Init_FxRate_derivations (pdata2);
                     DOMTest_FxRate_derivations (pctxt, pdata2, pXmlNode, TRUE);
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, pvalue->u.fxRate_list, (void*)pdata2);
                  }
               }
            }
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_valuationPriceFinal_sequence (OSCTXT* pctxt, 
   EquitySwapValuation_valuationPriceFinal_sequence* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice"))) {
            pvalue->m.grossPricePresent = 1;
            DOMTest_ActualPrice (pctxt, &pvalue->grossPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            DOMTest_ActualPrice (pctxt, &pvalue->netPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("accruedInterestPrice"))) {
            pvalue->m.accruedInterestPricePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->accruedInterestPrice);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxConversion"))) {
            pvalue->m.fxConversionPresent = 1;
            DOMTest_EquitySwapValuation_valuationPriceFinal_sequence_fxConversion (pctxt, &pvalue->fxConversion, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_valuationPriceFinal_choice (OSCTXT* pctxt, 
   EquitySwapValuation_valuationPriceFinal_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               pvalue->u.determinationMethod = pXmlNode->children->content;
            }
            else {
               pvalue->u.determinationMethod = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 2;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            pvalue->t = 3;
            pvalue->u.sequence
                = rtxMemAllocType (pctxt, EquitySwapValuation_valuationPriceFinal_sequence);

            if (pvalue->u.sequence == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_EquitySwapValuation_valuationPriceFinal_sequence (pvalue->u.sequence);
            DOMTest_EquitySwapValuation_valuationPriceFinal_sequence (pctxt, pvalue->u.sequence, pXmlNode, FALSE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_valuationPriceFinal_equityValuationDate (OSCTXT* pctxt, 
   EquitySwapValuation_valuationPriceFinal_equityValuationDate* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustableDate"))) {
            pvalue->t = 1;
            pvalue->u.adjustableDate
                = rtxMemAllocType (pctxt, AdjustableDate);

            if (pvalue->u.adjustableDate == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AdjustableDate (pvalue->u.adjustableDate);
            DOMTest_AdjustableDate (pctxt, pvalue->u.adjustableDate, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relativeDateSequence"))) {
            pvalue->t = 2;
            pvalue->u.relativeDateSequence
                = rtxMemAllocType (pctxt, RelativeDateSequence);

            if (pvalue->u.relativeDateSequence == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RelativeDateSequence (pvalue->u.relativeDateSequence);
            DOMTest_RelativeDateSequence (pctxt, pvalue->u.relativeDateSequence, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_valuationPriceFinal (OSCTXT* pctxt, 
   EquitySwapValuation_valuationPriceFinal* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("commission"))) {
            pvalue->m.commissionPresent = 1;
            DOMTest_Commission (pctxt, &pvalue->commission, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            DOMTest_EquitySwapValuation_valuationPriceFinal_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationTimeType"))) {
            pvalue->m.valuationTimeTypePresent = 1;
            if (0 != pXmlNode->children) {
               TimeTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->valuationTimeType);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationTime"))) {
            pvalue->m.valuationTimePresent = 1;
            DOMTest_BusinessCenterTime (pctxt, &pvalue->valuationTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityValuationDate"))) {
            DOMTest_EquitySwapValuation_valuationPriceFinal_equityValuationDate (pctxt, &pvalue->equityValuationDate, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation (OSCTXT* pctxt, EquitySwapValuation* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("initialPrice"))) {
            DOMTest_EquitySwapValuation_initialPrice (pctxt, &pvalue->initialPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityNotionalReset"))) {
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->equityNotionalReset);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationPriceInterim"))) {
            pvalue->m.valuationPriceInterimPresent = 1;
            DOMTest_EquitySwapValuation_valuationPriceInterim (pctxt, &pvalue->valuationPriceInterim, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationPriceFinal"))) {
            DOMTest_EquitySwapValuation_valuationPriceFinal (pctxt, &pvalue->valuationPriceFinal, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityPaymentDates"))) {
            DOMTest_EquityPaymentDates (pctxt, &pvalue->equityPaymentDates, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_InterestAccrualsMethod (OSCTXT* pctxt, 
   InterestAccrualsMethod* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("floatingRateCalculation"))) {
            pvalue->t = 1;
            pvalue->u.floatingRateCalculation
                = rtxMemAllocType (pctxt, FloatingRateCalculation);

            if (pvalue->u.floatingRateCalculation == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FloatingRateCalculation (pvalue->u.floatingRateCalculation);
            DOMTest_FloatingRateCalculation (pctxt, pvalue->u.floatingRateCalculation, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fixedRate"))) {
            pvalue->t = 2;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->u.fixedRate);
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_MessageHeader (OSCTXT* pctxt, MessageHeader* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("conversationId"))) {
            pvalue->m.conversationIdPresent = 1;
            DOMTest_ConversationId (pctxt, &pvalue->conversationId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("messageId"))) {
            DOMTest_MessageId (pctxt, &pvalue->messageId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("inReplyTo"))) {
            pvalue->m.inReplyToPresent = 1;
            DOMTest_MessageId (pctxt, &pvalue->inReplyTo, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("sentBy"))) {
            DOMTest_PartyId (pctxt, &pvalue->sentBy, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("sendTo"))) {
            { PartyId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, PartyId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PartyId (pdata2);
            DOMTest_PartyId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->sendTo_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("copyTo"))) {
            { PartyId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, PartyId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PartyId (pdata2);
            DOMTest_PartyId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->copyTo_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("creationTimestamp"))) {
            if (0 != pXmlNode->children) {
               pvalue->creationTimestamp = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->creationTimestamp = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("expiryTimestamp"))) {
            pvalue->m.expiryTimestampPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->expiryTimestamp = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->expiryTimestamp = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Signature"))) {
            { Signature* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Signature);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Signature (pdata2);
            DOMTest_Signature (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->signature_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_Equity_1 (OSCTXT* pctxt, Equity_1* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("description"))) {
            if (0 != pXmlNode->children) {
               pvalue->description = pXmlNode->children->content;
            }
            else {
               pvalue->description = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("instrumentId"))) {
            { InstrumentId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, InstrumentId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InstrumentId (pdata2);
            DOMTest_InstrumentId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->instrumentId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("currency"))) {
            pvalue->m.currencyPresent = 1;
            DOMTest_Currency (pctxt, &pvalue->currency, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("exchangeId"))) {
            { ExchangeId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ExchangeId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ExchangeId (pdata2);
            DOMTest_ExchangeId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->exchangeId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relatedExchangeId"))) {
            { ExchangeId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ExchangeId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ExchangeId (pdata2);
            DOMTest_ExchangeId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->relatedExchangeId_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("clearanceSystem"))) {
            pvalue->m.clearanceSystemPresent = 1;
            DOMTest_ClearanceSystem (pctxt, &pvalue->clearanceSystem, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_RequestMessageHeader (OSCTXT* pctxt, RequestMessageHeader* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("conversationId"))) {
            pvalue->m.conversationIdPresent = 1;
            DOMTest_ConversationId (pctxt, &pvalue->conversationId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("messageId"))) {
            DOMTest_MessageId (pctxt, &pvalue->messageId, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("sentBy"))) {
            DOMTest_PartyId (pctxt, &pvalue->sentBy, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("sendTo"))) {
            { PartyId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, PartyId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PartyId (pdata2);
            DOMTest_PartyId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->sendTo_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("copyTo"))) {
            { PartyId* pdata2;
            pdata2 = rtxMemAllocType (pctxt, PartyId);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PartyId (pdata2);
            DOMTest_PartyId (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->copyTo_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("creationTimestamp"))) {
            if (0 != pXmlNode->children) {
               pvalue->creationTimestamp = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->creationTimestamp = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("expiryTimestamp"))) {
            pvalue->m.expiryTimestampPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->expiryTimestamp = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->expiryTimestamp = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Signature"))) {
            { Signature* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Signature);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Signature (pdata2);
            DOMTest_Signature (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->signature_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_MessageHeader_derivations (OSCTXT* pctxt, 
   MessageHeader_derivations* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("MessageHeader");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("MessageHeader")))
   {
      pvalue->t = 1;
      pvalue->u.messageHeader = rtxMemAllocType (pctxt, MessageHeader);

      if (pvalue->u.messageHeader == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MessageHeader (pvalue->u.messageHeader);
      DOMTest_MessageHeader (pctxt, pvalue->u.messageHeader, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("NotificationMessageHeader")))
   {
      pvalue->t = 2;
      pvalue->u.notificationMessageHeader
          = rtxMemAllocType (pctxt, NotificationMessageHeader);

      if (pvalue->u.notificationMessageHeader == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_NotificationMessageHeader (pvalue->u.notificationMessageHeader);
      DOMTest_NotificationMessageHeader (pctxt, pvalue->u.notificationMessageHeader, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("RequestMessageHeader")))
   {
      pvalue->t = 3;
      pvalue->u.requestMessageHeader
          = rtxMemAllocType (pctxt, RequestMessageHeader);

      if (pvalue->u.requestMessageHeader == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_RequestMessageHeader (pvalue->u.requestMessageHeader);
      DOMTest_RequestMessageHeader (pctxt, pvalue->u.requestMessageHeader, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("ResponseMessageHeader")))
   {
      pvalue->t = 4;
      pvalue->u.responseMessageHeader
          = rtxMemAllocType (pctxt, ResponseMessageHeader);

      if (pvalue->u.responseMessageHeader == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ResponseMessageHeader (pvalue->u.responseMessageHeader);
      DOMTest_ResponseMessageHeader (pctxt, pvalue->u.responseMessageHeader, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_Message (OSCTXT* pctxt, Message* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               Message_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("header"))) {
            DOMTest_MessageHeader_derivations (pctxt, &pvalue->header, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("validation"))) {
            pvalue->m.validation_modelPresent = 1;
            DOMTest_Validation_model (pctxt, &pvalue->validation_model, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_RequestMessage (OSCTXT* pctxt, RequestMessage* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               RequestMessage_version_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->version);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("header"))) {
            DOMTest_RequestMessageHeader (pctxt, &pvalue->header, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("validation"))) {
            pvalue->m.validation_modelPresent = 1;
            DOMTest_Validation_model (pctxt, &pvalue->validation_model, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_Product_derivations (OSCTXT* pctxt, Product_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("Product");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("Product")))
   {
      pvalue->t = 1;
      pvalue->u.product = rtxMemAllocType (pctxt, Product_1);

      if (pvalue->u.product == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Product_1 (pvalue->u.product);
      DOMTest_Product_1 (pctxt, pvalue->u.product, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("Strategy")))
   {
      pvalue->t = 2;
      pvalue->u.strategy = rtxMemAllocType (pctxt, Strategy);

      if (pvalue->u.strategy == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Strategy (pvalue->u.strategy);
      DOMTest_Strategy (pctxt, pvalue->u.strategy, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("FXAverageRateOption")))
   {
      pvalue->t = 3;
      pvalue->u.fXAverageRateOption
          = rtxMemAllocType (pctxt, FXAverageRateOption);

      if (pvalue->u.fXAverageRateOption == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_FXAverageRateOption (pvalue->u.fXAverageRateOption);
      DOMTest_FXAverageRateOption (pctxt, pvalue->u.fXAverageRateOption, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("FXOptionLeg"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("FXBarrierOption")))
   {
      pvalue->t = 4;
      pvalue->u.fXOptionLeg
          = rtxMemAllocType (pctxt, FXOptionLeg_derivations);

      if (pvalue->u.fXOptionLeg == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_FXOptionLeg_derivations (pvalue->u.fXOptionLeg);
      DOMTest_FXOptionLeg_derivations (pctxt, pvalue->u.fXOptionLeg, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("FXDigitalOption")))
   {
      pvalue->t = 5;
      pvalue->u.fXDigitalOption = rtxMemAllocType (pctxt, FXDigitalOption);

      if (pvalue->u.fXDigitalOption == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_FXDigitalOption (pvalue->u.fXDigitalOption);
      DOMTest_FXDigitalOption (pctxt, pvalue->u.fXDigitalOption, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("FXLeg")))
   {
      pvalue->t = 6;
      pvalue->u.fXLeg = rtxMemAllocType (pctxt, FXLeg);

      if (pvalue->u.fXLeg == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_FXLeg (pvalue->u.fXLeg);
      DOMTest_FXLeg (pctxt, pvalue->u.fXLeg, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("FXSwap")))
   {
      pvalue->t = 7;
      pvalue->u.fXSwap = rtxMemAllocType (pctxt, FXSwap);

      if (pvalue->u.fXSwap == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_FXSwap (pvalue->u.fXSwap);
      DOMTest_FXSwap (pctxt, pvalue->u.fXSwap, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("TermDeposit")))
   {
      pvalue->t = 8;
      pvalue->u.termDeposit = rtxMemAllocType (pctxt, TermDeposit);

      if (pvalue->u.termDeposit == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TermDeposit (pvalue->u.termDeposit);
      DOMTest_TermDeposit (pctxt, pvalue->u.termDeposit, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("BulletPayment")))
   {
      pvalue->t = 9;
      pvalue->u.bulletPayment = rtxMemAllocType (pctxt, BulletPayment);

      if (pvalue->u.bulletPayment == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BulletPayment (pvalue->u.bulletPayment);
      DOMTest_BulletPayment (pctxt, pvalue->u.bulletPayment, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("CapFloor")))
   {
      pvalue->t = 10;
      pvalue->u.capFloor = rtxMemAllocType (pctxt, CapFloor);

      if (pvalue->u.capFloor == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CapFloor (pvalue->u.capFloor);
      DOMTest_CapFloor (pctxt, pvalue->u.capFloor, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("Fra")))
   {
      pvalue->t = 11;
      pvalue->u.fra = rtxMemAllocType (pctxt, Fra);

      if (pvalue->u.fra == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Fra (pvalue->u.fra);
      DOMTest_Fra (pctxt, pvalue->u.fra, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("Swap")))
   {
      pvalue->t = 12;
      pvalue->u.swap = rtxMemAllocType (pctxt, Swap);

      if (pvalue->u.swap == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Swap (pvalue->u.swap);
      DOMTest_Swap (pctxt, pvalue->u.swap, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("Swaption")))
   {
      pvalue->t = 13;
      pvalue->u.swaption = rtxMemAllocType (pctxt, Swaption);

      if (pvalue->u.swaption == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Swaption (pvalue->u.swaption);
      DOMTest_Swaption (pctxt, pvalue->u.swaption, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("EquityOption")))
   {
      pvalue->t = 14;
      pvalue->u.equityOption = rtxMemAllocType (pctxt, EquityOption);

      if (pvalue->u.equityOption == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EquityOption (pvalue->u.equityOption);
      DOMTest_EquityOption (pctxt, pvalue->u.equityOption, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("EquitySwap")))
   {
      pvalue->t = 15;
      pvalue->u.equitySwap = rtxMemAllocType (pctxt, EquitySwap);

      if (pvalue->u.equitySwap == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EquitySwap (pvalue->u.equitySwap);
      DOMTest_EquitySwap (pctxt, pvalue->u.equitySwap, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("CreditDefaultSwap")))
   {
      pvalue->t = 16;
      pvalue->u.creditDefaultSwap
          = rtxMemAllocType (pctxt, CreditDefaultSwap);

      if (pvalue->u.creditDefaultSwap == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CreditDefaultSwap (pvalue->u.creditDefaultSwap);
      DOMTest_CreditDefaultSwap (pctxt, pvalue->u.creditDefaultSwap, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_SharedAmericanExercise_derivations (OSCTXT* pctxt, 
   SharedAmericanExercise_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("SharedAmericanExercise");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("SharedAmericanExercise")))
   {
      pvalue->t = 1;
      pvalue->u.sharedAmericanExercise
          = rtxMemAllocType (pctxt, SharedAmericanExercise);

      if (pvalue->u.sharedAmericanExercise == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SharedAmericanExercise (pvalue->u.sharedAmericanExercise);
      DOMTest_SharedAmericanExercise (pctxt, pvalue->u.sharedAmericanExercise, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("EquityAmericanExercise")))
   {
      pvalue->t = 2;
      pvalue->u.equityAmericanExercise
          = rtxMemAllocType (pctxt, EquityAmericanExercise);

      if (pvalue->u.equityAmericanExercise == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EquityAmericanExercise (pvalue->u.equityAmericanExercise);
      DOMTest_EquityAmericanExercise (pctxt, pvalue->u.equityAmericanExercise, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_Exercise_derivations (OSCTXT* pctxt, Exercise_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("Exercise");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("Exercise")))
   {
      pvalue->t = 1;
      pvalue->u.exercise = rtxMemAllocType (pctxt, Exercise_1);

      if (pvalue->u.exercise == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Exercise_1 (pvalue->u.exercise);
      DOMTest_Exercise_1 (pctxt, pvalue->u.exercise, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("AmericanExercise")))
   {
      pvalue->t = 2;
      pvalue->u.americanExercise = rtxMemAllocType (pctxt, AmericanExercise);

      if (pvalue->u.americanExercise == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_AmericanExercise (pvalue->u.americanExercise);
      DOMTest_AmericanExercise (pctxt, pvalue->u.americanExercise, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("BermudaExercise")))
   {
      pvalue->t = 3;
      pvalue->u.bermudaExercise = rtxMemAllocType (pctxt, BermudaExercise);

      if (pvalue->u.bermudaExercise == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_BermudaExercise (pvalue->u.bermudaExercise);
      DOMTest_BermudaExercise (pctxt, pvalue->u.bermudaExercise, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("EuropeanExercise")))
   {
      pvalue->t = 4;
      pvalue->u.europeanExercise = rtxMemAllocType (pctxt, EuropeanExercise);

      if (pvalue->u.europeanExercise == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EuropeanExercise (pvalue->u.europeanExercise);
      DOMTest_EuropeanExercise (pctxt, pvalue->u.europeanExercise, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("EquityEuropeanExercise")))
   {
      pvalue->t = 5;
      pvalue->u.equityEuropeanExercise
          = rtxMemAllocType (pctxt, EquityEuropeanExercise);

      if (pvalue->u.equityEuropeanExercise == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EquityEuropeanExercise (pvalue->u.equityEuropeanExercise);
      DOMTest_EquityEuropeanExercise (pctxt, pvalue->u.equityEuropeanExercise, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("SharedAmericanExercise"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("EquityAmericanExercise")))
   {
      pvalue->t = 6;
      pvalue->u.sharedAmericanExercise
          = rtxMemAllocType (pctxt, SharedAmericanExercise_derivations);

      if (pvalue->u.sharedAmericanExercise == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SharedAmericanExercise_derivations (pvalue->u.sharedAmericanExercise);
      DOMTest_SharedAmericanExercise_derivations (pctxt, pvalue->u.sharedAmericanExercise, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_sequence_fxConversion (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_sequence_fxConversion* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 1;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxRate"))) {
            pvalue->t = 2;
            pvalue->u.fxRate_list = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.fxRate_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.fxRate_list);
            {
            FxRate_derivations* pdata2;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxRate"))) {
                     pdata2 = rtxMemAllocType (pctxt, FxRate_derivations);

                     if (pdata2 == NULL)
                        return LOG_RTERR (pctxt, RTERR_NOMEM);

                     asn1Init_FxRate_derivations (pdata2);
                     DOMTest_FxRate_derivations (pctxt, pdata2, pXmlNode, TRUE);
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, pvalue->u.fxRate_list, (void*)pdata2);
                  }
               }
            }
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_sequence (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_sequence* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice"))) {
            pvalue->m.grossPricePresent = 1;
            DOMTest_ActualPrice (pctxt, &pvalue->grossPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            DOMTest_ActualPrice (pctxt, &pvalue->netPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("accruedInterestPrice"))) {
            pvalue->m.accruedInterestPricePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->accruedInterestPrice);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxConversion"))) {
            pvalue->m.fxConversionPresent = 1;
            DOMTest_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_sequence_fxConversion (pctxt, &pvalue->fxConversion, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_choice (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               pvalue->u.determinationMethod = pXmlNode->children->content;
            }
            else {
               pvalue->u.determinationMethod = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 2;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            pvalue->t = 3;
            pvalue->u.sequence
                = rtxMemAllocType (pctxt, EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_sequence);

            if (pvalue->u.sequence == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_sequence (pvalue->u.sequence);
            DOMTest_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_sequence (pctxt, pvalue->u.sequence, pXmlNode, FALSE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_equityValuationDate (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_equityValuationDate* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustableDate"))) {
            pvalue->t = 1;
            pvalue->u.adjustableDate
                = rtxMemAllocType (pctxt, AdjustableDate);

            if (pvalue->u.adjustableDate == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AdjustableDate (pvalue->u.adjustableDate);
            DOMTest_AdjustableDate (pctxt, pvalue->u.adjustableDate, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relativeDateSequence"))) {
            pvalue->t = 2;
            pvalue->u.relativeDateSequence
                = rtxMemAllocType (pctxt, RelativeDateSequence);

            if (pvalue->u.relativeDateSequence == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RelativeDateSequence (pvalue->u.relativeDateSequence);
            DOMTest_RelativeDateSequence (pctxt, pvalue->u.relativeDateSequence, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation_initialPrice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("commission"))) {
            pvalue->m.commissionPresent = 1;
            DOMTest_Commission (pctxt, &pvalue->commission, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            DOMTest_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationTimeType"))) {
            pvalue->m.valuationTimeTypePresent = 1;
            if (0 != pXmlNode->children) {
               TimeTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->valuationTimeType);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationTime"))) {
            pvalue->m.valuationTimePresent = 1;
            DOMTest_BusinessCenterTime (pctxt, &pvalue->valuationTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityValuationDate"))) {
            pvalue->m.equityValuationDatePresent = 1;
            DOMTest_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice_equityValuationDate (pctxt, &pvalue->equityValuationDate, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_sequence_fxConversion (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_sequence_fxConversion* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 1;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxRate"))) {
            pvalue->t = 2;
            pvalue->u.fxRate_list = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.fxRate_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.fxRate_list);
            {
            FxRate_derivations* pdata2;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxRate"))) {
                     pdata2 = rtxMemAllocType (pctxt, FxRate_derivations);

                     if (pdata2 == NULL)
                        return LOG_RTERR (pctxt, RTERR_NOMEM);

                     asn1Init_FxRate_derivations (pdata2);
                     DOMTest_FxRate_derivations (pctxt, pdata2, pXmlNode, TRUE);
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, pvalue->u.fxRate_list, (void*)pdata2);
                  }
               }
            }
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_sequence (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_sequence* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice"))) {
            pvalue->m.grossPricePresent = 1;
            DOMTest_ActualPrice (pctxt, &pvalue->grossPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            DOMTest_ActualPrice (pctxt, &pvalue->netPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("accruedInterestPrice"))) {
            pvalue->m.accruedInterestPricePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->accruedInterestPrice);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxConversion"))) {
            pvalue->m.fxConversionPresent = 1;
            DOMTest_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_sequence_fxConversion (pctxt, &pvalue->fxConversion, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_choice (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               pvalue->u.determinationMethod = pXmlNode->children->content;
            }
            else {
               pvalue->u.determinationMethod = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 2;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            pvalue->t = 3;
            pvalue->u.sequence
                = rtxMemAllocType (pctxt, EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_sequence);

            if (pvalue->u.sequence == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_sequence (pvalue->u.sequence);
            DOMTest_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_sequence (pctxt, pvalue->u.sequence, pXmlNode, FALSE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("commission"))) {
            pvalue->m.commissionPresent = 1;
            DOMTest_Commission (pctxt, &pvalue->commission, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            DOMTest_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationTimeType"))) {
            if (0 != pXmlNode->children) {
               TimeTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->valuationTimeType);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationTime"))) {
            pvalue->m.valuationTimePresent = 1;
            DOMTest_BusinessCenterTime (pctxt, &pvalue->valuationTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityValuationDates"))) {
            DOMTest_AdjustableRelativeOrPeriodicDates (pctxt, &pvalue->equityValuationDates, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_sequence_fxConversion (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_sequence_fxConversion* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 1;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxRate"))) {
            pvalue->t = 2;
            pvalue->u.fxRate_list = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.fxRate_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.fxRate_list);
            {
            FxRate_derivations* pdata2;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxRate"))) {
                     pdata2 = rtxMemAllocType (pctxt, FxRate_derivations);

                     if (pdata2 == NULL)
                        return LOG_RTERR (pctxt, RTERR_NOMEM);

                     asn1Init_FxRate_derivations (pdata2);
                     DOMTest_FxRate_derivations (pctxt, pdata2, pXmlNode, TRUE);
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, pvalue->u.fxRate_list, (void*)pdata2);
                  }
               }
            }
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_sequence (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_sequence* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice"))) {
            pvalue->m.grossPricePresent = 1;
            DOMTest_ActualPrice (pctxt, &pvalue->grossPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            DOMTest_ActualPrice (pctxt, &pvalue->netPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("accruedInterestPrice"))) {
            pvalue->m.accruedInterestPricePresent = 1;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->accruedInterestPrice);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fxConversion"))) {
            pvalue->m.fxConversionPresent = 1;
            DOMTest_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_sequence_fxConversion (pctxt, &pvalue->fxConversion, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_choice (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               pvalue->u.determinationMethod = pXmlNode->children->content;
            }
            else {
               pvalue->u.determinationMethod = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo"))) {
            pvalue->t = 2;
            pvalue->u.amountRelativeTo
                = rtxMemAllocType (pctxt, AmountRelativeTo);

            if (pvalue->u.amountRelativeTo == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AmountRelativeTo (pvalue->u.amountRelativeTo);
            DOMTest_AmountRelativeTo (pctxt, pvalue->u.amountRelativeTo, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            pvalue->t = 3;
            pvalue->u.sequence
                = rtxMemAllocType (pctxt, EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_sequence);

            if (pvalue->u.sequence == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_sequence (pvalue->u.sequence);
            DOMTest_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_sequence (pctxt, pvalue->u.sequence, pXmlNode, FALSE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_equityValuationDate (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_equityValuationDate* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("adjustableDate"))) {
            pvalue->t = 1;
            pvalue->u.adjustableDate
                = rtxMemAllocType (pctxt, AdjustableDate);

            if (pvalue->u.adjustableDate == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AdjustableDate (pvalue->u.adjustableDate);
            DOMTest_AdjustableDate (pctxt, pvalue->u.adjustableDate, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("relativeDateSequence"))) {
            pvalue->t = 2;
            pvalue->u.relativeDateSequence
                = rtxMemAllocType (pctxt, RelativeDateSequence);

            if (pvalue->u.relativeDateSequence == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RelativeDateSequence (pvalue->u.relativeDateSequence);
            DOMTest_RelativeDateSequence (pctxt, pvalue->u.relativeDateSequence, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("commission"))) {
            pvalue->m.commissionPresent = 1;
            DOMTest_Commission (pctxt, &pvalue->commission, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("determinationMethod")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("amountRelativeTo")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("grossPrice")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("netPrice"))) {
            DOMTest_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationTimeType"))) {
            pvalue->m.valuationTimeTypePresent = 1;
            if (0 != pXmlNode->children) {
               TimeTypeEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->valuationTimeType);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationTime"))) {
            pvalue->m.valuationTimePresent = 1;
            DOMTest_BusinessCenterTime (pctxt, &pvalue->valuationTime, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityValuationDate"))) {
            DOMTest_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal_equityValuationDate (pctxt, &pvalue->equityValuationDate, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_derivations_equityLeg_valuation (OSCTXT* pctxt, 
   EquitySwapValuation_derivations_equityLeg_valuation* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("initialPrice"))) {
            DOMTest_EquitySwapValuation_derivations_equityLeg_valuation_initialPrice (pctxt, &pvalue->initialPrice, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityNotionalReset"))) {
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->equityNotionalReset);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationPriceInterim"))) {
            pvalue->m.valuationPriceInterimPresent = 1;
            DOMTest_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceInterim (pctxt, &pvalue->valuationPriceInterim, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("valuationPriceFinal"))) {
            DOMTest_EquitySwapValuation_derivations_equityLeg_valuation_valuationPriceFinal (pctxt, &pvalue->valuationPriceFinal, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("equityPaymentDates"))) {
            DOMTest_EquityPaymentDates (pctxt, &pvalue->equityPaymentDates, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_EquitySwapValuation_derivations (OSCTXT* pctxt, 
   EquitySwapValuation_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("EquitySwapValuation");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("EquitySwapValuation")))
   {
      pvalue->t = 1;
      pvalue->u.equitySwapValuation
          = rtxMemAllocType (pctxt, EquitySwapValuation);

      if (pvalue->u.equitySwapValuation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EquitySwapValuation (pvalue->u.equitySwapValuation);
      DOMTest_EquitySwapValuation (pctxt, pvalue->u.equitySwapValuation, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("EquityLeg_valuation")))
   {
      pvalue->t = 2;
      pvalue->u.equityLeg_valuation
          = rtxMemAllocType (pctxt, EquitySwapValuation_derivations_equityLeg_valuation);

      if (pvalue->u.equityLeg_valuation == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EquitySwapValuation_derivations_equityLeg_valuation (pvalue->u.equityLeg_valuation);
      DOMTest_EquitySwapValuation_derivations_equityLeg_valuation (pctxt, pvalue->u.equityLeg_valuation, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_InterestAccrualsMethod_derivations_dividendConditions_interestAccrualsMethod_choice (OSCTXT* pctxt, 
   InterestAccrualsMethod_derivations_dividendConditions_interestAccrualsMethod_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("floatingRateCalculation"))) {
            pvalue->t = 1;
            pvalue->u.floatingRateCalculation
                = rtxMemAllocType (pctxt, FloatingRateCalculation);

            if (pvalue->u.floatingRateCalculation == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FloatingRateCalculation (pvalue->u.floatingRateCalculation);
            DOMTest_FloatingRateCalculation (pctxt, pvalue->u.floatingRateCalculation, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fixedRate"))) {
            pvalue->t = 2;
            if (0 != pXmlNode->children) {
               rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->u.fixedRate);
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_InterestAccrualsMethod_derivations_dividendConditions_interestAccrualsMethod (OSCTXT* pctxt, 
   InterestAccrualsMethod_derivations_dividendConditions_interestAccrualsMethod* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("floatingRateCalculation")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("fixedRate"))) {
            DOMTest_InterestAccrualsMethod_derivations_dividendConditions_interestAccrualsMethod_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("compoundingMethod"))) {
            if (0 != pXmlNode->children) {
               CompoundingMethodEnum_ToEnum (pctxt, pXmlNode->children->content, &pvalue->compoundingMethod);
            }
         }
      }
   }

   return 0;
}

int DOMTest_InterestAccrualsMethod_derivations (OSCTXT* pctxt, 
   InterestAccrualsMethod_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("InterestAccrualsMethod");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("InterestAccrualsMethod")))
   {
      pvalue->t = 1;
      pvalue->u.interestAccrualsMethod
          = rtxMemAllocType (pctxt, InterestAccrualsMethod);

      if (pvalue->u.interestAccrualsMethod == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_InterestAccrualsMethod (pvalue->u.interestAccrualsMethod);
      DOMTest_InterestAccrualsMethod (pctxt, pvalue->u.interestAccrualsMethod, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("DividendConditions_interestAccrualsMethod")))
   {
      pvalue->t = 2;
      pvalue->u.dividendConditions_interestAccrualsMethod
          = rtxMemAllocType (pctxt, InterestAccrualsMethod_derivations_dividendConditions_interestAccrualsMethod);

      if (pvalue->u.dividendConditions_interestAccrualsMethod == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_InterestAccrualsMethod_derivations_dividendConditions_interestAccrualsMethod (pvalue->u.dividendConditions_interestAccrualsMethod);
      DOMTest_InterestAccrualsMethod_derivations_dividendConditions_interestAccrualsMethod (pctxt, pvalue->u.dividendConditions_interestAccrualsMethod, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_SettlementTerms_derivations (OSCTXT* pctxt, 
   SettlementTerms_derivations* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("SettlementTerms");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("CurrencyScheme"))
   || rtxUTF8StrEqual (xsiType, OSUTF8(""))
   || rtxUTF8StrEqual (xsiType, OSUTF8("SettlementTerms")))
   {
      pvalue->t = 1;
      pvalue->u.settlementTerms = rtxMemAllocType (pctxt, SettlementTerms_1);

      if (pvalue->u.settlementTerms == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_SettlementTerms_1 (pvalue->u.settlementTerms);
      DOMTest_SettlementTerms_1 (pctxt, pvalue->u.settlementTerms, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("CashSettlementTerms")))
   {
      pvalue->t = 2;
      pvalue->u.cashSettlementTerms
          = rtxMemAllocType (pctxt, CashSettlementTerms);

      if (pvalue->u.cashSettlementTerms == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CashSettlementTerms (pvalue->u.cashSettlementTerms);
      DOMTest_CashSettlementTerms (pctxt, pvalue->u.cashSettlementTerms, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("PhysicalSettlementTerms")))
   {
      pvalue->t = 3;
      pvalue->u.physicalSettlementTerms
          = rtxMemAllocType (pctxt, PhysicalSettlementTerms);

      if (pvalue->u.physicalSettlementTerms == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PhysicalSettlementTerms (pvalue->u.physicalSettlementTerms);
      DOMTest_PhysicalSettlementTerms (pctxt, pvalue->u.physicalSettlementTerms, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

