/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 18-Oct-2006.
 */
#include "HepRep.h"
#include "libxml/parser.h"
#include "rtxmlsrc/osrtxml.h"
#include "rtxsrc/rtxCommon.h"

int DOMTest_Point (OSCTXT* pctxt, Point* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("x"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->x);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("y"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->y);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("z"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->z);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_Primitive (OSCTXT* pctxt, Primitive* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("point"))) {
            { Point* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Point);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Point (pdata2);
            DOMTest_Point (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->point_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_Type_element (OSCTXT* pctxt, Type_element* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("instance"))) {
            pvalue->t = 1;
            pvalue->u.instance = rtxMemAllocType (pctxt, Instance);

            if (pvalue->u.instance == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Instance ((Instance*)pvalue->u.instance);
            DOMTest_Instance (pctxt, (Instance*)pvalue->u.instance, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("type"))) {
            pvalue->t = 2;
            pvalue->u.type = rtxMemAllocType (pctxt, Type);

            if (pvalue->u.type == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Type ((Type*)pvalue->u.type);
            DOMTest_Type (pctxt, (Type*)pvalue->u.type, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("primitive"))) {
            pvalue->t = 3;
            pvalue->u.primitive = rtxMemAllocType (pctxt, Primitive);

            if (pvalue->u.primitive == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Primitive (pvalue->u.primitive);
            DOMTest_Primitive (pctxt, pvalue->u.primitive, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("point"))) {
            pvalue->t = 4;
            pvalue->u.point = rtxMemAllocType (pctxt, Point);

            if (pvalue->u.point == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Point (pvalue->u.point);
            DOMTest_Point (pctxt, pvalue->u.point, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest__SeqOfType_element (OSCTXT* pctxt, _SeqOfType_element* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   Type_element* pdata1 = rtxMemAllocTypeZ (pctxt, Type_element);
   DOMTest_Type_element (pctxt, pdata1, pXmlNode, setChild);
   if (0 != pdata1)
      rtxDListAppend (pctxt, pvalue, (void*)pdata1);

   return 0;
}

int DOMTest_Type (OSCTXT* pctxt, Type* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("name"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->name = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->name = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            pvalue->m.versionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->version = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->version = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("instance")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("type")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("primitive")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("point"))) {
            DOMTest__SeqOfType_element (pctxt, &pvalue->choice_list, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_Instance_element (OSCTXT* pctxt, Instance_element* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("type"))) {
            pvalue->t = 1;
            pvalue->u.type = rtxMemAllocType (pctxt, Type);

            if (pvalue->u.type == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Type (pvalue->u.type);
            DOMTest_Type (pctxt, pvalue->u.type, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("primitive"))) {
            pvalue->t = 2;
            pvalue->u.primitive = rtxMemAllocType (pctxt, Primitive);

            if (pvalue->u.primitive == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Primitive (pvalue->u.primitive);
            DOMTest_Primitive (pctxt, pvalue->u.primitive, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("point"))) {
            pvalue->t = 3;
            pvalue->u.point = rtxMemAllocType (pctxt, Point);

            if (pvalue->u.point == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Point (pvalue->u.point);
            DOMTest_Point (pctxt, pvalue->u.point, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest__SeqOfInstance_element (OSCTXT* pctxt, 
   _SeqOfInstance_element* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   Instance_element* pdata1 = rtxMemAllocTypeZ (pctxt, Instance_element);
   DOMTest_Instance_element (pctxt, pdata1, pXmlNode, setChild);
   if (0 != pdata1)
      rtxDListAppend (pctxt, pvalue, (void*)pdata1);

   return 0;
}

int DOMTest_Instance (OSCTXT* pctxt, Instance* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("type")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("primitive")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("point"))) {
            DOMTest__SeqOfInstance_element (pctxt, &pvalue->choice_list, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_Attribute_derivations_type_element (OSCTXT* pctxt, 
   Attribute_derivations_type_element* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("instance"))) {
            pvalue->t = 1;
            pvalue->u.instance = rtxMemAllocType (pctxt, Instance);

            if (pvalue->u.instance == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Instance (pvalue->u.instance);
            DOMTest_Instance (pctxt, pvalue->u.instance, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("type"))) {
            pvalue->t = 2;
            pvalue->u.type = rtxMemAllocType (pctxt, Type);

            if (pvalue->u.type == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Type (pvalue->u.type);
            DOMTest_Type (pctxt, pvalue->u.type, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("primitive"))) {
            pvalue->t = 3;
            pvalue->u.primitive = rtxMemAllocType (pctxt, Primitive);

            if (pvalue->u.primitive == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Primitive (pvalue->u.primitive);
            DOMTest_Primitive (pctxt, pvalue->u.primitive, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("point"))) {
            pvalue->t = 4;
            pvalue->u.point = rtxMemAllocType (pctxt, Point);

            if (pvalue->u.point == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Point (pvalue->u.point);
            DOMTest_Point (pctxt, pvalue->u.point, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest__SeqOfAttribute_derivations_type_element (OSCTXT* pctxt, 
   _SeqOfAttribute_derivations_type_element* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   Attribute_derivations_type_element* pdata1 = rtxMemAllocTypeZ (pctxt, Attribute_derivations_type_element);
   DOMTest_Attribute_derivations_type_element (pctxt, pdata1, pXmlNode, setChild);
   if (0 != pdata1)
      rtxDListAppend (pctxt, pvalue, (void*)pdata1);

   return 0;
}

int DOMTest_Attribute_derivations_type (OSCTXT* pctxt, 
   Attribute_derivations_type* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("name"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->name = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->name = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            pvalue->m.versionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->version = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->version = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("instance")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("type")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("primitive")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("point"))) {
            DOMTest__SeqOfAttribute_derivations_type_element (pctxt, &pvalue->choice_list, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_Attribute_derivations_instance_element (OSCTXT* pctxt, 
   Attribute_derivations_instance_element* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("type"))) {
            pvalue->t = 1;
            pvalue->u.type = rtxMemAllocType (pctxt, Type);

            if (pvalue->u.type == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Type (pvalue->u.type);
            DOMTest_Type (pctxt, pvalue->u.type, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("primitive"))) {
            pvalue->t = 2;
            pvalue->u.primitive = rtxMemAllocType (pctxt, Primitive);

            if (pvalue->u.primitive == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Primitive (pvalue->u.primitive);
            DOMTest_Primitive (pctxt, pvalue->u.primitive, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("point"))) {
            pvalue->t = 3;
            pvalue->u.point = rtxMemAllocType (pctxt, Point);

            if (pvalue->u.point == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Point (pvalue->u.point);
            DOMTest_Point (pctxt, pvalue->u.point, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest__SeqOfAttribute_derivations_instance_element (OSCTXT* pctxt, 
   _SeqOfAttribute_derivations_instance_element* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   Attribute_derivations_instance_element* pdata1 = rtxMemAllocTypeZ (pctxt, Attribute_derivations_instance_element);
   DOMTest_Attribute_derivations_instance_element (pctxt, pdata1, pXmlNode, setChild);
   if (0 != pdata1)
      rtxDListAppend (pctxt, pvalue, (void*)pdata1);

   return 0;
}

int DOMTest_Attribute_derivations_instance (OSCTXT* pctxt, 
   Attribute_derivations_instance* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("type")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("primitive")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("point"))) {
            DOMTest__SeqOfAttribute_derivations_instance_element (pctxt, &pvalue->choice_list, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_Attribute_derivations_primitive (OSCTXT* pctxt, 
   Attribute_derivations_primitive* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("point"))) {
            { Point* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Point);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Point (pdata2);
            DOMTest_Point (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->point_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_Attribute_derivations_point (OSCTXT* pctxt, 
   Attribute_derivations_point* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("x"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->x);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("y"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->y);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("z"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               rtxUTF8StrToDouble (((xmlNodePtr)pXmlAttr)->children->content, &pvalue->z);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_Attribute_derivations_heprep (OSCTXT* pctxt, 
   Attribute_derivations_heprep* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("type"))) {
            { Type* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Type);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Type (pdata2);
            DOMTest_Type (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->type_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_Attribute_derivations (OSCTXT* pctxt, 
   Attribute_derivations* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      return LOG_RTERR1 (pctxt, RTERR_ATTRMISRQ,
         rtxErrAddStrParm (pctxt, "xsi:type"));
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("_type")))
   {
      pvalue->t = 1;
      pvalue->u.type = rtxMemAllocType (pctxt, Attribute_derivations_type);

      if (pvalue->u.type == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Attribute_derivations_type (pvalue->u.type);
      DOMTest_Attribute_derivations_type (pctxt, pvalue->u.type, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("_instance")))
   {
      pvalue->t = 2;
      pvalue->u.instance
          = rtxMemAllocType (pctxt, Attribute_derivations_instance);

      if (pvalue->u.instance == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Attribute_derivations_instance (pvalue->u.instance);
      DOMTest_Attribute_derivations_instance (pctxt, pvalue->u.instance, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("_primitive")))
   {
      pvalue->t = 3;
      pvalue->u.primitive
          = rtxMemAllocType (pctxt, Attribute_derivations_primitive);

      if (pvalue->u.primitive == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Attribute_derivations_primitive (pvalue->u.primitive);
      DOMTest_Attribute_derivations_primitive (pctxt, pvalue->u.primitive, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("_point")))
   {
      pvalue->t = 4;
      pvalue->u.point = rtxMemAllocType (pctxt, Attribute_derivations_point);

      if (pvalue->u.point == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Attribute_derivations_point (pvalue->u.point);
      DOMTest_Attribute_derivations_point (pctxt, pvalue->u.point, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("_heprep")))
   {
      pvalue->t = 5;
      pvalue->u.heprep
          = rtxMemAllocType (pctxt, Attribute_derivations_heprep);

      if (pvalue->u.heprep == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Attribute_derivations_heprep (pvalue->u.heprep);
      DOMTest_Attribute_derivations_heprep (pctxt, pvalue->u.heprep, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_Attribute (OSCTXT* pctxt, Attribute* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_Attribute_derivations (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_Heprep (OSCTXT* pctxt, Heprep* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("type"))) {
            { Type* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Type);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Type (pdata2);
            DOMTest_Type (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->type_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_Attribute_1_element_attdef (OSCTXT* pctxt, 
   Attribute_1_element_attdef* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("desc"))) {
            pvalue->m.descPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->desc = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->desc = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("extra"))) {
            pvalue->m.extraPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->extra = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->extra = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("name"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->name = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->name = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->type = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->type = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_Attribute_1_element_attvalue (OSCTXT* pctxt, 
   Attribute_1_element_attvalue* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("name"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->name = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->name = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("showLabel"))) {
            pvalue->m.showLabelPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->showLabel = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->showLabel = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("value"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->value = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->value = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_Attribute_1_element (OSCTXT* pctxt, Attribute_1_element* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("attdef"))) {
            pvalue->t = 1;
            pvalue->u.attdef
                = rtxMemAllocType (pctxt, Attribute_1_element_attdef);

            if (pvalue->u.attdef == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Attribute_1_element_attdef (pvalue->u.attdef);
            DOMTest_Attribute_1_element_attdef (pctxt, pvalue->u.attdef, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("attvalue"))) {
            pvalue->t = 2;
            pvalue->u.attvalue
                = rtxMemAllocType (pctxt, Attribute_1_element_attvalue);

            if (pvalue->u.attvalue == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Attribute_1_element_attvalue (pvalue->u.attvalue);
            DOMTest_Attribute_1_element_attvalue (pctxt, pvalue->u.attvalue, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_Attribute_1 (OSCTXT* pctxt, Attribute_1* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   Attribute_1_element* pdata1 = rtxMemAllocTypeZ (pctxt, Attribute_1_element);
   DOMTest_Attribute_1_element (pctxt, pdata1, pXmlNode, setChild);
   if (0 != pdata1)
      rtxDListAppend (pctxt, pvalue, (void*)pdata1);

   return 0;
}

