/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 18-Oct-2006.
 */
#include "CoreComponentTypes.h"
#include "rtxsrc/rtxCommon.h"

/**************************************************************/
/*                                                            */
/*  AmountContent                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_AmountContent (OSCTXT* pctxt, CCT_AmountContent *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_real (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_CCT_AmountContent (OSCTXT* pctxt, CCT_AmountContent* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDouble (pctxt, pvalue, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CodeContent                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_CodeContent (OSCTXT* pctxt, CCT_CodeContent *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_CCT_CodeContent (OSCTXT* pctxt, CCT_CodeContent* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DateTimeContent                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_DateTimeContent (OSCTXT* pctxt, 
   CCT_DateTimeContent *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|26), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_CCT_DateTimeContent (OSCTXT* pctxt, CCT_DateTimeContent* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DateContent                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_DateContent (OSCTXT* pctxt, CCT_DateContent *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|26), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_CCT_DateContent (OSCTXT* pctxt, CCT_DateContent* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimeContent                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_TimeContent (OSCTXT* pctxt, CCT_TimeContent *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|26), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_CCT_TimeContent (OSCTXT* pctxt, CCT_TimeContent* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GraphicContent                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_GraphicContent (OSCTXT* pctxt, 
   CCT_GraphicContent *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_octstr (pctxt, &pvalue->data, &pvalue->numocts, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_CCT_GraphicContent (OSCTXT* pctxt, CCT_GraphicContent* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynBase64Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IdentifierContent                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_IdentifierContent (OSCTXT* pctxt, 
   CCT_IdentifierContent *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_CCT_IdentifierContent (OSCTXT* pctxt, CCT_IdentifierContent* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IndicatorContent                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_IndicatorContent (OSCTXT* pctxt, 
   CCT_IndicatorContent *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_boolean (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_CCT_IndicatorContent (OSCTXT* pctxt, CCT_IndicatorContent* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecBool (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MeasureContent                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_MeasureContent (OSCTXT* pctxt, 
   CCT_MeasureContent *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_real (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_CCT_MeasureContent (OSCTXT* pctxt, CCT_MeasureContent* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDouble (pctxt, pvalue, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NumericContent                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_NumericContent (OSCTXT* pctxt, 
   CCT_NumericContent *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_real (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_CCT_NumericContent (OSCTXT* pctxt, CCT_NumericContent* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDouble (pctxt, pvalue, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PictureContent                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_PictureContent (OSCTXT* pctxt, 
   CCT_PictureContent *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_octstr (pctxt, &pvalue->data, &pvalue->numocts, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_CCT_PictureContent (OSCTXT* pctxt, CCT_PictureContent* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynBase64Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantityContent                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_QuantityContent (OSCTXT* pctxt, 
   CCT_QuantityContent *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_real (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_CCT_QuantityContent (OSCTXT* pctxt, CCT_QuantityContent* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDouble (pctxt, pvalue, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TextContent                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_TextContent (OSCTXT* pctxt, CCT_TextContent *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_CCT_TextContent (OSCTXT* pctxt, CCT_TextContent* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DurationContent                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_DurationContent (OSCTXT* pctxt, 
   CCT_DurationContent *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_CCT_DurationContent (OSCTXT* pctxt, CCT_DurationContent* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ValueContent                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_ValueContent (OSCTXT* pctxt, CCT_ValueContent *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_real (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_CCT_ValueContent (OSCTXT* pctxt, CCT_ValueContent* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDouble (pctxt, pvalue, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PercentContent                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_PercentContent (OSCTXT* pctxt, 
   CCT_PercentContent *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_real (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_CCT_PercentContent (OSCTXT* pctxt, CCT_PercentContent* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDouble (pctxt, pvalue, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NameContent                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_NameContent (OSCTXT* pctxt, CCT_NameContent *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_CCT_NameContent (OSCTXT* pctxt, CCT_NameContent* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RateContent                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_RateContent (OSCTXT* pctxt, CCT_RateContent *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_real (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_CCT_RateContent (OSCTXT* pctxt, CCT_RateContent* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDouble (pctxt, pvalue, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DimensionContent                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_DimensionContent (OSCTXT* pctxt, 
   CCT_DimensionContent *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_real (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_CCT_DimensionContent (OSCTXT* pctxt, CCT_DimensionContent* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDouble (pctxt, pvalue, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  YearContent                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_YearContent (OSCTXT* pctxt, CCT_YearContent *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|26), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_CCT_YearContent (OSCTXT* pctxt, CCT_YearContent* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  YearMonthContent                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_YearMonthContent (OSCTXT* pctxt, 
   CCT_YearMonthContent *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|26), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_CCT_YearMonthContent (OSCTXT* pctxt, CCT_YearMonthContent* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MonthContent                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_MonthContent (OSCTXT* pctxt, CCT_MonthContent *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|26), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_CCT_MonthContent (OSCTXT* pctxt, CCT_MonthContent* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MonthDayContent                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_MonthDayContent (OSCTXT* pctxt, 
   CCT_MonthDayContent *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|26), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_CCT_MonthDayContent (OSCTXT* pctxt, CCT_MonthDayContent* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DayContent                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_DayContent (OSCTXT* pctxt, CCT_DayContent *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|26), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_CCT_DayContent (OSCTXT* pctxt, CCT_DayContent* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FrequencyContent                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_FrequencyContent (OSCTXT* pctxt, 
   CCT_FrequencyContent *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_integer (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_CCT_FrequencyContent (OSCTXT* pctxt, CCT_FrequencyContent* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecInt (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LanguageCodeContent                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_LanguageCodeContent (OSCTXT* pctxt, 
   CCT_LanguageCodeContent *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_CCT_LanguageCodeContent (OSCTXT* pctxt, 
   CCT_LanguageCodeContent* pvalue)
{
   int stat = 0;

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimeType_uidRefs                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_TimeType_uidRefs (OSCTXT* pctxt, 
   CCT_TimeType_uidRefs *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   const OSUTF8CHAR* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_utf8str (pctxt, &pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TimeType_uidRefs.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_TimeType_uidRefs (OSCTXT* pctxt, CCT_TimeType_uidRefs* pvalue)
{
   int stat = 0;

   rtxDListInit (pvalue);

   stat = rtXmlpDecStrList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TimeType                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_TimeType (OSCTXT* pctxt, CCT_TimeType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode uid */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uid, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode uidRef */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uidRef, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode uidRefs */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_TimeType_uidRefs (pctxt, 
               &pvalue->uidRefs, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_charstr (pctxt, &pvalue->base, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|26), length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_TimeType (OSCTXT* pctxt, CCT_TimeType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("language"), 8}, 0 },
         { {OSUTF8("uid"), 3}, 0 },
         { {OSUTF8("uidRef"), 6}, 0 },
         { {OSUTF8("uidRefs"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* language */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         case 1: /* uid */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uid);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidPresent = TRUE;
            break;

         case 2: /* uidRef */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uidRef);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefPresent = TRUE;
            break;

         case 3: /* uidRefs */
            rtxDListInit (&pvalue->uidRefs);

            stat = rtXmlpDecStrList (pctxt, &pvalue->uidRefs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefsPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "CCT_TimeType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "CCT_TimeType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)&pvalue->base);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DateType_uidRefs                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_DateType_uidRefs (OSCTXT* pctxt, 
   CCT_DateType_uidRefs *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   const OSUTF8CHAR* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_utf8str (pctxt, &pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DateType_uidRefs.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_DateType_uidRefs (OSCTXT* pctxt, CCT_DateType_uidRefs* pvalue)
{
   int stat = 0;

   rtxDListInit (pvalue);

   stat = rtXmlpDecStrList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DateType                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_DateType (OSCTXT* pctxt, CCT_DateType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode uid */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uid, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode uidRef */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uidRef, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode uidRefs */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_DateType_uidRefs (pctxt, 
               &pvalue->uidRefs, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_charstr (pctxt, &pvalue->base, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|26), length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_DateType (OSCTXT* pctxt, CCT_DateType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("language"), 8}, 0 },
         { {OSUTF8("uid"), 3}, 0 },
         { {OSUTF8("uidRef"), 6}, 0 },
         { {OSUTF8("uidRefs"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* language */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         case 1: /* uid */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uid);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidPresent = TRUE;
            break;

         case 2: /* uidRef */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uidRef);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefPresent = TRUE;
            break;

         case 3: /* uidRefs */
            rtxDListInit (&pvalue->uidRefs);

            stat = rtXmlpDecStrList (pctxt, &pvalue->uidRefs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefsPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "CCT_DateType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "CCT_DateType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)&pvalue->base);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DateTimeType_uidRefs                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_DateTimeType_uidRefs (OSCTXT* pctxt, 
   CCT_DateTimeType_uidRefs *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   const OSUTF8CHAR* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_utf8str (pctxt, &pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DateTimeType_uidRefs.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_DateTimeType_uidRefs (OSCTXT* pctxt, 
   CCT_DateTimeType_uidRefs* pvalue)
{
   int stat = 0;

   rtxDListInit (pvalue);

   stat = rtXmlpDecStrList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DateTimeType                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_DateTimeType (OSCTXT* pctxt, CCT_DateTimeType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode uid */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uid, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode uidRef */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uidRef, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode uidRefs */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_DateTimeType_uidRefs (pctxt, 
               &pvalue->uidRefs, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_charstr (pctxt, &pvalue->base, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|26), length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_DateTimeType (OSCTXT* pctxt, CCT_DateTimeType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("language"), 8}, 0 },
         { {OSUTF8("uid"), 3}, 0 },
         { {OSUTF8("uidRef"), 6}, 0 },
         { {OSUTF8("uidRefs"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* language */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         case 1: /* uid */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uid);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidPresent = TRUE;
            break;

         case 2: /* uidRef */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uidRef);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefPresent = TRUE;
            break;

         case 3: /* uidRefs */
            rtxDListInit (&pvalue->uidRefs);

            stat = rtXmlpDecStrList (pctxt, &pvalue->uidRefs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefsPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "CCT_DateTimeType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "CCT_DateTimeType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)&pvalue->base);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PeriodGroup_element                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_PeriodGroup_element (OSCTXT* pctxt, 
   CCT_PeriodGroup_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode startTime */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_TimeType (pctxt, 
               &pvalue->startTime, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode endTime */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_TimeType (pctxt, 
               &pvalue->endTime, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_PeriodGroup_element (OSCTXT* pctxt, 
   CCT_PeriodGroup_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("StartTime"), 9}, 0}, 0 },
      {{{OSUTF8("EndTime"), 7}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 1, -1}, {2, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* StartTime */
         stat = XmlDec_CCT_TimeType (pctxt, &pvalue->startTime);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* EndTime */
         stat = XmlDec_CCT_TimeType (pctxt, &pvalue->endTime);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PeriodGroup_element_1                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_PeriodGroup_element_1 (OSCTXT* pctxt, 
   CCT_PeriodGroup_element_1 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode startDate */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_DateType (pctxt, 
               &pvalue->startDate, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode endDate */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_DateType (pctxt, 
               &pvalue->endDate, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_PeriodGroup_element_1 (OSCTXT* pctxt, 
   CCT_PeriodGroup_element_1* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("StartDate"), 9}, 0}, 0 },
      {{{OSUTF8("EndDate"), 7}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 1, -1}, {2, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* StartDate */
         stat = XmlDec_CCT_DateType (pctxt, &pvalue->startDate);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* EndDate */
         stat = XmlDec_CCT_DateType (pctxt, &pvalue->endDate);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PeriodGroup_element_2                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_PeriodGroup_element_2 (OSCTXT* pctxt, 
   CCT_PeriodGroup_element_2 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode startDateTime */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_DateTimeType (pctxt, 
               &pvalue->startDateTime, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode endDateTime */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_DateTimeType (pctxt, 
               &pvalue->endDateTime, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_PeriodGroup_element_2 (OSCTXT* pctxt, 
   CCT_PeriodGroup_element_2* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("StartDateTime"), 13}, 0}, 0 },
      {{{OSUTF8("EndDateTime"), 11}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 1, -1}, {2, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* StartDateTime */
         stat = XmlDec_CCT_DateTimeType (pctxt, &pvalue->startDateTime);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* EndDateTime */
         stat = XmlDec_CCT_DateTimeType (pctxt, &pvalue->endDateTime);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PeriodGroup                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_PeriodGroup (OSCTXT* pctxt, CCT_PeriodGroup *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.sequence_list = rtxMemAllocType (pctxt, OSRTDList);

         if (pvalue->u.sequence_list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         rtxDListFastInit (pvalue->u.sequence_list);
         /* decode inline SEQUENCE OF type */
         {
            int stat = 0;
            CCT_PeriodGroup_element* pdata2;
            OSRTDListNode* pnode;
            ASN1CCB ccb;

            /* decode SEQUENCE OF or SET OF */

            rtxDListInit (pvalue->u.sequence_list);

            ccb.len = length;
            ccb.ptr = OSRTBUFPTR(pctxt);

            while (!XD_CHKEND (pctxt, &ccb))
            {
               if (pvalue->u.sequence_list->count >= 1) return LOG_RTERR (pctxt, RTERR_SEQOVFLW);

               rtxDListAllocNodeAndData (pctxt, CCT_PeriodGroup_element, &pnode, &pdata2);

               if (pnode == NULL)
                  return LOG_RTERR (pctxt, RTERR_NOMEM);

               asn1Init_CCT_PeriodGroup_element (pdata2);

               stat = asn1D_CCT_PeriodGroup_element (pctxt, 
                  pdata2, ASN1EXPL, length);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               rtxDListAppendNode (pvalue->u.sequence_list, pnode);
            }

            if (!((pvalue->u.sequence_list->count >= 0 && pvalue->u.sequence_list->
               count <= 1))) {
               rtxErrAddStrParm (pctxt, "PeriodGroup.u.sequence_list.count");
               rtxErrAddIntParm (pctxt, (int)pvalue->u.sequence_list->count);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

         }
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.sequence_1_list = rtxMemAllocType (pctxt, OSRTDList);

         if (pvalue->u.sequence_1_list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         rtxDListFastInit (pvalue->u.sequence_1_list);
         /* decode inline SEQUENCE OF type */
         {
            int stat = 0;
            CCT_PeriodGroup_element_1* pdata2;
            OSRTDListNode* pnode;
            ASN1CCB ccb;

            /* decode SEQUENCE OF or SET OF */

            rtxDListInit (pvalue->u.sequence_1_list);

            ccb.len = length;
            ccb.ptr = OSRTBUFPTR(pctxt);

            while (!XD_CHKEND (pctxt, &ccb))
            {
               if (pvalue->u.sequence_1_list->count >= 1) return LOG_RTERR (pctxt, RTERR_SEQOVFLW);

               rtxDListAllocNodeAndData (pctxt, CCT_PeriodGroup_element_1, &pnode, &pdata2);

               if (pnode == NULL)
                  return LOG_RTERR (pctxt, RTERR_NOMEM);

               asn1Init_CCT_PeriodGroup_element_1 (pdata2);

               stat = asn1D_CCT_PeriodGroup_element_1 (pctxt, 
                  pdata2, ASN1EXPL, length);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               rtxDListAppendNode (pvalue->u.sequence_1_list, pnode);
            }

            if (!((pvalue->u.sequence_1_list->count >= 0 && pvalue->u.sequence_1_list
               ->count <= 1))) {
               rtxErrAddStrParm (pctxt, "PeriodGroup.u.sequence_1_list.count");
               rtxErrAddIntParm (pctxt, (int)pvalue->u.sequence_1_list->count);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

         }
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.sequence_2_list = rtxMemAllocType (pctxt, OSRTDList);

         if (pvalue->u.sequence_2_list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         rtxDListFastInit (pvalue->u.sequence_2_list);
         /* decode inline SEQUENCE OF type */
         {
            int stat = 0;
            CCT_PeriodGroup_element_2* pdata2;
            OSRTDListNode* pnode;
            ASN1CCB ccb;

            /* decode SEQUENCE OF or SET OF */

            rtxDListInit (pvalue->u.sequence_2_list);

            ccb.len = length;
            ccb.ptr = OSRTBUFPTR(pctxt);

            while (!XD_CHKEND (pctxt, &ccb))
            {
               if (pvalue->u.sequence_2_list->count >= 1) return LOG_RTERR (pctxt, RTERR_SEQOVFLW);

               rtxDListAllocNodeAndData (pctxt, CCT_PeriodGroup_element_2, &pnode, &pdata2);

               if (pnode == NULL)
                  return LOG_RTERR (pctxt, RTERR_NOMEM);

               asn1Init_CCT_PeriodGroup_element_2 (pdata2);

               stat = asn1D_CCT_PeriodGroup_element_2 (pctxt, 
                  pdata2, ASN1EXPL, length);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               rtxDListAppendNode (pvalue->u.sequence_2_list, pnode);
            }

            if (!((pvalue->u.sequence_2_list->count >= 0 && pvalue->u.sequence_2_list
               ->count <= 1))) {
               rtxErrAddStrParm (pctxt, "PeriodGroup.u.sequence_2_list.count");
               rtxErrAddIntParm (pctxt, (int)pvalue->u.sequence_2_list->count);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

         }
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_CCT_PeriodGroup (OSCTXT* pctxt, CCT_PeriodGroup* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("StartTime"), 9}, 0}, 0 },
      {{{OSUTF8("StartDate"), 9}, 0}, 1 },
      {{{OSUTF8("StartDateTime"), 13}, 0}, 2 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: {
      CCT_PeriodGroup_element* pdata1;

      pvalue->u.sequence_list = rtxMemAllocType (pctxt, OSRTDList);
      rtxDListInit (pvalue->u.sequence_list);

      do {
         pdata1 = rtxMemAllocType (pctxt, CCT_PeriodGroup_element);

         if (pdata1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CCT_PeriodGroup_element (pdata1);

         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_CCT_PeriodGroup_element (pctxt, pdata1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, pvalue->u.sequence_list, (void*)pdata1);

         stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 1, -1, FALSE);
         if (stat < 0 && stat != RTERR_UNEXPELEM)
            return LOG_RTERR (pctxt, stat);
      }
      while (stat == 0);

      rtXmlpMarkLastEventActive (pctxt);
      stat = 0;
      break;
   }
   case 1: {
      CCT_PeriodGroup_element_1* pdata1;

      pvalue->u.sequence_1_list = rtxMemAllocType (pctxt, OSRTDList);
      rtxDListInit (pvalue->u.sequence_1_list);

      do {
         pdata1 = rtxMemAllocType (pctxt, CCT_PeriodGroup_element_1);

         if (pdata1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CCT_PeriodGroup_element_1 (pdata1);

         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_CCT_PeriodGroup_element_1 (pctxt, pdata1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, pvalue->u.sequence_1_list, (void*)pdata1);

         stat = rtXmlpGetNextElemID (pctxt, elemtab + 1, 1, -1, FALSE);
         if (stat < 0 && stat != RTERR_UNEXPELEM)
            return LOG_RTERR (pctxt, stat);
      }
      while (stat == 1);

      rtXmlpMarkLastEventActive (pctxt);
      stat = 0;
      break;
   }
   case 2: {
      CCT_PeriodGroup_element_2* pdata1;

      pvalue->u.sequence_2_list = rtxMemAllocType (pctxt, OSRTDList);
      rtxDListInit (pvalue->u.sequence_2_list);

      do {
         pdata1 = rtxMemAllocType (pctxt, CCT_PeriodGroup_element_2);

         if (pdata1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CCT_PeriodGroup_element_2 (pdata1);

         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_CCT_PeriodGroup_element_2 (pctxt, pdata1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, pvalue->u.sequence_2_list, (void*)pdata1);

         stat = rtXmlpGetNextElemID (pctxt, elemtab + 2, 1, -1, FALSE);
         if (stat < 0 && stat != RTERR_UNEXPELEM)
            return LOG_RTERR (pctxt, stat);
      }
      while (stat == 2);

      rtXmlpMarkLastEventActive (pctxt);
      stat = 0;
      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ValueType_uidRefs                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_ValueType_uidRefs (OSCTXT* pctxt, 
   CCT_ValueType_uidRefs *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   const OSUTF8CHAR* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_utf8str (pctxt, &pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ValueType_uidRefs.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_ValueType_uidRefs (OSCTXT* pctxt, CCT_ValueType_uidRefs* pvalue)
{
   int stat = 0;

   rtxDListInit (pvalue);

   stat = rtXmlpDecStrList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ValueType                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_ValueType (OSCTXT* pctxt, CCT_ValueType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode uid */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uid, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode uidRef */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uidRef, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode uidRefs */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_ValueType_uidRefs (pctxt, 
               &pvalue->uidRefs, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_ValueType (OSCTXT* pctxt, CCT_ValueType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("language"), 8}, 0 },
         { {OSUTF8("uid"), 3}, 0 },
         { {OSUTF8("uidRef"), 6}, 0 },
         { {OSUTF8("uidRefs"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* language */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         case 1: /* uid */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uid);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidPresent = TRUE;
            break;

         case 2: /* uidRef */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uidRef);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefPresent = TRUE;
            break;

         case 3: /* uidRefs */
            rtxDListInit (&pvalue->uidRefs);

            stat = rtXmlpDecStrList (pctxt, &pvalue->uidRefs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefsPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "CCT_ValueType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "CCT_ValueType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDouble (pctxt, &pvalue->base, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DurationType_uidRefs                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_DurationType_uidRefs (OSCTXT* pctxt, 
   CCT_DurationType_uidRefs *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   const OSUTF8CHAR* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_utf8str (pctxt, &pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DurationType_uidRefs.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_DurationType_uidRefs (OSCTXT* pctxt, 
   CCT_DurationType_uidRefs* pvalue)
{
   int stat = 0;

   rtxDListInit (pvalue);

   stat = rtXmlpDecStrList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DurationType                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_DurationType (OSCTXT* pctxt, CCT_DurationType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode uid */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uid, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode uidRef */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uidRef, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode uidRefs */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_DurationType_uidRefs (pctxt, 
               &pvalue->uidRefs, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_DurationType (OSCTXT* pctxt, CCT_DurationType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("language"), 8}, 0 },
         { {OSUTF8("uid"), 3}, 0 },
         { {OSUTF8("uidRef"), 6}, 0 },
         { {OSUTF8("uidRefs"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* language */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         case 1: /* uid */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uid);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidPresent = TRUE;
            break;

         case 2: /* uidRef */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uidRef);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefPresent = TRUE;
            break;

         case 3: /* uidRefs */
            rtxDListInit (&pvalue->uidRefs);

            stat = rtXmlpDecStrList (pctxt, &pvalue->uidRefs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefsPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "CCT_DurationType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "CCT_DurationType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->base);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RecurrenceGroup_sequence                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_RecurrenceGroup_sequence (OSCTXT* pctxt, 
   CCT_RecurrenceGroup_sequence *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode startTime */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_TimeType (pctxt, 
               &pvalue->startTime, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.startTimePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode endTime */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_TimeType (pctxt, 
               &pvalue->endTime, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.endTimePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_RecurrenceGroup_sequence (OSCTXT* pctxt, 
   CCT_RecurrenceGroup_sequence* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("StartTime"), 9}, 0}, 0 },
      {{{OSUTF8("EndTime"), 7}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* StartTime */
         stat = XmlDec_CCT_TimeType (pctxt, &pvalue->startTime);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.startTimePresent = TRUE;
         break;
      }
      case 1: { /* EndTime */
         stat = XmlDec_CCT_TimeType (pctxt, &pvalue->endTime);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.endTimePresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RecurrenceGroup_sequence_1                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_RecurrenceGroup_sequence_1 (OSCTXT* pctxt, 
   CCT_RecurrenceGroup_sequence_1 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode startDate */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_DateType (pctxt, 
               &pvalue->startDate, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.startDatePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode endDate */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_DateType (pctxt, 
               &pvalue->endDate, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.endDatePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_RecurrenceGroup_sequence_1 (OSCTXT* pctxt, 
   CCT_RecurrenceGroup_sequence_1* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("StartDate"), 9}, 0}, 0 },
      {{{OSUTF8("EndDate"), 7}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* StartDate */
         stat = XmlDec_CCT_DateType (pctxt, &pvalue->startDate);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.startDatePresent = TRUE;
         break;
      }
      case 1: { /* EndDate */
         stat = XmlDec_CCT_DateType (pctxt, &pvalue->endDate);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.endDatePresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RecurrenceGroup_sequence_2                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_RecurrenceGroup_sequence_2 (OSCTXT* pctxt, 
   CCT_RecurrenceGroup_sequence_2 *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode startDateTime */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_DateTimeType (pctxt, 
               &pvalue->startDateTime, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.startDateTimePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode endDateTime */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_DateTimeType (pctxt, 
               &pvalue->endDateTime, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.endDateTimePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_RecurrenceGroup_sequence_2 (OSCTXT* pctxt, 
   CCT_RecurrenceGroup_sequence_2* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("StartDateTime"), 13}, 0}, 0 },
      {{{OSUTF8("EndDateTime"), 11}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* StartDateTime */
         stat = XmlDec_CCT_DateTimeType (pctxt, &pvalue->startDateTime);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.startDateTimePresent = TRUE;
         break;
      }
      case 1: { /* EndDateTime */
         stat = XmlDec_CCT_DateTimeType (pctxt, &pvalue->endDateTime);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.endDateTimePresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RecurrenceGroup                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_RecurrenceGroup (OSCTXT* pctxt, 
   CCT_RecurrenceGroup *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode sequence */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_RecurrenceGroup_sequence (pctxt, 
               &pvalue->sequence, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sequencePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode sequence_1 */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_RecurrenceGroup_sequence_1 (pctxt, 
               &pvalue->sequence_1, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sequence_1Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode sequence_2 */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_RecurrenceGroup_sequence_2 (pctxt, 
               &pvalue->sequence_2, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sequence_2Present = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode recurrenceValue */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_ValueType (pctxt, 
               &pvalue->recurrenceValue, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.recurrenceValuePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode frequencyDuration */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_DurationType (pctxt, 
               &pvalue->frequencyDuration, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode frequencyYear */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_charstr (pctxt, &pvalue->frequencyYear, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|26), length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode frequencyYearMonth */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_charstr (pctxt, &pvalue->frequencyYearMonth, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|26), length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode frequencyMonth */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_charstr (pctxt, &pvalue->frequencyMonth, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|26), length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 8:
         /* decode frequencyMonthDay */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_charstr (pctxt, &pvalue->frequencyMonthDay, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|26), length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 9:
         /* decode frequencyDay */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_charstr (pctxt, &pvalue->frequencyDay, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|26), length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 6) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_RecurrenceGroup (OSCTXT* pctxt, CCT_RecurrenceGroup* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("StartTime"), 9}, 0}, 0 },
      {{{OSUTF8("EndTime"), 7}, 0}, 0 },
      {{{OSUTF8("StartDate"), 9}, 0}, 1 },
      {{{OSUTF8("EndDate"), 7}, 0}, 1 },
      {{{OSUTF8("StartDateTime"), 13}, 0}, 2 },
      {{{OSUTF8("EndDateTime"), 11}, 0}, 2 },
      {{{OSUTF8("RecurrenceValue"), 15}, 0}, 3 },
      {{{OSUTF8("FrequencyDuration"), 17}, 0}, 4 },
      {{{OSUTF8("FrequencyYear"), 13}, 0}, 5 },
      {{{OSUTF8("FrequencyYearMonth"), 18}, 0}, 6 },
      {{{OSUTF8("FrequencyMonth"), 14}, 0}, 7 },
      {{{OSUTF8("FrequencyMonthDay"), 17}, 0}, 8 },
      {{{OSUTF8("FrequencyDay"), 12}, 0}, 9 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 8, -1}, {8, 1, -1}, {9, 1, -1}, {10, 1, -1}
      , {11, 1, -1}, {12, 1, -1}, {13, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 10; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /*  */
         stat = XmlDec_CCT_RecurrenceGroup_sequence (pctxt, &pvalue->sequence
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.sequencePresent = TRUE;
         break;
      }
      case 1: { /*  */
         stat = XmlDec_CCT_RecurrenceGroup_sequence_1 (pctxt, &pvalue->
            sequence_1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.sequence_1Present = TRUE;
         break;
      }
      case 2: { /*  */
         stat = XmlDec_CCT_RecurrenceGroup_sequence_2 (pctxt, &pvalue->
            sequence_2);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.sequence_2Present = TRUE;
         break;
      }
      case 3: { /* RecurrenceValue */
         stat = XmlDec_CCT_ValueType (pctxt, &pvalue->recurrenceValue);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.recurrenceValuePresent = TRUE;
         break;
      }
      case 4: { /* FrequencyDuration */
         stat = XmlDec_CCT_DurationType (pctxt, &pvalue->frequencyDuration);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 5: { /* FrequencyYear */
         stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)&pvalue->
            frequencyYear);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 6: { /* FrequencyYearMonth */
         stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)&pvalue->
            frequencyYearMonth);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 7: { /* FrequencyMonth */
         stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)&pvalue->
            frequencyMonth);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 8: { /* FrequencyMonthDay */
         stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)&pvalue->
            frequencyMonthDay);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 9: { /* FrequencyDay */
         stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)&pvalue->
            frequencyDay);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AmountType_uidRefs                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_AmountType_uidRefs (OSCTXT* pctxt, 
   CCT_AmountType_uidRefs *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   const OSUTF8CHAR* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_utf8str (pctxt, &pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "AmountType_uidRefs.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_AmountType_uidRefs (OSCTXT* pctxt, 
   CCT_AmountType_uidRefs* pvalue)
{
   int stat = 0;

   rtxDListInit (pvalue);

   stat = rtXmlpDecStrList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AmountType                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_AmountType (OSCTXT* pctxt, CCT_AmountType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode currencyId */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->currencyId, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode uid */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uid, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode uidRef */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uidRef, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode uidRefs */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_AmountType_uidRefs (pctxt, 
               &pvalue->uidRefs, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_AmountType (OSCTXT* pctxt, CCT_AmountType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("currencyId"), 10}, 0 },
         { {OSUTF8("language"), 8}, 0 },
         { {OSUTF8("uid"), 3}, 0 },
         { {OSUTF8("uidRef"), 6}, 0 },
         { {OSUTF8("uidRefs"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* currencyId */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->currencyId);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* language */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         case 2: /* uid */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uid);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidPresent = TRUE;
            break;

         case 3: /* uidRef */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uidRef);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefPresent = TRUE;
            break;

         case 4: /* uidRefs */
            rtxDListInit (&pvalue->uidRefs);

            stat = rtXmlpDecStrList (pctxt, &pvalue->uidRefs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefsPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "CCT_AmountType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "CCT_AmountType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDouble (pctxt, &pvalue->base, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CodeType_uidRefs                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_CodeType_uidRefs (OSCTXT* pctxt, 
   CCT_CodeType_uidRefs *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   const OSUTF8CHAR* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_utf8str (pctxt, &pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "CodeType_uidRefs.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_CodeType_uidRefs (OSCTXT* pctxt, CCT_CodeType_uidRefs* pvalue)
{
   int stat = 0;

   rtxDListInit (pvalue);

   stat = rtXmlpDecStrList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CodeType                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_CodeType (OSCTXT* pctxt, CCT_CodeType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode languageCode */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->languageCode, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languageCodePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode listAgencyId */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->listAgencyId, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode listId */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->listId, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode listVersionId */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->listVersionId, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.listVersionIdPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode uid */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uid, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode uidRef */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uidRef, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode uidRefs */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_CodeType_uidRefs (pctxt, 
               &pvalue->uidRefs, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 9:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_CodeType (OSCTXT* pctxt, CCT_CodeType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("language"), 8}, 0 },
         { {OSUTF8("languageCode"), 12}, 0 },
         { {OSUTF8("listAgencyId"), 12}, 0 },
         { {OSUTF8("listId"), 6}, 0 },
         { {OSUTF8("listVersionId"), 13}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("uid"), 3}, 0 },
         { {OSUTF8("uidRef"), 6}, 0 },
         { {OSUTF8("uidRefs"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 9, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* language */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         case 1: /* languageCode */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->languageCode);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languageCodePresent = TRUE;
            break;

         case 2: /* listAgencyId */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->listAgencyId);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* listId */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->listId);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* listVersionId */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->listVersionId);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.listVersionIdPresent = TRUE;
            break;

         case 5: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 6: /* uid */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uid);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidPresent = TRUE;
            break;

         case 7: /* uidRef */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uidRef);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefPresent = TRUE;
            break;

         case 8: /* uidRefs */
            rtxDListInit (&pvalue->uidRefs);

            stat = rtXmlpDecStrList (pctxt, &pvalue->uidRefs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefsPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "CCT_CodeType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "CCT_CodeType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->base);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  GraphicType                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_GraphicType (OSCTXT* pctxt, CCT_GraphicType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode format */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->format, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_octstr (pctxt, &pvalue->base.data, &pvalue->base.numocts, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_GraphicType (OSCTXT* pctxt, CCT_GraphicType* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("format"), 6}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* format */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->format);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "CCT_GraphicType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "CCT_GraphicType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDynBase64Str (pctxt, &pvalue->base);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IdentifierType_uidRefs                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_IdentifierType_uidRefs (OSCTXT* pctxt, 
   CCT_IdentifierType_uidRefs *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   const OSUTF8CHAR* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_utf8str (pctxt, &pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "IdentifierType_uidRefs.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_IdentifierType_uidRefs (OSCTXT* pctxt, 
   CCT_IdentifierType_uidRefs* pvalue)
{
   int stat = 0;

   rtxDListInit (pvalue);

   stat = rtXmlpDecStrList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IdentifierType                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_IdentifierType (OSCTXT* pctxt, 
   CCT_IdentifierType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode languageCode */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->languageCode, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languageCodePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode schemeAgencyName */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->schemeAgencyName, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode schemeName */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->schemeName, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode uid */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uid, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode uidRef */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uidRef, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode uidRefs */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_IdentifierType_uidRefs (pctxt, 
               &pvalue->uidRefs, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_IdentifierType (OSCTXT* pctxt, CCT_IdentifierType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("language"), 8}, 0 },
         { {OSUTF8("languageCode"), 12}, 0 },
         { {OSUTF8("schemeAgencyName"), 16}, 0 },
         { {OSUTF8("schemeName"), 10}, 0 },
         { {OSUTF8("uid"), 3}, 0 },
         { {OSUTF8("uidRef"), 6}, 0 },
         { {OSUTF8("uidRefs"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 7, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* language */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         case 1: /* languageCode */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->languageCode);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languageCodePresent = TRUE;
            break;

         case 2: /* schemeAgencyName */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->schemeAgencyName);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* schemeName */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->schemeName);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* uid */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uid);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidPresent = TRUE;
            break;

         case 5: /* uidRef */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uidRef);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefPresent = TRUE;
            break;

         case 6: /* uidRefs */
            rtxDListInit (&pvalue->uidRefs);

            stat = rtXmlpDecStrList (pctxt, &pvalue->uidRefs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefsPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "CCT_IdentifierType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "CCT_IdentifierType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->base);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IndicatorType_uidRefs                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_IndicatorType_uidRefs (OSCTXT* pctxt, 
   CCT_IndicatorType_uidRefs *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   const OSUTF8CHAR* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_utf8str (pctxt, &pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "IndicatorType_uidRefs.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_IndicatorType_uidRefs (OSCTXT* pctxt, 
   CCT_IndicatorType_uidRefs* pvalue)
{
   int stat = 0;

   rtxDListInit (pvalue);

   stat = rtXmlpDecStrList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  IndicatorType                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_IndicatorType (OSCTXT* pctxt, CCT_IndicatorType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode uid */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uid, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode uidRef */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uidRef, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode uidRefs */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_IndicatorType_uidRefs (pctxt, 
               &pvalue->uidRefs, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_IndicatorType (OSCTXT* pctxt, CCT_IndicatorType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("language"), 8}, 0 },
         { {OSUTF8("uid"), 3}, 0 },
         { {OSUTF8("uidRef"), 6}, 0 },
         { {OSUTF8("uidRefs"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* language */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         case 1: /* uid */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uid);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidPresent = TRUE;
            break;

         case 2: /* uidRef */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uidRef);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefPresent = TRUE;
            break;

         case 3: /* uidRefs */
            rtxDListInit (&pvalue->uidRefs);

            stat = rtXmlpDecStrList (pctxt, &pvalue->uidRefs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefsPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "CCT_IndicatorType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "CCT_IndicatorType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecBool (pctxt, &pvalue->base);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MeasureType_uidRefs                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_MeasureType_uidRefs (OSCTXT* pctxt, 
   CCT_MeasureType_uidRefs *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   const OSUTF8CHAR* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_utf8str (pctxt, &pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "MeasureType_uidRefs.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_MeasureType_uidRefs (OSCTXT* pctxt, 
   CCT_MeasureType_uidRefs* pvalue)
{
   int stat = 0;

   rtxDListInit (pvalue);

   stat = rtXmlpDecStrList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MeasureType                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_MeasureType (OSCTXT* pctxt, CCT_MeasureType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode uid */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uid, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode uidRef */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uidRef, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode uidRefs */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_MeasureType_uidRefs (pctxt, 
               &pvalue->uidRefs, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode unitCode */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->unitCode, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_MeasureType (OSCTXT* pctxt, CCT_MeasureType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("language"), 8}, 0 },
         { {OSUTF8("uid"), 3}, 0 },
         { {OSUTF8("uidRef"), 6}, 0 },
         { {OSUTF8("uidRefs"), 7}, 0 },
         { {OSUTF8("unitCode"), 8}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* language */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         case 1: /* uid */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uid);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidPresent = TRUE;
            break;

         case 2: /* uidRef */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uidRef);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefPresent = TRUE;
            break;

         case 3: /* uidRefs */
            rtxDListInit (&pvalue->uidRefs);

            stat = rtXmlpDecStrList (pctxt, &pvalue->uidRefs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefsPresent = TRUE;
            break;

         case 4: /* unitCode */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->unitCode);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "CCT_MeasureType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "CCT_MeasureType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDouble (pctxt, &pvalue->base, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NumericType_uidRefs                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_NumericType_uidRefs (OSCTXT* pctxt, 
   CCT_NumericType_uidRefs *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   const OSUTF8CHAR* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_utf8str (pctxt, &pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "NumericType_uidRefs.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_NumericType_uidRefs (OSCTXT* pctxt, 
   CCT_NumericType_uidRefs* pvalue)
{
   int stat = 0;

   rtxDListInit (pvalue);

   stat = rtXmlpDecStrList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NumericType                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_NumericType (OSCTXT* pctxt, CCT_NumericType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode format */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->format, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.formatPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode uid */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uid, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode uidRef */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uidRef, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode uidRefs */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_NumericType_uidRefs (pctxt, 
               &pvalue->uidRefs, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_NumericType (OSCTXT* pctxt, CCT_NumericType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("format"), 6}, 0 },
         { {OSUTF8("language"), 8}, 0 },
         { {OSUTF8("uid"), 3}, 0 },
         { {OSUTF8("uidRef"), 6}, 0 },
         { {OSUTF8("uidRefs"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* format */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->format);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.formatPresent = TRUE;
            break;

         case 1: /* language */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         case 2: /* uid */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uid);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidPresent = TRUE;
            break;

         case 3: /* uidRef */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uidRef);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefPresent = TRUE;
            break;

         case 4: /* uidRefs */
            rtxDListInit (&pvalue->uidRefs);

            stat = rtXmlpDecStrList (pctxt, &pvalue->uidRefs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefsPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "CCT_NumericType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "CCT_NumericType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDouble (pctxt, &pvalue->base, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PictureType_uidRefs                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_PictureType_uidRefs (OSCTXT* pctxt, 
   CCT_PictureType_uidRefs *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   const OSUTF8CHAR* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_utf8str (pctxt, &pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "PictureType_uidRefs.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_PictureType_uidRefs (OSCTXT* pctxt, 
   CCT_PictureType_uidRefs* pvalue)
{
   int stat = 0;

   rtxDListInit (pvalue);

   stat = rtXmlpDecStrList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PictureType                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_PictureType (OSCTXT* pctxt, CCT_PictureType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode format */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->format, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode uid */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uid, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode uidRef */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uidRef, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode uidRefs */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_PictureType_uidRefs (pctxt, 
               &pvalue->uidRefs, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_octstr (pctxt, &pvalue->base.data, &pvalue->base.numocts, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_PictureType (OSCTXT* pctxt, CCT_PictureType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("format"), 6}, 0 },
         { {OSUTF8("language"), 8}, 0 },
         { {OSUTF8("uid"), 3}, 0 },
         { {OSUTF8("uidRef"), 6}, 0 },
         { {OSUTF8("uidRefs"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* format */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->format);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* language */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         case 2: /* uid */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uid);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidPresent = TRUE;
            break;

         case 3: /* uidRef */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uidRef);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefPresent = TRUE;
            break;

         case 4: /* uidRefs */
            rtxDListInit (&pvalue->uidRefs);

            stat = rtXmlpDecStrList (pctxt, &pvalue->uidRefs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefsPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "CCT_PictureType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "CCT_PictureType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDynBase64Str (pctxt, &pvalue->base);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantityType_uidRefs                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_QuantityType_uidRefs (OSCTXT* pctxt, 
   CCT_QuantityType_uidRefs *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   const OSUTF8CHAR* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_utf8str (pctxt, &pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "QuantityType_uidRefs.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_QuantityType_uidRefs (OSCTXT* pctxt, 
   CCT_QuantityType_uidRefs* pvalue)
{
   int stat = 0;

   rtxDListInit (pvalue);

   stat = rtXmlpDecStrList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  QuantityType                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_QuantityType (OSCTXT* pctxt, CCT_QuantityType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode uid */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uid, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode uidRef */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uidRef, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode uidRefs */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_QuantityType_uidRefs (pctxt, 
               &pvalue->uidRefs, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode unitCode */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->unitCode, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode unitCodeListAgencyId */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->unitCodeListAgencyId, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.unitCodeListAgencyIdPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode unitCodeListId */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->unitCodeListId, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.unitCodeListIdPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_QuantityType (OSCTXT* pctxt, CCT_QuantityType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("language"), 8}, 0 },
         { {OSUTF8("uid"), 3}, 0 },
         { {OSUTF8("uidRef"), 6}, 0 },
         { {OSUTF8("uidRefs"), 7}, 0 },
         { {OSUTF8("unitCode"), 8}, 0 },
         { {OSUTF8("unitCodeListAgencyId"), 20}, 0 },
         { {OSUTF8("unitCodeListId"), 14}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 7, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* language */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         case 1: /* uid */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uid);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidPresent = TRUE;
            break;

         case 2: /* uidRef */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uidRef);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefPresent = TRUE;
            break;

         case 3: /* uidRefs */
            rtxDListInit (&pvalue->uidRefs);

            stat = rtXmlpDecStrList (pctxt, &pvalue->uidRefs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefsPresent = TRUE;
            break;

         case 4: /* unitCode */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->unitCode);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* unitCodeListAgencyId */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->unitCodeListAgencyId);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.unitCodeListAgencyIdPresent = TRUE;
            break;

         case 6: /* unitCodeListId */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->unitCodeListId);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.unitCodeListIdPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "CCT_QuantityType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "CCT_QuantityType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDouble (pctxt, &pvalue->base, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TextType_uidRefs                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_TextType_uidRefs (OSCTXT* pctxt, 
   CCT_TextType_uidRefs *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   const OSUTF8CHAR* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_utf8str (pctxt, &pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TextType_uidRefs.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_TextType_uidRefs (OSCTXT* pctxt, CCT_TextType_uidRefs* pvalue)
{
   int stat = 0;

   rtxDListInit (pvalue);

   stat = rtXmlpDecStrList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TextType                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_TextType (OSCTXT* pctxt, CCT_TextType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode languageCode */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->languageCode, ASN1IMPL, length);
            if (stat == 0) {
               { int nchars = rtxUTF8Len (pvalue->languageCode);
               if (!((nchars >= 0 && nchars <= 5))) {
                  rtxErrAddStrParm (pctxt, "TextType.languageCode");
                  rtxErrAddIntParm (pctxt, (int)nchars);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

               }
               pvalue->m.languageCodePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode uid */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uid, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode uidRef */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uidRef, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode uidRefs */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_TextType_uidRefs (pctxt, 
               &pvalue->uidRefs, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_TextType (OSCTXT* pctxt, CCT_TextType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("language"), 8}, 0 },
         { {OSUTF8("languageCode"), 12}, 0 },
         { {OSUTF8("uid"), 3}, 0 },
         { {OSUTF8("uidRef"), 6}, 0 },
         { {OSUTF8("uidRefs"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* language */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         case 1: /* languageCode */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->languageCode);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            { int nchars = rtxUTF8Len (pvalue->languageCode);
            if (!((nchars >= 0 && nchars <= 5))) {
               rtxErrAddStrParm (pctxt, "TextType.languageCode");
               rtxErrAddIntParm (pctxt, (int)nchars);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

            }

            pvalue->m.languageCodePresent = TRUE;
            break;

         case 2: /* uid */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uid);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidPresent = TRUE;
            break;

         case 3: /* uidRef */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uidRef);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefPresent = TRUE;
            break;

         case 4: /* uidRefs */
            rtxDListInit (&pvalue->uidRefs);

            stat = rtXmlpDecStrList (pctxt, &pvalue->uidRefs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefsPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "CCT_TextType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "CCT_TextType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->base);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PercentType_uidRefs                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_PercentType_uidRefs (OSCTXT* pctxt, 
   CCT_PercentType_uidRefs *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   const OSUTF8CHAR* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_utf8str (pctxt, &pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "PercentType_uidRefs.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_PercentType_uidRefs (OSCTXT* pctxt, 
   CCT_PercentType_uidRefs* pvalue)
{
   int stat = 0;

   rtxDListInit (pvalue);

   stat = rtXmlpDecStrList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PercentType                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_PercentType (OSCTXT* pctxt, CCT_PercentType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode uid */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uid, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode uidRef */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uidRef, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode uidRefs */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_PercentType_uidRefs (pctxt, 
               &pvalue->uidRefs, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_PercentType (OSCTXT* pctxt, CCT_PercentType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("language"), 8}, 0 },
         { {OSUTF8("uid"), 3}, 0 },
         { {OSUTF8("uidRef"), 6}, 0 },
         { {OSUTF8("uidRefs"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* language */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         case 1: /* uid */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uid);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidPresent = TRUE;
            break;

         case 2: /* uidRef */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uidRef);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefPresent = TRUE;
            break;

         case 3: /* uidRefs */
            rtxDListInit (&pvalue->uidRefs);

            stat = rtXmlpDecStrList (pctxt, &pvalue->uidRefs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefsPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "CCT_PercentType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "CCT_PercentType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDouble (pctxt, &pvalue->base, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NameType_uidRefs                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_NameType_uidRefs (OSCTXT* pctxt, 
   CCT_NameType_uidRefs *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   const OSUTF8CHAR* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_utf8str (pctxt, &pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "NameType_uidRefs.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_NameType_uidRefs (OSCTXT* pctxt, CCT_NameType_uidRefs* pvalue)
{
   int stat = 0;

   rtxDListInit (pvalue);

   stat = rtXmlpDecStrList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NameType                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_NameType (OSCTXT* pctxt, CCT_NameType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode languageCode */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->languageCode, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languageCodePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode uid */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uid, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode uidRef */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uidRef, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode uidRefs */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_NameType_uidRefs (pctxt, 
               &pvalue->uidRefs, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_NameType (OSCTXT* pctxt, CCT_NameType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("language"), 8}, 0 },
         { {OSUTF8("languageCode"), 12}, 0 },
         { {OSUTF8("uid"), 3}, 0 },
         { {OSUTF8("uidRef"), 6}, 0 },
         { {OSUTF8("uidRefs"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* language */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         case 1: /* languageCode */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->languageCode);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languageCodePresent = TRUE;
            break;

         case 2: /* uid */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uid);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidPresent = TRUE;
            break;

         case 3: /* uidRef */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uidRef);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefPresent = TRUE;
            break;

         case 4: /* uidRefs */
            rtxDListInit (&pvalue->uidRefs);

            stat = rtXmlpDecStrList (pctxt, &pvalue->uidRefs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefsPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "CCT_NameType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "CCT_NameType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->base);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RateType_uidRefs                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_RateType_uidRefs (OSCTXT* pctxt, 
   CCT_RateType_uidRefs *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   const OSUTF8CHAR* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_utf8str (pctxt, &pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "RateType_uidRefs.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_RateType_uidRefs (OSCTXT* pctxt, CCT_RateType_uidRefs* pvalue)
{
   int stat = 0;

   rtxDListInit (pvalue);

   stat = rtXmlpDecStrList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RateType                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_RateType (OSCTXT* pctxt, CCT_RateType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode uid */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uid, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode uidRef */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uidRef, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode uidRefs */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_RateType_uidRefs (pctxt, 
               &pvalue->uidRefs, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_RateType (OSCTXT* pctxt, CCT_RateType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("language"), 8}, 0 },
         { {OSUTF8("uid"), 3}, 0 },
         { {OSUTF8("uidRef"), 6}, 0 },
         { {OSUTF8("uidRefs"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* language */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         case 1: /* uid */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uid);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidPresent = TRUE;
            break;

         case 2: /* uidRef */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uidRef);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefPresent = TRUE;
            break;

         case 3: /* uidRefs */
            rtxDListInit (&pvalue->uidRefs);

            stat = rtXmlpDecStrList (pctxt, &pvalue->uidRefs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefsPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "CCT_RateType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "CCT_RateType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDouble (pctxt, &pvalue->base, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DimensionType_uidRefs                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_DimensionType_uidRefs (OSCTXT* pctxt, 
   CCT_DimensionType_uidRefs *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   const OSUTF8CHAR* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_utf8str (pctxt, &pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DimensionType_uidRefs.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_DimensionType_uidRefs (OSCTXT* pctxt, 
   CCT_DimensionType_uidRefs* pvalue)
{
   int stat = 0;

   rtxDListInit (pvalue);

   stat = rtXmlpDecStrList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DimensionType                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_DimensionType (OSCTXT* pctxt, CCT_DimensionType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode uid */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uid, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode uidRef */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uidRef, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode uidRefs */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_DimensionType_uidRefs (pctxt, 
               &pvalue->uidRefs, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode unitCode */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->unitCode, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_DimensionType (OSCTXT* pctxt, CCT_DimensionType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("language"), 8}, 0 },
         { {OSUTF8("uid"), 3}, 0 },
         { {OSUTF8("uidRef"), 6}, 0 },
         { {OSUTF8("uidRefs"), 7}, 0 },
         { {OSUTF8("unitCode"), 8}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* language */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         case 1: /* uid */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uid);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidPresent = TRUE;
            break;

         case 2: /* uidRef */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uidRef);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefPresent = TRUE;
            break;

         case 3: /* uidRefs */
            rtxDListInit (&pvalue->uidRefs);

            stat = rtXmlpDecStrList (pctxt, &pvalue->uidRefs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefsPresent = TRUE;
            break;

         case 4: /* unitCode */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->unitCode);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "CCT_DimensionType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "CCT_DimensionType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDouble (pctxt, &pvalue->base, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  YearType_uidRefs                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_YearType_uidRefs (OSCTXT* pctxt, 
   CCT_YearType_uidRefs *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   const OSUTF8CHAR* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_utf8str (pctxt, &pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "YearType_uidRefs.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_YearType_uidRefs (OSCTXT* pctxt, CCT_YearType_uidRefs* pvalue)
{
   int stat = 0;

   rtxDListInit (pvalue);

   stat = rtXmlpDecStrList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  YearType                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_YearType (OSCTXT* pctxt, CCT_YearType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode uid */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uid, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode uidRef */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uidRef, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode uidRefs */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_YearType_uidRefs (pctxt, 
               &pvalue->uidRefs, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_charstr (pctxt, &pvalue->base, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|26), length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_YearType (OSCTXT* pctxt, CCT_YearType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("language"), 8}, 0 },
         { {OSUTF8("uid"), 3}, 0 },
         { {OSUTF8("uidRef"), 6}, 0 },
         { {OSUTF8("uidRefs"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* language */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         case 1: /* uid */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uid);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidPresent = TRUE;
            break;

         case 2: /* uidRef */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uidRef);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefPresent = TRUE;
            break;

         case 3: /* uidRefs */
            rtxDListInit (&pvalue->uidRefs);

            stat = rtXmlpDecStrList (pctxt, &pvalue->uidRefs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefsPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "CCT_YearType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "CCT_YearType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)&pvalue->base);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  YearMonthType_uidRefs                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_YearMonthType_uidRefs (OSCTXT* pctxt, 
   CCT_YearMonthType_uidRefs *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   const OSUTF8CHAR* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_utf8str (pctxt, &pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "YearMonthType_uidRefs.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_YearMonthType_uidRefs (OSCTXT* pctxt, 
   CCT_YearMonthType_uidRefs* pvalue)
{
   int stat = 0;

   rtxDListInit (pvalue);

   stat = rtXmlpDecStrList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  YearMonthType                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_YearMonthType (OSCTXT* pctxt, CCT_YearMonthType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode uid */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uid, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode uidRef */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uidRef, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode uidRefs */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_YearMonthType_uidRefs (pctxt, 
               &pvalue->uidRefs, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_charstr (pctxt, &pvalue->base, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|26), length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_YearMonthType (OSCTXT* pctxt, CCT_YearMonthType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("language"), 8}, 0 },
         { {OSUTF8("uid"), 3}, 0 },
         { {OSUTF8("uidRef"), 6}, 0 },
         { {OSUTF8("uidRefs"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* language */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         case 1: /* uid */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uid);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidPresent = TRUE;
            break;

         case 2: /* uidRef */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uidRef);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefPresent = TRUE;
            break;

         case 3: /* uidRefs */
            rtxDListInit (&pvalue->uidRefs);

            stat = rtXmlpDecStrList (pctxt, &pvalue->uidRefs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefsPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "CCT_YearMonthType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "CCT_YearMonthType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)&pvalue->base);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MonthType_uidRefs                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_MonthType_uidRefs (OSCTXT* pctxt, 
   CCT_MonthType_uidRefs *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   const OSUTF8CHAR* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_utf8str (pctxt, &pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "MonthType_uidRefs.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_MonthType_uidRefs (OSCTXT* pctxt, CCT_MonthType_uidRefs* pvalue)
{
   int stat = 0;

   rtxDListInit (pvalue);

   stat = rtXmlpDecStrList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MonthType                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_MonthType (OSCTXT* pctxt, CCT_MonthType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode uid */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uid, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode uidRef */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uidRef, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode uidRefs */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_MonthType_uidRefs (pctxt, 
               &pvalue->uidRefs, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_charstr (pctxt, &pvalue->base, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|26), length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_MonthType (OSCTXT* pctxt, CCT_MonthType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("language"), 8}, 0 },
         { {OSUTF8("uid"), 3}, 0 },
         { {OSUTF8("uidRef"), 6}, 0 },
         { {OSUTF8("uidRefs"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* language */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         case 1: /* uid */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uid);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidPresent = TRUE;
            break;

         case 2: /* uidRef */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uidRef);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefPresent = TRUE;
            break;

         case 3: /* uidRefs */
            rtxDListInit (&pvalue->uidRefs);

            stat = rtXmlpDecStrList (pctxt, &pvalue->uidRefs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefsPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "CCT_MonthType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "CCT_MonthType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)&pvalue->base);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MonthDayType_uidRefs                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_MonthDayType_uidRefs (OSCTXT* pctxt, 
   CCT_MonthDayType_uidRefs *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   const OSUTF8CHAR* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_utf8str (pctxt, &pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "MonthDayType_uidRefs.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_MonthDayType_uidRefs (OSCTXT* pctxt, 
   CCT_MonthDayType_uidRefs* pvalue)
{
   int stat = 0;

   rtxDListInit (pvalue);

   stat = rtXmlpDecStrList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MonthDayType                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_MonthDayType (OSCTXT* pctxt, CCT_MonthDayType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode uid */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uid, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode uidRef */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uidRef, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode uidRefs */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_MonthDayType_uidRefs (pctxt, 
               &pvalue->uidRefs, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_charstr (pctxt, &pvalue->base, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|26), length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_MonthDayType (OSCTXT* pctxt, CCT_MonthDayType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("language"), 8}, 0 },
         { {OSUTF8("uid"), 3}, 0 },
         { {OSUTF8("uidRef"), 6}, 0 },
         { {OSUTF8("uidRefs"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* language */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         case 1: /* uid */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uid);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidPresent = TRUE;
            break;

         case 2: /* uidRef */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uidRef);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefPresent = TRUE;
            break;

         case 3: /* uidRefs */
            rtxDListInit (&pvalue->uidRefs);

            stat = rtXmlpDecStrList (pctxt, &pvalue->uidRefs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefsPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "CCT_MonthDayType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "CCT_MonthDayType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)&pvalue->base);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DayType_uidRefs                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_DayType_uidRefs (OSCTXT* pctxt, 
   CCT_DayType_uidRefs *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   const OSUTF8CHAR* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_utf8str (pctxt, &pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "DayType_uidRefs.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_DayType_uidRefs (OSCTXT* pctxt, CCT_DayType_uidRefs* pvalue)
{
   int stat = 0;

   rtxDListInit (pvalue);

   stat = rtXmlpDecStrList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DayType                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_DayType (OSCTXT* pctxt, CCT_DayType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode uid */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uid, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode uidRef */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uidRef, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode uidRefs */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_DayType_uidRefs (pctxt, 
               &pvalue->uidRefs, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_charstr (pctxt, &pvalue->base, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|26), length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_DayType (OSCTXT* pctxt, CCT_DayType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("language"), 8}, 0 },
         { {OSUTF8("uid"), 3}, 0 },
         { {OSUTF8("uidRef"), 6}, 0 },
         { {OSUTF8("uidRefs"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* language */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         case 1: /* uid */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uid);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidPresent = TRUE;
            break;

         case 2: /* uidRef */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uidRef);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefPresent = TRUE;
            break;

         case 3: /* uidRefs */
            rtxDListInit (&pvalue->uidRefs);

            stat = rtXmlpDecStrList (pctxt, &pvalue->uidRefs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefsPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "CCT_DayType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "CCT_DayType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)&pvalue->base);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FrequencyType_uidRefs                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_FrequencyType_uidRefs (OSCTXT* pctxt, 
   CCT_FrequencyType_uidRefs *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   const OSUTF8CHAR* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_utf8str (pctxt, &pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "FrequencyType_uidRefs.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_FrequencyType_uidRefs (OSCTXT* pctxt, 
   CCT_FrequencyType_uidRefs* pvalue)
{
   int stat = 0;

   rtxDListInit (pvalue);

   stat = rtXmlpDecStrList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FrequencyType                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_FrequencyType (OSCTXT* pctxt, CCT_FrequencyType *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode uid */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uid, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode uidRef */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uidRef, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode uidRefs */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_FrequencyType_uidRefs (pctxt, 
               &pvalue->uidRefs, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_FrequencyType (OSCTXT* pctxt, CCT_FrequencyType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("language"), 8}, 0 },
         { {OSUTF8("uid"), 3}, 0 },
         { {OSUTF8("uidRef"), 6}, 0 },
         { {OSUTF8("uidRefs"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* language */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         case 1: /* uid */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uid);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidPresent = TRUE;
            break;

         case 2: /* uidRef */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uidRef);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefPresent = TRUE;
            break;

         case 3: /* uidRefs */
            rtxDListInit (&pvalue->uidRefs);

            stat = rtXmlpDecStrList (pctxt, &pvalue->uidRefs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefsPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "CCT_FrequencyType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "CCT_FrequencyType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecInt (pctxt, &pvalue->base);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LanguageCodeType_uidRefs                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_LanguageCodeType_uidRefs (OSCTXT* pctxt, 
   CCT_LanguageCodeType_uidRefs *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   const OSUTF8CHAR* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_utf8str (pctxt, &pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "LanguageCodeType_uidRefs.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_LanguageCodeType_uidRefs (OSCTXT* pctxt, 
   CCT_LanguageCodeType_uidRefs* pvalue)
{
   int stat = 0;

   rtxDListInit (pvalue);

   stat = rtXmlpDecStrList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  LanguageCodeType                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_LanguageCodeType (OSCTXT* pctxt, 
   CCT_LanguageCodeType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode language */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->language, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languagePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode uid */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uid, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode uidRef */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uidRef, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode uidRefs */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_CCT_LanguageCodeType_uidRefs (pctxt, 
               &pvalue->uidRefs, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uidRefsPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_LanguageCodeType (OSCTXT* pctxt, CCT_LanguageCodeType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("language"), 8}, 0 },
         { {OSUTF8("uid"), 3}, 0 },
         { {OSUTF8("uidRef"), 6}, 0 },
         { {OSUTF8("uidRefs"), 7}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* language */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->language);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languagePresent = TRUE;
            break;

         case 1: /* uid */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uid);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidPresent = TRUE;
            break;

         case 2: /* uidRef */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uidRef);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefPresent = TRUE;
            break;

         case 3: /* uidRefs */
            rtxDListInit (&pvalue->uidRefs);

            stat = rtXmlpDecStrList (pctxt, &pvalue->uidRefs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.uidRefsPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "CCT_LanguageCodeType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "CCT_LanguageCodeType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->base);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ElectronicAddressType                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_CCT_ElectronicAddressType (OSCTXT* pctxt, 
   CCT_ElectronicAddressType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode contentId */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->contentId, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode fileName */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->fileName, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fileNamePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode languageCode */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->languageCode, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.languageCodePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode resourceId */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->resourceId, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_CCT_ElectronicAddressType (OSCTXT* pctxt, 
   CCT_ElectronicAddressType* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("contentId"), 9}, 0 },
         { {OSUTF8("fileName"), 8}, 0 },
         { {OSUTF8("languageCode"), 12}, 0 },
         { {OSUTF8("resourceId"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* contentId */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->contentId);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* fileName */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->fileName);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.fileNamePresent = TRUE;
            break;

         case 2: /* languageCode */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->languageCode);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.languageCodePresent = TRUE;
            break;

         case 3: /* resourceId */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->resourceId);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "CCT_ElectronicAddressType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "CCT_ElectronicAddressType");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->base);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_CCT_AmountContent_PDU (OSCTXT* pctxt, CCT_AmountContent* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("amountContent"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_CCT_AmountContent (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_CCT_CodeContent_PDU (OSCTXT* pctxt, CCT_CodeContent* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("codeContent"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_CCT_CodeContent (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_CCT_DateTimeContent_PDU (OSCTXT* pctxt, CCT_DateTimeContent* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("dateTimeContent"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_CCT_DateTimeContent (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_CCT_DateContent_PDU (OSCTXT* pctxt, CCT_DateContent* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("dateContent"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_CCT_DateContent (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_CCT_TimeContent_PDU (OSCTXT* pctxt, CCT_TimeContent* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("timeContent"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_CCT_TimeContent (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_CCT_GraphicContent_PDU (OSCTXT* pctxt, CCT_GraphicContent* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   asn1Init_CCT_GraphicContent (pvalue);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("graphicContent"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_CCT_GraphicContent (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_CCT_IdentifierContent_PDU (OSCTXT* pctxt, CCT_IdentifierContent* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("identifierContent"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_CCT_IdentifierContent (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_CCT_IndicatorContent_PDU (OSCTXT* pctxt, CCT_IndicatorContent* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("indicatorContent"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_CCT_IndicatorContent (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_CCT_MeasureContent_PDU (OSCTXT* pctxt, CCT_MeasureContent* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("measureContent"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_CCT_MeasureContent (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_CCT_NumericContent_PDU (OSCTXT* pctxt, CCT_NumericContent* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("numericContent"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_CCT_NumericContent (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_CCT_PictureContent_PDU (OSCTXT* pctxt, CCT_PictureContent* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   asn1Init_CCT_PictureContent (pvalue);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("pictureContent"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_CCT_PictureContent (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_CCT_QuantityContent_PDU (OSCTXT* pctxt, CCT_QuantityContent* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("quantityContent"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_CCT_QuantityContent (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_CCT_TextContent_PDU (OSCTXT* pctxt, CCT_TextContent* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("textContent"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_CCT_TextContent (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_CCT_DurationContent_PDU (OSCTXT* pctxt, CCT_DurationContent* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("durationContent"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_CCT_DurationContent (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_CCT_ValueContent_PDU (OSCTXT* pctxt, CCT_ValueContent* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("valueContent"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_CCT_ValueContent (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_CCT_PercentContent_PDU (OSCTXT* pctxt, CCT_PercentContent* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("percentContent"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_CCT_PercentContent (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_CCT_NameContent_PDU (OSCTXT* pctxt, CCT_NameContent* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("nameContent"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_CCT_NameContent (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_CCT_RateContent_PDU (OSCTXT* pctxt, CCT_RateContent* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("rateContent"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_CCT_RateContent (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_CCT_DimensionContent_PDU (OSCTXT* pctxt, CCT_DimensionContent* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("dimensionContent"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_CCT_DimensionContent (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_CCT_YearContent_PDU (OSCTXT* pctxt, CCT_YearContent* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("yearContent"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_CCT_YearContent (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_CCT_YearMonthContent_PDU (OSCTXT* pctxt, CCT_YearMonthContent* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("yearMonthContent"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_CCT_YearMonthContent (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_CCT_MonthContent_PDU (OSCTXT* pctxt, CCT_MonthContent* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("monthContent"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_CCT_MonthContent (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_CCT_MonthDayContent_PDU (OSCTXT* pctxt, CCT_MonthDayContent* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("monthDayContent"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_CCT_MonthDayContent (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_CCT_DayContent_PDU (OSCTXT* pctxt, CCT_DayContent* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("dayContent"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_CCT_DayContent (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_CCT_FrequencyContent_PDU (OSCTXT* pctxt, CCT_FrequencyContent* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("frequencyContent"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_CCT_FrequencyContent (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_CCT_LanguageCodeContent_PDU (OSCTXT* pctxt, CCT_LanguageCodeContent* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("languageCodeContent"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_CCT_LanguageCodeContent (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_CCT_PeriodGroup_PDU (OSCTXT* pctxt, CCT_PeriodGroup* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   asn1Init_CCT_PeriodGroup (pvalue);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("periodGroup"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_CCT_PeriodGroup (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlDec_CCT_RecurrenceGroup_PDU (OSCTXT* pctxt, CCT_RecurrenceGroup* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   asn1Init_CCT_RecurrenceGroup (pvalue);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("recurrenceGroup"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_CCT_RecurrenceGroup (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
