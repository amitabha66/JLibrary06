/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 18-Oct-2006.
 */
#include "AVCL.h"
#include "rtxsrc/rtxCommon.h"

/**************************************************************/
/*                                                            */
/*  NonNegativeScalarType                                     */
/*                                                            */
/**************************************************************/

/**************************************************************/
/*                                                            */
/*  AvclMessageType_transportStatus                           */
/*                                                            */
/**************************************************************/

static const OSEnumItem AvclMessageType_transportStatus_ENUMTAB[] = {
   { OSUTF8("none"), 0, 4, 0 },
   { OSUTF8("received"), 1, 8, 1 },
   { OSUTF8("sent"), 2, 4, 2 }
} ;
#define AvclMessageType_transportStatus_ENUMTABSIZE 3

const OSUTF8CHAR* AvclMessageType_transportStatus_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < AvclMessageType_transportStatus_ENUMTABSIZE) {
      return AvclMessageType_transportStatus_ENUMTAB
         [AvclMessageType_transportStatus_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int AvclMessageType_transportStatus_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, AvclMessageType_transportStatus* pvalue)
{
   OSUINT32 valueLen = rtxUTF8LenBytes (value);
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      AvclMessageType_transportStatus_ENUMTAB, 
      AvclMessageType_transportStatus_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (AvclMessageType_transportStatus)
         AvclMessageType_transportStatus_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

/**************************************************************/
/*                                                            */
/*  MetaDataType                                              */
/*                                                            */
/**************************************************************/

void asn1Init_MetaDataType (MetaDataType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->content = 0;
   pvalue->description = 0;
   pvalue->name = 0;
}

/**************************************************************/
/*                                                            */
/*  PriorityType                                              */
/*                                                            */
/**************************************************************/

/**************************************************************/
/*                                                            */
/*  PriorityElementType                                       */
/*                                                            */
/**************************************************************/

void asn1Init_PriorityElementType (PriorityElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  NonNegativeIntegerElementType                             */
/*                                                            */
/**************************************************************/

void asn1Init_NonNegativeIntegerElementType (
   NonNegativeIntegerElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  AcknowledgeType                                           */
/*                                                            */
/**************************************************************/

static const OSEnumItem AcknowledgeType_ENUMTAB[] = {
   { OSUTF8("negativeOnly"), 0, 12, 0 },
   { OSUTF8("no"), 1, 2, 1 },
   { OSUTF8("optional"), 2, 8, 2 },
   { OSUTF8("positiveOnly"), 3, 12, 3 },
   { OSUTF8("yes"), 4, 3, 4 }
} ;
#define AcknowledgeType_ENUMTABSIZE 5

const OSUTF8CHAR* AcknowledgeType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < AcknowledgeType_ENUMTABSIZE) {
      return AcknowledgeType_ENUMTAB
         [AcknowledgeType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int AcknowledgeType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, AcknowledgeType* pvalue)
{
   OSUINT32 valueLen = rtxUTF8LenBytes (value);
   OSINT32 idx = rtxLookupEnum (value, valueLen, AcknowledgeType_ENUMTAB, 
      AcknowledgeType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (AcknowledgeType)AcknowledgeType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

/**************************************************************/
/*                                                            */
/*  AcknowledgeElementType                                    */
/*                                                            */
/**************************************************************/

void asn1Init_AcknowledgeElementType (AcknowledgeElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  AvclMessageHeadType                                       */
/*                                                            */
/**************************************************************/

void asn1Init_AvclMessageHeadType (AvclMessageHeadType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   rtxDListFastInit (&pvalue->meta_list);
   asn1Init_PriorityElementType (&pvalue->priority);
   asn1Init_NonNegativeIntegerElementType (&pvalue->sender);
   rtxDListFastInit (&pvalue->recipient_list);
   asn1Init_AcknowledgeElementType (&pvalue->acknowledge);
}

/**************************************************************/
/*                                                            */
/*  LatitudeType                                              */
/*                                                            */
/**************************************************************/

/**************************************************************/
/*                                                            */
/*  LongitudeType                                             */
/*                                                            */
/**************************************************************/

/**************************************************************/
/*                                                            */
/*  LatitudeLongitudeElementType                              */
/*                                                            */
/**************************************************************/

void asn1Init_LatitudeLongitudeElementType (
   LatitudeLongitudeElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  PositiveScalarType                                        */
/*                                                            */
/**************************************************************/

/**************************************************************/
/*                                                            */
/*  GeoOriginElementType                                      */
/*                                                            */
/**************************************************************/

void asn1Init_GeoOriginElementType (GeoOriginElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  LatitudeLongitudeElementType_derivations                  */
/*                                                            */
/**************************************************************/

void asn1Init_LatitudeLongitudeElementType_derivations (
   LatitudeLongitudeElementType_derivations* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  XyElementType                                             */
/*                                                            */
/**************************************************************/

void asn1Init_XyElementType (XyElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  PointListElements                                         */
/*                                                            */
/**************************************************************/

void asn1Init_PointListElements (PointListElements* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  WaypointListType                                          */
/*                                                            */
/**************************************************************/

void asn1Init_WaypointListType (WaypointListType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_PointListElements (&pvalue->choice);
}

/**************************************************************/
/*                                                            */
/*  TurnDirectionType                                         */
/*                                                            */
/**************************************************************/

static const OSEnumItem TurnDirectionType_ENUMTAB[] = {
   { OSUTF8("left"), 0, 4, 0 },
   { OSUTF8("port"), 1, 4, 1 },
   { OSUTF8("right"), 2, 5, 2 },
   { OSUTF8("starboard"), 3, 9, 3 }
} ;
#define TurnDirectionType_ENUMTABSIZE 4

const OSUTF8CHAR* TurnDirectionType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < TurnDirectionType_ENUMTABSIZE) {
      return TurnDirectionType_ENUMTAB
         [TurnDirectionType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int TurnDirectionType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, TurnDirectionType* pvalue)
{
   OSUINT32 valueLen = rtxUTF8LenBytes (value);
   OSINT32 idx = rtxLookupEnum (value, valueLen, TurnDirectionType_ENUMTAB, 
      TurnDirectionType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (TurnDirectionType)TurnDirectionType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

/**************************************************************/
/*                                                            */
/*  HeadingType                                               */
/*                                                            */
/**************************************************************/

/**************************************************************/
/*                                                            */
/*  PositiveIntType                                           */
/*                                                            */
/**************************************************************/

/**************************************************************/
/*                                                            */
/*  HorizontalPositionElements                                */
/*                                                            */
/**************************************************************/

void asn1Init_HorizontalPositionElements (HorizontalPositionElements* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  HorizontalPositionElementType                             */
/*                                                            */
/**************************************************************/

void asn1Init_HorizontalPositionElementType (
   HorizontalPositionElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_HorizontalPositionElements (&pvalue->choice);
}

/**************************************************************/
/*                                                            */
/*  ParallelTrackType                                         */
/*                                                            */
/**************************************************************/

void asn1Init_ParallelTrackType (ParallelTrackType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_HorizontalPositionElementType (&pvalue->startPoint);
}

/**************************************************************/
/*                                                            */
/*  SectorPatternType                                         */
/*                                                            */
/**************************************************************/

void asn1Init_SectorPatternType (SectorPatternType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_HorizontalPositionElementType (&pvalue->startPoint);
}

/**************************************************************/
/*                                                            */
/*  ExpandingSquareType                                       */
/*                                                            */
/**************************************************************/

void asn1Init_ExpandingSquareType (ExpandingSquareType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_HorizontalPositionElementType (&pvalue->startPoint);
}

/**************************************************************/
/*                                                            */
/*  CompositeWaypointElements                                 */
/*                                                            */
/**************************************************************/

void asn1Init_CompositeWaypointElements (CompositeWaypointElements* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  PositiveScalarElementType                                 */
/*                                                            */
/**************************************************************/

void asn1Init_PositiveScalarElementType (PositiveScalarElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  SpeedElementType                                          */
/*                                                            */
/**************************************************************/

void asn1Init_SpeedElementType (SpeedElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  PositiveScalarElementType_derivations                     */
/*                                                            */
/**************************************************************/

void asn1Init_PositiveScalarElementType_derivations (
   PositiveScalarElementType_derivations* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  DepthTypeElements                                         */
/*                                                            */
/**************************************************************/

void asn1Init_DepthTypeElements (DepthTypeElements* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  TrackModeType                                             */
/*                                                            */
/**************************************************************/

static const OSEnumItem TrackModeType_ENUMTAB[] = {
   { OSUTF8("directTo"), 0, 8, 0 },
   { OSUTF8("trackTo"), 1, 7, 1 }
} ;
#define TrackModeType_ENUMTABSIZE 2

const OSUTF8CHAR* TrackModeType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < TrackModeType_ENUMTABSIZE) {
      return TrackModeType_ENUMTAB[TrackModeType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int TrackModeType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, TrackModeType* pvalue)
{
   OSUINT32 valueLen = rtxUTF8LenBytes (value);
   OSINT32 idx = rtxLookupEnum (value, valueLen, TrackModeType_ENUMTAB, 
      TrackModeType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (TrackModeType)TrackModeType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

/**************************************************************/
/*                                                            */
/*  TrackModeElementType                                      */
/*                                                            */
/**************************************************************/

void asn1Init_TrackModeElementType (TrackModeElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  SignedPercentType                                         */
/*                                                            */
/**************************************************************/

/**************************************************************/
/*                                                            */
/*  SignedPercentElementType                                  */
/*                                                            */
/**************************************************************/

void asn1Init_SignedPercentElementType (SignedPercentElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  SetPropellerCommandType_choice                            */
/*                                                            */
/**************************************************************/

void asn1Init_SetPropellerCommandType_choice (
   SetPropellerCommandType_choice* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  SetPropellerCommandType                                   */
/*                                                            */
/**************************************************************/

void asn1Init_SetPropellerCommandType (SetPropellerCommandType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_SetPropellerCommandType_choice (&pvalue->choice);
}

/**************************************************************/
/*                                                            */
/*  UuvSpeedElements                                          */
/*                                                            */
/**************************************************************/

void asn1Init_UuvSpeedElements (UuvSpeedElements* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  PositiveIntegerElementType                                */
/*                                                            */
/**************************************************************/

void asn1Init_PositiveIntegerElementType (PositiveIntegerElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  UuvCompositeWaypointCommandType                           */
/*                                                            */
/**************************************************************/

void asn1Init_UuvCompositeWaypointCommandType (
   UuvCompositeWaypointCommandType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_CompositeWaypointElements (&pvalue->choice);
   asn1Init_DepthTypeElements (&pvalue->choice_1);
   asn1Init_TrackModeElementType (&pvalue->homingMode);
   asn1Init_UuvSpeedElements (&pvalue->choice_2);
   asn1Init_PositiveIntegerElementType (&pvalue->gpsFixes);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->standoff);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->timeOut);
}

/**************************************************************/
/*                                                            */
/*  StringElementType                                         */
/*                                                            */
/**************************************************************/

void asn1Init_StringElementType (StringElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   pvalue->value = 0;
}

/**************************************************************/
/*                                                            */
/*  FollowBeaconCommandType                                   */
/*                                                            */
/**************************************************************/

void asn1Init_FollowBeaconCommandType (FollowBeaconCommandType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_StringElementType (&pvalue->beacon);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->timeOut);
}

/**************************************************************/
/*                                                            */
/*  GpsFixCommandType                                         */
/*                                                            */
/**************************************************************/

void asn1Init_GpsFixCommandType (GpsFixCommandType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  NoValueElementType                                        */
/*                                                            */
/**************************************************************/

void asn1Init_NoValueElementType (NoValueElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  HeadingElementType                                        */
/*                                                            */
/**************************************************************/

void asn1Init_HeadingElementType (HeadingElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  BooleanElementType                                        */
/*                                                            */
/**************************************************************/

void asn1Init_BooleanElementType (BooleanElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  BooleanElementType_derivations                            */
/*                                                            */
/**************************************************************/

void asn1Init_BooleanElementType_derivations (
   BooleanElementType_derivations* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  HoverCommandType                                          */
/*                                                            */
/**************************************************************/

void asn1Init_HoverCommandType (HoverCommandType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_HorizontalPositionElements (&pvalue->choice);
   asn1Init_DepthTypeElements (&pvalue->choice_1);
   asn1Init_HeadingElementType (&pvalue->heading);
   asn1Init_BooleanElementType_derivations (&pvalue->obtainGps);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->standoff);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->timeOut);
}

/**************************************************************/
/*                                                            */
/*  UuvLoiterCommandType                                      */
/*                                                            */
/**************************************************************/

void asn1Init_UuvLoiterCommandType (UuvLoiterCommandType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_HorizontalPositionElements (&pvalue->choice);
   asn1Init_DepthTypeElements (&pvalue->choice_1);
   asn1Init_UuvSpeedElements (&pvalue->choice_2);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->loiterDepth);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->timeOut);
}

/**************************************************************/
/*                                                            */
/*  ExitModeElements                                          */
/*                                                            */
/**************************************************************/

void asn1Init_ExitModeElements (ExitModeElements* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  QuitCommandType                                           */
/*                                                            */
/**************************************************************/

void asn1Init_QuitCommandType (QuitCommandType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_ExitModeElements (&pvalue->choice);
}

/**************************************************************/
/*                                                            */
/*  ScalarElementType                                         */
/*                                                            */
/**************************************************************/

void asn1Init_ScalarElementType (ScalarElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  RecoverCommandType                                        */
/*                                                            */
/**************************************************************/

void asn1Init_RecoverCommandType (RecoverCommandType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_ScalarElementType (&pvalue->range);
   asn1Init_HeadingElementType (&pvalue->heading);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->timeOut);
}

/**************************************************************/
/*                                                            */
/*  SendMessageCommandType_choice                             */
/*                                                            */
/**************************************************************/

void asn1Init_SendMessageCommandType_choice (
   SendMessageCommandType_choice* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  SendMessageCommandType                                    */
/*                                                            */
/**************************************************************/

void asn1Init_SendMessageCommandType (SendMessageCommandType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_SendMessageCommandType_choice (&pvalue->choice);
}

/**************************************************************/
/*                                                            */
/*  SetPlanesCommandType_choice                               */
/*                                                            */
/**************************************************************/

void asn1Init_SetPlanesCommandType_choice (SetPlanesCommandType_choice* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  SetPlanesCommandType                                      */
/*                                                            */
/**************************************************************/

void asn1Init_SetPlanesCommandType (SetPlanesCommandType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_SetPlanesCommandType_choice (&pvalue->choice);
}

/**************************************************************/
/*                                                            */
/*  AbsoluteHorizontalPositionElements                        */
/*                                                            */
/**************************************************************/

void asn1Init_AbsoluteHorizontalPositionElements (
   AbsoluteHorizontalPositionElements* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  UuvPositionCommandType                                    */
/*                                                            */
/**************************************************************/

void asn1Init_UuvPositionCommandType (UuvPositionCommandType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_AbsoluteHorizontalPositionElements (&pvalue->choice);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->depth);
}

/**************************************************************/
/*                                                            */
/*  SetSonarCommandType_choice                                */
/*                                                            */
/**************************************************************/

void asn1Init_SetSonarCommandType_choice (SetSonarCommandType_choice* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  BearingTypeElements                                       */
/*                                                            */
/**************************************************************/

void asn1Init_BearingTypeElements (BearingTypeElements* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  SetSonarCommandType                                       */
/*                                                            */
/**************************************************************/

void asn1Init_SetSonarCommandType (SetSonarCommandType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_StringElementType (&pvalue->model);
   asn1Init_SetSonarCommandType_choice (&pvalue->choice);
   asn1Init_ScalarElementType (&pvalue->bearing);
   asn1Init_ScalarElementType (&pvalue->elevation);
   asn1Init_BearingTypeElements (&pvalue->choice_1);
}

/**************************************************************/
/*                                                            */
/*  SetThrusterCommandType_choice                             */
/*                                                            */
/**************************************************************/

void asn1Init_SetThrusterCommandType_choice (
   SetThrusterCommandType_choice* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  SetThrusterCommandType                                    */
/*                                                            */
/**************************************************************/

void asn1Init_SetThrusterCommandType (SetThrusterCommandType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_SetThrusterCommandType_choice (&pvalue->choice);
}

/**************************************************************/
/*                                                            */
/*  TakeStationCommandType_choice                             */
/*                                                            */
/**************************************************************/

void asn1Init_TakeStationCommandType_choice (
   TakeStationCommandType_choice* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  TargetElementType                                         */
/*                                                            */
/**************************************************************/

void asn1Init_TargetElementType (TargetElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  TakeStationCommandType                                    */
/*                                                            */
/**************************************************************/

void asn1Init_TakeStationCommandType (TakeStationCommandType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_TakeStationCommandType_choice (&pvalue->choice);
   asn1Init_TargetElementType (&pvalue->targetLocation);
   asn1Init_TargetElementType (&pvalue->commandedStation);
   asn1Init_HeadingElementType (&pvalue->heading);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->timeOut);
}

/**************************************************************/
/*                                                            */
/*  UuvWaypointCommandType                                    */
/*                                                            */
/**************************************************************/

void asn1Init_UuvWaypointCommandType (UuvWaypointCommandType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_HorizontalPositionElements (&pvalue->choice);
   asn1Init_DepthTypeElements (&pvalue->choice_1);
   asn1Init_TrackModeElementType (&pvalue->homingMode);
   asn1Init_UuvSpeedElements (&pvalue->choice_2);
   asn1Init_BooleanElementType_derivations (&pvalue->obtainGps);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->standoff);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->timeOut);
}

/**************************************************************/
/*                                                            */
/*  UuvScriptCommandsType_element                             */
/*                                                            */
/**************************************************************/

void asn1Init_UuvScriptCommandsType_element (
   UuvScriptCommandsType_element* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  UuvScriptCommandsType                                     */
/*                                                            */
/**************************************************************/

void asn1Init_UuvScriptCommandsType (UuvScriptCommandsType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   rtxDListFastInit (&pvalue->choice_list);
}

/**************************************************************/
/*                                                            */
/*  SpeedTypeElements                                         */
/*                                                            */
/**************************************************************/

void asn1Init_SpeedTypeElements (SpeedTypeElements* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  UsvCompositeWaypointCommandType                           */
/*                                                            */
/**************************************************************/

void asn1Init_UsvCompositeWaypointCommandType (
   UsvCompositeWaypointCommandType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_CompositeWaypointElements (&pvalue->choice);
   asn1Init_TrackModeElementType (&pvalue->homingMode);
   asn1Init_SpeedTypeElements (&pvalue->choice_1);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->standoff);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->timeOut);
}

/**************************************************************/
/*                                                            */
/*  UsvLoiterCommandType                                      */
/*                                                            */
/**************************************************************/

void asn1Init_UsvLoiterCommandType (UsvLoiterCommandType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_HorizontalPositionElements (&pvalue->choice);
   asn1Init_SpeedTypeElements (&pvalue->choice_1);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->timeOut);
}

/**************************************************************/
/*                                                            */
/*  UsvPositionCommandType                                    */
/*                                                            */
/**************************************************************/

void asn1Init_UsvPositionCommandType (UsvPositionCommandType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_AbsoluteHorizontalPositionElements (&pvalue->choice);
}

/**************************************************************/
/*                                                            */
/*  UsvWaypointCommandType                                    */
/*                                                            */
/**************************************************************/

void asn1Init_UsvWaypointCommandType (UsvWaypointCommandType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_HorizontalPositionElements (&pvalue->choice);
   asn1Init_TrackModeElementType (&pvalue->homingMode);
   asn1Init_SpeedTypeElements (&pvalue->choice_1);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->standoff);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->timeOut);
}

/**************************************************************/
/*                                                            */
/*  UsvScriptCommandsType_element                             */
/*                                                            */
/**************************************************************/

void asn1Init_UsvScriptCommandsType_element (
   UsvScriptCommandsType_element* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  UsvScriptCommandsType                                     */
/*                                                            */
/**************************************************************/

void asn1Init_UsvScriptCommandsType (UsvScriptCommandsType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   rtxDListFastInit (&pvalue->choice_list);
}

/**************************************************************/
/*                                                            */
/*  UgvCompositeWaypointCommandType                           */
/*                                                            */
/**************************************************************/

void asn1Init_UgvCompositeWaypointCommandType (
   UgvCompositeWaypointCommandType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_CompositeWaypointElements (&pvalue->choice);
   asn1Init_TrackModeElementType (&pvalue->homingMode);
   asn1Init_SpeedTypeElements (&pvalue->choice_1);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->standoff);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->timeOut);
}

/**************************************************************/
/*                                                            */
/*  UgvLoiterCommandType                                      */
/*                                                            */
/**************************************************************/

void asn1Init_UgvLoiterCommandType (UgvLoiterCommandType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_HorizontalPositionElements (&pvalue->choice);
   asn1Init_SpeedTypeElements (&pvalue->choice_1);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->timeOut);
}

/**************************************************************/
/*                                                            */
/*  UgvPositionCommandType                                    */
/*                                                            */
/**************************************************************/

void asn1Init_UgvPositionCommandType (UgvPositionCommandType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_AbsoluteHorizontalPositionElements (&pvalue->choice);
}

/**************************************************************/
/*                                                            */
/*  UgvWaypointCommandType                                    */
/*                                                            */
/**************************************************************/

void asn1Init_UgvWaypointCommandType (UgvWaypointCommandType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_HorizontalPositionElements (&pvalue->choice);
   asn1Init_SpeedTypeElements (&pvalue->choice_1);
   asn1Init_TrackModeElementType (&pvalue->homingMode);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->standoff);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->timeOut);
}

/**************************************************************/
/*                                                            */
/*  UgvScriptCommandsType_element                             */
/*                                                            */
/**************************************************************/

void asn1Init_UgvScriptCommandsType_element (
   UgvScriptCommandsType_element* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  UgvScriptCommandsType                                     */
/*                                                            */
/**************************************************************/

void asn1Init_UgvScriptCommandsType (UgvScriptCommandsType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   rtxDListFastInit (&pvalue->choice_list);
}

/**************************************************************/
/*                                                            */
/*  AltitudeTypeElements                                      */
/*                                                            */
/**************************************************************/

void asn1Init_AltitudeTypeElements (AltitudeTypeElements* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  UavCompositeWaypointCommandType                           */
/*                                                            */
/**************************************************************/

void asn1Init_UavCompositeWaypointCommandType (
   UavCompositeWaypointCommandType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_CompositeWaypointElements (&pvalue->choice);
   asn1Init_AltitudeTypeElements (&pvalue->choice_1);
   asn1Init_TrackModeElementType (&pvalue->homingMode);
   asn1Init_SpeedTypeElements (&pvalue->choice_2);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->standoff);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->timeOut);
}

/**************************************************************/
/*                                                            */
/*  UavLoiterCommandType                                      */
/*                                                            */
/**************************************************************/

void asn1Init_UavLoiterCommandType (UavLoiterCommandType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_HorizontalPositionElements (&pvalue->choice);
   asn1Init_SpeedTypeElements (&pvalue->choice_1);
   asn1Init_AltitudeTypeElements (&pvalue->choice_2);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->loiterAltitude);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->timeOut);
}

/**************************************************************/
/*                                                            */
/*  UavPositionCommandType                                    */
/*                                                            */
/**************************************************************/

void asn1Init_UavPositionCommandType (UavPositionCommandType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_AbsoluteHorizontalPositionElements (&pvalue->choice);
   asn1Init_ScalarElementType (&pvalue->mSLAltitude);
}

/**************************************************************/
/*                                                            */
/*  PercentType                                               */
/*                                                            */
/**************************************************************/

/**************************************************************/
/*                                                            */
/*  PercentElementType                                        */
/*                                                            */
/**************************************************************/

void asn1Init_PercentElementType (PercentElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  UavWaypointCommandType                                    */
/*                                                            */
/**************************************************************/

void asn1Init_UavWaypointCommandType (UavWaypointCommandType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_HorizontalPositionElements (&pvalue->choice);
   asn1Init_AltitudeTypeElements (&pvalue->choice_1);
   asn1Init_TrackModeElementType (&pvalue->homingMode);
   asn1Init_SpeedTypeElements (&pvalue->choice_2);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->standoff);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->timeOut);
}

/**************************************************************/
/*                                                            */
/*  UavScriptCommandsType_element                             */
/*                                                            */
/**************************************************************/

void asn1Init_UavScriptCommandsType_element (
   UavScriptCommandsType_element* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  UavScriptCommandsType                                     */
/*                                                            */
/**************************************************************/

void asn1Init_UavScriptCommandsType (UavScriptCommandsType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   rtxDListFastInit (&pvalue->choice_list);
}

/**************************************************************/
/*                                                            */
/*  AbsoluteHorizontalPositionElementType                     */
/*                                                            */
/**************************************************************/

void asn1Init_AbsoluteHorizontalPositionElementType (
   AbsoluteHorizontalPositionElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_AbsoluteHorizontalPositionElements (&pvalue->choice);
}

/**************************************************************/
/*                                                            */
/*  WeaponStatusType                                          */
/*                                                            */
/**************************************************************/

static const OSEnumItem WeaponStatusType_ENUMTAB[] = {
   { OSUTF8("free"), 0, 4, 0 },
   { OSUTF8("safe"), 1, 4, 1 },
   { OSUTF8("tight"), 2, 5, 2 }
} ;
#define WeaponStatusType_ENUMTABSIZE 3

const OSUTF8CHAR* WeaponStatusType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < WeaponStatusType_ENUMTABSIZE) {
      return WeaponStatusType_ENUMTAB
         [WeaponStatusType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int WeaponStatusType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, WeaponStatusType* pvalue)
{
   OSUINT32 valueLen = rtxUTF8LenBytes (value);
   OSINT32 idx = rtxLookupEnum (value, valueLen, WeaponStatusType_ENUMTAB, 
      WeaponStatusType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (WeaponStatusType)WeaponStatusType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

/**************************************************************/
/*                                                            */
/*  ActionObjectElementType                                   */
/*                                                            */
/**************************************************************/

void asn1Init_ActionObjectElementType (ActionObjectElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   pvalue->name = 0;
}

/**************************************************************/
/*                                                            */
/*  AttackElementType                                         */
/*                                                            */
/**************************************************************/

void asn1Init_AttackElementType (AttackElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   rtxDListFastInit (&pvalue->target_list);
}

/**************************************************************/
/*                                                            */
/*  ContaminantType                                           */
/*                                                            */
/**************************************************************/

static const OSEnumItem ContaminantType_ENUMTAB[] = {
   { OSUTF8("biological"), 0, 10, 0 },
   { OSUTF8("chemical"), 1, 8, 1 },
   { OSUTF8("explosive"), 2, 9, 2 },
   { OSUTF8("nuclear"), 3, 7, 3 },
   { OSUTF8("toxin"), 4, 5, 4 }
} ;
#define ContaminantType_ENUMTABSIZE 5

const OSUTF8CHAR* ContaminantType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ContaminantType_ENUMTABSIZE) {
      return ContaminantType_ENUMTAB
         [ContaminantType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ContaminantType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ContaminantType* pvalue)
{
   OSUINT32 valueLen = rtxUTF8LenBytes (value);
   OSINT32 idx = rtxLookupEnum (value, valueLen, ContaminantType_ENUMTAB, 
      ContaminantType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ContaminantType)ContaminantType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

/**************************************************************/
/*                                                            */
/*  ContaminantElementType                                    */
/*                                                            */
/**************************************************************/

void asn1Init_ContaminantElementType (ContaminantElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  DecontaminateElementType                                  */
/*                                                            */
/**************************************************************/

void asn1Init_DecontaminateElementType (DecontaminateElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   rtxDListFastInit (&pvalue->contaminant_list);
}

/**************************************************************/
/*                                                            */
/*  DemolishElementType                                       */
/*                                                            */
/**************************************************************/

void asn1Init_DemolishElementType (DemolishElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   rtxDListFastInit (&pvalue->target_list);
}

/**************************************************************/
/*                                                            */
/*  IlluminatorType                                           */
/*                                                            */
/**************************************************************/

static const OSEnumItem IlluminatorType_ENUMTAB[] = {
   { OSUTF8("pyrotechnics"), 0, 12, 0 },
   { OSUTF8("spotlight"), 1, 9, 1 }
} ;
#define IlluminatorType_ENUMTABSIZE 2

const OSUTF8CHAR* IlluminatorType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < IlluminatorType_ENUMTABSIZE) {
      return IlluminatorType_ENUMTAB
         [IlluminatorType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int IlluminatorType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, IlluminatorType* pvalue)
{
   OSUINT32 valueLen = rtxUTF8LenBytes (value);
   OSINT32 idx = rtxLookupEnum (value, valueLen, IlluminatorType_ENUMTAB, 
      IlluminatorType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (IlluminatorType)IlluminatorType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

/**************************************************************/
/*                                                            */
/*  IlluminatorElementType                                    */
/*                                                            */
/**************************************************************/

void asn1Init_IlluminatorElementType (IlluminatorElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   rtxDListFastInit (&pvalue->illuminatorCharacteristic_list);
}

/**************************************************************/
/*                                                            */
/*  IlluminateElementType                                     */
/*                                                            */
/**************************************************************/

void asn1Init_IlluminateElementType (IlluminateElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_IlluminatorElementType (&pvalue->illuminator);
}

/**************************************************************/
/*                                                            */
/*  FrequencyRangeElementType                                 */
/*                                                            */
/**************************************************************/

void asn1Init_FrequencyRangeElementType (FrequencyRangeElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  JamElementType                                            */
/*                                                            */
/**************************************************************/

void asn1Init_JamElementType (JamElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   rtxDListFastInit (&pvalue->frequencyRange_list);
}

/**************************************************************/
/*                                                            */
/*  MarkerType                                                */
/*                                                            */
/**************************************************************/

static const OSEnumItem MarkerType_ENUMTAB[] = {
   { OSUTF8("laser"), 0, 5, 0 },
   { OSUTF8("smoke"), 1, 5, 1 }
} ;
#define MarkerType_ENUMTABSIZE 2

const OSUTF8CHAR* MarkerType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < MarkerType_ENUMTABSIZE) {
      return MarkerType_ENUMTAB[MarkerType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int MarkerType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, MarkerType* pvalue)
{
   OSUINT32 valueLen = rtxUTF8LenBytes (value);
   OSINT32 idx = rtxLookupEnum (value, valueLen, MarkerType_ENUMTAB, 
      MarkerType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (MarkerType)MarkerType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

/**************************************************************/
/*                                                            */
/*  MarkerElementType                                         */
/*                                                            */
/**************************************************************/

void asn1Init_MarkerElementType (MarkerElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   rtxDListFastInit (&pvalue->markerCharacteristic_list);
}

/**************************************************************/
/*                                                            */
/*  MarkElementType                                           */
/*                                                            */
/**************************************************************/

void asn1Init_MarkElementType (MarkElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_MarkerElementType (&pvalue->marker);
   rtxDListFastInit (&pvalue->target_list);
}

/**************************************************************/
/*                                                            */
/*  MonitorTransmissionsElementType                           */
/*                                                            */
/**************************************************************/

void asn1Init_MonitorTransmissionsElementType (
   MonitorTransmissionsElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   rtxDListFastInit (&pvalue->frequencyRange_list);
}

/**************************************************************/
/*                                                            */
/*  PatrolElementType                                         */
/*                                                            */
/**************************************************************/

void asn1Init_PatrolElementType (PatrolElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   rtxDListFastInit (&pvalue->qualifier_list);
}

/**************************************************************/
/*                                                            */
/*  RendezvousElementType                                     */
/*                                                            */
/**************************************************************/

void asn1Init_RendezvousElementType (RendezvousElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   pvalue->targetVehicleID = 0;
   rtxDListFastInit (&pvalue->qualifier_list);
}

/**************************************************************/
/*                                                            */
/*  SampleEnvironmentElementType                              */
/*                                                            */
/**************************************************************/

void asn1Init_SampleEnvironmentElementType (
   SampleEnvironmentElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   rtxDListFastInit (&pvalue->contaminant_list);
}

/**************************************************************/
/*                                                            */
/*  DatumTypeType                                             */
/*                                                            */
/**************************************************************/

static const OSEnumItem DatumTypeType_ENUMTAB[] = {
   { OSUTF8("area"), 0, 4, 0 },
   { OSUTF8("point"), 1, 5, 1 }
} ;
#define DatumTypeType_ENUMTABSIZE 2

const OSUTF8CHAR* DatumTypeType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < DatumTypeType_ENUMTABSIZE) {
      return DatumTypeType_ENUMTAB[DatumTypeType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int DatumTypeType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, DatumTypeType* pvalue)
{
   OSUINT32 valueLen = rtxUTF8LenBytes (value);
   OSINT32 idx = rtxLookupEnum (value, valueLen, DatumTypeType_ENUMTAB, 
      DatumTypeType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (DatumTypeType)DatumTypeType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

/**************************************************************/
/*                                                            */
/*  SearchElementType                                         */
/*                                                            */
/**************************************************************/

void asn1Init_SearchElementType (SearchElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   rtxDListFastInit (&pvalue->searchTarget_list);
}

/**************************************************************/
/*                                                            */
/*  GoalElements                                              */
/*                                                            */
/**************************************************************/

void asn1Init_GoalElements (GoalElements* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  CircleElementType                                         */
/*                                                            */
/**************************************************************/

void asn1Init_CircleElementType (CircleElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_AbsoluteHorizontalPositionElementType (&pvalue->center);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->radius);
}

/**************************************************************/
/*                                                            */
/*  AreaOrientationType                                       */
/*                                                            */
/**************************************************************/

/**************************************************************/
/*                                                            */
/*  AreaOrientationElementType                                */
/*                                                            */
/**************************************************************/

void asn1Init_AreaOrientationElementType (AreaOrientationElementType* pvalue)
{
   if (0 == pvalue) return;
}

/**************************************************************/
/*                                                            */
/*  RectangleElementType                                      */
/*                                                            */
/**************************************************************/

void asn1Init_RectangleElementType (RectangleElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_AbsoluteHorizontalPositionElementType (&pvalue->northwestCorner);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->width);
   asn1Init_PositiveScalarElementType_derivations (&pvalue->height);
   asn1Init_AreaOrientationElementType (&pvalue->orientation);
}

/**************************************************************/
/*                                                            */
/*  PolygonElementType                                        */
/*                                                            */
/**************************************************************/

void asn1Init_PolygonElementType (PolygonElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_PointListElements (&pvalue->choice);
}

/**************************************************************/
/*                                                            */
/*  LimitingLineElementType                                   */
/*                                                            */
/**************************************************************/

void asn1Init_LimitingLineElementType (LimitingLineElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_PointListElements (&pvalue->choice);
}

/**************************************************************/
/*                                                            */
/*  AreaElements                                              */
/*                                                            */
/**************************************************************/

void asn1Init_AreaElements (AreaElements* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  NumericalBlockElementType                                 */
/*                                                            */
/**************************************************************/

void asn1Init_NumericalBlockElementType (NumericalBlockElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  DepthBlockElements                                        */
/*                                                            */
/**************************************************************/

void asn1Init_DepthBlockElements (DepthBlockElements* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  AltitudeBlockElements                                     */
/*                                                            */
/**************************************************************/

void asn1Init_AltitudeBlockElements (AltitudeBlockElements* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  VerticalBlockElements                                     */
/*                                                            */
/**************************************************************/

void asn1Init_VerticalBlockElements (VerticalBlockElements* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  AreaElementType                                           */
/*                                                            */
/**************************************************************/

void asn1Init_AreaElementType (AreaElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_AreaElements (&pvalue->choice);
   asn1Init_VerticalBlockElements (&pvalue->choice_1);
}

/**************************************************************/
/*                                                            */
/*  AbsoluteTimingElementType                                 */
/*                                                            */
/**************************************************************/

void asn1Init_AbsoluteTimingElementType (AbsoluteTimingElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  TimingTypeElements                                        */
/*                                                            */
/**************************************************************/

void asn1Init_TimingTypeElements (TimingTypeElements* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  ReportingCriteriaType                                     */
/*                                                            */
/**************************************************************/

static const OSEnumItem ReportingCriteriaType_ENUMTAB[] = {
   { OSUTF8("never"), 0, 5, 0 },
   { OSUTF8("onCommence"), 1, 10, 1 },
   { OSUTF8("onComplete"), 2, 10, 2 },
   { OSUTF8("periodic"), 3, 8, 3 },
   { OSUTF8("statusChanged"), 4, 13, 4 }
} ;
#define ReportingCriteriaType_ENUMTABSIZE 5

const OSUTF8CHAR* ReportingCriteriaType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ReportingCriteriaType_ENUMTABSIZE) {
      return ReportingCriteriaType_ENUMTAB
         [ReportingCriteriaType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ReportingCriteriaType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ReportingCriteriaType* pvalue)
{
   OSUINT32 valueLen = rtxUTF8LenBytes (value);
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ReportingCriteriaType_ENUMTAB, ReportingCriteriaType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ReportingCriteriaType)
         ReportingCriteriaType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

/**************************************************************/
/*                                                            */
/*  ReportingCriteriaElementType                              */
/*                                                            */
/**************************************************************/

void asn1Init_ReportingCriteriaElementType (
   ReportingCriteriaElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  AgendaGoalElementType                                     */
/*                                                            */
/**************************************************************/

void asn1Init_AgendaGoalElementType (AgendaGoalElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   pvalue->nextOnFail = 0;
   pvalue->nextOnSucceed = 0;
   asn1Init_GoalElements (&pvalue->choice);
   asn1Init_AreaElementType (&pvalue->operatingArea);
   asn1Init_TimingTypeElements (&pvalue->choice_1);
   rtxDListFastInit (&pvalue->reportingCriteria_list);
}

/**************************************************************/
/*                                                            */
/*  AgendaGoalListType                                        */
/*                                                            */
/**************************************************************/

void asn1Init_AgendaGoalListType (AgendaGoalListType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   rtxDListFastInit (&pvalue->goal_list);
}

/**************************************************************/
/*                                                            */
/*  RouteElementType                                          */
/*                                                            */
/**************************************************************/

void asn1Init_RouteElementType (RouteElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_PointListElements (&pvalue->choice);
   asn1Init_VerticalBlockElements (&pvalue->choice_1);
}

/**************************************************************/
/*                                                            */
/*  AgendaConstraintListType                                  */
/*                                                            */
/**************************************************************/

void asn1Init_AgendaConstraintListType (AgendaConstraintListType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_RouteElementType (&pvalue->ingressRouting);
   rtxDListFastInit (&pvalue->avoidArea_list);
   asn1Init_RouteElementType (&pvalue->egressRouting);
}

/**************************************************************/
/*                                                            */
/*  AgendaMissionElementType                                  */
/*                                                            */
/**************************************************************/

void asn1Init_AgendaMissionElementType (AgendaMissionElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_AbsoluteHorizontalPositionElementType (&pvalue->launchPosition);
   asn1Init_AbsoluteHorizontalPositionElementType (&pvalue->recoveryPosition);
   asn1Init_AgendaGoalListType (&pvalue->goalList);
   asn1Init_AgendaConstraintListType (&pvalue->constraintList);
}

/**************************************************************/
/*                                                            */
/*  MissionSpecification                                      */
/*                                                            */
/**************************************************************/

void asn1Init_MissionSpecification (MissionSpecification* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  InformationRequestType                                    */
/*                                                            */
/**************************************************************/

static const OSEnumItem InformationRequestType_ENUMTAB[] = {
   { OSUTF8("contactSummary"), 0, 14, 0 },
   { OSUTF8("controlSettings"), 1, 15, 1 },
   { OSUTF8("ping"), 2, 4, 2 },
   { OSUTF8("posture"), 3, 7, 3 },
   { OSUTF8("sensorData"), 4, 10, 4 },
   { OSUTF8("vehicleCharacteristics"), 5, 22, 5 },
   { OSUTF8("vehicleTime"), 6, 11, 6 },
   { OSUTF8("velocity"), 7, 8, 7 },
   { OSUTF8("waypoint"), 8, 8, 8 }
} ;
#define InformationRequestType_ENUMTABSIZE 9

const OSUTF8CHAR* InformationRequestType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < InformationRequestType_ENUMTABSIZE) {
      return InformationRequestType_ENUMTAB
         [InformationRequestType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int InformationRequestType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, InformationRequestType* pvalue)
{
   OSUINT32 valueLen = rtxUTF8LenBytes (value);
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      InformationRequestType_ENUMTAB, InformationRequestType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (InformationRequestType)
         InformationRequestType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

/**************************************************************/
/*                                                            */
/*  InformationRequestElementType                             */
/*                                                            */
/**************************************************************/

void asn1Init_InformationRequestElementType (
   InformationRequestElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  VehicleGroupCompositionType                               */
/*                                                            */
/**************************************************************/

static const OSEnumItem VehicleGroupCompositionType_ENUMTAB[] = {
   { OSUTF8("announceGroup"), 0, 13, 0 },
   { OSUTF8("dissolveGroup"), 1, 13, 1 },
   { OSUTF8("finalizeGroupFormation"), 2, 22, 2 },
   { OSUTF8("initiateGroupFormation"), 3, 22, 3 },
   { OSUTF8("joinGroup"), 4, 9, 4 },
   { OSUTF8("leaveGroup"), 5, 10, 5 },
   { OSUTF8("locateGroup"), 6, 11, 6 }
} ;
#define VehicleGroupCompositionType_ENUMTABSIZE 7

const OSUTF8CHAR* VehicleGroupCompositionType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < VehicleGroupCompositionType_ENUMTABSIZE) {
      return VehicleGroupCompositionType_ENUMTAB
         [VehicleGroupCompositionType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int VehicleGroupCompositionType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, VehicleGroupCompositionType* pvalue)
{
   OSUINT32 valueLen = rtxUTF8LenBytes (value);
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      VehicleGroupCompositionType_ENUMTAB, 
      VehicleGroupCompositionType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (VehicleGroupCompositionType)
         VehicleGroupCompositionType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

/**************************************************************/
/*                                                            */
/*  VehicleGroupCompositionElementType                        */
/*                                                            */
/**************************************************************/

void asn1Init_VehicleGroupCompositionElementType (
   VehicleGroupCompositionElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  DimensionsElementType                                     */
/*                                                            */
/**************************************************************/

void asn1Init_DimensionsElementType (DimensionsElementType* pvalue)
{
   if (0 == pvalue) return;
}

/**************************************************************/
/*                                                            */
/*  UuvOperatingCharacteristicsElementType                    */
/*                                                            */
/**************************************************************/

void asn1Init_UuvOperatingCharacteristicsElementType (
   UuvOperatingCharacteristicsElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  DegreesOfControlElementType                               */
/*                                                            */
/**************************************************************/

void asn1Init_DegreesOfControlElementType (DegreesOfControlElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  UuvCapabilityType                                         */
/*                                                            */
/**************************************************************/

static const OSEnumItem UuvCapabilityType_ENUMTAB[] = {
   { OSUTF8("altitudeCapable"), 0, 15, 0 },
   { OSUTF8("bodyThrustersInstalled"), 1, 22, 1 },
   { OSUTF8("communicationsCapable"), 2, 21, 2 },
   { OSUTF8("gpsCapable"), 3, 10, 3 },
   { OSUTF8("hoverCapable"), 4, 12, 4 },
   { OSUTF8("satelliteCommunicationsCapable"), 5, 30, 5 },
   { OSUTF8("seaglider"), 6, 9, 6 },
   { OSUTF8("stationCapable"), 7, 14, 7 },
   { OSUTF8("thrusterPowered"), 8, 15, 8 },
   { OSUTF8("underwaterCommunicationsCapable"), 9, 31, 9 }
} ;
#define UuvCapabilityType_ENUMTABSIZE 10

const OSUTF8CHAR* UuvCapabilityType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < UuvCapabilityType_ENUMTABSIZE) {
      return UuvCapabilityType_ENUMTAB
         [UuvCapabilityType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int UuvCapabilityType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, UuvCapabilityType* pvalue)
{
   OSUINT32 valueLen = rtxUTF8LenBytes (value);
   OSINT32 idx = rtxLookupEnum (value, valueLen, UuvCapabilityType_ENUMTAB, 
      UuvCapabilityType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (UuvCapabilityType)UuvCapabilityType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

/**************************************************************/
/*                                                            */
/*  UuvCapabilityElementType                                  */
/*                                                            */
/**************************************************************/

void asn1Init_UuvCapabilityElementType (UuvCapabilityElementType* pvalue)
{
   if (0 == pvalue) return;
}

/**************************************************************/
/*                                                            */
/*  UuvCharacteristicsElementType                             */
/*                                                            */
/**************************************************************/

void asn1Init_UuvCharacteristicsElementType (
   UuvCharacteristicsElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_DimensionsElementType (&pvalue->dimensions);
   asn1Init_UuvOperatingCharacteristicsElementType (&pvalue->operatingCharacteristics);
   asn1Init_DegreesOfControlElementType (&pvalue->degreesOfControl);
   rtxDListFastInit (&pvalue->capability_list);
}

/**************************************************************/
/*                                                            */
/*  UgvOperatingCharacteristicsElementType                    */
/*                                                            */
/**************************************************************/

void asn1Init_UgvOperatingCharacteristicsElementType (
   UgvOperatingCharacteristicsElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  UgvCapabilityType                                         */
/*                                                            */
/**************************************************************/

static const OSEnumItem UgvCapabilityType_ENUMTAB[] = {
   { OSUTF8("communicationsCapable"), 0, 21, 0 },
   { OSUTF8("gpsCapable"), 1, 10, 1 },
   { OSUTF8("satelliteCommunicationsCapable"), 2, 30, 2 },
   { OSUTF8("tracked"), 3, 7, 3 }
} ;
#define UgvCapabilityType_ENUMTABSIZE 4

const OSUTF8CHAR* UgvCapabilityType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < UgvCapabilityType_ENUMTABSIZE) {
      return UgvCapabilityType_ENUMTAB
         [UgvCapabilityType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int UgvCapabilityType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, UgvCapabilityType* pvalue)
{
   OSUINT32 valueLen = rtxUTF8LenBytes (value);
   OSINT32 idx = rtxLookupEnum (value, valueLen, UgvCapabilityType_ENUMTAB, 
      UgvCapabilityType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (UgvCapabilityType)UgvCapabilityType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

/**************************************************************/
/*                                                            */
/*  UgvCapabilityElementType                                  */
/*                                                            */
/**************************************************************/

void asn1Init_UgvCapabilityElementType (UgvCapabilityElementType* pvalue)
{
   if (0 == pvalue) return;
}

/**************************************************************/
/*                                                            */
/*  UgvCharacteristicsElementType                             */
/*                                                            */
/**************************************************************/

void asn1Init_UgvCharacteristicsElementType (
   UgvCharacteristicsElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_DimensionsElementType (&pvalue->dimensions);
   asn1Init_UgvOperatingCharacteristicsElementType (&pvalue->operatingCharacteristics);
   asn1Init_DegreesOfControlElementType (&pvalue->degreesOfControl);
   rtxDListFastInit (&pvalue->capability_list);
}

/**************************************************************/
/*                                                            */
/*  UsvOperatingCharacteristicsElementType                    */
/*                                                            */
/**************************************************************/

void asn1Init_UsvOperatingCharacteristicsElementType (
   UsvOperatingCharacteristicsElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  UsvCapabilityType                                         */
/*                                                            */
/**************************************************************/

static const OSEnumItem UsvCapabilityType_ENUMTAB[] = {
   { OSUTF8("communicationsCapable"), 0, 21, 0 },
   { OSUTF8("gpsCapable"), 1, 10, 1 },
   { OSUTF8("satelliteCommunicationsCapable"), 2, 30, 2 },
   { OSUTF8("underwaterCommunicationsCapable"), 3, 31, 3 }
} ;
#define UsvCapabilityType_ENUMTABSIZE 4

const OSUTF8CHAR* UsvCapabilityType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < UsvCapabilityType_ENUMTABSIZE) {
      return UsvCapabilityType_ENUMTAB
         [UsvCapabilityType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int UsvCapabilityType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, UsvCapabilityType* pvalue)
{
   OSUINT32 valueLen = rtxUTF8LenBytes (value);
   OSINT32 idx = rtxLookupEnum (value, valueLen, UsvCapabilityType_ENUMTAB, 
      UsvCapabilityType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (UsvCapabilityType)UsvCapabilityType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

/**************************************************************/
/*                                                            */
/*  UsvCapabilityElementType                                  */
/*                                                            */
/**************************************************************/

void asn1Init_UsvCapabilityElementType (UsvCapabilityElementType* pvalue)
{
   if (0 == pvalue) return;
}

/**************************************************************/
/*                                                            */
/*  UsvCharacteristicsElementType                             */
/*                                                            */
/**************************************************************/

void asn1Init_UsvCharacteristicsElementType (
   UsvCharacteristicsElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_DimensionsElementType (&pvalue->dimensions);
   asn1Init_UsvOperatingCharacteristicsElementType (&pvalue->operatingCharacteristics);
   asn1Init_DegreesOfControlElementType (&pvalue->degreesOfControl);
   rtxDListFastInit (&pvalue->capability_list);
}

/**************************************************************/
/*                                                            */
/*  UavOperatingCharacteristicsElementType                    */
/*                                                            */
/**************************************************************/

void asn1Init_UavOperatingCharacteristicsElementType (
   UavOperatingCharacteristicsElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  UavCapabilityType                                         */
/*                                                            */
/**************************************************************/

static const OSEnumItem UavCapabilityType_ENUMTAB[] = {
   { OSUTF8("fixedWing"), 0, 9, 0 },
   { OSUTF8("gpsCapable"), 1, 10, 1 },
   { OSUTF8("multiEngine"), 2, 11, 2 },
   { OSUTF8("rotaryWing"), 3, 10, 3 },
   { OSUTF8("satelliteCommunicationsCapable"), 4, 30, 4 },
   { OSUTF8("singleEngine"), 5, 12, 5 }
} ;
#define UavCapabilityType_ENUMTABSIZE 6

const OSUTF8CHAR* UavCapabilityType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < UavCapabilityType_ENUMTABSIZE) {
      return UavCapabilityType_ENUMTAB
         [UavCapabilityType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int UavCapabilityType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, UavCapabilityType* pvalue)
{
   OSUINT32 valueLen = rtxUTF8LenBytes (value);
   OSINT32 idx = rtxLookupEnum (value, valueLen, UavCapabilityType_ENUMTAB, 
      UavCapabilityType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (UavCapabilityType)UavCapabilityType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

/**************************************************************/
/*                                                            */
/*  UavCapabilityElementType                                  */
/*                                                            */
/**************************************************************/

void asn1Init_UavCapabilityElementType (UavCapabilityElementType* pvalue)
{
   if (0 == pvalue) return;
}

/**************************************************************/
/*                                                            */
/*  UavCharacteristicsElementType                             */
/*                                                            */
/**************************************************************/

void asn1Init_UavCharacteristicsElementType (
   UavCharacteristicsElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_DimensionsElementType (&pvalue->dimensions);
   asn1Init_UavOperatingCharacteristicsElementType (&pvalue->operatingCharacteristics);
   asn1Init_DegreesOfControlElementType (&pvalue->degreesOfControl);
   rtxDListFastInit (&pvalue->capability_list);
}

/**************************************************************/
/*                                                            */
/*  VehicleCharacteristicsGroup                               */
/*                                                            */
/**************************************************************/

void asn1Init_VehicleCharacteristicsGroup (VehicleCharacteristicsGroup* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  UuvVerticalPositionElementType                            */
/*                                                            */
/**************************************************************/

void asn1Init_UuvVerticalPositionElementType (
   UuvVerticalPositionElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
}

/**************************************************************/
/*                                                            */
/*  OrientationType                                           */
/*                                                            */
/**************************************************************/

/**************************************************************/
/*                                                            */
/*  OrientationElementType                                    */
/*                                                            */
/**************************************************************/

void asn1Init_OrientationElementType (OrientationElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
}

/**************************************************************/
/*                                                            */
/*  WorldCoordinateVelocityElementType                        */
/*                                                            */
/**************************************************************/

void asn1Init_WorldCoordinateVelocityElementType (
   WorldCoordinateVelocityElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
}

/**************************************************************/
/*                                                            */
/*  BodyCoordinateVelocityElementType                         */
/*                                                            */
/**************************************************************/

void asn1Init_BodyCoordinateVelocityElementType (
   BodyCoordinateVelocityElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
}

/**************************************************************/
/*                                                            */
/*  DopplerVelocityElementType                                */
/*                                                            */
/**************************************************************/

void asn1Init_DopplerVelocityElementType (DopplerVelocityElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
}

/**************************************************************/
/*                                                            */
/*  UuvTelemetryElementType                                   */
/*                                                            */
/**************************************************************/

void asn1Init_UuvTelemetryElementType (UuvTelemetryElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   { OSUINT8 i;
   pvalue->_order.n = 7;
   for (i = 0; i < 7; i++) {
      pvalue->_order.elem[i] = i;
   }}
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_AbsoluteHorizontalPositionElementType (&pvalue->geographicPosition);
   asn1Init_UuvVerticalPositionElementType (&pvalue->verticalPosition);
   asn1Init_OrientationElementType (&pvalue->orientation);
   asn1Init_WorldCoordinateVelocityElementType (&pvalue->worldCoordinateVelocity);
   asn1Init_BodyCoordinateVelocityElementType (&pvalue->bodyCoordinateVelocity);
   asn1Init_DopplerVelocityElementType (&pvalue->dopplerVelocity);
   asn1Init_PercentElementType (&pvalue->remainingPower);
}

/**************************************************************/
/*                                                            */
/*  UsvTelemetryElementType                                   */
/*                                                            */
/**************************************************************/

void asn1Init_UsvTelemetryElementType (UsvTelemetryElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   { OSUINT8 i;
   pvalue->_order.n = 6;
   for (i = 0; i < 6; i++) {
      pvalue->_order.elem[i] = i;
   }}
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_AbsoluteHorizontalPositionElementType (&pvalue->geographicPosition);
   asn1Init_OrientationElementType (&pvalue->orientation);
   asn1Init_WorldCoordinateVelocityElementType (&pvalue->worldCoordinateVelocity);
   asn1Init_BodyCoordinateVelocityElementType (&pvalue->bodyCoordinateVelocity);
   asn1Init_DopplerVelocityElementType (&pvalue->dopplerVelocity);
   asn1Init_PercentElementType (&pvalue->remainingPower);
}

/**************************************************************/
/*                                                            */
/*  UgvVerticalPositionElementType                            */
/*                                                            */
/**************************************************************/

void asn1Init_UgvVerticalPositionElementType (
   UgvVerticalPositionElementType* pvalue)
{
   if (0 == pvalue) return;
}

/**************************************************************/
/*                                                            */
/*  UgvTelemetryElementType                                   */
/*                                                            */
/**************************************************************/

void asn1Init_UgvTelemetryElementType (UgvTelemetryElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   { OSUINT8 i;
   pvalue->_order.n = 7;
   for (i = 0; i < 7; i++) {
      pvalue->_order.elem[i] = i;
   }}
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_AbsoluteHorizontalPositionElementType (&pvalue->geographicPosition);
   asn1Init_UgvVerticalPositionElementType (&pvalue->altitude);
   asn1Init_OrientationElementType (&pvalue->orientation);
   asn1Init_WorldCoordinateVelocityElementType (&pvalue->worldCoordinateVelocity);
   asn1Init_BodyCoordinateVelocityElementType (&pvalue->bodyCoordinateVelocity);
   asn1Init_DopplerVelocityElementType (&pvalue->dopplerVelocity);
   asn1Init_PercentElementType (&pvalue->remainingPower);
}

/**************************************************************/
/*                                                            */
/*  UavVerticalPositionElementType                            */
/*                                                            */
/**************************************************************/

void asn1Init_UavVerticalPositionElementType (
   UavVerticalPositionElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
}

/**************************************************************/
/*                                                            */
/*  UavTelemetryElementType                                   */
/*                                                            */
/**************************************************************/

void asn1Init_UavTelemetryElementType (UavTelemetryElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   { OSUINT8 i;
   pvalue->_order.n = 7;
   for (i = 0; i < 7; i++) {
      pvalue->_order.elem[i] = i;
   }}
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_AbsoluteHorizontalPositionElementType (&pvalue->geographicPosition);
   asn1Init_UavVerticalPositionElementType (&pvalue->verticalPosition);
   asn1Init_OrientationElementType (&pvalue->orientation);
   asn1Init_WorldCoordinateVelocityElementType (&pvalue->worldCoordinateVelocity);
   asn1Init_BodyCoordinateVelocityElementType (&pvalue->bodyCoordinateVelocity);
   asn1Init_DopplerVelocityElementType (&pvalue->dopplerVelocity);
   asn1Init_PercentElementType (&pvalue->remainingPower);
}

/**************************************************************/
/*                                                            */
/*  DiscreteTimeResultsElementType_choice                     */
/*                                                            */
/**************************************************************/

void asn1Init_DiscreteTimeResultsElementType_choice (
   DiscreteTimeResultsElementType_choice* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  UuvPropellersOrderElementType                             */
/*                                                            */
/**************************************************************/

void asn1Init_UuvPropellersOrderElementType (
   UuvPropellersOrderElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
}

/**************************************************************/
/*                                                            */
/*  UuvPlanesOrderElementType                                 */
/*                                                            */
/**************************************************************/

void asn1Init_UuvPlanesOrderElementType (UuvPlanesOrderElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
}

/**************************************************************/
/*                                                            */
/*  UuvBodyThrustersOrderElementType                          */
/*                                                            */
/**************************************************************/

void asn1Init_UuvBodyThrustersOrderElementType (
   UuvBodyThrustersOrderElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
}

/**************************************************************/
/*                                                            */
/*  UuvControlOrdersElementType                               */
/*                                                            */
/**************************************************************/

void asn1Init_UuvControlOrdersElementType (UuvControlOrdersElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   { OSUINT8 i;
   pvalue->_order.n = 4;
   for (i = 0; i < 4; i++) {
      pvalue->_order.elem[i] = i;
   }}
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_UuvPropellersOrderElementType (&pvalue->propellers);
   asn1Init_ScalarElementType (&pvalue->rudder);
   asn1Init_UuvPlanesOrderElementType (&pvalue->planes);
   asn1Init_UuvBodyThrustersOrderElementType (&pvalue->bodyThrusters);
}

/**************************************************************/
/*                                                            */
/*  UsvPropellersOrderElementType                             */
/*                                                            */
/**************************************************************/

void asn1Init_UsvPropellersOrderElementType (
   UsvPropellersOrderElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
}

/**************************************************************/
/*                                                            */
/*  UsvControlOrdersElementType                               */
/*                                                            */
/**************************************************************/

void asn1Init_UsvControlOrdersElementType (UsvControlOrdersElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   { OSUINT8 i;
   pvalue->_order.n = 2;
   for (i = 0; i < 2; i++) {
      pvalue->_order.elem[i] = i;
   }}
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_UsvPropellersOrderElementType (&pvalue->propellers);
   asn1Init_SignedPercentElementType (&pvalue->rudder);
}

/**************************************************************/
/*                                                            */
/*  UgvControlOrdersElementType                               */
/*                                                            */
/**************************************************************/

void asn1Init_UgvControlOrdersElementType (UgvControlOrdersElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   { OSUINT8 i;
   pvalue->_order.n = 1;
   for (i = 0; i < 1; i++) {
      pvalue->_order.elem[i] = i;
   }}
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_NoValueElementType (&pvalue->placeHolder);
}

/**************************************************************/
/*                                                            */
/*  UavEnginesOrdersElementType                               */
/*                                                            */
/**************************************************************/

void asn1Init_UavEnginesOrdersElementType (UavEnginesOrdersElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
}

/**************************************************************/
/*                                                            */
/*  UavStabilatorOrderElementType                             */
/*                                                            */
/**************************************************************/

void asn1Init_UavStabilatorOrderElementType (
   UavStabilatorOrderElementType* pvalue)
{
   if (0 == pvalue) return;
}

/**************************************************************/
/*                                                            */
/*  FixedWingUAVControlOrders                                 */
/*                                                            */
/**************************************************************/

void asn1Init_FixedWingUAVControlOrders (FixedWingUAVControlOrders* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_UavEnginesOrdersElementType (&pvalue->engines);
   asn1Init_SignedPercentElementType (&pvalue->aileron);
   asn1Init_SignedPercentElementType (&pvalue->rudder);
   asn1Init_UavStabilatorOrderElementType (&pvalue->elevator);
}

/**************************************************************/
/*                                                            */
/*  UavCyclicOrderElementType                                 */
/*                                                            */
/**************************************************************/

void asn1Init_UavCyclicOrderElementType (UavCyclicOrderElementType* pvalue)
{
   if (0 == pvalue) return;
}

/**************************************************************/
/*                                                            */
/*  RotaryWingUAVControlOrders                                */
/*                                                            */
/**************************************************************/

void asn1Init_RotaryWingUAVControlOrders (RotaryWingUAVControlOrders* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_SignedPercentElementType (&pvalue->collective);
   asn1Init_UavCyclicOrderElementType (&pvalue->cyclic);
   asn1Init_SignedPercentElementType (&pvalue->pedals);
}

/**************************************************************/
/*                                                            */
/*  UavControlOrdersElementType_choice                        */
/*                                                            */
/**************************************************************/

void asn1Init_UavControlOrdersElementType_choice (
   UavControlOrdersElementType_choice* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  UavControlOrdersElementType                               */
/*                                                            */
/**************************************************************/

void asn1Init_UavControlOrdersElementType (UavControlOrdersElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_UavControlOrdersElementType_choice (&pvalue->choice);
}

/**************************************************************/
/*                                                            */
/*  DiscreteTimeResultsElementType_choice_1                   */
/*                                                            */
/**************************************************************/

void asn1Init_DiscreteTimeResultsElementType_choice_1 (
   DiscreteTimeResultsElementType_choice_1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  SensorElements_activeSonar                                */
/*                                                            */
/**************************************************************/

void asn1Init_SensorElements_activeSonar (SensorElements_activeSonar* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   pvalue->model = 0;
}

/**************************************************************/
/*                                                            */
/*  SensorElements_imagingSonar                               */
/*                                                            */
/**************************************************************/

void asn1Init_SensorElements_imagingSonar (SensorElements_imagingSonar* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   pvalue->model = 0;
}

/**************************************************************/
/*                                                            */
/*  SensorElements_blazedArraySonar                           */
/*                                                            */
/**************************************************************/

void asn1Init_SensorElements_blazedArraySonar (
   SensorElements_blazedArraySonar* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   pvalue->model = 0;
}

/**************************************************************/
/*                                                            */
/*  SensorElements_syntheticApertureSonar                     */
/*                                                            */
/**************************************************************/

void asn1Init_SensorElements_syntheticApertureSonar (
   SensorElements_syntheticApertureSonar* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   pvalue->model = 0;
}

/**************************************************************/
/*                                                            */
/*  SensorElements_passiveSonar                               */
/*                                                            */
/**************************************************************/

void asn1Init_SensorElements_passiveSonar (SensorElements_passiveSonar* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   pvalue->model = 0;
}

/**************************************************************/
/*                                                            */
/*  SensorElements_radar                                      */
/*                                                            */
/**************************************************************/

void asn1Init_SensorElements_radar (SensorElements_radar* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   pvalue->model = 0;
}

/**************************************************************/
/*                                                            */
/*  SensorElements_dopplerRadar                               */
/*                                                            */
/**************************************************************/

void asn1Init_SensorElements_dopplerRadar (SensorElements_dopplerRadar* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   pvalue->model = 0;
}

/**************************************************************/
/*                                                            */
/*  SensorElements_syntheticApertureRadar                     */
/*                                                            */
/**************************************************************/

void asn1Init_SensorElements_syntheticApertureRadar (
   SensorElements_syntheticApertureRadar* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   pvalue->model = 0;
}

/**************************************************************/
/*                                                            */
/*  SensorElements_trackWhileScanRadar_track                  */
/*                                                            */
/**************************************************************/

void asn1Init_SensorElements_trackWhileScanRadar_track (
   SensorElements_trackWhileScanRadar_track* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->trackID = 0;
}

/**************************************************************/
/*                                                            */
/*  SensorElements_trackWhileScanRadar                        */
/*                                                            */
/**************************************************************/

void asn1Init_SensorElements_trackWhileScanRadar (
   SensorElements_trackWhileScanRadar* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   pvalue->model = 0;
   rtxDListFastInit (&pvalue->track_list);
}

/**************************************************************/
/*                                                            */
/*  SensorElements_earlyWarningRadar                          */
/*                                                            */
/**************************************************************/

void asn1Init_SensorElements_earlyWarningRadar (
   SensorElements_earlyWarningRadar* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   pvalue->model = 0;
}

/**************************************************************/
/*                                                            */
/*  SensorElements_acquisitionRadar                           */
/*                                                            */
/**************************************************************/

void asn1Init_SensorElements_acquisitionRadar (
   SensorElements_acquisitionRadar* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   pvalue->model = 0;
}

/**************************************************************/
/*                                                            */
/*  SensorElements_trackingRadar                              */
/*                                                            */
/**************************************************************/

void asn1Init_SensorElements_trackingRadar (
   SensorElements_trackingRadar* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   pvalue->model = 0;
}

/**************************************************************/
/*                                                            */
/*  SensorElements_fireControlRadar                           */
/*                                                            */
/**************************************************************/

void asn1Init_SensorElements_fireControlRadar (
   SensorElements_fireControlRadar* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   pvalue->model = 0;
}

/**************************************************************/
/*                                                            */
/*  SensorElements_surfaceSearchRadar                         */
/*                                                            */
/**************************************************************/

void asn1Init_SensorElements_surfaceSearchRadar (
   SensorElements_surfaceSearchRadar* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   pvalue->model = 0;
}

/**************************************************************/
/*                                                            */
/*  SensorElements_eSM                                        */
/*                                                            */
/**************************************************************/

void asn1Init_SensorElements_eSM (SensorElements_eSM* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   pvalue->model = 0;
}

/**************************************************************/
/*                                                            */
/*  SensorElements_passiveSoundDetection                      */
/*                                                            */
/**************************************************************/

void asn1Init_SensorElements_passiveSoundDetection (
   SensorElements_passiveSoundDetection* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   pvalue->model = 0;
}

/**************************************************************/
/*                                                            */
/*  SensorElements_chemicalBiologicalRadiologicalDetection    */
/*                                                            */
/**************************************************************/

void asn1Init_SensorElements_chemicalBiologicalRadiologicalDetection (
   SensorElements_chemicalBiologicalRadiologicalDetection* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   pvalue->model = 0;
   pvalue->substance = 0;
}

/**************************************************************/
/*                                                            */
/*  SensorElements_video                                      */
/*                                                            */
/**************************************************************/

void asn1Init_SensorElements_video (SensorElements_video* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   pvalue->model = 0;
}

/**************************************************************/
/*                                                            */
/*  SensorElements_fLIR                                       */
/*                                                            */
/**************************************************************/

void asn1Init_SensorElements_fLIR (SensorElements_fLIR* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   pvalue->model = 0;
}

/**************************************************************/
/*                                                            */
/*  SensorElements_motionSensor                               */
/*                                                            */
/**************************************************************/

void asn1Init_SensorElements_motionSensor (SensorElements_motionSensor* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   pvalue->model = 0;
}

/**************************************************************/
/*                                                            */
/*  SensorElements                                            */
/*                                                            */
/**************************************************************/

void asn1Init_SensorElements (SensorElements* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  SensorElementType                                         */
/*                                                            */
/**************************************************************/

void asn1Init_SensorElementType (SensorElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   rtxDListFastInit (&pvalue->choice_list);
}

/**************************************************************/
/*                                                            */
/*  WeaponElementType                                         */
/*                                                            */
/**************************************************************/

void asn1Init_WeaponElementType (WeaponElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  DiscreteTimeResultsElementType                            */
/*                                                            */
/**************************************************************/

void asn1Init_DiscreteTimeResultsElementType (
   DiscreteTimeResultsElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_DiscreteTimeResultsElementType_choice (&pvalue->choice);
   asn1Init_DiscreteTimeResultsElementType_choice_1 (&pvalue->choice_1);
   asn1Init_SensorElementType (&pvalue->sensor);
   asn1Init_WeaponElementType (&pvalue->weapon);
}

/**************************************************************/
/*                                                            */
/*  UuvLoggableEventType_element                              */
/*                                                            */
/**************************************************************/

void asn1Init_UuvLoggableEventType_element (
   UuvLoggableEventType_element* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  UuvLoggableEventType                                      */
/*                                                            */
/**************************************************************/

void asn1Init_UuvLoggableEventType (UuvLoggableEventType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   rtxDListFastInit (&pvalue->choice_list);
}

/**************************************************************/
/*                                                            */
/*  UgvLoggableEventType_element                              */
/*                                                            */
/**************************************************************/

void asn1Init_UgvLoggableEventType_element (
   UgvLoggableEventType_element* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  UgvLoggableEventType                                      */
/*                                                            */
/**************************************************************/

void asn1Init_UgvLoggableEventType (UgvLoggableEventType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   rtxDListFastInit (&pvalue->choice_list);
}

/**************************************************************/
/*                                                            */
/*  UsvLoggableEventType_element                              */
/*                                                            */
/**************************************************************/

void asn1Init_UsvLoggableEventType_element (
   UsvLoggableEventType_element* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  UsvLoggableEventType                                      */
/*                                                            */
/**************************************************************/

void asn1Init_UsvLoggableEventType (UsvLoggableEventType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   rtxDListFastInit (&pvalue->choice_list);
}

/**************************************************************/
/*                                                            */
/*  UavLoggableEventType_element                              */
/*                                                            */
/**************************************************************/

void asn1Init_UavLoggableEventType_element (
   UavLoggableEventType_element* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  UavLoggableEventType                                      */
/*                                                            */
/**************************************************************/

void asn1Init_UavLoggableEventType (UavLoggableEventType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   rtxDListFastInit (&pvalue->choice_list);
}

/**************************************************************/
/*                                                            */
/*  LoggableEvent                                             */
/*                                                            */
/**************************************************************/

void asn1Init_LoggableEvent (LoggableEvent* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  MessageBodyContent_sensorDataReport                       */
/*                                                            */
/**************************************************************/

void asn1Init_MessageBodyContent_sensorDataReport (
   MessageBodyContent_sensorDataReport* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  MessageBodyContent                                        */
/*                                                            */
/**************************************************************/

void asn1Init_MessageBodyContent (MessageBodyContent* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  AvclMessageBodyType                                       */
/*                                                            */
/**************************************************************/

void asn1Init_AvclMessageBodyType (AvclMessageBodyType* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_MessageBodyContent (pvalue);
}

/**************************************************************/
/*                                                            */
/*  AvclMessageType                                           */
/*                                                            */
/**************************************************************/

void asn1Init_AvclMessageType (AvclMessageType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   pvalue->version = 0;
   asn1Init_AvclMessageHeadType (&pvalue->head);
   asn1Init_AvclMessageBodyType (&pvalue->body);
}

/**************************************************************/
/*                                                            */
/*  AVCLMessage                                               */
/*                                                            */
/**************************************************************/

void asn1Init_AVCLMessage (AVCLMessage* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_AvclMessageType (pvalue);
}

/**************************************************************/
/*                                                            */
/*  CalendarDaysType                                          */
/*                                                            */
/**************************************************************/

/**************************************************************/
/*                                                            */
/*  MonthsType                                                */
/*                                                            */
/**************************************************************/

static const OSEnumItem MonthsType_ENUMTAB[] = {
   { OSUTF8("April"), 0, 5, 0 },
   { OSUTF8("August"), 1, 6, 1 },
   { OSUTF8("December"), 2, 8, 2 },
   { OSUTF8("February"), 3, 8, 3 },
   { OSUTF8("January"), 4, 7, 4 },
   { OSUTF8("July"), 5, 4, 5 },
   { OSUTF8("June"), 6, 4, 6 },
   { OSUTF8("March"), 7, 5, 7 },
   { OSUTF8("May"), 8, 3, 8 },
   { OSUTF8("November"), 9, 8, 9 },
   { OSUTF8("October"), 10, 7, 10 },
   { OSUTF8("September"), 11, 9, 11 }
} ;
#define MonthsType_ENUMTABSIZE 12

const OSUTF8CHAR* MonthsType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < MonthsType_ENUMTABSIZE) {
      return MonthsType_ENUMTAB[MonthsType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int MonthsType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, MonthsType* pvalue)
{
   OSUINT32 valueLen = rtxUTF8LenBytes (value);
   OSINT32 idx = rtxLookupEnum (value, valueLen, MonthsType_ENUMTAB, 
      MonthsType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (MonthsType)MonthsType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

/**************************************************************/
/*                                                            */
/*  ClockHoursType                                            */
/*                                                            */
/**************************************************************/

/**************************************************************/
/*                                                            */
/*  ClockMinutesOrSecondsType                                 */
/*                                                            */
/**************************************************************/

/**************************************************************/
/*                                                            */
/*  TimeZoneType                                              */
/*                                                            */
/**************************************************************/

/**************************************************************/
/*                                                            */
/*  NonNegativeIntType                                        */
/*                                                            */
/**************************************************************/

/**************************************************************/
/*                                                            */
/*  AvclHeadType                                              */
/*                                                            */
/**************************************************************/

void asn1Init_AvclHeadType (AvclHeadType* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

/**************************************************************/
/*                                                            */
/*  UnitsOfMeasureElementType                                 */
/*                                                            */
/**************************************************************/

void asn1Init_UnitsOfMeasureElementType (UnitsOfMeasureElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->angle = 0;
   pvalue->description = 0;
   pvalue->distance = 0;
   pvalue->id = 0;
   pvalue->mass = 0;
   pvalue->time_ = 0;
}

/**************************************************************/
/*                                                            */
/*  ConfigurationElementType_choice                           */
/*                                                            */
/**************************************************************/

void asn1Init_ConfigurationElementType_choice (
   ConfigurationElementType_choice* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  ConfigurationElementType                                  */
/*                                                            */
/**************************************************************/

void asn1Init_ConfigurationElementType (ConfigurationElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_ConfigurationElementType_choice (&pvalue->choice);
}

/**************************************************************/
/*                                                            */
/*  MissionPreparationElementType                             */
/*                                                            */
/**************************************************************/

void asn1Init_MissionPreparationElementType (
   MissionPreparationElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_UnitsOfMeasureElementType (&pvalue->unitsOfMeasure);
   asn1Init_GeoOriginElementType (&pvalue->geoOrigin);
   asn1Init_ConfigurationElementType (&pvalue->configuration);
   asn1Init_MissionSpecification (&pvalue->choice);
}

/**************************************************************/
/*                                                            */
/*  EventLogElementType                                       */
/*                                                            */
/**************************************************************/

void asn1Init_EventLogElementType (EventLogElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   rtxDListFastInit (&pvalue->choice_list);
}

/**************************************************************/
/*                                                            */
/*  DateTimeGroupElementType                                  */
/*                                                            */
/**************************************************************/

void asn1Init_DateTimeGroupElementType (DateTimeGroupElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
}

/**************************************************************/
/*                                                            */
/*  MissionResultsElementType_element                         */
/*                                                            */
/**************************************************************/

void asn1Init_MissionResultsElementType_element (
   MissionResultsElementType_element* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

/**************************************************************/
/*                                                            */
/*  MissionResultsElementType                                 */
/*                                                            */
/**************************************************************/

void asn1Init_MissionResultsElementType (MissionResultsElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   asn1Init_DateTimeGroupElementType (&pvalue->missionStartTime);
   rtxDListFastInit (&pvalue->choice_list);
}

/**************************************************************/
/*                                                            */
/*  AvclBodyType                                              */
/*                                                            */
/**************************************************************/

void asn1Init_AvclBodyType (AvclBodyType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   { OSUINT8 i;
   pvalue->_order.n = 3;
   for (i = 0; i < 3; i++) {
      pvalue->_order.elem[i] = i;
   }}
   asn1Init_MissionPreparationElementType (&pvalue->missionPreparation);
   asn1Init_EventLogElementType (&pvalue->eventLog);
   asn1Init_MissionResultsElementType (&pvalue->missionResults);
}

/**************************************************************/
/*                                                            */
/*  AVCL                                                      */
/*                                                            */
/**************************************************************/

EXTERN const char* gs_AVCL_AVCL_date_CharSet =
"+-.0123456789:TZ";

void asn1Init_AVCL (AVCL* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->date = 0;
   pvalue->description = 0;
   pvalue->id = 0;
   pvalue->vehicleType = 0;
   asn1Init_AvclHeadType (&pvalue->head);
   asn1Init_AvclBodyType (&pvalue->body);
}

/**************************************************************/
/*                                                            */
/*  AvclMessageListBodyType                                   */
/*                                                            */
/**************************************************************/

void asn1Init_AvclMessageListBodyType (AvclMessageListBodyType* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

/**************************************************************/
/*                                                            */
/*  AVCLMessageList                                           */
/*                                                            */
/**************************************************************/

EXTERN const char* gs_AVCL_AVCLMessageList_date_CharSet =
"+-.0123456789:TZ";

void asn1Init_AVCLMessageList (AVCLMessageList* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->date = 0;
   pvalue->description = 0;
   pvalue->id = 0;
   pvalue->vehicleType = 0;
   asn1Init_AvclHeadType (&pvalue->head);
   asn1Init_AvclMessageListBodyType (&pvalue->body);
}

/**************************************************************/
/*                                                            */
/*  NonNegativeScalarElementType                              */
/*                                                            */
/**************************************************************/

void asn1Init_NonNegativeScalarElementType (
   NonNegativeScalarElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  IntegerElementType                                        */
/*                                                            */
/**************************************************************/

void asn1Init_IntegerElementType (IntegerElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
}

/**************************************************************/
/*                                                            */
/*  TokenElementType                                          */
/*                                                            */
/**************************************************************/

void asn1Init_TokenElementType (TokenElementType* pvalue)
{
   if (0 == pvalue) return;
   memset (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->description = 0;
   pvalue->id = 0;
   pvalue->value = 0;
}

/**************************************************************/
/*                                                            */
/*  TelemetryElement                                          */
/*                                                            */
/**************************************************************/

void asn1Init_TelemetryElement (TelemetryElement* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   memset (&pvalue->u, 0, sizeof(pvalue->u));
}

