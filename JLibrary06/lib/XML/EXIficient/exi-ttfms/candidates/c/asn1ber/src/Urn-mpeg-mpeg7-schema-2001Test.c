/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 18-Oct-2006.
 */
#include "Urn-mpeg-mpeg7-schema-2001.h"
#include "Urn-tva-metadata-2005.h"
#include "libxml/parser.h"
#include "rtxmlsrc/osrtxml.h"
#include "rtxsrc/rtxCommon.h"

int DOMTest_InlineMediaType_choice (OSCTXT* pctxt, 
   InlineMediaType_choice* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MediaData16"))) {
            pvalue->t = 1;
            pvalue->u.mediaData16 = rtxMemAllocType (pctxt, ASN1DynOctStr);

            if (pvalue->u.mediaData16 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            pvalue->u.mediaData16->numocts = 0;
            pvalue->u.mediaData16->data = 0;
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecDynHexStr (pctxt, pvalue->u.mediaData16);
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MediaData64"))) {
            pvalue->t = 2;
            pvalue->u.mediaData64 = rtxMemAllocType (pctxt, ASN1DynOctStr);

            if (pvalue->u.mediaData64 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            pvalue->u.mediaData64->numocts = 0;
            pvalue->u.mediaData64->data = 0;
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecDynBase64Str (pctxt, pvalue->u.mediaData64);
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_InlineMediaType (OSCTXT* pctxt, InlineMediaType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->type = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->type = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MediaData16")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MediaData64"))) {
            DOMTest_InlineMediaType_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_MediaLocatorType_choice (OSCTXT* pctxt, 
   MediaLocatorType_choice* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MediaUri"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               pvalue->u.mediaUri = pXmlNode->children->content;
            }
            else {
               pvalue->u.mediaUri = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("InlineMedia"))) {
            pvalue->t = 2;
            pvalue->u.inlineMedia = rtxMemAllocType (pctxt, InlineMediaType);

            if (pvalue->u.inlineMedia == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InlineMediaType (pvalue->u.inlineMedia);
            DOMTest_InlineMediaType (pctxt, pvalue->u.inlineMedia, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_MediaLocatorType (OSCTXT* pctxt, MediaLocatorType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MediaUri")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("InlineMedia"))) {
            pvalue->m.choicePresent = 1;
            DOMTest_MediaLocatorType_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("StreamID"))) {
            pvalue->m.streamIDPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->streamID = atoi ((const char*)pXmlNode->children->content);
            }
         }
      }
   }

   return 0;
}

int DOMTest_MediaRelTimePointType (OSCTXT* pctxt, 
   MediaRelTimePointType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mediaTimeBase"))) {
            pvalue->m.mediaTimeBasePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mediaTimeBase = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->mediaTimeBase = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_MediaRelIncrTimePointType (OSCTXT* pctxt, 
   MediaRelIncrTimePointType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mediaTimeBase"))) {
            pvalue->m.mediaTimeBasePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mediaTimeBase = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->mediaTimeBase = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mediaTimeUnit"))) {
            pvalue->m.mediaTimeUnitPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mediaTimeUnit = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->mediaTimeUnit = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = atoi ((const char*)pXmlNode->children->content);
   }

   return 0;
}

int DOMTest_ImageLocatorType_choice (OSCTXT* pctxt, 
   ImageLocatorType_choice* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MediaUri"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               pvalue->u.mediaUri = pXmlNode->children->content;
            }
            else {
               pvalue->u.mediaUri = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("InlineMedia"))) {
            pvalue->t = 2;
            pvalue->u.inlineMedia = rtxMemAllocType (pctxt, InlineMediaType);

            if (pvalue->u.inlineMedia == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InlineMediaType (pvalue->u.inlineMedia);
            DOMTest_InlineMediaType (pctxt, pvalue->u.inlineMedia, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_ImageLocatorType (OSCTXT* pctxt, ImageLocatorType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MediaUri")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("InlineMedia"))) {
            pvalue->m.choicePresent = 1;
            DOMTest_ImageLocatorType_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("StreamID"))) {
            pvalue->m.streamIDPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->streamID = atoi ((const char*)pXmlNode->children->content);
            }
         }
      }
   }

   return 0;
}

int DOMTest_MediaIncrDurationType (OSCTXT* pctxt, 
   MediaIncrDurationType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mediaTimeUnit"))) {
            pvalue->m.mediaTimeUnitPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mediaTimeUnit = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->mediaTimeUnit = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = atoi ((const char*)pXmlNode->children->content);
   }

   return 0;
}

int DOMTest_MediaTimeType_choice (OSCTXT* pctxt, MediaTimeType_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MediaTimePoint"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               pvalue->u.mediaTimePoint = pXmlNode->children->content;
            }
            else {
               pvalue->u.mediaTimePoint = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MediaRelTimePoint"))) {
            pvalue->t = 2;
            pvalue->u.mediaRelTimePoint
                = rtxMemAllocType (pctxt, MediaRelTimePointType);

            if (pvalue->u.mediaRelTimePoint == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MediaRelTimePointType (pvalue->u.mediaRelTimePoint);
            DOMTest_MediaRelTimePointType (pctxt, pvalue->u.mediaRelTimePoint, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MediaRelIncrTimePoint"))) {
            pvalue->t = 3;
            pvalue->u.mediaRelIncrTimePoint
                = rtxMemAllocType (pctxt, MediaRelIncrTimePointType);

            if (pvalue->u.mediaRelIncrTimePoint == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MediaRelIncrTimePointType (pvalue->u.mediaRelIncrTimePoint);
            DOMTest_MediaRelIncrTimePointType (pctxt, pvalue->u.mediaRelIncrTimePoint, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_MediaTimeType_choice_1 (OSCTXT* pctxt, 
   MediaTimeType_choice_1* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MediaDuration"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               pvalue->u.mediaDuration = pXmlNode->children->content;
            }
            else {
               pvalue->u.mediaDuration = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MediaIncrDuration"))) {
            pvalue->t = 2;
            pvalue->u.mediaIncrDuration
                = rtxMemAllocType (pctxt, MediaIncrDurationType);

            if (pvalue->u.mediaIncrDuration == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MediaIncrDurationType (pvalue->u.mediaIncrDuration);
            DOMTest_MediaIncrDurationType (pctxt, pvalue->u.mediaIncrDuration, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_MediaTimeType (OSCTXT* pctxt, MediaTimeType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MediaTimePoint")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MediaRelTimePoint")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MediaRelIncrTimePoint"))) {
            DOMTest_MediaTimeType_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MediaDuration")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MediaIncrDuration"))) {
            pvalue->m.choice_1Present = 1;
            DOMTest_MediaTimeType_choice_1 (pctxt, &pvalue->choice_1, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_TemporalSegmentLocatorType_choice (OSCTXT* pctxt, 
   TemporalSegmentLocatorType_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MediaUri"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               pvalue->u.mediaUri = pXmlNode->children->content;
            }
            else {
               pvalue->u.mediaUri = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("InlineMedia"))) {
            pvalue->t = 2;
            pvalue->u.inlineMedia = rtxMemAllocType (pctxt, InlineMediaType);

            if (pvalue->u.inlineMedia == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InlineMediaType (pvalue->u.inlineMedia);
            DOMTest_InlineMediaType (pctxt, pvalue->u.inlineMedia, pXmlNode, TRUE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_TemporalSegmentLocatorType (OSCTXT* pctxt, 
   TemporalSegmentLocatorType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MediaUri")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("InlineMedia"))) {
            pvalue->m.choicePresent = 1;
            DOMTest_TemporalSegmentLocatorType_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("StreamID"))) {
            pvalue->m.streamIDPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->streamID = atoi ((const char*)pXmlNode->children->content);
            }
         }
      }
   }

   return 0;
}

int DOMTest_TitleMediaType (OSCTXT* pctxt, TitleMediaType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TitleImage"))) {
            pvalue->m.titleImagePresent = 1;
            DOMTest_ImageLocatorType (pctxt, &pvalue->titleImage, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TitleVideo"))) {
            pvalue->m.titleVideoPresent = 1;
            DOMTest_TemporalSegmentLocatorType (pctxt, &pvalue->titleVideo, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TitleAudio"))) {
            pvalue->m.titleAudioPresent = 1;
            DOMTest_TemporalSegmentLocatorType (pctxt, &pvalue->titleAudio, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_TermReferenceType (OSCTXT* pctxt, TermReferenceType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   pvalue->t = 1;
   if (0 != pXmlNode->children) {
      pvalue->u.alt = pXmlNode->children->content;
   }
   else {
      pvalue->u.alt = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_TextualBaseType (OSCTXT* pctxt, TextualBaseType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("lang"))) {
            pvalue->m.langPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->lang = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->lang = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("phoneticAlphabet"))) {
            pvalue->m.phoneticAlphabetPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               PhoneticAlphabetType_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->phoneticAlphabet);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("phoneticTranscription"))) {
            pvalue->m.phoneticTranscriptionPresent = 1;
            {
            const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            else {
               pdata2 = (const OSUTF8CHAR*)"";
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->phoneticTranscription, (void*)pdata2);
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_NameComponentType (OSCTXT* pctxt, NameComponentType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("abbrev"))) {
            pvalue->m.abbrevPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->abbrev = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->abbrev = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("initial"))) {
            pvalue->m.initialPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->initial = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->initial = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("lang"))) {
            pvalue->m.langPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->lang = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->lang = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("phoneticAlphabet"))) {
            pvalue->m.phoneticAlphabetPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               PhoneticAlphabetType_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->phoneticAlphabet);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("phoneticTranscription"))) {
            pvalue->m.phoneticTranscriptionPresent = 1;
            {
            const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            else {
               pdata2 = (const OSUTF8CHAR*)"";
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->phoneticTranscription, (void*)pdata2);
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_PersonNameType_element (OSCTXT* pctxt, 
   PersonNameType_element* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("GivenName"))) {
            pvalue->t = 1;
            pvalue->u.givenName = rtxMemAllocType (pctxt, NameComponentType);

            if (pvalue->u.givenName == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_NameComponentType (pvalue->u.givenName);
            DOMTest_NameComponentType (pctxt, pvalue->u.givenName, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("FamilyName"))) {
            pvalue->t = 2;
            pvalue->u.familyName_list = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.familyName_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.familyName_list);
            {
            NameComponentType* pdata2;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("FamilyName"))) {
                     pdata2 = rtxMemAllocType (pctxt, NameComponentType);

                     if (pdata2 == NULL)
                        return LOG_RTERR (pctxt, RTERR_NOMEM);

                     asn1Init_NameComponentType (pdata2);
                     DOMTest_NameComponentType (pctxt, pdata2, pXmlNode, TRUE);
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, pvalue->u.familyName_list, (void*)pdata2);
                  }
               }
            }
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Title"))) {
            pvalue->t = 3;
            pvalue->u.title_list = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.title_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.title_list);
            {
            NameComponentType* pdata2;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Title"))) {
                     pdata2 = rtxMemAllocType (pctxt, NameComponentType);

                     if (pdata2 == NULL)
                        return LOG_RTERR (pctxt, RTERR_NOMEM);

                     asn1Init_NameComponentType (pdata2);
                     DOMTest_NameComponentType (pctxt, pdata2, pXmlNode, TRUE);
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, pvalue->u.title_list, (void*)pdata2);
                  }
               }
            }
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Numeration"))) {
            pvalue->t = 4;
            pvalue->u.numeration_list = rtxMemAllocZ (pctxt, sizeof(OSUINT32)+
               (sizeof(const OSUTF8CHAR*)*1));

            if (pvalue->u.numeration_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            pvalue->u.numeration_list->n = 0;
            {
            OSRTDList tmplist;
            const OSUTF8CHAR* pdata2 = 0;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Numeration"))) {
                     if (0 != pXmlNode->children) {
                        pdata2 = pXmlNode->children->content;
                     }
                     else {
                        pdata2 = (const OSUTF8CHAR*)"";
                     }
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, &tmplist, (void*)pdata2);
                  }
               }
            }

            /* Convert list to array */
            { OSUINT32 i = 0;
            OSRTDListNode* pnode = tmplist.head;

            if (tmplist.count > 1) return LOG_RTERR (pctxt, RTERR_SEQOVFLW);

            pvalue->u.numeration_list->n = tmplist.count;
            while (0 != pnode) {
               pdata2 = (const OSUTF8CHAR*)pnode->data;
               pvalue->u.numeration_list->elem[i++] = pdata2;
               pnode = pnode->next;
            }}
            rtxDListFreeNodes (pctxt, &tmplist);
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_PersonNameType (OSCTXT* pctxt, PersonNameType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("dateFrom"))) {
            pvalue->m.dateFromPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->dateFrom = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->dateFrom = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("dateTo"))) {
            pvalue->m.dateToPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->dateTo = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->dateTo = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("lang"))) {
            pvalue->m.langPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->lang = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->lang = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            pvalue->m.typePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               PersonNameType_type_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->type);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("GivenName")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("FamilyName")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Title")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Numeration"))) {
            pvalue->m.choice_listPresent = 1;
            { PersonNameType_element* pdata2;
            pdata2 = rtxMemAllocType (pctxt, PersonNameType_element);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PersonNameType_element (pdata2);
            DOMTest_PersonNameType_element (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_TextualType (OSCTXT* pctxt, TextualType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("lang"))) {
            pvalue->m.langPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->lang = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->lang = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("phoneticAlphabet"))) {
            pvalue->m.phoneticAlphabetPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               PhoneticAlphabetType_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->phoneticAlphabet);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("phoneticTranscription"))) {
            pvalue->m.phoneticTranscriptionPresent = 1;
            {
            const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            else {
               pdata2 = (const OSUTF8CHAR*)"";
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->phoneticTranscription, (void*)pdata2);
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_InlineTermDefinitionType_name (OSCTXT* pctxt, 
   InlineTermDefinitionType_name* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("lang"))) {
            pvalue->m.langPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->lang = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->lang = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("phoneticAlphabet"))) {
            pvalue->m.phoneticAlphabetPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               PhoneticAlphabetType_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->phoneticAlphabet);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("phoneticTranscription"))) {
            pvalue->m.phoneticTranscriptionPresent = 1;
            {
            const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            else {
               pdata2 = (const OSUTF8CHAR*)"";
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->phoneticTranscription, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("preferred"))) {
            pvalue->m.preferredPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->preferred);
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_InlineTermDefinitionType (OSCTXT* pctxt, 
   InlineTermDefinitionType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Name"))) {
            { InlineTermDefinitionType_name* pdata2;
            pdata2 = rtxMemAllocType (pctxt, InlineTermDefinitionType_name);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InlineTermDefinitionType_name (pdata2);
            DOMTest_InlineTermDefinitionType_name (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->name_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Definition"))) {
            { TextualType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TextualType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TextualType (pdata2);
            DOMTest_TextualType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->definition_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_ControlledTermUseType_name (OSCTXT* pctxt, 
   ControlledTermUseType_name* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("lang"))) {
            pvalue->m.langPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->lang = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->lang = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("phoneticAlphabet"))) {
            pvalue->m.phoneticAlphabetPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               PhoneticAlphabetType_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->phoneticAlphabet);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("phoneticTranscription"))) {
            pvalue->m.phoneticTranscriptionPresent = 1;
            {
            const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            else {
               pdata2 = (const OSUTF8CHAR*)"";
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->phoneticTranscription, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("preferred"))) {
            pvalue->m.preferredPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->preferred);
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_ControlledTermUseType (OSCTXT* pctxt, 
   ControlledTermUseType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            DOMTest_TermReferenceType (pctxt, &pvalue->href, ((xmlNodePtr)pXmlAttr), FALSE);
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Name"))) {
            { ControlledTermUseType_name* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ControlledTermUseType_name);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ControlledTermUseType_name (pdata2);
            DOMTest_ControlledTermUseType_name (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->name_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Definition"))) {
            { TextualType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TextualType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TextualType (pdata2);
            DOMTest_TextualType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->definition_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_ParentalGuidanceType_choice (OSCTXT* pctxt, 
   ParentalGuidanceType_choice* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ParentalRating"))) {
            pvalue->t = 1;
            pvalue->u.parentalRating
                = rtxMemAllocType (pctxt, ControlledTermUseType);

            if (pvalue->u.parentalRating == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ControlledTermUseType (pvalue->u.parentalRating);
            DOMTest_ControlledTermUseType (pctxt, pvalue->u.parentalRating, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MinimumAge"))) {
            pvalue->t = 2;
            if (0 != pXmlNode->children) {
               pvalue->u.minimumAge = atoi ((const char*)pXmlNode->children->content);
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_ParentalGuidanceType (OSCTXT* pctxt, ParentalGuidanceType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ParentalRating")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MinimumAge"))) {
            DOMTest_ParentalGuidanceType_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Region"))) {
            { RegionCode pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            else {
               pdata2 = (const OSUTF8CHAR*)"";
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->region_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_MPEG7_ReferenceType (OSCTXT* pctxt, MPEG7_ReferenceType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            pvalue->m.hrefPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->href = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->href = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("idref"))) {
            pvalue->m.idrefPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->idref = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->idref = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("xpath"))) {
            pvalue->m.xpathPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->xpath = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->xpath = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_TermRelationQualifierType (OSCTXT* pctxt, 
   TermRelationQualifierType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   pvalue->t = 2;
   if (0 != pXmlNode->children) {
      pvalue->u.alt_1 = pXmlNode->children->content;
   }
   else {
      pvalue->u.alt_1 = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_TitleType_type (OSCTXT* pctxt, TitleType_type* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   pvalue->t = 2;
   if (0 != pXmlNode->children) {
      pvalue->u.alt_1 = pXmlNode->children->content;
   }
   else {
      pvalue->u.alt_1 = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_TitleType (OSCTXT* pctxt, TitleType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("lang"))) {
            pvalue->m.langPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->lang = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->lang = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("phoneticAlphabet"))) {
            pvalue->m.phoneticAlphabetPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               PhoneticAlphabetType_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->phoneticAlphabet);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("phoneticTranscription"))) {
            pvalue->m.phoneticTranscriptionPresent = 1;
            {
            const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            else {
               pdata2 = (const OSUTF8CHAR*)"";
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->phoneticTranscription, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            pvalue->m.typePresent = 1;
            DOMTest_TitleType_type (pctxt, &pvalue->type, ((xmlNodePtr)pXmlAttr), FALSE);
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_ExtendedLanguageType (OSCTXT* pctxt, ExtendedLanguageType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("supplemental"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->supplemental);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            pvalue->m.typePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               ExtendedLanguageType_type_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->type);
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_HeaderType (OSCTXT* pctxt, HeaderType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_ClassificationSchemeAliasType (OSCTXT* pctxt, 
   ClassificationSchemeAliasType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("alias"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->alias = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->alias = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("href"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->href = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->href = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_ClassificationSchemeAliasType_derivations (OSCTXT* pctxt, 
   ClassificationSchemeAliasType_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("ClassificationSchemeAliasType");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("ClassificationSchemeAliasType")))
   {
      pvalue->t = 1;
      pvalue->u.classificationSchemeAliasType
          = rtxMemAllocType (pctxt, ClassificationSchemeAliasType);

      if (pvalue->u.classificationSchemeAliasType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ClassificationSchemeAliasType (pvalue->u.classificationSchemeAliasType);
      DOMTest_ClassificationSchemeAliasType (pctxt, pvalue->u.classificationSchemeAliasType, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("CSAliasType")))
   {
      pvalue->t = 2;
      pvalue->u.cSAliasType = rtxMemAllocType (pctxt, CSAliasType);

      if (pvalue->u.cSAliasType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CSAliasType ((CSAliasType*)pvalue->u.cSAliasType);
      DOMTest_CSAliasType (pctxt, (CSAliasType*)pvalue->u.cSAliasType, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_HeaderType_derivations (OSCTXT* pctxt, 
   HeaderType_derivations* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      return LOG_RTERR1 (pctxt, RTERR_ATTRMISRQ,
         rtxErrAddStrParm (pctxt, "xsi:type"));
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("ClassificationSchemeAliasType"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("CSAliasType")))
   {
      pvalue->t = 1;
      pvalue->u.classificationSchemeAliasType
          = rtxMemAllocType (pctxt, ClassificationSchemeAliasType_derivations);

      if (pvalue->u.classificationSchemeAliasType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ClassificationSchemeAliasType_derivations (pvalue->u.classificationSchemeAliasType);
      DOMTest_ClassificationSchemeAliasType_derivations (pctxt, pvalue->u.classificationSchemeAliasType, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_DSType (OSCTXT* pctxt, DSType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mediaTimeBase"))) {
            pvalue->m.mediaTimeBasePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mediaTimeBase = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->mediaTimeBase = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mediaTimeUnit"))) {
            pvalue->m.mediaTimeUnitPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mediaTimeUnit = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->mediaTimeUnit = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeBase"))) {
            pvalue->m.timeBasePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->timeBase = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->timeBase = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeUnit"))) {
            pvalue->m.timeUnitPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->timeUnit = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->timeUnit = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Header"))) {
            { HeaderType_derivations* pdata2;
            pdata2 = rtxMemAllocType (pctxt, HeaderType_derivations);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_HeaderType_derivations (pdata2);
            DOMTest_HeaderType_derivations (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->header_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_ClassificationSchemeBaseType (OSCTXT* pctxt, 
   ClassificationSchemeBaseType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("domain"))) {
            pvalue->m.domainPresent = 1;
            {
            const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            else {
               pdata2 = (const OSUTF8CHAR*)"";
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->domain, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mediaTimeBase"))) {
            pvalue->m.mediaTimeBasePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mediaTimeBase = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->mediaTimeBase = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mediaTimeUnit"))) {
            pvalue->m.mediaTimeUnitPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mediaTimeUnit = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->mediaTimeUnit = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeBase"))) {
            pvalue->m.timeBasePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->timeBase = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->timeBase = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeUnit"))) {
            pvalue->m.timeUnitPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->timeUnit = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->timeUnit = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("uri"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->uri = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->uri = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Import"))) {
            { MPEG7_ReferenceType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, MPEG7_ReferenceType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MPEG7_ReferenceType (pdata2);
            DOMTest_MPEG7_ReferenceType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->import_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_TermDefinitionBaseType_name (OSCTXT* pctxt, 
   TermDefinitionBaseType_name* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("lang"))) {
            pvalue->m.langPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->lang = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->lang = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("phoneticAlphabet"))) {
            pvalue->m.phoneticAlphabetPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               PhoneticAlphabetType_ToEnum (pctxt, ((xmlNodePtr)pXmlAttr)->children->content, &pvalue->phoneticAlphabet);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("phoneticTranscription"))) {
            pvalue->m.phoneticTranscriptionPresent = 1;
            {
            const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            else {
               pdata2 = (const OSUTF8CHAR*)"";
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->phoneticTranscription, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("preferred"))) {
            pvalue->m.preferredPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->preferred);
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }
   else {
      pvalue->base = (const OSUTF8CHAR*)"";
   }

   return 0;
}

int DOMTest_TermDefinitionBaseType (OSCTXT* pctxt, 
   TermDefinitionBaseType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mediaTimeBase"))) {
            pvalue->m.mediaTimeBasePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mediaTimeBase = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->mediaTimeBase = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mediaTimeUnit"))) {
            pvalue->m.mediaTimeUnitPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mediaTimeUnit = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->mediaTimeUnit = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("termID"))) {
            pvalue->m.termIDPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->termID = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->termID = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeBase"))) {
            pvalue->m.timeBasePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->timeBase = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->timeBase = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeUnit"))) {
            pvalue->m.timeUnitPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->timeUnit = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->timeUnit = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Name"))) {
            { TermDefinitionBaseType_name* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TermDefinitionBaseType_name);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TermDefinitionBaseType_name (pdata2);
            DOMTest_TermDefinitionBaseType_name (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->name_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Definition"))) {
            { TextualType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TextualType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TextualType (pdata2);
            DOMTest_TextualType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->definition_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_TermDefinitionType_term (OSCTXT* pctxt, 
   TermDefinitionType_term* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mediaTimeBase"))) {
            pvalue->m.mediaTimeBasePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mediaTimeBase = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->mediaTimeBase = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mediaTimeUnit"))) {
            pvalue->m.mediaTimeUnitPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mediaTimeUnit = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->mediaTimeUnit = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("relation"))) {
            pvalue->m.relationPresent = 1;
            DOMTest_TermRelationQualifierType (pctxt, &pvalue->relation, ((xmlNodePtr)pXmlAttr), FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("termID"))) {
            pvalue->m.termIDPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->termID = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->termID = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeBase"))) {
            pvalue->m.timeBasePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->timeBase = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->timeBase = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeUnit"))) {
            pvalue->m.timeUnitPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->timeUnit = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->timeUnit = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_TermDefinitionType (OSCTXT* pctxt, TermDefinitionType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mediaTimeBase"))) {
            pvalue->m.mediaTimeBasePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mediaTimeBase = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->mediaTimeBase = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mediaTimeUnit"))) {
            pvalue->m.mediaTimeUnitPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mediaTimeUnit = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->mediaTimeUnit = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("termID"))) {
            pvalue->m.termIDPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->termID = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->termID = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeBase"))) {
            pvalue->m.timeBasePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->timeBase = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->timeBase = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeUnit"))) {
            pvalue->m.timeUnitPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->timeUnit = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->timeUnit = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Term"))) {
            { TermDefinitionType_term* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TermDefinitionType_term);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TermDefinitionType_term (pdata2);
            DOMTest_TermDefinitionType_term (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->term_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_TermDefinitionType_derivations_termDefinitionType_2_Term (OSCTXT* pctxt, 
   TermDefinitionType_derivations_termDefinitionType_2_Term* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mediaTimeBase"))) {
            pvalue->m.mediaTimeBasePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mediaTimeBase = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->mediaTimeBase = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mediaTimeUnit"))) {
            pvalue->m.mediaTimeUnitPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mediaTimeUnit = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->mediaTimeUnit = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("relation"))) {
            pvalue->m.relationPresent = 1;
            DOMTest_TermRelationQualifierType (pctxt, &pvalue->relation, ((xmlNodePtr)pXmlAttr), FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("termID"))) {
            pvalue->m.termIDPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->termID = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->termID = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeBase"))) {
            pvalue->m.timeBasePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->timeBase = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->timeBase = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeUnit"))) {
            pvalue->m.timeUnitPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->timeUnit = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->timeUnit = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_TermDefinitionType_derivations (OSCTXT* pctxt, 
   TermDefinitionType_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("TermDefinitionType");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("TermDefinitionType")))
   {
      pvalue->t = 1;
      pvalue->u.termDefinitionType
          = rtxMemAllocType (pctxt, TermDefinitionType);

      if (pvalue->u.termDefinitionType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TermDefinitionType (pvalue->u.termDefinitionType);
      DOMTest_TermDefinitionType (pctxt, pvalue->u.termDefinitionType, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("TermDefinitionType_2_Term")))
   {
      pvalue->t = 2;
      pvalue->u.termDefinitionType_2_Term
          = rtxMemAllocType (pctxt, TermDefinitionType_derivations_termDefinitionType_2_Term);

      if (pvalue->u.termDefinitionType_2_Term == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TermDefinitionType_derivations_termDefinitionType_2_Term (pvalue->u.termDefinitionType_2_Term);
      DOMTest_TermDefinitionType_derivations_termDefinitionType_2_Term (pctxt, pvalue->u.termDefinitionType_2_Term, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_ClassificationSchemeType (OSCTXT* pctxt, 
   ClassificationSchemeType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("domain"))) {
            pvalue->m.domainPresent = 1;
            {
            const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            else {
               pdata2 = (const OSUTF8CHAR*)"";
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->domain, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mediaTimeBase"))) {
            pvalue->m.mediaTimeBasePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mediaTimeBase = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->mediaTimeBase = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("mediaTimeUnit"))) {
            pvalue->m.mediaTimeUnitPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mediaTimeUnit = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->mediaTimeUnit = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeBase"))) {
            pvalue->m.timeBasePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->timeBase = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->timeBase = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("timeUnit"))) {
            pvalue->m.timeUnitPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->timeUnit = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->timeUnit = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("uri"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->uri = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->uri = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Term"))) {
            { TermDefinitionType_derivations* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TermDefinitionType_derivations);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TermDefinitionType_derivations (pdata2);
            DOMTest_TermDefinitionType_derivations (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->term_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_MediaLocatorType_derivations (OSCTXT* pctxt, 
   MediaLocatorType_derivations* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("MediaLocatorType");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("MediaLocatorType")))
   {
      pvalue->t = 1;
      pvalue->u.mediaLocatorType = rtxMemAllocType (pctxt, MediaLocatorType);

      if (pvalue->u.mediaLocatorType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_MediaLocatorType (pvalue->u.mediaLocatorType);
      DOMTest_MediaLocatorType (pctxt, pvalue->u.mediaLocatorType, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("ImageLocatorType")))
   {
      pvalue->t = 2;
      pvalue->u.imageLocatorType = rtxMemAllocType (pctxt, ImageLocatorType);

      if (pvalue->u.imageLocatorType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ImageLocatorType (pvalue->u.imageLocatorType);
      DOMTest_ImageLocatorType (pctxt, pvalue->u.imageLocatorType, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("TemporalSegmentLocatorType")))
   {
      pvalue->t = 3;
      pvalue->u.temporalSegmentLocatorType
          = rtxMemAllocType (pctxt, TemporalSegmentLocatorType);

      if (pvalue->u.temporalSegmentLocatorType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TemporalSegmentLocatorType (pvalue->u.temporalSegmentLocatorType);
      DOMTest_TemporalSegmentLocatorType (pctxt, pvalue->u.temporalSegmentLocatorType, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_InlineTermDefinitionType_derivations (OSCTXT* pctxt, 
   InlineTermDefinitionType_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      return LOG_RTERR1 (pctxt, RTERR_ATTRMISRQ,
         rtxErrAddStrParm (pctxt, "xsi:type"));
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("ControlledTermUseType")))
   {
      pvalue->t = 1;
      pvalue->u.controlledTermUseType
          = rtxMemAllocType (pctxt, ControlledTermUseType);

      if (pvalue->u.controlledTermUseType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ControlledTermUseType (pvalue->u.controlledTermUseType);
      DOMTest_ControlledTermUseType (pctxt, pvalue->u.controlledTermUseType, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_ClassificationSchemeType_derivations (OSCTXT* pctxt, 
   ClassificationSchemeType_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("ClassificationSchemeType");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("ClassificationSchemeType")))
   {
      pvalue->t = 1;
      pvalue->u.classificationSchemeType
          = rtxMemAllocType (pctxt, Urn_tva_metadata_2005_ClassificationSchemeType);

      if (pvalue->u.classificationSchemeType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Urn_tva_metadata_2005_ClassificationSchemeType ((Urn_tva_metadata_2005_ClassificationSchemeType*)pvalue->u.classificationSchemeType);
      DOMTest_Urn_tva_metadata_2005_ClassificationSchemeType (pctxt, (Urn_tva_metadata_2005_ClassificationSchemeType*)pvalue->u.classificationSchemeType, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("ClassificationSchemeType")))
   {
      pvalue->t = 2;
      pvalue->u.classificationSchemeType_1
          = rtxMemAllocType (pctxt, Urn_tva_metadata_2005_ClassificationSchemeType);

      if (pvalue->u.classificationSchemeType_1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Urn_tva_metadata_2005_ClassificationSchemeType ((Urn_tva_metadata_2005_ClassificationSchemeType*)pvalue->u.classificationSchemeType_1);
      DOMTest_Urn_tva_metadata_2005_ClassificationSchemeType (pctxt, (Urn_tva_metadata_2005_ClassificationSchemeType*)pvalue->u.classificationSchemeType_1, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_ClassificationSchemeBaseType_derivations (OSCTXT* pctxt, 
   ClassificationSchemeBaseType_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      return LOG_RTERR1 (pctxt, RTERR_ATTRMISRQ,
         rtxErrAddStrParm (pctxt, "xsi:type"));
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("ClassificationSchemeType")))
   {
      pvalue->t = 1;
      pvalue->u.classificationSchemeType
          = rtxMemAllocType (pctxt, ClassificationSchemeType_derivations);

      if (pvalue->u.classificationSchemeType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ClassificationSchemeType_derivations (pvalue->u.classificationSchemeType);
      DOMTest_ClassificationSchemeType_derivations (pctxt, pvalue->u.classificationSchemeType, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_TermDefinitionBaseType_derivations (OSCTXT* pctxt, 
   TermDefinitionBaseType_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      return LOG_RTERR1 (pctxt, RTERR_ATTRMISRQ,
         rtxErrAddStrParm (pctxt, "xsi:type"));
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("TermDefinitionType"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TermDefinitionType_2_Term")))
   {
      pvalue->t = 1;
      pvalue->u.termDefinitionType
          = rtxMemAllocType (pctxt, TermDefinitionType_derivations);

      if (pvalue->u.termDefinitionType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TermDefinitionType_derivations (pvalue->u.termDefinitionType);
      DOMTest_TermDefinitionType_derivations (pctxt, pvalue->u.termDefinitionType, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_DSType_derivations (OSCTXT* pctxt, DSType_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      return LOG_RTERR1 (pctxt, RTERR_ATTRMISRQ,
         rtxErrAddStrParm (pctxt, "xsi:type"));
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("ClassificationSchemeType")))
   {
      pvalue->t = 1;
      pvalue->u.classificationSchemeBaseType
          = rtxMemAllocType (pctxt, ClassificationSchemeBaseType_derivations);

      if (pvalue->u.classificationSchemeBaseType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ClassificationSchemeBaseType_derivations (pvalue->u.classificationSchemeBaseType);
      DOMTest_ClassificationSchemeBaseType_derivations (pctxt, pvalue->u.classificationSchemeBaseType, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("TermDefinitionType"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TermDefinitionType_2_Term")))
   {
      pvalue->t = 2;
      pvalue->u.termDefinitionBaseType
          = rtxMemAllocType (pctxt, TermDefinitionBaseType_derivations);

      if (pvalue->u.termDefinitionBaseType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_TermDefinitionBaseType_derivations (pvalue->u.termDefinitionBaseType);
      DOMTest_TermDefinitionBaseType_derivations (pctxt, pvalue->u.termDefinitionBaseType, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_Mpeg7BaseType_derivations (OSCTXT* pctxt, 
   Mpeg7BaseType_derivations* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      return LOG_RTERR1 (pctxt, RTERR_ATTRMISRQ,
         rtxErrAddStrParm (pctxt, "xsi:type"));
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("ClassificationSchemeType"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TermDefinitionType"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("TermDefinitionType_2_Term")))
   {
      pvalue->t = 1;
      pvalue->u.dSType = rtxMemAllocType (pctxt, DSType_derivations);

      if (pvalue->u.dSType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_DSType_derivations (pvalue->u.dSType);
      DOMTest_DSType_derivations (pctxt, pvalue->u.dSType, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("ClassificationSchemeAliasType"))
   || rtxUTF8StrEqual (xsiType, OSUTF8("CSAliasType")))
   {
      pvalue->t = 2;
      pvalue->u.headerType = rtxMemAllocType (pctxt, HeaderType_derivations);

      if (pvalue->u.headerType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_HeaderType_derivations (pvalue->u.headerType);
      DOMTest_HeaderType_derivations (pctxt, pvalue->u.headerType, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

