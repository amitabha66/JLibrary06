/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 18-Oct-2006.
 */
#include "Ns4.h"
#include "Ns13.h"
#include "Odf.h"
#include "Xforms.h"
#include "rtxsrc/rtxCommon.h"

/**************************************************************/
/*                                                            */
/*  Apply_design_mode                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Apply_design_mode (OSCTXT* pctxt, Apply_design_mode *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Apply_design_mode (OSCTXT* pctxt, Apply_design_mode* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Apply_design_mode_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Automatic_focus                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Automatic_focus (OSCTXT* pctxt, Automatic_focus *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Automatic_focus (OSCTXT* pctxt, Automatic_focus* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Automatic_focus_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Form_actuate                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Form_actuate (OSCTXT* pctxt, Form_actuate *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Form_actuate (OSCTXT* pctxt, Form_actuate* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Form_actuate_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Form_allow_deletes                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Form_allow_deletes (OSCTXT* pctxt, 
   Form_allow_deletes *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Form_allow_deletes (OSCTXT* pctxt, Form_allow_deletes* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Form_allow_deletes_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Form_allow_inserts                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Form_allow_inserts (OSCTXT* pctxt, 
   Form_allow_inserts *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Form_allow_inserts (OSCTXT* pctxt, Form_allow_inserts* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Form_allow_inserts_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Form_allow_updates                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Form_allow_updates (OSCTXT* pctxt, 
   Form_allow_updates *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Form_allow_updates (OSCTXT* pctxt, Form_allow_updates* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Form_allow_updates_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Form_apply_filter                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Form_apply_filter (OSCTXT* pctxt, Form_apply_filter *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Form_apply_filter (OSCTXT* pctxt, Form_apply_filter* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Form_apply_filter_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Form_command_type                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Form_command_type (OSCTXT* pctxt, Form_command_type *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Form_command_type (OSCTXT* pctxt, Form_command_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Form_command_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Form_datasource                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Form_datasource (OSCTXT* pctxt, Form_datasource *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Form_datasource (OSCTXT* pctxt, Form_datasource* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Form_escape_processing                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Form_escape_processing (OSCTXT* pctxt, 
   Form_escape_processing *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Form_escape_processing (OSCTXT* pctxt, 
   Form_escape_processing* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Form_escape_processing_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Form_ignore_result                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Form_ignore_result (OSCTXT* pctxt, 
   Form_ignore_result *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Form_ignore_result (OSCTXT* pctxt, Form_ignore_result* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Form_ignore_result_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Form_method_alt_1                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Form_method_alt_1 (OSCTXT* pctxt, Form_method_alt_1 *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Form_method_alt_1 (OSCTXT* pctxt, Form_method_alt_1* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Form_method_alt_1_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Form_method_alt_2                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Form_method_alt_2 (OSCTXT* pctxt, Form_method_alt_2 *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Form_method_alt_2 (OSCTXT* pctxt, Form_method_alt_2* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Form_method_alt_2_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Form_method                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Form_method (OSCTXT* pctxt, Form_method *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
         stat = asn1D_Form_method_alt_1 (pctxt, 
            &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_PRIM|2):
         stat = asn1D_Form_method_alt_2 (pctxt, 
            &pvalue->u.alt_2, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Form_method (OSCTXT* pctxt, Form_method* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      stat = Form_method_alt_1_ToEnum (pctxt, pdata1, &pvalue->u.alt_1);
      if (stat == 0) pvalue->t = 2;
   }
   if (pvalue->t == 0) {
      stat = Form_method_alt_2_ToEnum (pctxt, pdata1, &pvalue->u.alt_2);
      if (stat == 0) pvalue->t = 3;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Form_navigation_mode                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Form_navigation_mode (OSCTXT* pctxt, 
   Form_navigation_mode *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Form_navigation_mode (OSCTXT* pctxt, Form_navigation_mode* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Form_navigation_mode_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Form_tab_cycle                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Form_tab_cycle (OSCTXT* pctxt, Form_tab_cycle *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Form_tab_cycle (OSCTXT* pctxt, Form_tab_cycle* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Form_tab_cycle_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Property_value_type                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Property_value_type (OSCTXT* pctxt, 
   Property_value_type *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Property_value_type (OSCTXT* pctxt, Property_value_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Property_value_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Property                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Property (OSCTXT* pctxt, Property *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode property_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->property_name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode boolean_value */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Boolean_value (pctxt, 
               (Ns13_Boolean_value*)&pvalue->boolean_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.boolean_valuePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode currency */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Currency (pctxt, 
               (Ns13_Currency*)&pvalue->currency, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.currencyPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode date_value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->date_value = rtxMemAllocType (pctxt, Ns13_Date_value);

            if (pvalue->date_value == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Date_value ((Ns13_Date_value*)pvalue->date_value);
            asn1Init_Ns13_Date_value ((Ns13_Date_value*)pvalue->date_value);

            stat = asn1D_Ns13_Date_value (pctxt, 
               (Ns13_Date_value*)pvalue->date_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.date_valuePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode string_value */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_String_value (pctxt, 
               (Ns13_String_value*)&pvalue->string_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.string_valuePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode time_value */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Time_value (pctxt, 
               (Ns13_Time_value*)&pvalue->time_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.time_valuePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Value (pctxt, 
               (Ns13_Value*)&pvalue->value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.valuePresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode value_type */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Property_value_type (pctxt, 
               &pvalue->value_type, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Property (OSCTXT* pctxt, Property* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("property-name"), 13}, 0 },
         { {OSUTF8("boolean-value"), 13}, 0 },
         { {OSUTF8("currency"), 8}, 0 },
         { {OSUTF8("date-value"), 10}, 0 },
         { {OSUTF8("string-value"), 12}, 0 },
         { {OSUTF8("time-value"), 10}, 0 },
         { {OSUTF8("value"), 5}, 0 },
         { {OSUTF8("value-type"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 8, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* property-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->property_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* boolean-value */
            stat = XmlDec_Ns13_Boolean_value (pctxt, &pvalue->boolean_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.boolean_valuePresent = TRUE;
            break;

         case 2: /* currency */
            stat = XmlDec_Ns13_Currency (pctxt, &pvalue->currency);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.currencyPresent = TRUE;
            break;

         case 3: /* date-value */
            pvalue->date_value = rtxMemAllocType (pctxt, Ns13_Date_value);

            if (pvalue->date_value == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Date_value ((Ns13_Date_value*)pvalue->date_value);

            stat = XmlDec_Ns13_Date_value (pctxt, pvalue->date_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.date_valuePresent = TRUE;
            break;

         case 4: /* string-value */
            stat = XmlDec_Ns13_String_value (pctxt, &pvalue->string_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.string_valuePresent = TRUE;
            break;

         case 5: /* time-value */
            stat = XmlDec_Ns13_Time_value (pctxt, &pvalue->time_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.time_valuePresent = TRUE;
            break;

         case 6: /* value */
            stat = XmlDec_Ns13_Value (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.valuePresent = TRUE;
            break;

         case 7: /* value-type */
            stat = XmlDec_Property_value_type (pctxt, &pvalue->value_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Property");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Property");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  List_property_value_type                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_List_property_value_type (OSCTXT* pctxt, 
   List_property_value_type *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_List_property_value_type (OSCTXT* pctxt, 
   List_property_value_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = List_property_value_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  List_value                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_List_value (OSCTXT* pctxt, List_value *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode boolean_value */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Boolean_value (pctxt, 
               (Ns13_Boolean_value*)&pvalue->boolean_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.boolean_valuePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode currency */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Currency (pctxt, 
               (Ns13_Currency*)&pvalue->currency, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.currencyPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode date_value */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->date_value = rtxMemAllocType (pctxt, Ns13_Date_value);

            if (pvalue->date_value == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Date_value ((Ns13_Date_value*)pvalue->date_value);
            asn1Init_Ns13_Date_value ((Ns13_Date_value*)pvalue->date_value);

            stat = asn1D_Ns13_Date_value (pctxt, 
               (Ns13_Date_value*)pvalue->date_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.date_valuePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 3:
         /* decode string_value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_String_value (pctxt, 
               (Ns13_String_value*)&pvalue->string_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.string_valuePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode time_value */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Time_value (pctxt, 
               (Ns13_Time_value*)&pvalue->time_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.time_valuePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Value (pctxt, 
               (Ns13_Value*)&pvalue->value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.valuePresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_List_value (OSCTXT* pctxt, List_value* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("boolean-value"), 13}, 0 },
         { {OSUTF8("currency"), 8}, 0 },
         { {OSUTF8("date-value"), 10}, 0 },
         { {OSUTF8("string-value"), 12}, 0 },
         { {OSUTF8("time-value"), 10}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 6, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* boolean-value */
            stat = XmlDec_Ns13_Boolean_value (pctxt, &pvalue->boolean_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.boolean_valuePresent = TRUE;
            break;

         case 1: /* currency */
            stat = XmlDec_Ns13_Currency (pctxt, &pvalue->currency);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.currencyPresent = TRUE;
            break;

         case 2: /* date-value */
            pvalue->date_value = rtxMemAllocType (pctxt, Ns13_Date_value);

            if (pvalue->date_value == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Date_value ((Ns13_Date_value*)pvalue->date_value);

            stat = XmlDec_Ns13_Date_value (pctxt, pvalue->date_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.date_valuePresent = TRUE;
            break;

         case 3: /* string-value */
            stat = XmlDec_Ns13_String_value (pctxt, &pvalue->string_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.string_valuePresent = TRUE;
            break;

         case 4: /* time-value */
            stat = XmlDec_Ns13_Time_value (pctxt, &pvalue->time_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.time_valuePresent = TRUE;
            break;

         case 5: /* value */
            stat = XmlDec_Ns13_Value (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.valuePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "List_value");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "List_value");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  List_property                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_List_property (OSCTXT* pctxt, List_property *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode property_name */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->property_name, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode value_type */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_List_property_value_type (pctxt, 
               &pvalue->value_type, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode list_value */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_List_value (pctxt, 
               &pvalue->list_value, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_List_property (OSCTXT* pctxt, List_property* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("property-name"), 13}, 0 },
         { {OSUTF8("value-type"), 10}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 2, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* property-name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->property_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 1: /* value-type */
            stat = XmlDec_List_property_value_type (pctxt, &pvalue->value_type
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "List_property");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "List_property");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("list-value"), 10}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 1, -1}, {1, 0, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* list-value */
         stat = XmlDec_List_value (pctxt, &pvalue->list_value);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Properties_element                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Properties_element (OSCTXT* pctxt, 
   Properties_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.property = rtxMemAllocType (pctxt, Property);

         if (pvalue->u.property == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Property (pvalue->u.property);
         stat = asn1D_Property (pctxt, 
            pvalue->u.property, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.list_property = rtxMemAllocType (pctxt, List_property);

         if (pvalue->u.list_property == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_List_property (pvalue->u.list_property);
         stat = asn1D_List_property (pctxt, 
            pvalue->u.list_property, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Properties_element (OSCTXT* pctxt, Properties_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("property"), 8}, 0}, 0 },
      {{{OSUTF8("list-property"), 13}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* property */
      pvalue->u.property = rtxMemAllocType (pctxt, Property);

      if (pvalue->u.property == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Property (pvalue->u.property);

      stat = XmlDec_Property (pctxt, pvalue->u.property);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* list-property */
      pvalue->u.list_property = rtxMemAllocType (pctxt, List_property);

      if (pvalue->u.list_property == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_List_property (pvalue->u.list_property);

      stat = XmlDec_List_property (pctxt, pvalue->u.list_property);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Properties                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Properties (OSCTXT* pctxt, Properties *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   Properties_element* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (XD_PEEKTAG (pctxt, 0x30)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_UNIV|TM_CONS|16));

   if (XD_PEEKTAG (pctxt, 0xa0)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_CTXT|TM_CONS|0));

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      rtxDListAllocNodeAndData (pctxt, Properties_element, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Properties_element (pdata1);

      stat = asn1D_Properties_element (pctxt, 
         pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

int XmlDec_Properties (OSCTXT* pctxt, Properties* pvalue)
{
   int stat = 0;

   { int elemID;
   Properties_element* pdata1;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("property"), 8}, 0}, 0 },
      {{{OSUTF8("list-property"), 13}, 0}, 0 }
   } ;

   rtxDListInit (pvalue);
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, FALSE);
      if (elemID < 0 || elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0:
         rtXmlpMarkLastEventActive (pctxt);

         pdata1 = rtxMemAllocType (pctxt, Properties_element);

         if (pdata1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Properties_element (pdata1);

         stat = XmlDec_Properties_element (pctxt, pdata1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         break;

      }
   }

   if (elemID == RTERR_UNEXPELEM || elemID == XML_OK_EOB) {
      stat = 0;
   }
   else return LOG_RTERR (pctxt, elemID);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Text_convert_empty_to_null                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Text_convert_empty_to_null (OSCTXT* pctxt, 
   Text_convert_empty_to_null *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Text_convert_empty_to_null (OSCTXT* pctxt, 
   Text_convert_empty_to_null* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Text_convert_empty_to_null_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Text_disabled                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Text_disabled (OSCTXT* pctxt, Text_disabled *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Text_disabled (OSCTXT* pctxt, Text_disabled* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Text_disabled_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Text_printable                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Text_printable (OSCTXT* pctxt, Text_printable *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Text_printable (OSCTXT* pctxt, Text_printable* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Text_printable_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Text_readonly                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Text_readonly (OSCTXT* pctxt, Text_readonly *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Text_readonly (OSCTXT* pctxt, Text_readonly* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Text_readonly_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Text_tab_stop                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Text_tab_stop (OSCTXT* pctxt, Text_tab_stop *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Text_tab_stop (OSCTXT* pctxt, Text_tab_stop* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Text_tab_stop_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Text                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns4_Text (OSCTXT* pctxt, Ns4_Text *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bind */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Bind (pctxt, 
               (Bind*)&pvalue->bind, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bindPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode control_implementation */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->control_implementation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.control_implementationPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode convert_empty_to_null */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Text_convert_empty_to_null (pctxt, 
               &pvalue->convert_empty_to_null, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.convert_empty_to_nullPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode current_value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->current_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.current_valuePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode data_field */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->data_field, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_fieldPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode disabled */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Text_disabled (pctxt, 
               &pvalue->disabled, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.disabledPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode max_length */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->max_length, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.max_lengthPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode printable */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Text_printable (pctxt, 
               &pvalue->printable, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.printablePresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode readonly */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Text_readonly (pctxt, 
               &pvalue->readonly, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.readonlyPresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode tab_index */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->tab_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_indexPresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode tab_stop */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Text_tab_stop (pctxt, 
               &pvalue->tab_stop, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_stopPresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode title */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->title, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.titlePresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.valuePresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode properties */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Properties (pctxt, 
               &pvalue->properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 16:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns4_Text (OSCTXT* pctxt, Ns4_Text* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bind"), 4}, 0 },
         { {OSUTF8("control-implementation"), 22}, 0 },
         { {OSUTF8("convert-empty-to-null"), 21}, 0 },
         { {OSUTF8("current-value"), 13}, 0 },
         { {OSUTF8("data-field"), 10}, 0 },
         { {OSUTF8("disabled"), 8}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("max-length"), 10}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("printable"), 9}, 0 },
         { {OSUTF8("readonly"), 8}, 0 },
         { {OSUTF8("tab-index"), 9}, 0 },
         { {OSUTF8("tab-stop"), 8}, 0 },
         { {OSUTF8("title"), 5}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 15, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bind */
            stat = XmlDec_Bind (pctxt, &pvalue->bind);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bindPresent = TRUE;
            break;

         case 1: /* control-implementation */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->control_implementation
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.control_implementationPresent = TRUE;
            break;

         case 2: /* convert-empty-to-null */
            stat = XmlDec_Text_convert_empty_to_null (pctxt, &pvalue->
               convert_empty_to_null);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.convert_empty_to_nullPresent = TRUE;
            break;

         case 3: /* current-value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->current_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.current_valuePresent = TRUE;
            break;

         case 4: /* data-field */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->data_field);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_fieldPresent = TRUE;
            break;

         case 5: /* disabled */
            stat = XmlDec_Text_disabled (pctxt, &pvalue->disabled);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.disabledPresent = TRUE;
            break;

         case 6: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 7: /* max-length */
            stat = rtXmlpDecUInt (pctxt, &pvalue->max_length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.max_lengthPresent = TRUE;
            break;

         case 8: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 9: /* printable */
            stat = XmlDec_Text_printable (pctxt, &pvalue->printable);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.printablePresent = TRUE;
            break;

         case 10: /* readonly */
            stat = XmlDec_Text_readonly (pctxt, &pvalue->readonly);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.readonlyPresent = TRUE;
            break;

         case 11: /* tab-index */
            stat = rtXmlpDecUInt (pctxt, &pvalue->tab_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_indexPresent = TRUE;
            break;

         case 12: /* tab-stop */
            stat = XmlDec_Text_tab_stop (pctxt, &pvalue->tab_stop);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_stopPresent = TRUE;
            break;

         case 13: /* title */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->title);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.titlePresent = TRUE;
            break;

         case 14: /* value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.valuePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns4_Text");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns4_Text");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("properties"), 10}, 0}, 0 },
      {{{OSUTF8("event-listeners"), 15}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* properties */
         stat = XmlDec_Properties (pctxt, &pvalue->properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.propertiesPresent = TRUE;
         break;
      }
      case 1: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Textarea_convert_empty_to_null                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Textarea_convert_empty_to_null (OSCTXT* pctxt, 
   Textarea_convert_empty_to_null *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Textarea_convert_empty_to_null (OSCTXT* pctxt, 
   Textarea_convert_empty_to_null* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Textarea_convert_empty_to_null_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Textarea_disabled                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Textarea_disabled (OSCTXT* pctxt, Textarea_disabled *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Textarea_disabled (OSCTXT* pctxt, Textarea_disabled* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Textarea_disabled_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Textarea_printable                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Textarea_printable (OSCTXT* pctxt, 
   Textarea_printable *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Textarea_printable (OSCTXT* pctxt, Textarea_printable* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Textarea_printable_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Textarea_readonly                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Textarea_readonly (OSCTXT* pctxt, Textarea_readonly *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Textarea_readonly (OSCTXT* pctxt, Textarea_readonly* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Textarea_readonly_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Textarea_tab_stop                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Textarea_tab_stop (OSCTXT* pctxt, Textarea_tab_stop *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Textarea_tab_stop (OSCTXT* pctxt, Textarea_tab_stop* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Textarea_tab_stop_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Textarea                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Textarea (OSCTXT* pctxt, Textarea *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bind */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Bind (pctxt, 
               (Bind*)&pvalue->bind, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bindPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode control_implementation */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->control_implementation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.control_implementationPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode convert_empty_to_null */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Textarea_convert_empty_to_null (pctxt, 
               &pvalue->convert_empty_to_null, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.convert_empty_to_nullPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode current_value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->current_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.current_valuePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode data_field */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->data_field, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_fieldPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode disabled */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Textarea_disabled (pctxt, 
               &pvalue->disabled, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.disabledPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode max_length */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->max_length, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.max_lengthPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode printable */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Textarea_printable (pctxt, 
               &pvalue->printable, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.printablePresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode readonly */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Textarea_readonly (pctxt, 
               &pvalue->readonly, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.readonlyPresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode tab_index */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->tab_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_indexPresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode tab_stop */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Textarea_tab_stop (pctxt, 
               &pvalue->tab_stop, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_stopPresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode title */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->title, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.titlePresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.valuePresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode properties */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Properties (pctxt, 
               &pvalue->properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 16:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 17:
         /* decode p_list */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Odf_P* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->p_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Odf_P, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Odf_P ((Odf_P*)pdata2);

                  stat = asn1D_Odf_P (pctxt, 
                     (Odf_P*)pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->p_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_CONS|17):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Textarea (OSCTXT* pctxt, Textarea* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bind"), 4}, 0 },
         { {OSUTF8("control-implementation"), 22}, 0 },
         { {OSUTF8("convert-empty-to-null"), 21}, 0 },
         { {OSUTF8("current-value"), 13}, 0 },
         { {OSUTF8("data-field"), 10}, 0 },
         { {OSUTF8("disabled"), 8}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("max-length"), 10}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("printable"), 9}, 0 },
         { {OSUTF8("readonly"), 8}, 0 },
         { {OSUTF8("tab-index"), 9}, 0 },
         { {OSUTF8("tab-stop"), 8}, 0 },
         { {OSUTF8("title"), 5}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 15, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bind */
            stat = XmlDec_Bind (pctxt, &pvalue->bind);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bindPresent = TRUE;
            break;

         case 1: /* control-implementation */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->control_implementation
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.control_implementationPresent = TRUE;
            break;

         case 2: /* convert-empty-to-null */
            stat = XmlDec_Textarea_convert_empty_to_null (pctxt, &pvalue->
               convert_empty_to_null);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.convert_empty_to_nullPresent = TRUE;
            break;

         case 3: /* current-value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->current_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.current_valuePresent = TRUE;
            break;

         case 4: /* data-field */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->data_field);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_fieldPresent = TRUE;
            break;

         case 5: /* disabled */
            stat = XmlDec_Textarea_disabled (pctxt, &pvalue->disabled);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.disabledPresent = TRUE;
            break;

         case 6: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 7: /* max-length */
            stat = rtXmlpDecUInt (pctxt, &pvalue->max_length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.max_lengthPresent = TRUE;
            break;

         case 8: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 9: /* printable */
            stat = XmlDec_Textarea_printable (pctxt, &pvalue->printable);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.printablePresent = TRUE;
            break;

         case 10: /* readonly */
            stat = XmlDec_Textarea_readonly (pctxt, &pvalue->readonly);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.readonlyPresent = TRUE;
            break;

         case 11: /* tab-index */
            stat = rtXmlpDecUInt (pctxt, &pvalue->tab_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_indexPresent = TRUE;
            break;

         case 12: /* tab-stop */
            stat = XmlDec_Textarea_tab_stop (pctxt, &pvalue->tab_stop);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_stopPresent = TRUE;
            break;

         case 13: /* title */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->title);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.titlePresent = TRUE;
            break;

         case 14: /* value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.valuePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Textarea");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Textarea");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("properties"), 10}, 0}, 0 },
      {{{OSUTF8("event-listeners"), 15}, 0}, 1 },
      {{{OSUTF8("p"), 1}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* properties */
         stat = XmlDec_Properties (pctxt, &pvalue->properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.propertiesPresent = TRUE;
         break;
      }
      case 1: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      case 2: {
         Odf_P* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Odf_P);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Odf_P ((Odf_P*)pdata1);

            stat = XmlDec_Odf_P (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->p_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 2, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Formatted_text_convert_empty_to_null                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Formatted_text_convert_empty_to_null (OSCTXT* pctxt, 
   Formatted_text_convert_empty_to_null *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Formatted_text_convert_empty_to_null (OSCTXT* pctxt, 
   Formatted_text_convert_empty_to_null* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Formatted_text_convert_empty_to_null_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Formatted_text_disabled                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Formatted_text_disabled (OSCTXT* pctxt, 
   Formatted_text_disabled *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Formatted_text_disabled (OSCTXT* pctxt, 
   Formatted_text_disabled* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Formatted_text_disabled_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Formatted_text_printable                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Formatted_text_printable (OSCTXT* pctxt, 
   Formatted_text_printable *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Formatted_text_printable (OSCTXT* pctxt, 
   Formatted_text_printable* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Formatted_text_printable_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Formatted_text_readonly                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Formatted_text_readonly (OSCTXT* pctxt, 
   Formatted_text_readonly *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Formatted_text_readonly (OSCTXT* pctxt, 
   Formatted_text_readonly* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Formatted_text_readonly_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Formatted_text_tab_stop                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Formatted_text_tab_stop (OSCTXT* pctxt, 
   Formatted_text_tab_stop *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Formatted_text_tab_stop (OSCTXT* pctxt, 
   Formatted_text_tab_stop* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Formatted_text_tab_stop_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Formatted_text_validation                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Formatted_text_validation (OSCTXT* pctxt, 
   Formatted_text_validation *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Formatted_text_validation (OSCTXT* pctxt, 
   Formatted_text_validation* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Formatted_text_validation_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Formatted_text                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Formatted_text (OSCTXT* pctxt, Formatted_text *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bind */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Bind (pctxt, 
               (Bind*)&pvalue->bind, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bindPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode control_implementation */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->control_implementation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.control_implementationPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode convert_empty_to_null */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Formatted_text_convert_empty_to_null (pctxt, 
               &pvalue->convert_empty_to_null, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.convert_empty_to_nullPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode current_value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->current_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.current_valuePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode data_field */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->data_field, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_fieldPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode disabled */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Formatted_text_disabled (pctxt, 
               &pvalue->disabled, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.disabledPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode max_length */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->max_length, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.max_lengthPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode max_value */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->max_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.max_valuePresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode min_value */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->min_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.min_valuePresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode printable */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Formatted_text_printable (pctxt, 
               &pvalue->printable, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.printablePresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode readonly */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Formatted_text_readonly (pctxt, 
               &pvalue->readonly, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.readonlyPresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode tab_index */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->tab_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_indexPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode tab_stop */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Formatted_text_tab_stop (pctxt, 
               &pvalue->tab_stop, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_stopPresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode title */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->title, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.titlePresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode validation */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Formatted_text_validation (pctxt, 
               &pvalue->validation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.validationPresent = TRUE;
            }
         }
         break;

      case 17:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.valuePresent = TRUE;
            }
         }
         break;

      case 18:
         /* decode properties */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Properties (pctxt, 
               &pvalue->properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 19:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x93)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_PRIM|16):
         case (TM_CTXT|TM_PRIM|17):
         case (TM_CTXT|TM_CONS|17):
         case (TM_CTXT|TM_CONS|18):
         case (TM_CTXT|TM_CONS|19):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Formatted_text (OSCTXT* pctxt, Formatted_text* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bind"), 4}, 0 },
         { {OSUTF8("control-implementation"), 22}, 0 },
         { {OSUTF8("convert-empty-to-null"), 21}, 0 },
         { {OSUTF8("current-value"), 13}, 0 },
         { {OSUTF8("data-field"), 10}, 0 },
         { {OSUTF8("disabled"), 8}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("max-length"), 10}, 0 },
         { {OSUTF8("max-value"), 9}, 0 },
         { {OSUTF8("min-value"), 9}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("printable"), 9}, 0 },
         { {OSUTF8("readonly"), 8}, 0 },
         { {OSUTF8("tab-index"), 9}, 0 },
         { {OSUTF8("tab-stop"), 8}, 0 },
         { {OSUTF8("title"), 5}, 0 },
         { {OSUTF8("validation"), 10}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 18, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bind */
            stat = XmlDec_Bind (pctxt, &pvalue->bind);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bindPresent = TRUE;
            break;

         case 1: /* control-implementation */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->control_implementation
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.control_implementationPresent = TRUE;
            break;

         case 2: /* convert-empty-to-null */
            stat = XmlDec_Formatted_text_convert_empty_to_null (pctxt, &pvalue
               ->convert_empty_to_null);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.convert_empty_to_nullPresent = TRUE;
            break;

         case 3: /* current-value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->current_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.current_valuePresent = TRUE;
            break;

         case 4: /* data-field */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->data_field);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_fieldPresent = TRUE;
            break;

         case 5: /* disabled */
            stat = XmlDec_Formatted_text_disabled (pctxt, &pvalue->disabled);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.disabledPresent = TRUE;
            break;

         case 6: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 7: /* max-length */
            stat = rtXmlpDecUInt (pctxt, &pvalue->max_length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.max_lengthPresent = TRUE;
            break;

         case 8: /* max-value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->max_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.max_valuePresent = TRUE;
            break;

         case 9: /* min-value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->min_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.min_valuePresent = TRUE;
            break;

         case 10: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 11: /* printable */
            stat = XmlDec_Formatted_text_printable (pctxt, &pvalue->printable
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.printablePresent = TRUE;
            break;

         case 12: /* readonly */
            stat = XmlDec_Formatted_text_readonly (pctxt, &pvalue->readonly);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.readonlyPresent = TRUE;
            break;

         case 13: /* tab-index */
            stat = rtXmlpDecUInt (pctxt, &pvalue->tab_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_indexPresent = TRUE;
            break;

         case 14: /* tab-stop */
            stat = XmlDec_Formatted_text_tab_stop (pctxt, &pvalue->tab_stop);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_stopPresent = TRUE;
            break;

         case 15: /* title */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->title);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.titlePresent = TRUE;
            break;

         case 16: /* validation */
            stat = XmlDec_Formatted_text_validation (pctxt, &pvalue->validation
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.validationPresent = TRUE;
            break;

         case 17: /* value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.valuePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Formatted_text");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Formatted_text");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("properties"), 10}, 0}, 0 },
      {{{OSUTF8("event-listeners"), 15}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* properties */
         stat = XmlDec_Properties (pctxt, &pvalue->properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.propertiesPresent = TRUE;
         break;
      }
      case 1: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Number_convert_empty_to_null                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Number_convert_empty_to_null (OSCTXT* pctxt, 
   Number_convert_empty_to_null *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Number_convert_empty_to_null (OSCTXT* pctxt, 
   Number_convert_empty_to_null* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Number_convert_empty_to_null_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Number_disabled                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Number_disabled (OSCTXT* pctxt, Number_disabled *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Number_disabled (OSCTXT* pctxt, Number_disabled* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Number_disabled_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Number_printable                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Number_printable (OSCTXT* pctxt, Number_printable *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Number_printable (OSCTXT* pctxt, Number_printable* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Number_printable_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Number_readonly                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Number_readonly (OSCTXT* pctxt, Number_readonly *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Number_readonly (OSCTXT* pctxt, Number_readonly* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Number_readonly_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Number_tab_stop                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Number_tab_stop (OSCTXT* pctxt, Number_tab_stop *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Number_tab_stop (OSCTXT* pctxt, Number_tab_stop* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Number_tab_stop_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Number                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns4_Number (OSCTXT* pctxt, Ns4_Number *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bind */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Bind (pctxt, 
               (Bind*)&pvalue->bind, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bindPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode control_implementation */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->control_implementation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.control_implementationPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode convert_empty_to_null */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Number_convert_empty_to_null (pctxt, 
               &pvalue->convert_empty_to_null, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.convert_empty_to_nullPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode current_value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->current_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.current_valuePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode data_field */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->data_field, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_fieldPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode disabled */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Number_disabled (pctxt, 
               &pvalue->disabled, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.disabledPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode max_length */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->max_length, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.max_lengthPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode max_value */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->max_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.max_valuePresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode min_value */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->min_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.min_valuePresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode printable */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Number_printable (pctxt, 
               &pvalue->printable, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.printablePresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode readonly */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Number_readonly (pctxt, 
               &pvalue->readonly, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.readonlyPresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode tab_index */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->tab_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_indexPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode tab_stop */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Number_tab_stop (pctxt, 
               &pvalue->tab_stop, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_stopPresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode title */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->title, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.titlePresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.valuePresent = TRUE;
            }
         }
         break;

      case 17:
         /* decode properties */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Properties (pctxt, 
               &pvalue->properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 18:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_PRIM|16):
         case (TM_CTXT|TM_CONS|17):
         case (TM_CTXT|TM_CONS|18):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns4_Number (OSCTXT* pctxt, Ns4_Number* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bind"), 4}, 0 },
         { {OSUTF8("control-implementation"), 22}, 0 },
         { {OSUTF8("convert-empty-to-null"), 21}, 0 },
         { {OSUTF8("current-value"), 13}, 0 },
         { {OSUTF8("data-field"), 10}, 0 },
         { {OSUTF8("disabled"), 8}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("max-length"), 10}, 0 },
         { {OSUTF8("max-value"), 9}, 0 },
         { {OSUTF8("min-value"), 9}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("printable"), 9}, 0 },
         { {OSUTF8("readonly"), 8}, 0 },
         { {OSUTF8("tab-index"), 9}, 0 },
         { {OSUTF8("tab-stop"), 8}, 0 },
         { {OSUTF8("title"), 5}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 17, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bind */
            stat = XmlDec_Bind (pctxt, &pvalue->bind);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bindPresent = TRUE;
            break;

         case 1: /* control-implementation */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->control_implementation
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.control_implementationPresent = TRUE;
            break;

         case 2: /* convert-empty-to-null */
            stat = XmlDec_Number_convert_empty_to_null (pctxt, &pvalue->
               convert_empty_to_null);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.convert_empty_to_nullPresent = TRUE;
            break;

         case 3: /* current-value */
            stat = rtXmlpDecDouble (pctxt, &pvalue->current_value, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.current_valuePresent = TRUE;
            break;

         case 4: /* data-field */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->data_field);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_fieldPresent = TRUE;
            break;

         case 5: /* disabled */
            stat = XmlDec_Number_disabled (pctxt, &pvalue->disabled);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.disabledPresent = TRUE;
            break;

         case 6: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 7: /* max-length */
            stat = rtXmlpDecUInt (pctxt, &pvalue->max_length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.max_lengthPresent = TRUE;
            break;

         case 8: /* max-value */
            stat = rtXmlpDecDouble (pctxt, &pvalue->max_value, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.max_valuePresent = TRUE;
            break;

         case 9: /* min-value */
            stat = rtXmlpDecDouble (pctxt, &pvalue->min_value, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.min_valuePresent = TRUE;
            break;

         case 10: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 11: /* printable */
            stat = XmlDec_Number_printable (pctxt, &pvalue->printable);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.printablePresent = TRUE;
            break;

         case 12: /* readonly */
            stat = XmlDec_Number_readonly (pctxt, &pvalue->readonly);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.readonlyPresent = TRUE;
            break;

         case 13: /* tab-index */
            stat = rtXmlpDecUInt (pctxt, &pvalue->tab_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_indexPresent = TRUE;
            break;

         case 14: /* tab-stop */
            stat = XmlDec_Number_tab_stop (pctxt, &pvalue->tab_stop);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_stopPresent = TRUE;
            break;

         case 15: /* title */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->title);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.titlePresent = TRUE;
            break;

         case 16: /* value */
            stat = rtXmlpDecDouble (pctxt, &pvalue->value, -1, -1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.valuePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns4_Number");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns4_Number");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("properties"), 10}, 0}, 0 },
      {{{OSUTF8("event-listeners"), 15}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* properties */
         stat = XmlDec_Properties (pctxt, &pvalue->properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.propertiesPresent = TRUE;
         break;
      }
      case 1: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Date_convert_empty_to_null                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Date_convert_empty_to_null (OSCTXT* pctxt, 
   Date_convert_empty_to_null *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Date_convert_empty_to_null (OSCTXT* pctxt, 
   Date_convert_empty_to_null* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Date_convert_empty_to_null_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Date_disabled                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Date_disabled (OSCTXT* pctxt, Date_disabled *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Date_disabled (OSCTXT* pctxt, Date_disabled* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Date_disabled_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Date_printable                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Date_printable (OSCTXT* pctxt, Date_printable *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Date_printable (OSCTXT* pctxt, Date_printable* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Date_printable_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Date_readonly                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Date_readonly (OSCTXT* pctxt, Date_readonly *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Date_readonly (OSCTXT* pctxt, Date_readonly* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Date_readonly_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Date_tab_stop                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Date_tab_stop (OSCTXT* pctxt, Date_tab_stop *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Date_tab_stop (OSCTXT* pctxt, Date_tab_stop* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Date_tab_stop_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Date                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns4_Date (OSCTXT* pctxt, Ns4_Date *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bind */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Bind (pctxt, 
               (Bind*)&pvalue->bind, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bindPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode control_implementation */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->control_implementation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.control_implementationPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode convert_empty_to_null */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Date_convert_empty_to_null (pctxt, 
               &pvalue->convert_empty_to_null, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.convert_empty_to_nullPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode current_value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_charstr (pctxt, &pvalue->current_value, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|26), length);
            if (stat == 0) {
               pvalue->m.current_valuePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode data_field */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->data_field, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_fieldPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode disabled */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Date_disabled (pctxt, 
               &pvalue->disabled, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.disabledPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode max_length */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->max_length, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.max_lengthPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode max_value */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_charstr (pctxt, &pvalue->max_value, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|26), length);
            if (stat == 0) {
               pvalue->m.max_valuePresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode min_value */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_charstr (pctxt, &pvalue->min_value, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|26), length);
            if (stat == 0) {
               pvalue->m.min_valuePresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode printable */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Date_printable (pctxt, 
               &pvalue->printable, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.printablePresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode readonly */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Date_readonly (pctxt, 
               &pvalue->readonly, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.readonlyPresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode tab_index */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->tab_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_indexPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode tab_stop */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Date_tab_stop (pctxt, 
               &pvalue->tab_stop, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_stopPresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode title */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->title, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.titlePresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_charstr (pctxt, &pvalue->value, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|26), length);
            if (stat == 0) {
               pvalue->m.valuePresent = TRUE;
            }
         }
         break;

      case 17:
         /* decode properties */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Properties (pctxt, 
               &pvalue->properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 18:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_PRIM|16):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_CONS|17):
         case (TM_CTXT|TM_CONS|18):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns4_Date (OSCTXT* pctxt, Ns4_Date* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bind"), 4}, 0 },
         { {OSUTF8("control-implementation"), 22}, 0 },
         { {OSUTF8("convert-empty-to-null"), 21}, 0 },
         { {OSUTF8("current-value"), 13}, 0 },
         { {OSUTF8("data-field"), 10}, 0 },
         { {OSUTF8("disabled"), 8}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("max-length"), 10}, 0 },
         { {OSUTF8("max-value"), 9}, 0 },
         { {OSUTF8("min-value"), 9}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("printable"), 9}, 0 },
         { {OSUTF8("readonly"), 8}, 0 },
         { {OSUTF8("tab-index"), 9}, 0 },
         { {OSUTF8("tab-stop"), 8}, 0 },
         { {OSUTF8("title"), 5}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 17, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bind */
            stat = XmlDec_Bind (pctxt, &pvalue->bind);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bindPresent = TRUE;
            break;

         case 1: /* control-implementation */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->control_implementation
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.control_implementationPresent = TRUE;
            break;

         case 2: /* convert-empty-to-null */
            stat = XmlDec_Date_convert_empty_to_null (pctxt, &pvalue->
               convert_empty_to_null);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.convert_empty_to_nullPresent = TRUE;
            break;

         case 3: /* current-value */
            stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)&pvalue->
               current_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.current_valuePresent = TRUE;
            break;

         case 4: /* data-field */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->data_field);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_fieldPresent = TRUE;
            break;

         case 5: /* disabled */
            stat = XmlDec_Date_disabled (pctxt, &pvalue->disabled);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.disabledPresent = TRUE;
            break;

         case 6: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 7: /* max-length */
            stat = rtXmlpDecUInt (pctxt, &pvalue->max_length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.max_lengthPresent = TRUE;
            break;

         case 8: /* max-value */
            stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)&pvalue->
               max_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.max_valuePresent = TRUE;
            break;

         case 9: /* min-value */
            stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)&pvalue->
               min_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.min_valuePresent = TRUE;
            break;

         case 10: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 11: /* printable */
            stat = XmlDec_Date_printable (pctxt, &pvalue->printable);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.printablePresent = TRUE;
            break;

         case 12: /* readonly */
            stat = XmlDec_Date_readonly (pctxt, &pvalue->readonly);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.readonlyPresent = TRUE;
            break;

         case 13: /* tab-index */
            stat = rtXmlpDecUInt (pctxt, &pvalue->tab_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_indexPresent = TRUE;
            break;

         case 14: /* tab-stop */
            stat = XmlDec_Date_tab_stop (pctxt, &pvalue->tab_stop);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_stopPresent = TRUE;
            break;

         case 15: /* title */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->title);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.titlePresent = TRUE;
            break;

         case 16: /* value */
            stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)&pvalue->
               value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.valuePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns4_Date");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns4_Date");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("properties"), 10}, 0}, 0 },
      {{{OSUTF8("event-listeners"), 15}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* properties */
         stat = XmlDec_Properties (pctxt, &pvalue->properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.propertiesPresent = TRUE;
         break;
      }
      case 1: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Combobox_auto_complete                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Combobox_auto_complete (OSCTXT* pctxt, 
   Combobox_auto_complete *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Combobox_auto_complete (OSCTXT* pctxt, 
   Combobox_auto_complete* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Combobox_auto_complete_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Combobox_convert_empty_to_null                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Combobox_convert_empty_to_null (OSCTXT* pctxt, 
   Combobox_convert_empty_to_null *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Combobox_convert_empty_to_null (OSCTXT* pctxt, 
   Combobox_convert_empty_to_null* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Combobox_convert_empty_to_null_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Combobox_disabled                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Combobox_disabled (OSCTXT* pctxt, Combobox_disabled *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Combobox_disabled (OSCTXT* pctxt, Combobox_disabled* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Combobox_disabled_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Combobox_dropdown                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Combobox_dropdown (OSCTXT* pctxt, Combobox_dropdown *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Combobox_dropdown (OSCTXT* pctxt, Combobox_dropdown* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Combobox_dropdown_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Combobox_list_source_type                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Combobox_list_source_type (OSCTXT* pctxt, 
   Combobox_list_source_type *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Combobox_list_source_type (OSCTXT* pctxt, 
   Combobox_list_source_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Combobox_list_source_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Combobox_printable                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Combobox_printable (OSCTXT* pctxt, 
   Combobox_printable *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Combobox_printable (OSCTXT* pctxt, Combobox_printable* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Combobox_printable_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Combobox_readonly                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Combobox_readonly (OSCTXT* pctxt, Combobox_readonly *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Combobox_readonly (OSCTXT* pctxt, Combobox_readonly* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Combobox_readonly_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Combobox_tab_stop                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Combobox_tab_stop (OSCTXT* pctxt, Combobox_tab_stop *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Combobox_tab_stop (OSCTXT* pctxt, Combobox_tab_stop* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Combobox_tab_stop_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Item                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Item (OSCTXT* pctxt, Item *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode label */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->label, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.labelPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Item (OSCTXT* pctxt, Item* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("label"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* label */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->label);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.labelPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Item");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Item");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Combobox                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Combobox (OSCTXT* pctxt, Combobox *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bind */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Bind (pctxt, 
               (Bind*)&pvalue->bind, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bindPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode auto_complete */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Combobox_auto_complete (pctxt, 
               &pvalue->auto_complete, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.auto_completePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode control_implementation */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->control_implementation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.control_implementationPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode convert_empty_to_null */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Combobox_convert_empty_to_null (pctxt, 
               &pvalue->convert_empty_to_null, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.convert_empty_to_nullPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode current_value */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->current_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.current_valuePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode data_field */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->data_field, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_fieldPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode disabled */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Combobox_disabled (pctxt, 
               &pvalue->disabled, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.disabledPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode dropdown */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Combobox_dropdown (pctxt, 
               &pvalue->dropdown, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dropdownPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 9:
         /* decode list_source */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->list_source, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.list_sourcePresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode list_source_type */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Combobox_list_source_type (pctxt, 
               &pvalue->list_source_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.list_source_typePresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode max_length */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->max_length, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.max_lengthPresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode printable */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Combobox_printable (pctxt, 
               &pvalue->printable, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.printablePresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode readonly */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Combobox_readonly (pctxt, 
               &pvalue->readonly, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.readonlyPresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode size */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->size, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sizePresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode tab_index */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->tab_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_indexPresent = TRUE;
            }
         }
         break;

      case 17:
         /* decode tab_stop */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Combobox_tab_stop (pctxt, 
               &pvalue->tab_stop, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_stopPresent = TRUE;
            }
         }
         break;

      case 18:
         /* decode title */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->title, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.titlePresent = TRUE;
            }
         }
         break;

      case 19:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x93)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.valuePresent = TRUE;
            }
         }
         break;

      case 20:
         /* decode properties */
         if (XD_PEEKTAG (pctxt, 0x94)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Properties (pctxt, 
               &pvalue->properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 21:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x95)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 22:
         /* decode item_list */
         if (XD_PEEKTAG (pctxt, 0x96)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Item* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->item_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Item, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Item (pdata2);

                  stat = asn1D_Item (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->item_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_PRIM|16):
         case (TM_CTXT|TM_PRIM|17):
         case (TM_CTXT|TM_PRIM|18):
         case (TM_CTXT|TM_CONS|18):
         case (TM_CTXT|TM_PRIM|19):
         case (TM_CTXT|TM_CONS|19):
         case (TM_CTXT|TM_CONS|20):
         case (TM_CTXT|TM_CONS|21):
         case (TM_CTXT|TM_CONS|22):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Combobox (OSCTXT* pctxt, Combobox* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bind"), 4}, 0 },
         { {OSUTF8("auto-complete"), 13}, 0 },
         { {OSUTF8("control-implementation"), 22}, 0 },
         { {OSUTF8("convert-empty-to-null"), 21}, 0 },
         { {OSUTF8("current-value"), 13}, 0 },
         { {OSUTF8("data-field"), 10}, 0 },
         { {OSUTF8("disabled"), 8}, 0 },
         { {OSUTF8("dropdown"), 8}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("list-source"), 11}, 0 },
         { {OSUTF8("list-source-type"), 16}, 0 },
         { {OSUTF8("max-length"), 10}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("printable"), 9}, 0 },
         { {OSUTF8("readonly"), 8}, 0 },
         { {OSUTF8("size"), 4}, 0 },
         { {OSUTF8("tab-index"), 9}, 0 },
         { {OSUTF8("tab-stop"), 8}, 0 },
         { {OSUTF8("title"), 5}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 20, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bind */
            stat = XmlDec_Bind (pctxt, &pvalue->bind);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bindPresent = TRUE;
            break;

         case 1: /* auto-complete */
            stat = XmlDec_Combobox_auto_complete (pctxt, &pvalue->auto_complete
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.auto_completePresent = TRUE;
            break;

         case 2: /* control-implementation */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->control_implementation
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.control_implementationPresent = TRUE;
            break;

         case 3: /* convert-empty-to-null */
            stat = XmlDec_Combobox_convert_empty_to_null (pctxt, &pvalue->
               convert_empty_to_null);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.convert_empty_to_nullPresent = TRUE;
            break;

         case 4: /* current-value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->current_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.current_valuePresent = TRUE;
            break;

         case 5: /* data-field */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->data_field);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_fieldPresent = TRUE;
            break;

         case 6: /* disabled */
            stat = XmlDec_Combobox_disabled (pctxt, &pvalue->disabled);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.disabledPresent = TRUE;
            break;

         case 7: /* dropdown */
            stat = XmlDec_Combobox_dropdown (pctxt, &pvalue->dropdown);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.dropdownPresent = TRUE;
            break;

         case 8: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 9: /* list-source */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->list_source);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.list_sourcePresent = TRUE;
            break;

         case 10: /* list-source-type */
            stat = XmlDec_Combobox_list_source_type (pctxt, &pvalue->
               list_source_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.list_source_typePresent = TRUE;
            break;

         case 11: /* max-length */
            stat = rtXmlpDecUInt (pctxt, &pvalue->max_length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.max_lengthPresent = TRUE;
            break;

         case 12: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 13: /* printable */
            stat = XmlDec_Combobox_printable (pctxt, &pvalue->printable);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.printablePresent = TRUE;
            break;

         case 14: /* readonly */
            stat = XmlDec_Combobox_readonly (pctxt, &pvalue->readonly);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.readonlyPresent = TRUE;
            break;

         case 15: /* size */
            stat = rtXmlpDecUInt (pctxt, &pvalue->size);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.sizePresent = TRUE;
            break;

         case 16: /* tab-index */
            stat = rtXmlpDecUInt (pctxt, &pvalue->tab_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_indexPresent = TRUE;
            break;

         case 17: /* tab-stop */
            stat = XmlDec_Combobox_tab_stop (pctxt, &pvalue->tab_stop);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_stopPresent = TRUE;
            break;

         case 18: /* title */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->title);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.titlePresent = TRUE;
            break;

         case 19: /* value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.valuePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Combobox");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Combobox");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("properties"), 10}, 0}, 0 },
      {{{OSUTF8("event-listeners"), 15}, 0}, 1 },
      {{{OSUTF8("item"), 4}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* properties */
         stat = XmlDec_Properties (pctxt, &pvalue->properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.propertiesPresent = TRUE;
         break;
      }
      case 1: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      case 2: {
         Item* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Item);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Item (pdata1);

            stat = XmlDec_Item (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->item_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 2, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Listbox_disabled                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Listbox_disabled (OSCTXT* pctxt, Listbox_disabled *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Listbox_disabled (OSCTXT* pctxt, Listbox_disabled* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Listbox_disabled_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Listbox_dropdown                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Listbox_dropdown (OSCTXT* pctxt, Listbox_dropdown *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Listbox_dropdown (OSCTXT* pctxt, Listbox_dropdown* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Listbox_dropdown_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Listbox_list_source_type                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Listbox_list_source_type (OSCTXT* pctxt, 
   Listbox_list_source_type *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Listbox_list_source_type (OSCTXT* pctxt, 
   Listbox_list_source_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Listbox_list_source_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Listbox_multiple                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Listbox_multiple (OSCTXT* pctxt, Listbox_multiple *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Listbox_multiple (OSCTXT* pctxt, Listbox_multiple* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Listbox_multiple_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Listbox_printable                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Listbox_printable (OSCTXT* pctxt, Listbox_printable *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Listbox_printable (OSCTXT* pctxt, Listbox_printable* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Listbox_printable_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Listbox_tab_stop                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Listbox_tab_stop (OSCTXT* pctxt, Listbox_tab_stop *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Listbox_tab_stop (OSCTXT* pctxt, Listbox_tab_stop* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Listbox_tab_stop_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Option_current_selected                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Option_current_selected (OSCTXT* pctxt, 
   Option_current_selected *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Option_current_selected (OSCTXT* pctxt, 
   Option_current_selected* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Option_current_selected_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Option_selected                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Option_selected (OSCTXT* pctxt, Option_selected *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Option_selected (OSCTXT* pctxt, Option_selected* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Option_selected_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Option                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Option (OSCTXT* pctxt, Option *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode current_selected */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Option_current_selected (pctxt, 
               &pvalue->current_selected, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.current_selectedPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode label */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->label, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.labelPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode selected */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Option_selected (pctxt, 
               &pvalue->selected, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.selectedPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.valuePresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Option (OSCTXT* pctxt, Option* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("current-selected"), 16}, 0 },
         { {OSUTF8("label"), 5}, 0 },
         { {OSUTF8("selected"), 8}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* current-selected */
            stat = XmlDec_Option_current_selected (pctxt, &pvalue->
               current_selected);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.current_selectedPresent = TRUE;
            break;

         case 1: /* label */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->label);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.labelPresent = TRUE;
            break;

         case 2: /* selected */
            stat = XmlDec_Option_selected (pctxt, &pvalue->selected);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.selectedPresent = TRUE;
            break;

         case 3: /* value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.valuePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Option");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Option");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Listbox                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Listbox (OSCTXT* pctxt, Listbox *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bind */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Bind (pctxt, 
               (Bind*)&pvalue->bind, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bindPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode bound_column */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->bound_column, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bound_columnPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode control_implementation */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->control_implementation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.control_implementationPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode data_field */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->data_field, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_fieldPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode disabled */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Listbox_disabled (pctxt, 
               &pvalue->disabled, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.disabledPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode dropdown */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Listbox_dropdown (pctxt, 
               &pvalue->dropdown, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dropdownPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode list_source */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->list_source, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.list_sourcePresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode list_source_type */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Listbox_list_source_type (pctxt, 
               &pvalue->list_source_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.list_source_typePresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode multiple */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Listbox_multiple (pctxt, 
               &pvalue->multiple, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.multiplePresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode printable */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Listbox_printable (pctxt, 
               &pvalue->printable, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.printablePresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode size */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->size, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sizePresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode tab_index */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->tab_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_indexPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode tab_stop */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Listbox_tab_stop (pctxt, 
               &pvalue->tab_stop, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_stopPresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode title */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->title, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.titlePresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode xforms_list_source */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->xforms_list_source, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.xforms_list_sourcePresent = TRUE;
            }
         }
         break;

      case 17:
         /* decode properties */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Properties (pctxt, 
               &pvalue->properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 18:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 19:
         /* decode option_list */
         if (XD_PEEKTAG (pctxt, 0x93)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Option* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->option_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Option, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Option (pdata2);

                  stat = asn1D_Option (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->option_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_PRIM|16):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_CONS|17):
         case (TM_CTXT|TM_CONS|18):
         case (TM_CTXT|TM_CONS|19):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Listbox (OSCTXT* pctxt, Listbox* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bind"), 4}, 0 },
         { {OSUTF8("bound-column"), 12}, 0 },
         { {OSUTF8("control-implementation"), 22}, 0 },
         { {OSUTF8("data-field"), 10}, 0 },
         { {OSUTF8("disabled"), 8}, 0 },
         { {OSUTF8("dropdown"), 8}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("list-source"), 11}, 0 },
         { {OSUTF8("list-source-type"), 16}, 0 },
         { {OSUTF8("multiple"), 8}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("printable"), 9}, 0 },
         { {OSUTF8("size"), 4}, 0 },
         { {OSUTF8("tab-index"), 9}, 0 },
         { {OSUTF8("tab-stop"), 8}, 0 },
         { {OSUTF8("title"), 5}, 0 },
         { {OSUTF8("xforms-list-source"), 18}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 17, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bind */
            stat = XmlDec_Bind (pctxt, &pvalue->bind);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bindPresent = TRUE;
            break;

         case 1: /* bound-column */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->bound_column);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bound_columnPresent = TRUE;
            break;

         case 2: /* control-implementation */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->control_implementation
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.control_implementationPresent = TRUE;
            break;

         case 3: /* data-field */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->data_field);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_fieldPresent = TRUE;
            break;

         case 4: /* disabled */
            stat = XmlDec_Listbox_disabled (pctxt, &pvalue->disabled);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.disabledPresent = TRUE;
            break;

         case 5: /* dropdown */
            stat = XmlDec_Listbox_dropdown (pctxt, &pvalue->dropdown);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.dropdownPresent = TRUE;
            break;

         case 6: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 7: /* list-source */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->list_source);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.list_sourcePresent = TRUE;
            break;

         case 8: /* list-source-type */
            stat = XmlDec_Listbox_list_source_type (pctxt, &pvalue->
               list_source_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.list_source_typePresent = TRUE;
            break;

         case 9: /* multiple */
            stat = XmlDec_Listbox_multiple (pctxt, &pvalue->multiple);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.multiplePresent = TRUE;
            break;

         case 10: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 11: /* printable */
            stat = XmlDec_Listbox_printable (pctxt, &pvalue->printable);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.printablePresent = TRUE;
            break;

         case 12: /* size */
            stat = rtXmlpDecUInt (pctxt, &pvalue->size);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.sizePresent = TRUE;
            break;

         case 13: /* tab-index */
            stat = rtXmlpDecUInt (pctxt, &pvalue->tab_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_indexPresent = TRUE;
            break;

         case 14: /* tab-stop */
            stat = XmlDec_Listbox_tab_stop (pctxt, &pvalue->tab_stop);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_stopPresent = TRUE;
            break;

         case 15: /* title */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->title);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.titlePresent = TRUE;
            break;

         case 16: /* xforms-list-source */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->xforms_list_source);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.xforms_list_sourcePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Listbox");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Listbox");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("properties"), 10}, 0}, 0 },
      {{{OSUTF8("event-listeners"), 15}, 0}, 1 },
      {{{OSUTF8("option"), 6}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* properties */
         stat = XmlDec_Properties (pctxt, &pvalue->properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.propertiesPresent = TRUE;
         break;
      }
      case 1: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      case 2: {
         Option* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Option);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Option (pdata1);

            stat = XmlDec_Option (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->option_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 2, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Checkbox_current_state                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Checkbox_current_state (OSCTXT* pctxt, 
   Checkbox_current_state *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Checkbox_current_state (OSCTXT* pctxt, 
   Checkbox_current_state* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Checkbox_current_state_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Checkbox_disabled                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Checkbox_disabled (OSCTXT* pctxt, Checkbox_disabled *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Checkbox_disabled (OSCTXT* pctxt, Checkbox_disabled* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Checkbox_disabled_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Checkbox_image_align                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Checkbox_image_align (OSCTXT* pctxt, 
   Checkbox_image_align *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Checkbox_image_align (OSCTXT* pctxt, Checkbox_image_align* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Checkbox_image_align_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Checkbox_image_position                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Checkbox_image_position (OSCTXT* pctxt, 
   Checkbox_image_position *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Checkbox_image_position (OSCTXT* pctxt, 
   Checkbox_image_position* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Checkbox_image_position_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Checkbox_is_tristate                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Checkbox_is_tristate (OSCTXT* pctxt, 
   Checkbox_is_tristate *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Checkbox_is_tristate (OSCTXT* pctxt, Checkbox_is_tristate* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Checkbox_is_tristate_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Checkbox_printable                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Checkbox_printable (OSCTXT* pctxt, 
   Checkbox_printable *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Checkbox_printable (OSCTXT* pctxt, Checkbox_printable* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Checkbox_printable_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Checkbox_state                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Checkbox_state (OSCTXT* pctxt, Checkbox_state *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Checkbox_state (OSCTXT* pctxt, Checkbox_state* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Checkbox_state_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Checkbox_tab_stop                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Checkbox_tab_stop (OSCTXT* pctxt, Checkbox_tab_stop *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Checkbox_tab_stop (OSCTXT* pctxt, Checkbox_tab_stop* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Checkbox_tab_stop_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Checkbox_visual_effect                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Checkbox_visual_effect (OSCTXT* pctxt, 
   Checkbox_visual_effect *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Checkbox_visual_effect (OSCTXT* pctxt, 
   Checkbox_visual_effect* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Checkbox_visual_effect_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Checkbox                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Checkbox (OSCTXT* pctxt, Checkbox *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bind */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Bind (pctxt, 
               (Bind*)&pvalue->bind, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bindPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode control_implementation */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->control_implementation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.control_implementationPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode current_state */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Checkbox_current_state (pctxt, 
               &pvalue->current_state, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.current_statePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode data_field */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->data_field, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_fieldPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode disabled */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Checkbox_disabled (pctxt, 
               &pvalue->disabled, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.disabledPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode image_align */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Checkbox_image_align (pctxt, 
               &pvalue->image_align, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.image_alignPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode image_position */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Checkbox_image_position (pctxt, 
               &pvalue->image_position, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.image_positionPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode is_tristate */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Checkbox_is_tristate (pctxt, 
               &pvalue->is_tristate, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.is_tristatePresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode label */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->label, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.labelPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode printable */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Checkbox_printable (pctxt, 
               &pvalue->printable, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.printablePresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode state */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Checkbox_state (pctxt, 
               &pvalue->state, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.statePresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode tab_index */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->tab_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_indexPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode tab_stop */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Checkbox_tab_stop (pctxt, 
               &pvalue->tab_stop, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_stopPresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode title */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->title, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.titlePresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.valuePresent = TRUE;
            }
         }
         break;

      case 17:
         /* decode visual_effect */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Checkbox_visual_effect (pctxt, 
               &pvalue->visual_effect, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.visual_effectPresent = TRUE;
            }
         }
         break;

      case 18:
         /* decode properties */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Properties (pctxt, 
               &pvalue->properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 19:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x93)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_PRIM|16):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_PRIM|17):
         case (TM_CTXT|TM_CONS|18):
         case (TM_CTXT|TM_CONS|19):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Checkbox (OSCTXT* pctxt, Checkbox* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bind"), 4}, 0 },
         { {OSUTF8("control-implementation"), 22}, 0 },
         { {OSUTF8("current-state"), 13}, 0 },
         { {OSUTF8("data-field"), 10}, 0 },
         { {OSUTF8("disabled"), 8}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("image-align"), 11}, 0 },
         { {OSUTF8("image-position"), 14}, 0 },
         { {OSUTF8("is-tristate"), 11}, 0 },
         { {OSUTF8("label"), 5}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("printable"), 9}, 0 },
         { {OSUTF8("state"), 5}, 0 },
         { {OSUTF8("tab-index"), 9}, 0 },
         { {OSUTF8("tab-stop"), 8}, 0 },
         { {OSUTF8("title"), 5}, 0 },
         { {OSUTF8("value"), 5}, 0 },
         { {OSUTF8("visual-effect"), 13}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 18, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bind */
            stat = XmlDec_Bind (pctxt, &pvalue->bind);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bindPresent = TRUE;
            break;

         case 1: /* control-implementation */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->control_implementation
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.control_implementationPresent = TRUE;
            break;

         case 2: /* current-state */
            stat = XmlDec_Checkbox_current_state (pctxt, &pvalue->current_state
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.current_statePresent = TRUE;
            break;

         case 3: /* data-field */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->data_field);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_fieldPresent = TRUE;
            break;

         case 4: /* disabled */
            stat = XmlDec_Checkbox_disabled (pctxt, &pvalue->disabled);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.disabledPresent = TRUE;
            break;

         case 5: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 6: /* image-align */
            stat = XmlDec_Checkbox_image_align (pctxt, &pvalue->image_align);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.image_alignPresent = TRUE;
            break;

         case 7: /* image-position */
            stat = XmlDec_Checkbox_image_position (pctxt, &pvalue->
               image_position);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.image_positionPresent = TRUE;
            break;

         case 8: /* is-tristate */
            stat = XmlDec_Checkbox_is_tristate (pctxt, &pvalue->is_tristate);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.is_tristatePresent = TRUE;
            break;

         case 9: /* label */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->label);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.labelPresent = TRUE;
            break;

         case 10: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 11: /* printable */
            stat = XmlDec_Checkbox_printable (pctxt, &pvalue->printable);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.printablePresent = TRUE;
            break;

         case 12: /* state */
            stat = XmlDec_Checkbox_state (pctxt, &pvalue->state);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.statePresent = TRUE;
            break;

         case 13: /* tab-index */
            stat = rtXmlpDecUInt (pctxt, &pvalue->tab_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_indexPresent = TRUE;
            break;

         case 14: /* tab-stop */
            stat = XmlDec_Checkbox_tab_stop (pctxt, &pvalue->tab_stop);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_stopPresent = TRUE;
            break;

         case 15: /* title */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->title);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.titlePresent = TRUE;
            break;

         case 16: /* value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.valuePresent = TRUE;
            break;

         case 17: /* visual-effect */
            stat = XmlDec_Checkbox_visual_effect (pctxt, &pvalue->visual_effect
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.visual_effectPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Checkbox");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Checkbox");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("properties"), 10}, 0}, 0 },
      {{{OSUTF8("event-listeners"), 15}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* properties */
         stat = XmlDec_Properties (pctxt, &pvalue->properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.propertiesPresent = TRUE;
         break;
      }
      case 1: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Password_convert_empty_to_null                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Password_convert_empty_to_null (OSCTXT* pctxt, 
   Password_convert_empty_to_null *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Password_convert_empty_to_null (OSCTXT* pctxt, 
   Password_convert_empty_to_null* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Password_convert_empty_to_null_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Password_disabled                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Password_disabled (OSCTXT* pctxt, Password_disabled *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Password_disabled (OSCTXT* pctxt, Password_disabled* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Password_disabled_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Password_printable                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Password_printable (OSCTXT* pctxt, 
   Password_printable *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Password_printable (OSCTXT* pctxt, Password_printable* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Password_printable_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Password_tab_stop                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Password_tab_stop (OSCTXT* pctxt, Password_tab_stop *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Password_tab_stop (OSCTXT* pctxt, Password_tab_stop* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Password_tab_stop_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Password                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Password (OSCTXT* pctxt, Password *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bind */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Bind (pctxt, 
               (Bind*)&pvalue->bind, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bindPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode control_implementation */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->control_implementation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.control_implementationPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode convert_empty_to_null */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Password_convert_empty_to_null (pctxt, 
               &pvalue->convert_empty_to_null, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.convert_empty_to_nullPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode disabled */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Password_disabled (pctxt, 
               &pvalue->disabled, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.disabledPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode echo_char */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->echo_char, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.echo_charPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode max_length */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->max_length, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.max_lengthPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode printable */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Password_printable (pctxt, 
               &pvalue->printable, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.printablePresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode tab_index */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->tab_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_indexPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode tab_stop */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Password_tab_stop (pctxt, 
               &pvalue->tab_stop, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_stopPresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode title */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->title, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.titlePresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.valuePresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode properties */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Properties (pctxt, 
               &pvalue->properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 14:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_CONS|14):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Password (OSCTXT* pctxt, Password* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bind"), 4}, 0 },
         { {OSUTF8("control-implementation"), 22}, 0 },
         { {OSUTF8("convert-empty-to-null"), 21}, 0 },
         { {OSUTF8("disabled"), 8}, 0 },
         { {OSUTF8("echo-char"), 9}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("max-length"), 10}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("printable"), 9}, 0 },
         { {OSUTF8("tab-index"), 9}, 0 },
         { {OSUTF8("tab-stop"), 8}, 0 },
         { {OSUTF8("title"), 5}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 13, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bind */
            stat = XmlDec_Bind (pctxt, &pvalue->bind);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bindPresent = TRUE;
            break;

         case 1: /* control-implementation */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->control_implementation
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.control_implementationPresent = TRUE;
            break;

         case 2: /* convert-empty-to-null */
            stat = XmlDec_Password_convert_empty_to_null (pctxt, &pvalue->
               convert_empty_to_null);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.convert_empty_to_nullPresent = TRUE;
            break;

         case 3: /* disabled */
            stat = XmlDec_Password_disabled (pctxt, &pvalue->disabled);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.disabledPresent = TRUE;
            break;

         case 4: /* echo-char */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->echo_char);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.echo_charPresent = TRUE;
            break;

         case 5: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 6: /* max-length */
            stat = rtXmlpDecUInt (pctxt, &pvalue->max_length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.max_lengthPresent = TRUE;
            break;

         case 7: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 8: /* printable */
            stat = XmlDec_Password_printable (pctxt, &pvalue->printable);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.printablePresent = TRUE;
            break;

         case 9: /* tab-index */
            stat = rtXmlpDecUInt (pctxt, &pvalue->tab_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_indexPresent = TRUE;
            break;

         case 10: /* tab-stop */
            stat = XmlDec_Password_tab_stop (pctxt, &pvalue->tab_stop);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_stopPresent = TRUE;
            break;

         case 11: /* title */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->title);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.titlePresent = TRUE;
            break;

         case 12: /* value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.valuePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Password");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Password");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("properties"), 10}, 0}, 0 },
      {{{OSUTF8("event-listeners"), 15}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* properties */
         stat = XmlDec_Properties (pctxt, &pvalue->properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.propertiesPresent = TRUE;
         break;
      }
      case 1: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  File_disabled                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_File_disabled (OSCTXT* pctxt, File_disabled *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_File_disabled (OSCTXT* pctxt, File_disabled* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = File_disabled_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  File_printable                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_File_printable (OSCTXT* pctxt, File_printable *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_File_printable (OSCTXT* pctxt, File_printable* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = File_printable_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  File_readonly                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_File_readonly (OSCTXT* pctxt, File_readonly *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_File_readonly (OSCTXT* pctxt, File_readonly* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = File_readonly_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  File_tab_stop                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_File_tab_stop (OSCTXT* pctxt, File_tab_stop *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_File_tab_stop (OSCTXT* pctxt, File_tab_stop* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = File_tab_stop_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  File                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_File (OSCTXT* pctxt, File *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bind */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Bind (pctxt, 
               (Bind*)&pvalue->bind, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bindPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode control_implementation */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->control_implementation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.control_implementationPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode current_value */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->current_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.current_valuePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode disabled */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_File_disabled (pctxt, 
               &pvalue->disabled, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.disabledPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode max_length */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->max_length, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.max_lengthPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode printable */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_File_printable (pctxt, 
               &pvalue->printable, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.printablePresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode readonly */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_File_readonly (pctxt, 
               &pvalue->readonly, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.readonlyPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode tab_index */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->tab_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_indexPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode tab_stop */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_File_tab_stop (pctxt, 
               &pvalue->tab_stop, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_stopPresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode title */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->title, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.titlePresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.valuePresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode properties */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Properties (pctxt, 
               &pvalue->properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 14:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_CONS|14):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_File (OSCTXT* pctxt, File* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bind"), 4}, 0 },
         { {OSUTF8("control-implementation"), 22}, 0 },
         { {OSUTF8("current-value"), 13}, 0 },
         { {OSUTF8("disabled"), 8}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("max-length"), 10}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("printable"), 9}, 0 },
         { {OSUTF8("readonly"), 8}, 0 },
         { {OSUTF8("tab-index"), 9}, 0 },
         { {OSUTF8("tab-stop"), 8}, 0 },
         { {OSUTF8("title"), 5}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 13, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bind */
            stat = XmlDec_Bind (pctxt, &pvalue->bind);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bindPresent = TRUE;
            break;

         case 1: /* control-implementation */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->control_implementation
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.control_implementationPresent = TRUE;
            break;

         case 2: /* current-value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->current_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.current_valuePresent = TRUE;
            break;

         case 3: /* disabled */
            stat = XmlDec_File_disabled (pctxt, &pvalue->disabled);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.disabledPresent = TRUE;
            break;

         case 4: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* max-length */
            stat = rtXmlpDecUInt (pctxt, &pvalue->max_length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.max_lengthPresent = TRUE;
            break;

         case 6: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 7: /* printable */
            stat = XmlDec_File_printable (pctxt, &pvalue->printable);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.printablePresent = TRUE;
            break;

         case 8: /* readonly */
            stat = XmlDec_File_readonly (pctxt, &pvalue->readonly);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.readonlyPresent = TRUE;
            break;

         case 9: /* tab-index */
            stat = rtXmlpDecUInt (pctxt, &pvalue->tab_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_indexPresent = TRUE;
            break;

         case 10: /* tab-stop */
            stat = XmlDec_File_tab_stop (pctxt, &pvalue->tab_stop);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_stopPresent = TRUE;
            break;

         case 11: /* title */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->title);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.titlePresent = TRUE;
            break;

         case 12: /* value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.valuePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "File");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "File");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("properties"), 10}, 0}, 0 },
      {{{OSUTF8("event-listeners"), 15}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* properties */
         stat = XmlDec_Properties (pctxt, &pvalue->properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.propertiesPresent = TRUE;
         break;
      }
      case 1: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Time_convert_empty_to_null                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Time_convert_empty_to_null (OSCTXT* pctxt, 
   Time_convert_empty_to_null *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Time_convert_empty_to_null (OSCTXT* pctxt, 
   Time_convert_empty_to_null* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Time_convert_empty_to_null_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Time_disabled                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Time_disabled (OSCTXT* pctxt, Time_disabled *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Time_disabled (OSCTXT* pctxt, Time_disabled* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Time_disabled_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Time_printable                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Time_printable (OSCTXT* pctxt, Time_printable *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Time_printable (OSCTXT* pctxt, Time_printable* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Time_printable_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Time_readonly                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Time_readonly (OSCTXT* pctxt, Time_readonly *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Time_readonly (OSCTXT* pctxt, Time_readonly* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Time_readonly_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Time_tab_stop                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Time_tab_stop (OSCTXT* pctxt, Time_tab_stop *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Time_tab_stop (OSCTXT* pctxt, Time_tab_stop* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Time_tab_stop_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Time                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns4_Time (OSCTXT* pctxt, Ns4_Time *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bind */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Bind (pctxt, 
               (Bind*)&pvalue->bind, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bindPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode control_implementation */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->control_implementation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.control_implementationPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode convert_empty_to_null */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Time_convert_empty_to_null (pctxt, 
               &pvalue->convert_empty_to_null, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.convert_empty_to_nullPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode current_value */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_charstr (pctxt, &pvalue->current_value, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|26), length);
            if (stat == 0) {
               pvalue->m.current_valuePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode data_field */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->data_field, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_fieldPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode disabled */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Time_disabled (pctxt, 
               &pvalue->disabled, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.disabledPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode max_length */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->max_length, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.max_lengthPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode max_value */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_charstr (pctxt, &pvalue->max_value, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|26), length);
            if (stat == 0) {
               pvalue->m.max_valuePresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode min_value */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_charstr (pctxt, &pvalue->min_value, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|26), length);
            if (stat == 0) {
               pvalue->m.min_valuePresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode printable */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Time_printable (pctxt, 
               &pvalue->printable, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.printablePresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode readonly */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Time_readonly (pctxt, 
               &pvalue->readonly, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.readonlyPresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode tab_index */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->tab_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_indexPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode tab_stop */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Time_tab_stop (pctxt, 
               &pvalue->tab_stop, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_stopPresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode title */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->title, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.titlePresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_charstr (pctxt, &pvalue->value, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|26), length);
            if (stat == 0) {
               pvalue->m.valuePresent = TRUE;
            }
         }
         break;

      case 17:
         /* decode properties */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Properties (pctxt, 
               &pvalue->properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 18:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_PRIM|16):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_CONS|17):
         case (TM_CTXT|TM_CONS|18):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns4_Time (OSCTXT* pctxt, Ns4_Time* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bind"), 4}, 0 },
         { {OSUTF8("control-implementation"), 22}, 0 },
         { {OSUTF8("convert-empty-to-null"), 21}, 0 },
         { {OSUTF8("current-value"), 13}, 0 },
         { {OSUTF8("data-field"), 10}, 0 },
         { {OSUTF8("disabled"), 8}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("max-length"), 10}, 0 },
         { {OSUTF8("max-value"), 9}, 0 },
         { {OSUTF8("min-value"), 9}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("printable"), 9}, 0 },
         { {OSUTF8("readonly"), 8}, 0 },
         { {OSUTF8("tab-index"), 9}, 0 },
         { {OSUTF8("tab-stop"), 8}, 0 },
         { {OSUTF8("title"), 5}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 17, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bind */
            stat = XmlDec_Bind (pctxt, &pvalue->bind);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bindPresent = TRUE;
            break;

         case 1: /* control-implementation */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->control_implementation
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.control_implementationPresent = TRUE;
            break;

         case 2: /* convert-empty-to-null */
            stat = XmlDec_Time_convert_empty_to_null (pctxt, &pvalue->
               convert_empty_to_null);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.convert_empty_to_nullPresent = TRUE;
            break;

         case 3: /* current-value */
            stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)&pvalue->
               current_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.current_valuePresent = TRUE;
            break;

         case 4: /* data-field */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->data_field);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_fieldPresent = TRUE;
            break;

         case 5: /* disabled */
            stat = XmlDec_Time_disabled (pctxt, &pvalue->disabled);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.disabledPresent = TRUE;
            break;

         case 6: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 7: /* max-length */
            stat = rtXmlpDecUInt (pctxt, &pvalue->max_length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.max_lengthPresent = TRUE;
            break;

         case 8: /* max-value */
            stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)&pvalue->
               max_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.max_valuePresent = TRUE;
            break;

         case 9: /* min-value */
            stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)&pvalue->
               min_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.min_valuePresent = TRUE;
            break;

         case 10: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 11: /* printable */
            stat = XmlDec_Time_printable (pctxt, &pvalue->printable);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.printablePresent = TRUE;
            break;

         case 12: /* readonly */
            stat = XmlDec_Time_readonly (pctxt, &pvalue->readonly);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.readonlyPresent = TRUE;
            break;

         case 13: /* tab-index */
            stat = rtXmlpDecUInt (pctxt, &pvalue->tab_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_indexPresent = TRUE;
            break;

         case 14: /* tab-stop */
            stat = XmlDec_Time_tab_stop (pctxt, &pvalue->tab_stop);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_stopPresent = TRUE;
            break;

         case 15: /* title */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->title);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.titlePresent = TRUE;
            break;

         case 16: /* value */
            stat = rtXmlpDecDynUTF8Str (pctxt, (const OSUTF8CHAR**)&pvalue->
               value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.valuePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns4_Time");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns4_Time");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("properties"), 10}, 0}, 0 },
      {{{OSUTF8("event-listeners"), 15}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* properties */
         stat = XmlDec_Properties (pctxt, &pvalue->properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.propertiesPresent = TRUE;
         break;
      }
      case 1: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Fixed_text_disabled                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Fixed_text_disabled (OSCTXT* pctxt, 
   Fixed_text_disabled *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Fixed_text_disabled (OSCTXT* pctxt, Fixed_text_disabled* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Fixed_text_disabled_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Fixed_text_multi_line                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Fixed_text_multi_line (OSCTXT* pctxt, 
   Fixed_text_multi_line *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Fixed_text_multi_line (OSCTXT* pctxt, Fixed_text_multi_line* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Fixed_text_multi_line_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Fixed_text_printable                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Fixed_text_printable (OSCTXT* pctxt, 
   Fixed_text_printable *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Fixed_text_printable (OSCTXT* pctxt, Fixed_text_printable* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Fixed_text_printable_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Fixed_text                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Fixed_text (OSCTXT* pctxt, Fixed_text *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bind */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Bind (pctxt, 
               (Bind*)&pvalue->bind, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bindPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode control_implementation */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->control_implementation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.control_implementationPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode disabled */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Fixed_text_disabled (pctxt, 
               &pvalue->disabled, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.disabledPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode for_ */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->for_, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.for_Present = TRUE;
            }
         }
         break;

      case 4:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode label */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->label, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.labelPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode multi_line */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Fixed_text_multi_line (pctxt, 
               &pvalue->multi_line, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.multi_linePresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode printable */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Fixed_text_printable (pctxt, 
               &pvalue->printable, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.printablePresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode title */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->title, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.titlePresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode properties */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Properties (pctxt, 
               &pvalue->properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 11:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_CONS|11):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Fixed_text (OSCTXT* pctxt, Fixed_text* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bind"), 4}, 0 },
         { {OSUTF8("control-implementation"), 22}, 0 },
         { {OSUTF8("disabled"), 8}, 0 },
         { {OSUTF8("for"), 3}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("label"), 5}, 0 },
         { {OSUTF8("multi-line"), 10}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("printable"), 9}, 0 },
         { {OSUTF8("title"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 10, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bind */
            stat = XmlDec_Bind (pctxt, &pvalue->bind);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bindPresent = TRUE;
            break;

         case 1: /* control-implementation */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->control_implementation
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.control_implementationPresent = TRUE;
            break;

         case 2: /* disabled */
            stat = XmlDec_Fixed_text_disabled (pctxt, &pvalue->disabled);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.disabledPresent = TRUE;
            break;

         case 3: /* for */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->for_);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.for_Present = TRUE;
            break;

         case 4: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* label */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->label);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.labelPresent = TRUE;
            break;

         case 6: /* multi-line */
            stat = XmlDec_Fixed_text_multi_line (pctxt, &pvalue->multi_line);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.multi_linePresent = TRUE;
            break;

         case 7: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 8: /* printable */
            stat = XmlDec_Fixed_text_printable (pctxt, &pvalue->printable);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.printablePresent = TRUE;
            break;

         case 9: /* title */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->title);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.titlePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Fixed_text");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Fixed_text");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("properties"), 10}, 0}, 0 },
      {{{OSUTF8("event-listeners"), 15}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* properties */
         stat = XmlDec_Properties (pctxt, &pvalue->properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.propertiesPresent = TRUE;
         break;
      }
      case 1: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Button_button_type                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Button_button_type (OSCTXT* pctxt, 
   Button_button_type *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Button_button_type (OSCTXT* pctxt, Button_button_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Button_button_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Button_default_button                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Button_default_button (OSCTXT* pctxt, 
   Button_default_button *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Button_default_button (OSCTXT* pctxt, Button_default_button* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Button_default_button_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Button_disabled                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Button_disabled (OSCTXT* pctxt, Button_disabled *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Button_disabled (OSCTXT* pctxt, Button_disabled* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Button_disabled_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Button_focus_on_click                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Button_focus_on_click (OSCTXT* pctxt, 
   Button_focus_on_click *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Button_focus_on_click (OSCTXT* pctxt, Button_focus_on_click* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Button_focus_on_click_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Button_image_align                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Button_image_align (OSCTXT* pctxt, 
   Button_image_align *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Button_image_align (OSCTXT* pctxt, Button_image_align* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Button_image_align_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Button_image_position                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Button_image_position (OSCTXT* pctxt, 
   Button_image_position *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Button_image_position (OSCTXT* pctxt, Button_image_position* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Button_image_position_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Button_printable                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Button_printable (OSCTXT* pctxt, Button_printable *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Button_printable (OSCTXT* pctxt, Button_printable* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Button_printable_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Button_tab_stop                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Button_tab_stop (OSCTXT* pctxt, Button_tab_stop *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Button_tab_stop (OSCTXT* pctxt, Button_tab_stop* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Button_tab_stop_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Button_toggle                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Button_toggle (OSCTXT* pctxt, Button_toggle *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Button_toggle (OSCTXT* pctxt, Button_toggle* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Button_toggle_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Button                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Button (OSCTXT* pctxt, Button *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode href */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Href (pctxt, 
               &pvalue->href, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.hrefPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode bind */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Bind (pctxt, 
               (Bind*)&pvalue->bind, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bindPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode button_type */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Button_button_type (pctxt, 
               &pvalue->button_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.button_typePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode control_implementation */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->control_implementation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.control_implementationPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode default_button */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Button_default_button (pctxt, 
               &pvalue->default_button, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.default_buttonPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode disabled */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Button_disabled (pctxt, 
               &pvalue->disabled, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.disabledPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode focus_on_click */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Button_focus_on_click (pctxt, 
               &pvalue->focus_on_click, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.focus_on_clickPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 8:
         /* decode image_align */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Button_image_align (pctxt, 
               &pvalue->image_align, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.image_alignPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode image_data */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->image_data, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.image_dataPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode image_position */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Button_image_position (pctxt, 
               &pvalue->image_position, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.image_positionPresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode label */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->label, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.labelPresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode printable */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Button_printable (pctxt, 
               &pvalue->printable, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.printablePresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode tab_index */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->tab_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_indexPresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode tab_stop */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Button_tab_stop (pctxt, 
               &pvalue->tab_stop, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_stopPresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode title */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->title, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.titlePresent = TRUE;
            }
         }
         break;

      case 17:
         /* decode toggle */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Button_toggle (pctxt, 
               &pvalue->toggle, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.togglePresent = TRUE;
            }
         }
         break;

      case 18:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.valuePresent = TRUE;
            }
         }
         break;

      case 19:
         /* decode xforms_submission */
         if (XD_PEEKTAG (pctxt, 0x93)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->xforms_submission, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.xforms_submissionPresent = TRUE;
            }
         }
         break;

      case 20:
         /* decode target_frame */
         if (XD_PEEKTAG (pctxt, 0x94)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->target_frame = rtxMemAllocType (pctxt, Ns13_Target_frame);

            if (pvalue->target_frame == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Target_frame ((Ns13_Target_frame*)pvalue->target_frame);
            asn1Init_Ns13_Target_frame ((Ns13_Target_frame*)pvalue->target_frame);

            stat = asn1D_Ns13_Target_frame (pctxt, 
               (Ns13_Target_frame*)pvalue->target_frame, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.target_framePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 21:
         /* decode properties */
         if (XD_PEEKTAG (pctxt, 0x95)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Properties (pctxt, 
               &pvalue->properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 22:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x96)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_PRIM|16):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_PRIM|17):
         case (TM_CTXT|TM_PRIM|18):
         case (TM_CTXT|TM_CONS|18):
         case (TM_CTXT|TM_PRIM|19):
         case (TM_CTXT|TM_CONS|19):
         case (TM_CTXT|TM_CONS|20):
         case (TM_CTXT|TM_CONS|21):
         case (TM_CTXT|TM_CONS|22):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Button (OSCTXT* pctxt, Button* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("href"), 4}, 0 },
         { {OSUTF8("bind"), 4}, 0 },
         { {OSUTF8("button-type"), 11}, 0 },
         { {OSUTF8("control-implementation"), 22}, 0 },
         { {OSUTF8("default-button"), 14}, 0 },
         { {OSUTF8("disabled"), 8}, 0 },
         { {OSUTF8("focus-on-click"), 14}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("image-align"), 11}, 0 },
         { {OSUTF8("image-data"), 10}, 0 },
         { {OSUTF8("image-position"), 14}, 0 },
         { {OSUTF8("label"), 5}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("printable"), 9}, 0 },
         { {OSUTF8("tab-index"), 9}, 0 },
         { {OSUTF8("tab-stop"), 8}, 0 },
         { {OSUTF8("title"), 5}, 0 },
         { {OSUTF8("toggle"), 6}, 0 },
         { {OSUTF8("value"), 5}, 0 },
         { {OSUTF8("xforms-submission"), 17}, 0 },
         { {OSUTF8("target-frame"), 12}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 21, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* href */
            stat = XmlDec_Xlink_Href (pctxt, &pvalue->href);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.hrefPresent = TRUE;
            break;

         case 1: /* bind */
            stat = XmlDec_Bind (pctxt, &pvalue->bind);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bindPresent = TRUE;
            break;

         case 2: /* button-type */
            stat = XmlDec_Button_button_type (pctxt, &pvalue->button_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.button_typePresent = TRUE;
            break;

         case 3: /* control-implementation */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->control_implementation
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.control_implementationPresent = TRUE;
            break;

         case 4: /* default-button */
            stat = XmlDec_Button_default_button (pctxt, &pvalue->default_button
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.default_buttonPresent = TRUE;
            break;

         case 5: /* disabled */
            stat = XmlDec_Button_disabled (pctxt, &pvalue->disabled);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.disabledPresent = TRUE;
            break;

         case 6: /* focus-on-click */
            stat = XmlDec_Button_focus_on_click (pctxt, &pvalue->focus_on_click
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.focus_on_clickPresent = TRUE;
            break;

         case 7: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 8: /* image-align */
            stat = XmlDec_Button_image_align (pctxt, &pvalue->image_align);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.image_alignPresent = TRUE;
            break;

         case 9: /* image-data */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->image_data);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.image_dataPresent = TRUE;
            break;

         case 10: /* image-position */
            stat = XmlDec_Button_image_position (pctxt, &pvalue->image_position
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.image_positionPresent = TRUE;
            break;

         case 11: /* label */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->label);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.labelPresent = TRUE;
            break;

         case 12: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 13: /* printable */
            stat = XmlDec_Button_printable (pctxt, &pvalue->printable);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.printablePresent = TRUE;
            break;

         case 14: /* tab-index */
            stat = rtXmlpDecUInt (pctxt, &pvalue->tab_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_indexPresent = TRUE;
            break;

         case 15: /* tab-stop */
            stat = XmlDec_Button_tab_stop (pctxt, &pvalue->tab_stop);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_stopPresent = TRUE;
            break;

         case 16: /* title */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->title);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.titlePresent = TRUE;
            break;

         case 17: /* toggle */
            stat = XmlDec_Button_toggle (pctxt, &pvalue->toggle);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.togglePresent = TRUE;
            break;

         case 18: /* value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.valuePresent = TRUE;
            break;

         case 19: /* xforms-submission */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->xforms_submission);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.xforms_submissionPresent = TRUE;
            break;

         case 20: /* target-frame */
            pvalue->target_frame = rtxMemAllocType (pctxt, Ns13_Target_frame);

            if (pvalue->target_frame == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Target_frame ((Ns13_Target_frame*)pvalue->
               target_frame);

            stat = XmlDec_Ns13_Target_frame (pctxt, pvalue->target_frame);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.target_framePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Button");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Button");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("properties"), 10}, 0}, 0 },
      {{{OSUTF8("event-listeners"), 15}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* properties */
         stat = XmlDec_Properties (pctxt, &pvalue->properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.propertiesPresent = TRUE;
         break;
      }
      case 1: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Image_button_type                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Image_button_type (OSCTXT* pctxt, Image_button_type *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Image_button_type (OSCTXT* pctxt, Image_button_type* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Image_button_type_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Image_disabled                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Image_disabled (OSCTXT* pctxt, Image_disabled *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Image_disabled (OSCTXT* pctxt, Image_disabled* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Image_disabled_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Image_printable                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Image_printable (OSCTXT* pctxt, Image_printable *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Image_printable (OSCTXT* pctxt, Image_printable* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Image_printable_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Image_tab_stop                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Image_tab_stop (OSCTXT* pctxt, Image_tab_stop *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Image_tab_stop (OSCTXT* pctxt, Image_tab_stop* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Image_tab_stop_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Image                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns4_Image (OSCTXT* pctxt, Ns4_Image *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode href */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Href (pctxt, 
               &pvalue->href, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.hrefPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode bind */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Bind (pctxt, 
               (Bind*)&pvalue->bind, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bindPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode button_type */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Image_button_type (pctxt, 
               &pvalue->button_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.button_typePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode control_implementation */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->control_implementation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.control_implementationPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode disabled */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Image_disabled (pctxt, 
               &pvalue->disabled, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.disabledPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode image_data */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->image_data, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.image_dataPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode printable */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Image_printable (pctxt, 
               &pvalue->printable, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.printablePresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode tab_index */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->tab_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_indexPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode tab_stop */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Image_tab_stop (pctxt, 
               &pvalue->tab_stop, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_stopPresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode title */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->title, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.titlePresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.valuePresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode target_frame */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->target_frame = rtxMemAllocType (pctxt, Ns13_Target_frame);

            if (pvalue->target_frame == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Target_frame ((Ns13_Target_frame*)pvalue->target_frame);
            asn1Init_Ns13_Target_frame ((Ns13_Target_frame*)pvalue->target_frame);

            stat = asn1D_Ns13_Target_frame (pctxt, 
               (Ns13_Target_frame*)pvalue->target_frame, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.target_framePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 14:
         /* decode properties */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Properties (pctxt, 
               &pvalue->properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 15:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_CONS|15):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns4_Image (OSCTXT* pctxt, Ns4_Image* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("href"), 4}, 0 },
         { {OSUTF8("bind"), 4}, 0 },
         { {OSUTF8("button-type"), 11}, 0 },
         { {OSUTF8("control-implementation"), 22}, 0 },
         { {OSUTF8("disabled"), 8}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("image-data"), 10}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("printable"), 9}, 0 },
         { {OSUTF8("tab-index"), 9}, 0 },
         { {OSUTF8("tab-stop"), 8}, 0 },
         { {OSUTF8("title"), 5}, 0 },
         { {OSUTF8("value"), 5}, 0 },
         { {OSUTF8("target-frame"), 12}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 14, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* href */
            stat = XmlDec_Xlink_Href (pctxt, &pvalue->href);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.hrefPresent = TRUE;
            break;

         case 1: /* bind */
            stat = XmlDec_Bind (pctxt, &pvalue->bind);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bindPresent = TRUE;
            break;

         case 2: /* button-type */
            stat = XmlDec_Image_button_type (pctxt, &pvalue->button_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.button_typePresent = TRUE;
            break;

         case 3: /* control-implementation */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->control_implementation
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.control_implementationPresent = TRUE;
            break;

         case 4: /* disabled */
            stat = XmlDec_Image_disabled (pctxt, &pvalue->disabled);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.disabledPresent = TRUE;
            break;

         case 5: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 6: /* image-data */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->image_data);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.image_dataPresent = TRUE;
            break;

         case 7: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 8: /* printable */
            stat = XmlDec_Image_printable (pctxt, &pvalue->printable);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.printablePresent = TRUE;
            break;

         case 9: /* tab-index */
            stat = rtXmlpDecUInt (pctxt, &pvalue->tab_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_indexPresent = TRUE;
            break;

         case 10: /* tab-stop */
            stat = XmlDec_Image_tab_stop (pctxt, &pvalue->tab_stop);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_stopPresent = TRUE;
            break;

         case 11: /* title */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->title);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.titlePresent = TRUE;
            break;

         case 12: /* value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.valuePresent = TRUE;
            break;

         case 13: /* target-frame */
            pvalue->target_frame = rtxMemAllocType (pctxt, Ns13_Target_frame);

            if (pvalue->target_frame == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Target_frame ((Ns13_Target_frame*)pvalue->
               target_frame);

            stat = XmlDec_Ns13_Target_frame (pctxt, pvalue->target_frame);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.target_framePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns4_Image");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns4_Image");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("properties"), 10}, 0}, 0 },
      {{{OSUTF8("event-listeners"), 15}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* properties */
         stat = XmlDec_Properties (pctxt, &pvalue->properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.propertiesPresent = TRUE;
         break;
      }
      case 1: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Radio_current_selected                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Radio_current_selected (OSCTXT* pctxt, 
   Radio_current_selected *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Radio_current_selected (OSCTXT* pctxt, 
   Radio_current_selected* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Radio_current_selected_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Radio_disabled                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Radio_disabled (OSCTXT* pctxt, Radio_disabled *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Radio_disabled (OSCTXT* pctxt, Radio_disabled* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Radio_disabled_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Radio_image_align                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Radio_image_align (OSCTXT* pctxt, Radio_image_align *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Radio_image_align (OSCTXT* pctxt, Radio_image_align* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Radio_image_align_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Radio_image_position                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Radio_image_position (OSCTXT* pctxt, 
   Radio_image_position *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Radio_image_position (OSCTXT* pctxt, Radio_image_position* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Radio_image_position_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Radio_printable                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Radio_printable (OSCTXT* pctxt, Radio_printable *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Radio_printable (OSCTXT* pctxt, Radio_printable* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Radio_printable_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Radio_selected                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Radio_selected (OSCTXT* pctxt, Radio_selected *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Radio_selected (OSCTXT* pctxt, Radio_selected* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Radio_selected_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Radio_tab_stop                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Radio_tab_stop (OSCTXT* pctxt, Radio_tab_stop *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Radio_tab_stop (OSCTXT* pctxt, Radio_tab_stop* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Radio_tab_stop_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Radio_visual_effect                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Radio_visual_effect (OSCTXT* pctxt, 
   Radio_visual_effect *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Radio_visual_effect (OSCTXT* pctxt, Radio_visual_effect* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Radio_visual_effect_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Radio                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Radio (OSCTXT* pctxt, Radio *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bind */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Bind (pctxt, 
               (Bind*)&pvalue->bind, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bindPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode control_implementation */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->control_implementation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.control_implementationPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode current_selected */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Radio_current_selected (pctxt, 
               &pvalue->current_selected, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.current_selectedPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode data_field */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->data_field, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_fieldPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode disabled */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Radio_disabled (pctxt, 
               &pvalue->disabled, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.disabledPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode image_align */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Radio_image_align (pctxt, 
               &pvalue->image_align, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.image_alignPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode image_position */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Radio_image_position (pctxt, 
               &pvalue->image_position, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.image_positionPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode label */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->label, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.labelPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode printable */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Radio_printable (pctxt, 
               &pvalue->printable, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.printablePresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode selected */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Radio_selected (pctxt, 
               &pvalue->selected, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.selectedPresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode tab_index */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->tab_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_indexPresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode tab_stop */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Radio_tab_stop (pctxt, 
               &pvalue->tab_stop, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_stopPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode title */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->title, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.titlePresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.valuePresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode visual_effect */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Radio_visual_effect (pctxt, 
               &pvalue->visual_effect, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.visual_effectPresent = TRUE;
            }
         }
         break;

      case 17:
         /* decode properties */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Properties (pctxt, 
               &pvalue->properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 18:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_PRIM|16):
         case (TM_CTXT|TM_CONS|17):
         case (TM_CTXT|TM_CONS|18):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Radio (OSCTXT* pctxt, Radio* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bind"), 4}, 0 },
         { {OSUTF8("control-implementation"), 22}, 0 },
         { {OSUTF8("current-selected"), 16}, 0 },
         { {OSUTF8("data-field"), 10}, 0 },
         { {OSUTF8("disabled"), 8}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("image-align"), 11}, 0 },
         { {OSUTF8("image-position"), 14}, 0 },
         { {OSUTF8("label"), 5}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("printable"), 9}, 0 },
         { {OSUTF8("selected"), 8}, 0 },
         { {OSUTF8("tab-index"), 9}, 0 },
         { {OSUTF8("tab-stop"), 8}, 0 },
         { {OSUTF8("title"), 5}, 0 },
         { {OSUTF8("value"), 5}, 0 },
         { {OSUTF8("visual-effect"), 13}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 17, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bind */
            stat = XmlDec_Bind (pctxt, &pvalue->bind);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bindPresent = TRUE;
            break;

         case 1: /* control-implementation */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->control_implementation
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.control_implementationPresent = TRUE;
            break;

         case 2: /* current-selected */
            stat = XmlDec_Radio_current_selected (pctxt, &pvalue->
               current_selected);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.current_selectedPresent = TRUE;
            break;

         case 3: /* data-field */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->data_field);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_fieldPresent = TRUE;
            break;

         case 4: /* disabled */
            stat = XmlDec_Radio_disabled (pctxt, &pvalue->disabled);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.disabledPresent = TRUE;
            break;

         case 5: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 6: /* image-align */
            stat = XmlDec_Radio_image_align (pctxt, &pvalue->image_align);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.image_alignPresent = TRUE;
            break;

         case 7: /* image-position */
            stat = XmlDec_Radio_image_position (pctxt, &pvalue->image_position
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.image_positionPresent = TRUE;
            break;

         case 8: /* label */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->label);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.labelPresent = TRUE;
            break;

         case 9: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 10: /* printable */
            stat = XmlDec_Radio_printable (pctxt, &pvalue->printable);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.printablePresent = TRUE;
            break;

         case 11: /* selected */
            stat = XmlDec_Radio_selected (pctxt, &pvalue->selected);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.selectedPresent = TRUE;
            break;

         case 12: /* tab-index */
            stat = rtXmlpDecUInt (pctxt, &pvalue->tab_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_indexPresent = TRUE;
            break;

         case 13: /* tab-stop */
            stat = XmlDec_Radio_tab_stop (pctxt, &pvalue->tab_stop);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_stopPresent = TRUE;
            break;

         case 14: /* title */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->title);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.titlePresent = TRUE;
            break;

         case 15: /* value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.valuePresent = TRUE;
            break;

         case 16: /* visual-effect */
            stat = XmlDec_Radio_visual_effect (pctxt, &pvalue->visual_effect);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.visual_effectPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Radio");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Radio");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("properties"), 10}, 0}, 0 },
      {{{OSUTF8("event-listeners"), 15}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* properties */
         stat = XmlDec_Properties (pctxt, &pvalue->properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.propertiesPresent = TRUE;
         break;
      }
      case 1: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Frame_disabled                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Frame_disabled (OSCTXT* pctxt, Frame_disabled *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Frame_disabled (OSCTXT* pctxt, Frame_disabled* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Frame_disabled_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Frame_printable                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Frame_printable (OSCTXT* pctxt, Frame_printable *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Frame_printable (OSCTXT* pctxt, Frame_printable* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Frame_printable_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Frame                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns4_Frame (OSCTXT* pctxt, Ns4_Frame *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bind */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Bind (pctxt, 
               (Bind*)&pvalue->bind, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bindPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode control_implementation */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->control_implementation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.control_implementationPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode disabled */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Frame_disabled (pctxt, 
               &pvalue->disabled, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.disabledPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode for_ */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->for_, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.for_Present = TRUE;
            }
         }
         break;

      case 4:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode label */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->label, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.labelPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode printable */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Frame_printable (pctxt, 
               &pvalue->printable, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.printablePresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode title */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->title, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.titlePresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode properties */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Properties (pctxt, 
               &pvalue->properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 10:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns4_Frame (OSCTXT* pctxt, Ns4_Frame* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bind"), 4}, 0 },
         { {OSUTF8("control-implementation"), 22}, 0 },
         { {OSUTF8("disabled"), 8}, 0 },
         { {OSUTF8("for"), 3}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("label"), 5}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("printable"), 9}, 0 },
         { {OSUTF8("title"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 9, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bind */
            stat = XmlDec_Bind (pctxt, &pvalue->bind);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bindPresent = TRUE;
            break;

         case 1: /* control-implementation */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->control_implementation
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.control_implementationPresent = TRUE;
            break;

         case 2: /* disabled */
            stat = XmlDec_Frame_disabled (pctxt, &pvalue->disabled);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.disabledPresent = TRUE;
            break;

         case 3: /* for */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->for_);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.for_Present = TRUE;
            break;

         case 4: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* label */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->label);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.labelPresent = TRUE;
            break;

         case 6: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 7: /* printable */
            stat = XmlDec_Frame_printable (pctxt, &pvalue->printable);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.printablePresent = TRUE;
            break;

         case 8: /* title */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->title);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.titlePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns4_Frame");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns4_Frame");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("properties"), 10}, 0}, 0 },
      {{{OSUTF8("event-listeners"), 15}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* properties */
         stat = XmlDec_Properties (pctxt, &pvalue->properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.propertiesPresent = TRUE;
         break;
      }
      case 1: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Image_frame_disabled                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Image_frame_disabled (OSCTXT* pctxt, 
   Image_frame_disabled *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Image_frame_disabled (OSCTXT* pctxt, Image_frame_disabled* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Image_frame_disabled_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Image_frame_printable                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Image_frame_printable (OSCTXT* pctxt, 
   Image_frame_printable *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Image_frame_printable (OSCTXT* pctxt, Image_frame_printable* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Image_frame_printable_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Image_frame_readonly                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Image_frame_readonly (OSCTXT* pctxt, 
   Image_frame_readonly *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Image_frame_readonly (OSCTXT* pctxt, Image_frame_readonly* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Image_frame_readonly_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Image_frame                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Image_frame (OSCTXT* pctxt, Image_frame *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bind */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Bind (pctxt, 
               (Bind*)&pvalue->bind, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bindPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode control_implementation */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->control_implementation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.control_implementationPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode data_field */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->data_field, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.data_fieldPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode disabled */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Image_frame_disabled (pctxt, 
               &pvalue->disabled, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.disabledPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode image_data */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->image_data, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.image_dataPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode printable */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Image_frame_printable (pctxt, 
               &pvalue->printable, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.printablePresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode readonly */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Image_frame_readonly (pctxt, 
               &pvalue->readonly, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.readonlyPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode title */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->title, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.titlePresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode properties */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Properties (pctxt, 
               &pvalue->properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 11:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_CONS|11):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Image_frame (OSCTXT* pctxt, Image_frame* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bind"), 4}, 0 },
         { {OSUTF8("control-implementation"), 22}, 0 },
         { {OSUTF8("data-field"), 10}, 0 },
         { {OSUTF8("disabled"), 8}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("image-data"), 10}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("printable"), 9}, 0 },
         { {OSUTF8("readonly"), 8}, 0 },
         { {OSUTF8("title"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 10, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bind */
            stat = XmlDec_Bind (pctxt, &pvalue->bind);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bindPresent = TRUE;
            break;

         case 1: /* control-implementation */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->control_implementation
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.control_implementationPresent = TRUE;
            break;

         case 2: /* data-field */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->data_field);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.data_fieldPresent = TRUE;
            break;

         case 3: /* disabled */
            stat = XmlDec_Image_frame_disabled (pctxt, &pvalue->disabled);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.disabledPresent = TRUE;
            break;

         case 4: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* image-data */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->image_data);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.image_dataPresent = TRUE;
            break;

         case 6: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 7: /* printable */
            stat = XmlDec_Image_frame_printable (pctxt, &pvalue->printable);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.printablePresent = TRUE;
            break;

         case 8: /* readonly */
            stat = XmlDec_Image_frame_readonly (pctxt, &pvalue->readonly);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.readonlyPresent = TRUE;
            break;

         case 9: /* title */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->title);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.titlePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Image_frame");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Image_frame");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("properties"), 10}, 0}, 0 },
      {{{OSUTF8("event-listeners"), 15}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* properties */
         stat = XmlDec_Properties (pctxt, &pvalue->properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.propertiesPresent = TRUE;
         break;
      }
      case 1: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Hidden                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Hidden (OSCTXT* pctxt, Hidden *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bind */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Bind (pctxt, 
               (Bind*)&pvalue->bind, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bindPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode control_implementation */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->control_implementation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.control_implementationPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.valuePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode properties */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Properties (pctxt, 
               &pvalue->properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Hidden (OSCTXT* pctxt, Hidden* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bind"), 4}, 0 },
         { {OSUTF8("control-implementation"), 22}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 5, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bind */
            stat = XmlDec_Bind (pctxt, &pvalue->bind);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bindPresent = TRUE;
            break;

         case 1: /* control-implementation */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->control_implementation
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.control_implementationPresent = TRUE;
            break;

         case 2: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 4: /* value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.valuePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Hidden");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Hidden");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("properties"), 10}, 0}, 0 },
      {{{OSUTF8("event-listeners"), 15}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* properties */
         stat = XmlDec_Properties (pctxt, &pvalue->properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.propertiesPresent = TRUE;
         break;
      }
      case 1: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Grid_disabled                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Grid_disabled (OSCTXT* pctxt, Grid_disabled *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Grid_disabled (OSCTXT* pctxt, Grid_disabled* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Grid_disabled_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Grid_printable                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Grid_printable (OSCTXT* pctxt, Grid_printable *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Grid_printable (OSCTXT* pctxt, Grid_printable* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Grid_printable_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Grid_tab_stop                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Grid_tab_stop (OSCTXT* pctxt, Grid_tab_stop *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Grid_tab_stop (OSCTXT* pctxt, Grid_tab_stop* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Grid_tab_stop_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Column_text_style_name                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Column_text_style_name (OSCTXT* pctxt, 
   Column_text_style_name *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.alt, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
      case (TM_CTXT|TM_CONS|1):
         stat = xd_utf8str (pctxt, &pvalue->u.alt_1, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         ccb.len = 0;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Column_text_style_name (OSCTXT* pctxt, 
   Column_text_style_name* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* pdata1;

   stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   pvalue->t = 0;
   if (pvalue->t == 0) {
      pvalue->u.alt = pdata1;
      pvalue->t = 1;
   }
   if (pvalue->t == 0) {
      pvalue->u.alt_1 = pdata1;
      pvalue->t = 2;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Column_element                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Column_element (OSCTXT* pctxt, Column_element *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.text = rtxMemAllocType (pctxt, Ns4_Text);

         if (pvalue->u.text == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns4_Text (pvalue->u.text);
         stat = asn1D_Ns4_Text (pctxt, 
            pvalue->u.text, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.textarea = rtxMemAllocType (pctxt, Textarea);

         if (pvalue->u.textarea == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Textarea (pvalue->u.textarea);
         stat = asn1D_Textarea (pctxt, 
            pvalue->u.textarea, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.formatted_text = rtxMemAllocType (pctxt, Formatted_text);

         if (pvalue->u.formatted_text == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Formatted_text (pvalue->u.formatted_text);
         stat = asn1D_Formatted_text (pctxt, 
            pvalue->u.formatted_text, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.number = rtxMemAllocType (pctxt, Ns4_Number);

         if (pvalue->u.number == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns4_Number (pvalue->u.number);
         stat = asn1D_Ns4_Number (pctxt, 
            pvalue->u.number, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.date = rtxMemAllocType (pctxt, Ns4_Date);

         if (pvalue->u.date == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns4_Date (pvalue->u.date);
         stat = asn1D_Ns4_Date (pctxt, 
            pvalue->u.date, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.combobox = rtxMemAllocType (pctxt, Combobox);

         if (pvalue->u.combobox == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Combobox (pvalue->u.combobox);
         stat = asn1D_Combobox (pctxt, 
            pvalue->u.combobox, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.listbox = rtxMemAllocType (pctxt, Listbox);

         if (pvalue->u.listbox == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Listbox (pvalue->u.listbox);
         stat = asn1D_Listbox (pctxt, 
            pvalue->u.listbox, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.checkbox = rtxMemAllocType (pctxt, Checkbox);

         if (pvalue->u.checkbox == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Checkbox (pvalue->u.checkbox);
         stat = asn1D_Checkbox (pctxt, 
            pvalue->u.checkbox, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Column_element (OSCTXT* pctxt, Column_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("text"), 4}, 0}, 0 },
      {{{OSUTF8("textarea"), 8}, 0}, 1 },
      {{{OSUTF8("formatted-text"), 14}, 0}, 2 },
      {{{OSUTF8("number"), 6}, 0}, 3 },
      {{{OSUTF8("date"), 4}, 0}, 4 },
      {{{OSUTF8("combobox"), 8}, 0}, 5 },
      {{{OSUTF8("listbox"), 7}, 0}, 6 },
      {{{OSUTF8("checkbox"), 8}, 0}, 7 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 8, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* text */
      pvalue->u.text = rtxMemAllocType (pctxt, Ns4_Text);

      if (pvalue->u.text == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns4_Text (pvalue->u.text);

      stat = XmlDec_Ns4_Text (pctxt, pvalue->u.text);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* textarea */
      pvalue->u.textarea = rtxMemAllocType (pctxt, Textarea);

      if (pvalue->u.textarea == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Textarea (pvalue->u.textarea);

      stat = XmlDec_Textarea (pctxt, pvalue->u.textarea);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* formatted-text */
      pvalue->u.formatted_text = rtxMemAllocType (pctxt, Formatted_text);

      if (pvalue->u.formatted_text == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Formatted_text (pvalue->u.formatted_text);

      stat = XmlDec_Formatted_text (pctxt, pvalue->u.formatted_text);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* number */
      pvalue->u.number = rtxMemAllocType (pctxt, Ns4_Number);

      if (pvalue->u.number == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns4_Number (pvalue->u.number);

      stat = XmlDec_Ns4_Number (pctxt, pvalue->u.number);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* date */
      pvalue->u.date = rtxMemAllocType (pctxt, Ns4_Date);

      if (pvalue->u.date == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns4_Date (pvalue->u.date);

      stat = XmlDec_Ns4_Date (pctxt, pvalue->u.date);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* combobox */
      pvalue->u.combobox = rtxMemAllocType (pctxt, Combobox);

      if (pvalue->u.combobox == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Combobox (pvalue->u.combobox);

      stat = XmlDec_Combobox (pctxt, pvalue->u.combobox);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* listbox */
      pvalue->u.listbox = rtxMemAllocType (pctxt, Listbox);

      if (pvalue->u.listbox == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Listbox (pvalue->u.listbox);

      stat = XmlDec_Listbox (pctxt, pvalue->u.listbox);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* checkbox */
      pvalue->u.checkbox = rtxMemAllocType (pctxt, Checkbox);

      if (pvalue->u.checkbox == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Checkbox (pvalue->u.checkbox);

      stat = XmlDec_Checkbox (pctxt, pvalue->u.checkbox);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Column                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Column (OSCTXT* pctxt, Column *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode control_implementation */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->control_implementation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.control_implementationPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode label */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->label, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.labelPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode text_style_name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Column_text_style_name (pctxt, 
               &pvalue->text_style_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.text_style_namePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 4:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Column_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Column_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Column_element (pdata2);

                  stat = asn1D_Column_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Column (OSCTXT* pctxt, Column* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("control-implementation"), 22}, 0 },
         { {OSUTF8("label"), 5}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("text-style-name"), 15}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* control-implementation */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->control_implementation
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.control_implementationPresent = TRUE;
            break;

         case 1: /* label */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->label);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.labelPresent = TRUE;
            break;

         case 2: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 3: /* text-style-name */
            stat = XmlDec_Column_text_style_name (pctxt, &pvalue->
               text_style_name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.text_style_namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Column");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Column");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("text"), 4}, 0}, 0 },
      {{{OSUTF8("textarea"), 8}, 0}, 0 },
      {{{OSUTF8("formatted-text"), 14}, 0}, 0 },
      {{{OSUTF8("number"), 6}, 0}, 0 },
      {{{OSUTF8("date"), 4}, 0}, 0 },
      {{{OSUTF8("combobox"), 8}, 0}, 0 },
      {{{OSUTF8("listbox"), 7}, 0}, 0 },
      {{{OSUTF8("checkbox"), 8}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 8, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         Column_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Column_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Column_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Column_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 8, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Grid                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Ns4_Grid (OSCTXT* pctxt, Ns4_Grid *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bind */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Bind (pctxt, 
               (Bind*)&pvalue->bind, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bindPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode control_implementation */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->control_implementation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.control_implementationPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode disabled */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Grid_disabled (pctxt, 
               &pvalue->disabled, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.disabledPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode printable */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Grid_printable (pctxt, 
               &pvalue->printable, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.printablePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode tab_index */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->tab_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_indexPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode tab_stop */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Grid_tab_stop (pctxt, 
               &pvalue->tab_stop, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_stopPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode title */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->title, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.titlePresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode properties */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Properties (pctxt, 
               &pvalue->properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 10:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 11:
         /* decode column_list */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Column* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->column_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Column, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Column (pdata2);

                  stat = asn1D_Column (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->column_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_CONS|11):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Ns4_Grid (OSCTXT* pctxt, Ns4_Grid* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bind"), 4}, 0 },
         { {OSUTF8("control-implementation"), 22}, 0 },
         { {OSUTF8("disabled"), 8}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("printable"), 9}, 0 },
         { {OSUTF8("tab-index"), 9}, 0 },
         { {OSUTF8("tab-stop"), 8}, 0 },
         { {OSUTF8("title"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 9, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bind */
            stat = XmlDec_Bind (pctxt, &pvalue->bind);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bindPresent = TRUE;
            break;

         case 1: /* control-implementation */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->control_implementation
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.control_implementationPresent = TRUE;
            break;

         case 2: /* disabled */
            stat = XmlDec_Grid_disabled (pctxt, &pvalue->disabled);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.disabledPresent = TRUE;
            break;

         case 3: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 4: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 5: /* printable */
            stat = XmlDec_Grid_printable (pctxt, &pvalue->printable);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.printablePresent = TRUE;
            break;

         case 6: /* tab-index */
            stat = rtXmlpDecUInt (pctxt, &pvalue->tab_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_indexPresent = TRUE;
            break;

         case 7: /* tab-stop */
            stat = XmlDec_Grid_tab_stop (pctxt, &pvalue->tab_stop);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_stopPresent = TRUE;
            break;

         case 8: /* title */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->title);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.titlePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Ns4_Grid");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Ns4_Grid");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("properties"), 10}, 0}, 0 },
      {{{OSUTF8("event-listeners"), 15}, 0}, 1 },
      {{{OSUTF8("column"), 6}, 0}, 2 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 3, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 3; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* properties */
         stat = XmlDec_Properties (pctxt, &pvalue->properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.propertiesPresent = TRUE;
         break;
      }
      case 1: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      case 2: {
         Column* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Column);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Column (pdata1);

            stat = XmlDec_Column (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->column_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 2, 1, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Value_range_disabled                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Value_range_disabled (OSCTXT* pctxt, 
   Value_range_disabled *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Value_range_disabled (OSCTXT* pctxt, Value_range_disabled* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Value_range_disabled_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Value_range_orientation                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Value_range_orientation (OSCTXT* pctxt, 
   Value_range_orientation *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Value_range_orientation (OSCTXT* pctxt, 
   Value_range_orientation* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Value_range_orientation_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Value_range_printable                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Value_range_printable (OSCTXT* pctxt, 
   Value_range_printable *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Value_range_printable (OSCTXT* pctxt, Value_range_printable* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Value_range_printable_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Value_range_tab_stop                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Value_range_tab_stop (OSCTXT* pctxt, 
   Value_range_tab_stop *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enum (pctxt, (OSINT32*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_Value_range_tab_stop (OSCTXT* pctxt, Value_range_tab_stop* pvalue)
{
   int stat = 0;

   { const OSUTF8CHAR* strval;
   stat = rtXmlpDecDynUTF8Str (pctxt, &strval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = Value_range_tab_stop_ToEnum (pctxt, strval, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxMemFreePtr (pctxt, (void*)strval);
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Value_range                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Value_range (OSCTXT* pctxt, Value_range *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bind */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Bind (pctxt, 
               (Bind*)&pvalue->bind, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bindPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode control_implementation */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->control_implementation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.control_implementationPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode delay_for_repeat */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->delay_for_repeat, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.delay_for_repeatPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode disabled */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Value_range_disabled (pctxt, 
               &pvalue->disabled, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.disabledPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode max_value */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->max_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.max_valuePresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode min_value */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->min_value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.min_valuePresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode orientation */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Value_range_orientation (pctxt, 
               &pvalue->orientation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.orientationPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode page_step_size */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->page_step_size, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.page_step_sizePresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode printable */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Value_range_printable (pctxt, 
               &pvalue->printable, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.printablePresent = TRUE;
            }
         }
         break;

      case 11:
         /* decode step_size */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->step_size, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.step_sizePresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode tab_index */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->tab_index, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_indexPresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode tab_stop */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Value_range_tab_stop (pctxt, 
               &pvalue->tab_stop, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_stopPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode title */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->title, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.titlePresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->value, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.valuePresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode properties */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Properties (pctxt, 
               &pvalue->properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 17:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_PRIM|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_CONS|17):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Value_range (OSCTXT* pctxt, Value_range* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bind"), 4}, 0 },
         { {OSUTF8("control-implementation"), 22}, 0 },
         { {OSUTF8("delay-for-repeat"), 16}, 0 },
         { {OSUTF8("disabled"), 8}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("max-value"), 9}, 0 },
         { {OSUTF8("min-value"), 9}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("orientation"), 11}, 0 },
         { {OSUTF8("page-step-size"), 14}, 0 },
         { {OSUTF8("printable"), 9}, 0 },
         { {OSUTF8("step-size"), 9}, 0 },
         { {OSUTF8("tab-index"), 9}, 0 },
         { {OSUTF8("tab-stop"), 8}, 0 },
         { {OSUTF8("title"), 5}, 0 },
         { {OSUTF8("value"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 16, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bind */
            stat = XmlDec_Bind (pctxt, &pvalue->bind);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bindPresent = TRUE;
            break;

         case 1: /* control-implementation */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->control_implementation
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.control_implementationPresent = TRUE;
            break;

         case 2: /* delay-for-repeat */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->delay_for_repeat);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.delay_for_repeatPresent = TRUE;
            break;

         case 3: /* disabled */
            stat = XmlDec_Value_range_disabled (pctxt, &pvalue->disabled);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.disabledPresent = TRUE;
            break;

         case 4: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 5: /* max-value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->max_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.max_valuePresent = TRUE;
            break;

         case 6: /* min-value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->min_value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.min_valuePresent = TRUE;
            break;

         case 7: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 8: /* orientation */
            stat = XmlDec_Value_range_orientation (pctxt, &pvalue->orientation
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.orientationPresent = TRUE;
            break;

         case 9: /* page-step-size */
            stat = rtXmlpDecUInt (pctxt, &pvalue->page_step_size);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.page_step_sizePresent = TRUE;
            break;

         case 10: /* printable */
            stat = XmlDec_Value_range_printable (pctxt, &pvalue->printable);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.printablePresent = TRUE;
            break;

         case 11: /* step-size */
            stat = rtXmlpDecUInt (pctxt, &pvalue->step_size);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.step_sizePresent = TRUE;
            break;

         case 12: /* tab-index */
            stat = rtXmlpDecUInt (pctxt, &pvalue->tab_index);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_indexPresent = TRUE;
            break;

         case 13: /* tab-stop */
            stat = XmlDec_Value_range_tab_stop (pctxt, &pvalue->tab_stop);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_stopPresent = TRUE;
            break;

         case 14: /* title */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->title);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.titlePresent = TRUE;
            break;

         case 15: /* value */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->value);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.valuePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Value_range");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Value_range");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("properties"), 10}, 0}, 0 },
      {{{OSUTF8("event-listeners"), 15}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* properties */
         stat = XmlDec_Properties (pctxt, &pvalue->properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.propertiesPresent = TRUE;
         break;
      }
      case 1: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Generic_control                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Generic_control (OSCTXT* pctxt, Generic_control *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bind */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Bind (pctxt, 
               (Bind*)&pvalue->bind, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bindPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode control_implementation */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->control_implementation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.control_implementationPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode properties */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Properties (pctxt, 
               &pvalue->properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Generic_control (OSCTXT* pctxt, Generic_control* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("bind"), 4}, 0 },
         { {OSUTF8("control-implementation"), 22}, 0 },
         { {OSUTF8("id"), 2}, 0 },
         { {OSUTF8("name"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 4, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* bind */
            stat = XmlDec_Bind (pctxt, &pvalue->bind);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.bindPresent = TRUE;
            break;

         case 1: /* control-implementation */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->control_implementation
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.control_implementationPresent = TRUE;
            break;

         case 2: /* id */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         case 3: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Generic_control");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Generic_control");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("properties"), 10}, 0}, 0 },
      {{{OSUTF8("event-listeners"), 15}, 0}, 1 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 2, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 2; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* properties */
         stat = XmlDec_Properties (pctxt, &pvalue->properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.propertiesPresent = TRUE;
         break;
      }
      case 1: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Form_element                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Form_element (OSCTXT* pctxt, Form_element *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.text = rtxMemAllocType (pctxt, Ns4_Text);

         if (pvalue->u.text == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns4_Text (pvalue->u.text);
         stat = asn1D_Ns4_Text (pctxt, 
            pvalue->u.text, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.textarea = rtxMemAllocType (pctxt, Textarea);

         if (pvalue->u.textarea == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Textarea (pvalue->u.textarea);
         stat = asn1D_Textarea (pctxt, 
            pvalue->u.textarea, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_CONS|2):
         pvalue->u.formatted_text = rtxMemAllocType (pctxt, Formatted_text);

         if (pvalue->u.formatted_text == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Formatted_text (pvalue->u.formatted_text);
         stat = asn1D_Formatted_text (pctxt, 
            pvalue->u.formatted_text, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_CONS|3):
         pvalue->u.number = rtxMemAllocType (pctxt, Ns4_Number);

         if (pvalue->u.number == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns4_Number (pvalue->u.number);
         stat = asn1D_Ns4_Number (pctxt, 
            pvalue->u.number, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.date = rtxMemAllocType (pctxt, Ns4_Date);

         if (pvalue->u.date == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns4_Date (pvalue->u.date);
         stat = asn1D_Ns4_Date (pctxt, 
            pvalue->u.date, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.combobox = rtxMemAllocType (pctxt, Combobox);

         if (pvalue->u.combobox == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Combobox (pvalue->u.combobox);
         stat = asn1D_Combobox (pctxt, 
            pvalue->u.combobox, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_CONS|6):
         pvalue->u.listbox = rtxMemAllocType (pctxt, Listbox);

         if (pvalue->u.listbox == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Listbox (pvalue->u.listbox);
         stat = asn1D_Listbox (pctxt, 
            pvalue->u.listbox, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.checkbox = rtxMemAllocType (pctxt, Checkbox);

         if (pvalue->u.checkbox == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Checkbox (pvalue->u.checkbox);
         stat = asn1D_Checkbox (pctxt, 
            pvalue->u.checkbox, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_CONS|8):
         pvalue->u.password = rtxMemAllocType (pctxt, Password);

         if (pvalue->u.password == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Password (pvalue->u.password);
         stat = asn1D_Password (pctxt, 
            pvalue->u.password, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.file = rtxMemAllocType (pctxt, File);

         if (pvalue->u.file == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_File (pvalue->u.file);
         stat = asn1D_File (pctxt, 
            pvalue->u.file, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_CONS|10):
         pvalue->u.time_ = rtxMemAllocType (pctxt, Ns4_Time);

         if (pvalue->u.time_ == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns4_Time (pvalue->u.time_);
         stat = asn1D_Ns4_Time (pctxt, 
            pvalue->u.time_, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.fixed_text = rtxMemAllocType (pctxt, Fixed_text);

         if (pvalue->u.fixed_text == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Fixed_text (pvalue->u.fixed_text);
         stat = asn1D_Fixed_text (pctxt, 
            pvalue->u.fixed_text, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.button = rtxMemAllocType (pctxt, Button);

         if (pvalue->u.button == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Button (pvalue->u.button);
         stat = asn1D_Button (pctxt, 
            pvalue->u.button, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.image = rtxMemAllocType (pctxt, Ns4_Image);

         if (pvalue->u.image == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns4_Image (pvalue->u.image);
         stat = asn1D_Ns4_Image (pctxt, 
            pvalue->u.image, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.radio = rtxMemAllocType (pctxt, Radio);

         if (pvalue->u.radio == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Radio (pvalue->u.radio);
         stat = asn1D_Radio (pctxt, 
            pvalue->u.radio, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.frame = rtxMemAllocType (pctxt, Ns4_Frame);

         if (pvalue->u.frame == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns4_Frame (pvalue->u.frame);
         stat = asn1D_Ns4_Frame (pctxt, 
            pvalue->u.frame, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_CONS|16):
         pvalue->u.image_frame = rtxMemAllocType (pctxt, Image_frame);

         if (pvalue->u.image_frame == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Image_frame (pvalue->u.image_frame);
         stat = asn1D_Image_frame (pctxt, 
            pvalue->u.image_frame, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      case (TM_CTXT|TM_CONS|17):
         pvalue->u.hidden = rtxMemAllocType (pctxt, Hidden);

         if (pvalue->u.hidden == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Hidden (pvalue->u.hidden);
         stat = asn1D_Hidden (pctxt, 
            pvalue->u.hidden, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 18;
         break;

      case (TM_CTXT|TM_CONS|18):
         pvalue->u.grid = rtxMemAllocType (pctxt, Ns4_Grid);

         if (pvalue->u.grid == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Ns4_Grid (pvalue->u.grid);
         stat = asn1D_Ns4_Grid (pctxt, 
            pvalue->u.grid, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 19;
         break;

      case (TM_CTXT|TM_CONS|19):
         pvalue->u.value_range = rtxMemAllocType (pctxt, Value_range);

         if (pvalue->u.value_range == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Value_range (pvalue->u.value_range);
         stat = asn1D_Value_range (pctxt, 
            pvalue->u.value_range, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 20;
         break;

      case (TM_CTXT|TM_CONS|20):
         pvalue->u.generic_control = rtxMemAllocType (pctxt, Generic_control);

         if (pvalue->u.generic_control == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Generic_control (pvalue->u.generic_control);
         stat = asn1D_Generic_control (pctxt, 
            pvalue->u.generic_control, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 21;
         break;

      case (TM_CTXT|TM_CONS|21):
         pvalue->u.form = rtxMemAllocType (pctxt, Form);

         if (pvalue->u.form == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_Form ((Form*)pvalue->u.form);
         stat = asn1D_Form (pctxt, 
            (Form*)pvalue->u.form, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 22;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_Form_element (OSCTXT* pctxt, Form_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("text"), 4}, 0}, 0 },
      {{{OSUTF8("textarea"), 8}, 0}, 1 },
      {{{OSUTF8("formatted-text"), 14}, 0}, 2 },
      {{{OSUTF8("number"), 6}, 0}, 3 },
      {{{OSUTF8("date"), 4}, 0}, 4 },
      {{{OSUTF8("combobox"), 8}, 0}, 5 },
      {{{OSUTF8("listbox"), 7}, 0}, 6 },
      {{{OSUTF8("checkbox"), 8}, 0}, 7 },
      {{{OSUTF8("password"), 8}, 0}, 8 },
      {{{OSUTF8("file"), 4}, 0}, 9 },
      {{{OSUTF8("time"), 4}, 0}, 10 },
      {{{OSUTF8("fixed-text"), 10}, 0}, 11 },
      {{{OSUTF8("button"), 6}, 0}, 12 },
      {{{OSUTF8("image"), 5}, 0}, 13 },
      {{{OSUTF8("radio"), 5}, 0}, 14 },
      {{{OSUTF8("frame"), 5}, 0}, 15 },
      {{{OSUTF8("image-frame"), 11}, 0}, 16 },
      {{{OSUTF8("hidden"), 6}, 0}, 17 },
      {{{OSUTF8("grid"), 4}, 0}, 18 },
      {{{OSUTF8("value-range"), 11}, 0}, 19 },
      {{{OSUTF8("generic-control"), 15}, 0}, 20 },
      {{{OSUTF8("form"), 4}, 0}, 21 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 22, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* text */
      pvalue->u.text = rtxMemAllocType (pctxt, Ns4_Text);

      if (pvalue->u.text == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns4_Text (pvalue->u.text);

      stat = XmlDec_Ns4_Text (pctxt, pvalue->u.text);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* textarea */
      pvalue->u.textarea = rtxMemAllocType (pctxt, Textarea);

      if (pvalue->u.textarea == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Textarea (pvalue->u.textarea);

      stat = XmlDec_Textarea (pctxt, pvalue->u.textarea);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* formatted-text */
      pvalue->u.formatted_text = rtxMemAllocType (pctxt, Formatted_text);

      if (pvalue->u.formatted_text == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Formatted_text (pvalue->u.formatted_text);

      stat = XmlDec_Formatted_text (pctxt, pvalue->u.formatted_text);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* number */
      pvalue->u.number = rtxMemAllocType (pctxt, Ns4_Number);

      if (pvalue->u.number == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns4_Number (pvalue->u.number);

      stat = XmlDec_Ns4_Number (pctxt, pvalue->u.number);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* date */
      pvalue->u.date = rtxMemAllocType (pctxt, Ns4_Date);

      if (pvalue->u.date == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns4_Date (pvalue->u.date);

      stat = XmlDec_Ns4_Date (pctxt, pvalue->u.date);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* combobox */
      pvalue->u.combobox = rtxMemAllocType (pctxt, Combobox);

      if (pvalue->u.combobox == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Combobox (pvalue->u.combobox);

      stat = XmlDec_Combobox (pctxt, pvalue->u.combobox);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* listbox */
      pvalue->u.listbox = rtxMemAllocType (pctxt, Listbox);

      if (pvalue->u.listbox == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Listbox (pvalue->u.listbox);

      stat = XmlDec_Listbox (pctxt, pvalue->u.listbox);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* checkbox */
      pvalue->u.checkbox = rtxMemAllocType (pctxt, Checkbox);

      if (pvalue->u.checkbox == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Checkbox (pvalue->u.checkbox);

      stat = XmlDec_Checkbox (pctxt, pvalue->u.checkbox);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* password */
      pvalue->u.password = rtxMemAllocType (pctxt, Password);

      if (pvalue->u.password == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Password (pvalue->u.password);

      stat = XmlDec_Password (pctxt, pvalue->u.password);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* file */
      pvalue->u.file = rtxMemAllocType (pctxt, File);

      if (pvalue->u.file == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_File (pvalue->u.file);

      stat = XmlDec_File (pctxt, pvalue->u.file);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* time */
      pvalue->u.time_ = rtxMemAllocType (pctxt, Ns4_Time);

      if (pvalue->u.time_ == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns4_Time (pvalue->u.time_);

      stat = XmlDec_Ns4_Time (pctxt, pvalue->u.time_);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* fixed-text */
      pvalue->u.fixed_text = rtxMemAllocType (pctxt, Fixed_text);

      if (pvalue->u.fixed_text == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Fixed_text (pvalue->u.fixed_text);

      stat = XmlDec_Fixed_text (pctxt, pvalue->u.fixed_text);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* button */
      pvalue->u.button = rtxMemAllocType (pctxt, Button);

      if (pvalue->u.button == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Button (pvalue->u.button);

      stat = XmlDec_Button (pctxt, pvalue->u.button);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* image */
      pvalue->u.image = rtxMemAllocType (pctxt, Ns4_Image);

      if (pvalue->u.image == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns4_Image (pvalue->u.image);

      stat = XmlDec_Ns4_Image (pctxt, pvalue->u.image);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* radio */
      pvalue->u.radio = rtxMemAllocType (pctxt, Radio);

      if (pvalue->u.radio == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Radio (pvalue->u.radio);

      stat = XmlDec_Radio (pctxt, pvalue->u.radio);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* frame */
      pvalue->u.frame = rtxMemAllocType (pctxt, Ns4_Frame);

      if (pvalue->u.frame == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns4_Frame (pvalue->u.frame);

      stat = XmlDec_Ns4_Frame (pctxt, pvalue->u.frame);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* image-frame */
      pvalue->u.image_frame = rtxMemAllocType (pctxt, Image_frame);

      if (pvalue->u.image_frame == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Image_frame (pvalue->u.image_frame);

      stat = XmlDec_Image_frame (pctxt, pvalue->u.image_frame);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 17: { /* hidden */
      pvalue->u.hidden = rtxMemAllocType (pctxt, Hidden);

      if (pvalue->u.hidden == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Hidden (pvalue->u.hidden);

      stat = XmlDec_Hidden (pctxt, pvalue->u.hidden);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 18: { /* grid */
      pvalue->u.grid = rtxMemAllocType (pctxt, Ns4_Grid);

      if (pvalue->u.grid == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Ns4_Grid (pvalue->u.grid);

      stat = XmlDec_Ns4_Grid (pctxt, pvalue->u.grid);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 19: { /* value-range */
      pvalue->u.value_range = rtxMemAllocType (pctxt, Value_range);

      if (pvalue->u.value_range == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Value_range (pvalue->u.value_range);

      stat = XmlDec_Value_range (pctxt, pvalue->u.value_range);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 20: { /* generic-control */
      pvalue->u.generic_control = rtxMemAllocType (pctxt, Generic_control);

      if (pvalue->u.generic_control == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Generic_control (pvalue->u.generic_control);

      stat = XmlDec_Generic_control (pctxt, pvalue->u.generic_control);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 21: { /* form */
      pvalue->u.form = rtxMemAllocType (pctxt, Form);

      if (pvalue->u.form == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_Form ((Form*)pvalue->u.form);

      stat = XmlDec_Form (pctxt, pvalue->u.form);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Connection_resource                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Connection_resource (OSCTXT* pctxt, 
   Connection_resource *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode href */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Href (pctxt, 
               &pvalue->href, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Connection_resource (OSCTXT* pctxt, Connection_resource* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("href"), 4}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* href */
            stat = XmlDec_Xlink_Href (pctxt, &pvalue->href);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Connection_resource");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Connection_resource");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Form                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Form (OSCTXT* pctxt, Form *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode actuate */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Form_actuate (pctxt, 
               &pvalue->actuate, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.actuatePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode href */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Href (pctxt, 
               &pvalue->href, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.hrefPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Xlink_Type (pctxt, 
               &pvalue->type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.typePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode allow_deletes */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Form_allow_deletes (pctxt, 
               &pvalue->allow_deletes, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.allow_deletesPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode allow_inserts */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Form_allow_inserts (pctxt, 
               &pvalue->allow_inserts, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.allow_insertsPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode allow_updates */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Form_allow_updates (pctxt, 
               &pvalue->allow_updates, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.allow_updatesPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode apply_filter */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Form_apply_filter (pctxt, 
               &pvalue->apply_filter, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.apply_filterPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode command */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->command, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.commandPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode command_type */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Form_command_type (pctxt, 
               &pvalue->command_type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.command_typePresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode control_implementation */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->control_implementation, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.control_implementationPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode datasource */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Form_datasource (pctxt, 
               &pvalue->datasource, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.datasourcePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 11:
         /* decode detail_fields */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->detail_fields, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.detail_fieldsPresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode enctype */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->enctype, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.enctypePresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode escape_processing */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Form_escape_processing (pctxt, 
               &pvalue->escape_processing, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.escape_processingPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode filter */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->filter, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.filterPresent = TRUE;
            }
         }
         break;

      case 15:
         /* decode ignore_result */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Form_ignore_result (pctxt, 
               &pvalue->ignore_result, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.ignore_resultPresent = TRUE;
            }
         }
         break;

      case 16:
         /* decode master_fields */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->master_fields, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.master_fieldsPresent = TRUE;
            }
         }
         break;

      case 17:
         /* decode method */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Form_method (pctxt, 
               &pvalue->method, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.methodPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 18:
         /* decode name */
         if (XD_PEEKTAG (pctxt, 0x92)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.namePresent = TRUE;
            }
         }
         break;

      case 19:
         /* decode navigation_mode */
         if (XD_PEEKTAG (pctxt, 0x93)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Form_navigation_mode (pctxt, 
               &pvalue->navigation_mode, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.navigation_modePresent = TRUE;
            }
         }
         break;

      case 20:
         /* decode order */
         if (XD_PEEKTAG (pctxt, 0x94)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->order, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.orderPresent = TRUE;
            }
         }
         break;

      case 21:
         /* decode tab_cycle */
         if (XD_PEEKTAG (pctxt, 0x95)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Form_tab_cycle (pctxt, 
               &pvalue->tab_cycle, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tab_cyclePresent = TRUE;
            }
         }
         break;

      case 22:
         /* decode target_frame */
         if (XD_PEEKTAG (pctxt, 0x96)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->target_frame = rtxMemAllocType (pctxt, Ns13_Target_frame);

            if (pvalue->target_frame == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Target_frame ((Ns13_Target_frame*)pvalue->target_frame);
            asn1Init_Ns13_Target_frame ((Ns13_Target_frame*)pvalue->target_frame);

            stat = asn1D_Ns13_Target_frame (pctxt, 
               (Ns13_Target_frame*)pvalue->target_frame, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.target_framePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 23:
         /* decode properties */
         if (XD_PEEKTAG (pctxt, 0x97)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Properties (pctxt, 
               &pvalue->properties, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.propertiesPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 24:
         /* decode event_listeners */
         if (XD_PEEKTAG (pctxt, 0x98)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Ns13_Event_listeners (pctxt, 
               (Ns13_Event_listeners*)&pvalue->event_listeners, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.event_listenersPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 25:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x99)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Form_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Form_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Form_element (pdata2);

                  stat = asn1D_Form_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 26:
         /* decode connection_resource */
         if (XD_PEEKTAG (pctxt, 0x9a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Connection_resource (pctxt, 
               &pvalue->connection_resource, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.connection_resourcePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_PRIM|14):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_PRIM|15):
         case (TM_CTXT|TM_PRIM|16):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_CONS|17):
         case (TM_CTXT|TM_PRIM|18):
         case (TM_CTXT|TM_CONS|18):
         case (TM_CTXT|TM_PRIM|19):
         case (TM_CTXT|TM_PRIM|20):
         case (TM_CTXT|TM_CONS|20):
         case (TM_CTXT|TM_PRIM|21):
         case (TM_CTXT|TM_CONS|22):
         case (TM_CTXT|TM_CONS|23):
         case (TM_CTXT|TM_CONS|24):
         case (TM_CTXT|TM_CONS|25):
         case (TM_CTXT|TM_CONS|26):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Form (OSCTXT* pctxt, Form* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("actuate"), 7}, 0 },
         { {OSUTF8("href"), 4}, 0 },
         { {OSUTF8("type"), 4}, 0 },
         { {OSUTF8("allow-deletes"), 13}, 0 },
         { {OSUTF8("allow-inserts"), 13}, 0 },
         { {OSUTF8("allow-updates"), 13}, 0 },
         { {OSUTF8("apply-filter"), 12}, 0 },
         { {OSUTF8("command"), 7}, 0 },
         { {OSUTF8("command-type"), 12}, 0 },
         { {OSUTF8("control-implementation"), 22}, 0 },
         { {OSUTF8("datasource"), 10}, 0 },
         { {OSUTF8("detail-fields"), 13}, 0 },
         { {OSUTF8("enctype"), 7}, 0 },
         { {OSUTF8("escape-processing"), 17}, 0 },
         { {OSUTF8("filter"), 6}, 0 },
         { {OSUTF8("ignore-result"), 13}, 0 },
         { {OSUTF8("master-fields"), 13}, 0 },
         { {OSUTF8("method"), 6}, 0 },
         { {OSUTF8("name"), 4}, 0 },
         { {OSUTF8("navigation-mode"), 15}, 0 },
         { {OSUTF8("order"), 5}, 0 },
         { {OSUTF8("tab-cycle"), 9}, 0 },
         { {OSUTF8("target-frame"), 12}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 23, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* actuate */
            stat = XmlDec_Form_actuate (pctxt, &pvalue->actuate);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.actuatePresent = TRUE;
            break;

         case 1: /* href */
            stat = XmlDec_Xlink_Href (pctxt, &pvalue->href);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.hrefPresent = TRUE;
            break;

         case 2: /* type */
            stat = XmlDec_Xlink_Type (pctxt, &pvalue->type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.typePresent = TRUE;
            break;

         case 3: /* allow-deletes */
            stat = XmlDec_Form_allow_deletes (pctxt, &pvalue->allow_deletes);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.allow_deletesPresent = TRUE;
            break;

         case 4: /* allow-inserts */
            stat = XmlDec_Form_allow_inserts (pctxt, &pvalue->allow_inserts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.allow_insertsPresent = TRUE;
            break;

         case 5: /* allow-updates */
            stat = XmlDec_Form_allow_updates (pctxt, &pvalue->allow_updates);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.allow_updatesPresent = TRUE;
            break;

         case 6: /* apply-filter */
            stat = XmlDec_Form_apply_filter (pctxt, &pvalue->apply_filter);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.apply_filterPresent = TRUE;
            break;

         case 7: /* command */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->command);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.commandPresent = TRUE;
            break;

         case 8: /* command-type */
            stat = XmlDec_Form_command_type (pctxt, &pvalue->command_type);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.command_typePresent = TRUE;
            break;

         case 9: /* control-implementation */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->control_implementation
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.control_implementationPresent = TRUE;
            break;

         case 10: /* datasource */
            stat = XmlDec_Form_datasource (pctxt, &pvalue->datasource);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.datasourcePresent = TRUE;
            break;

         case 11: /* detail-fields */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->detail_fields);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.detail_fieldsPresent = TRUE;
            break;

         case 12: /* enctype */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->enctype);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.enctypePresent = TRUE;
            break;

         case 13: /* escape-processing */
            stat = XmlDec_Form_escape_processing (pctxt, &pvalue->
               escape_processing);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.escape_processingPresent = TRUE;
            break;

         case 14: /* filter */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->filter);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.filterPresent = TRUE;
            break;

         case 15: /* ignore-result */
            stat = XmlDec_Form_ignore_result (pctxt, &pvalue->ignore_result);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.ignore_resultPresent = TRUE;
            break;

         case 16: /* master-fields */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->master_fields);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.master_fieldsPresent = TRUE;
            break;

         case 17: /* method */
            stat = XmlDec_Form_method (pctxt, &pvalue->method);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.methodPresent = TRUE;
            break;

         case 18: /* name */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.namePresent = TRUE;
            break;

         case 19: /* navigation-mode */
            stat = XmlDec_Form_navigation_mode (pctxt, &pvalue->navigation_mode
               );
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.navigation_modePresent = TRUE;
            break;

         case 20: /* order */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->order);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.orderPresent = TRUE;
            break;

         case 21: /* tab-cycle */
            stat = XmlDec_Form_tab_cycle (pctxt, &pvalue->tab_cycle);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.tab_cyclePresent = TRUE;
            break;

         case 22: /* target-frame */
            pvalue->target_frame = rtxMemAllocType (pctxt, Ns13_Target_frame);

            if (pvalue->target_frame == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Ns13_Target_frame ((Ns13_Target_frame*)pvalue->
               target_frame);

            stat = XmlDec_Ns13_Target_frame (pctxt, pvalue->target_frame);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.target_framePresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "Form");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "Form");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("properties"), 10}, 0}, 0 },
      {{{OSUTF8("event-listeners"), 15}, 0}, 1 },
      {{{OSUTF8("text"), 4}, 0}, 2 },
      {{{OSUTF8("textarea"), 8}, 0}, 2 },
      {{{OSUTF8("formatted-text"), 14}, 0}, 2 },
      {{{OSUTF8("number"), 6}, 0}, 2 },
      {{{OSUTF8("date"), 4}, 0}, 2 },
      {{{OSUTF8("combobox"), 8}, 0}, 2 },
      {{{OSUTF8("listbox"), 7}, 0}, 2 },
      {{{OSUTF8("checkbox"), 8}, 0}, 2 },
      {{{OSUTF8("password"), 8}, 0}, 2 },
      {{{OSUTF8("file"), 4}, 0}, 2 },
      {{{OSUTF8("time"), 4}, 0}, 2 },
      {{{OSUTF8("fixed-text"), 10}, 0}, 2 },
      {{{OSUTF8("button"), 6}, 0}, 2 },
      {{{OSUTF8("image"), 5}, 0}, 2 },
      {{{OSUTF8("radio"), 5}, 0}, 2 },
      {{{OSUTF8("frame"), 5}, 0}, 2 },
      {{{OSUTF8("image-frame"), 11}, 0}, 2 },
      {{{OSUTF8("hidden"), 6}, 0}, 2 },
      {{{OSUTF8("grid"), 4}, 0}, 2 },
      {{{OSUTF8("value-range"), 11}, 0}, 2 },
      {{{OSUTF8("generic-control"), 15}, 0}, 2 },
      {{{OSUTF8("form"), 4}, 0}, 2 },
      {{{OSUTF8("connection-resource"), 19}, 0}, 3 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 25, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 4; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: { /* properties */
         stat = XmlDec_Properties (pctxt, &pvalue->properties);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.propertiesPresent = TRUE;
         break;
      }
      case 1: { /* event-listeners */
         stat = XmlDec_Ns13_Event_listeners (pctxt, &pvalue->event_listeners);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.event_listenersPresent = TRUE;
         break;
      }
      case 2: {
         Form_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Form_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Form_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_Form_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 2, 22, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 3: { /* connection-resource */
         stat = XmlDec_Connection_resource (pctxt, &pvalue->connection_resource
            );
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.connection_resourcePresent = TRUE;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

