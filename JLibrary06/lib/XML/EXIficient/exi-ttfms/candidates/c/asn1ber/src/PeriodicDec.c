/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 18-Oct-2006.
 */
#include "Periodic.h"
#include "rtxsrc/rtxCommon.h"

/**************************************************************/
/*                                                            */
/*  PERIODIC_TABLE_aTOM_element_bOILING_POINT                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PERIODIC_TABLE_aTOM_element_bOILING_POINT (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element_bOILING_POINT *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode uNITS */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uNITS, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PERIODIC_TABLE_aTOM_element_bOILING_POINT (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element_bOILING_POINT* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("UNITS"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* UNITS */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uNITS);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "PERIODIC_TABLE_aTOM_element_bOILING_POINT");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "PERIODIC_TABLE_aTOM_element_bOILING_POINT");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDouble (pctxt, &pvalue->base, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PERIODIC_TABLE_aTOM_element_mELTING_POINT                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PERIODIC_TABLE_aTOM_element_mELTING_POINT (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element_mELTING_POINT *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode uNITS */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uNITS, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PERIODIC_TABLE_aTOM_element_mELTING_POINT (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element_mELTING_POINT* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("UNITS"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* UNITS */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uNITS);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "PERIODIC_TABLE_aTOM_element_mELTING_POINT");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "PERIODIC_TABLE_aTOM_element_mELTING_POINT");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDouble (pctxt, &pvalue->base, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PERIODIC_TABLE_aTOM_element_dENSITY                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PERIODIC_TABLE_aTOM_element_dENSITY (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element_dENSITY *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode uNITS */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uNITS, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PERIODIC_TABLE_aTOM_element_dENSITY (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element_dENSITY* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("UNITS"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* UNITS */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uNITS);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "PERIODIC_TABLE_aTOM_element_dENSITY");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "PERIODIC_TABLE_aTOM_element_dENSITY");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDouble (pctxt, &pvalue->base, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PERIODIC_TABLE_aTOM_element_cOVALENT_RADIUS               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PERIODIC_TABLE_aTOM_element_cOVALENT_RADIUS (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element_cOVALENT_RADIUS *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode uNITS */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uNITS, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PERIODIC_TABLE_aTOM_element_cOVALENT_RADIUS (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element_cOVALENT_RADIUS* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("UNITS"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* UNITS */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uNITS);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "PERIODIC_TABLE_aTOM_element_cOVALENT_RADIUS");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "PERIODIC_TABLE_aTOM_element_cOVALENT_RADIUS");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDouble (pctxt, &pvalue->base, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PERIODIC_TABLE_aTOM_element_aTOMIC_RADIUS                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PERIODIC_TABLE_aTOM_element_aTOMIC_RADIUS (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element_aTOMIC_RADIUS *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode uNITS */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uNITS, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PERIODIC_TABLE_aTOM_element_aTOMIC_RADIUS (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element_aTOMIC_RADIUS* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("UNITS"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* UNITS */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uNITS);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "PERIODIC_TABLE_aTOM_element_aTOMIC_RADIUS");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "PERIODIC_TABLE_aTOM_element_aTOMIC_RADIUS");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDouble (pctxt, &pvalue->base, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PERIODIC_TABLE_aTOM_element_hEAT_OF_VAPORIZATION          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PERIODIC_TABLE_aTOM_element_hEAT_OF_VAPORIZATION (
   OSCTXT* pctxt, PERIODIC_TABLE_aTOM_element_hEAT_OF_VAPORIZATION *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode uNITS */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uNITS, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PERIODIC_TABLE_aTOM_element_hEAT_OF_VAPORIZATION (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element_hEAT_OF_VAPORIZATION* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("UNITS"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* UNITS */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uNITS);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "PERIODIC_TABLE_aTOM_element_hEAT_OF_VAPORIZATION");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "PERIODIC_TABLE_aTOM_element_hEAT_OF_VAPORIZATION");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDouble (pctxt, &pvalue->base, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PERIODIC_TABLE_aTOM_element_aTOMIC_VOLUME                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PERIODIC_TABLE_aTOM_element_aTOMIC_VOLUME (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element_aTOMIC_VOLUME *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode uNITS */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uNITS, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PERIODIC_TABLE_aTOM_element_aTOMIC_VOLUME (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element_aTOMIC_VOLUME* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("UNITS"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* UNITS */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uNITS);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "PERIODIC_TABLE_aTOM_element_aTOMIC_VOLUME");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "PERIODIC_TABLE_aTOM_element_aTOMIC_VOLUME");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDouble (pctxt, &pvalue->base, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PERIODIC_TABLE_aTOM_element_hEAT_OF_FUSION                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PERIODIC_TABLE_aTOM_element_hEAT_OF_FUSION (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element_hEAT_OF_FUSION *pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode uNITS */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uNITS, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PERIODIC_TABLE_aTOM_element_hEAT_OF_FUSION (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element_hEAT_OF_FUSION* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("UNITS"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* UNITS */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uNITS);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "PERIODIC_TABLE_aTOM_element_hEAT_OF_FUSION");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "PERIODIC_TABLE_aTOM_element_hEAT_OF_FUSION");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDouble (pctxt, &pvalue->base, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PERIODIC_TABLE_aTOM_element_sPECIFIC_HEAT_CAPACITY        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PERIODIC_TABLE_aTOM_element_sPECIFIC_HEAT_CAPACITY (
   OSCTXT* pctxt, PERIODIC_TABLE_aTOM_element_sPECIFIC_HEAT_CAPACITY *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode uNITS */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uNITS, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PERIODIC_TABLE_aTOM_element_sPECIFIC_HEAT_CAPACITY (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element_sPECIFIC_HEAT_CAPACITY* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("UNITS"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* UNITS */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uNITS);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "PERIODIC_TABLE_aTOM_element_sPECIFIC_HEAT_CAPACITY");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "PERIODIC_TABLE_aTOM_element_sPECIFIC_HEAT_CAPACITY");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDouble (pctxt, &pvalue->base, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PERIODIC_TABLE_aTOM_element_tHERMAL_CONDUCTIVITY          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PERIODIC_TABLE_aTOM_element_tHERMAL_CONDUCTIVITY (
   OSCTXT* pctxt, PERIODIC_TABLE_aTOM_element_tHERMAL_CONDUCTIVITY *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode uNITS */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uNITS, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_real (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PERIODIC_TABLE_aTOM_element_tHERMAL_CONDUCTIVITY (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element_tHERMAL_CONDUCTIVITY* pvalue)
{
   int stat = 0;

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("UNITS"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* UNITS */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uNITS);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "PERIODIC_TABLE_aTOM_element_tHERMAL_CONDUCTIVITY");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "PERIODIC_TABLE_aTOM_element_tHERMAL_CONDUCTIVITY");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   stat = rtXmlpDecDouble (pctxt, &pvalue->base, -1, -1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PERIODIC_TABLE_aTOM_element                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PERIODIC_TABLE_aTOM_element (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_PRIM|0):
      case (TM_CTXT|TM_CONS|0):
         stat = xd_utf8str (pctxt, &pvalue->u.nAME, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_PRIM|1):
         stat = xd_real (pctxt, &pvalue->u.aTOMIC_WEIGHT, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      case (TM_CTXT|TM_PRIM|2):
         stat = xd_uint8 (pctxt, &pvalue->u.aTOMIC_NUMBER, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 3;
         break;

      case (TM_CTXT|TM_PRIM|3):
      case (TM_CTXT|TM_CONS|3):
         stat = xd_utf8str (pctxt, &pvalue->u.oXIDATION_STATES, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 4;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_CONS|4):
         pvalue->u.bOILING_POINT
             = rtxMemAllocType (pctxt, PERIODIC_TABLE_aTOM_element_bOILING_POINT);

         if (pvalue->u.bOILING_POINT == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PERIODIC_TABLE_aTOM_element_bOILING_POINT (pvalue->u.bOILING_POINT);
         stat = asn1D_PERIODIC_TABLE_aTOM_element_bOILING_POINT (pctxt, 
            pvalue->u.bOILING_POINT, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 5;
         break;

      case (TM_CTXT|TM_CONS|5):
         pvalue->u.mELTING_POINT
             = rtxMemAllocType (pctxt, PERIODIC_TABLE_aTOM_element_mELTING_POINT);

         if (pvalue->u.mELTING_POINT == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PERIODIC_TABLE_aTOM_element_mELTING_POINT (pvalue->u.mELTING_POINT);
         stat = asn1D_PERIODIC_TABLE_aTOM_element_mELTING_POINT (pctxt, 
            pvalue->u.mELTING_POINT, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 6;
         break;

      case (TM_CTXT|TM_PRIM|6):
      case (TM_CTXT|TM_CONS|6):
         stat = xd_utf8str (pctxt, &pvalue->u.sYMBOL, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 7;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_CONS|7):
         pvalue->u.dENSITY
             = rtxMemAllocType (pctxt, PERIODIC_TABLE_aTOM_element_dENSITY);

         if (pvalue->u.dENSITY == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PERIODIC_TABLE_aTOM_element_dENSITY (pvalue->u.dENSITY);
         stat = asn1D_PERIODIC_TABLE_aTOM_element_dENSITY (pctxt, 
            pvalue->u.dENSITY, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 8;
         break;

      case (TM_CTXT|TM_PRIM|8):
      case (TM_CTXT|TM_CONS|8):
         stat = xd_utf8str (pctxt, &pvalue->u.eLECTRON_CONFIGURATION, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 9;
         ccb.len = 0;
         break;

      case (TM_CTXT|TM_CONS|9):
         pvalue->u.cOVALENT_RADIUS
             = rtxMemAllocType (pctxt, PERIODIC_TABLE_aTOM_element_cOVALENT_RADIUS);

         if (pvalue->u.cOVALENT_RADIUS == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PERIODIC_TABLE_aTOM_element_cOVALENT_RADIUS (pvalue->u.cOVALENT_RADIUS);
         stat = asn1D_PERIODIC_TABLE_aTOM_element_cOVALENT_RADIUS (pctxt, 
            pvalue->u.cOVALENT_RADIUS, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 10;
         break;

      case (TM_CTXT|TM_PRIM|10):
         stat = xd_real (pctxt, &pvalue->u.eLECTRONEGATIVITY, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 11;
         break;

      case (TM_CTXT|TM_CONS|11):
         pvalue->u.aTOMIC_RADIUS
             = rtxMemAllocType (pctxt, PERIODIC_TABLE_aTOM_element_aTOMIC_RADIUS);

         if (pvalue->u.aTOMIC_RADIUS == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PERIODIC_TABLE_aTOM_element_aTOMIC_RADIUS (pvalue->u.aTOMIC_RADIUS);
         stat = asn1D_PERIODIC_TABLE_aTOM_element_aTOMIC_RADIUS (pctxt, 
            pvalue->u.aTOMIC_RADIUS, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 12;
         break;

      case (TM_CTXT|TM_CONS|12):
         pvalue->u.hEAT_OF_VAPORIZATION
             = rtxMemAllocType (pctxt, PERIODIC_TABLE_aTOM_element_hEAT_OF_VAPORIZATION);

         if (pvalue->u.hEAT_OF_VAPORIZATION == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PERIODIC_TABLE_aTOM_element_hEAT_OF_VAPORIZATION (pvalue->u.hEAT_OF_VAPORIZATION);
         stat = asn1D_PERIODIC_TABLE_aTOM_element_hEAT_OF_VAPORIZATION (pctxt, 
            pvalue->u.hEAT_OF_VAPORIZATION, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 13;
         break;

      case (TM_CTXT|TM_CONS|13):
         pvalue->u.aTOMIC_VOLUME
             = rtxMemAllocType (pctxt, PERIODIC_TABLE_aTOM_element_aTOMIC_VOLUME);

         if (pvalue->u.aTOMIC_VOLUME == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PERIODIC_TABLE_aTOM_element_aTOMIC_VOLUME (pvalue->u.aTOMIC_VOLUME);
         stat = asn1D_PERIODIC_TABLE_aTOM_element_aTOMIC_VOLUME (pctxt, 
            pvalue->u.aTOMIC_VOLUME, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 14;
         break;

      case (TM_CTXT|TM_CONS|14):
         pvalue->u.hEAT_OF_FUSION
             = rtxMemAllocType (pctxt, PERIODIC_TABLE_aTOM_element_hEAT_OF_FUSION);

         if (pvalue->u.hEAT_OF_FUSION == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PERIODIC_TABLE_aTOM_element_hEAT_OF_FUSION (pvalue->u.hEAT_OF_FUSION);
         stat = asn1D_PERIODIC_TABLE_aTOM_element_hEAT_OF_FUSION (pctxt, 
            pvalue->u.hEAT_OF_FUSION, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 15;
         break;

      case (TM_CTXT|TM_CONS|15):
         pvalue->u.sPECIFIC_HEAT_CAPACITY
             = rtxMemAllocType (pctxt, PERIODIC_TABLE_aTOM_element_sPECIFIC_HEAT_CAPACITY);

         if (pvalue->u.sPECIFIC_HEAT_CAPACITY == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PERIODIC_TABLE_aTOM_element_sPECIFIC_HEAT_CAPACITY (pvalue->u.sPECIFIC_HEAT_CAPACITY);
         stat = asn1D_PERIODIC_TABLE_aTOM_element_sPECIFIC_HEAT_CAPACITY (pctxt, 
            pvalue->u.sPECIFIC_HEAT_CAPACITY, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 16;
         break;

      case (TM_CTXT|TM_PRIM|16):
         stat = xd_real (pctxt, &pvalue->u.iONIZATION_POTENTIAL, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 17;
         break;

      case (TM_CTXT|TM_CONS|17):
         pvalue->u.tHERMAL_CONDUCTIVITY
             = rtxMemAllocType (pctxt, PERIODIC_TABLE_aTOM_element_tHERMAL_CONDUCTIVITY);

         if (pvalue->u.tHERMAL_CONDUCTIVITY == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PERIODIC_TABLE_aTOM_element_tHERMAL_CONDUCTIVITY (pvalue->u.tHERMAL_CONDUCTIVITY);
         stat = asn1D_PERIODIC_TABLE_aTOM_element_tHERMAL_CONDUCTIVITY (pctxt, 
            pvalue->u.tHERMAL_CONDUCTIVITY, ASN1IMPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 18;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_PERIODIC_TABLE_aTOM_element (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM_element* pvalue)
{
   int stat = 0;

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("NAME"), 4}, 0}, 0 },
      {{{OSUTF8("ATOMIC_WEIGHT"), 13}, 0}, 1 },
      {{{OSUTF8("ATOMIC_NUMBER"), 13}, 0}, 2 },
      {{{OSUTF8("OXIDATION_STATES"), 16}, 0}, 3 },
      {{{OSUTF8("BOILING_POINT"), 13}, 0}, 4 },
      {{{OSUTF8("MELTING_POINT"), 13}, 0}, 5 },
      {{{OSUTF8("SYMBOL"), 6}, 0}, 6 },
      {{{OSUTF8("DENSITY"), 7}, 0}, 7 },
      {{{OSUTF8("ELECTRON_CONFIGURATION"), 22}, 0}, 8 },
      {{{OSUTF8("COVALENT_RADIUS"), 15}, 0}, 9 },
      {{{OSUTF8("ELECTRONEGATIVITY"), 17}, 0}, 10 },
      {{{OSUTF8("ATOMIC_RADIUS"), 13}, 0}, 11 },
      {{{OSUTF8("HEAT_OF_VAPORIZATION"), 20}, 0}, 12 },
      {{{OSUTF8("ATOMIC_VOLUME"), 13}, 0}, 13 },
      {{{OSUTF8("HEAT_OF_FUSION"), 14}, 0}, 14 },
      {{{OSUTF8("SPECIFIC_HEAT_CAPACITY"), 22}, 0}, 15 },
      {{{OSUTF8("IONIZATION_POTENTIAL"), 20}, 0}, 16 },
      {{{OSUTF8("THERMAL_CONDUCTIVITY"), 20}, 0}, 17 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 18, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: { /* NAME */
      stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->u.nAME);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 1: { /* ATOMIC_WEIGHT */
      stat = rtXmlpDecDouble (pctxt, &pvalue->u.aTOMIC_WEIGHT, -1, -1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 2: { /* ATOMIC_NUMBER */
      stat = rtXmlpDecUInt8 (pctxt, &pvalue->u.aTOMIC_NUMBER);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 3: { /* OXIDATION_STATES */
      stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->u.oXIDATION_STATES);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 4: { /* BOILING_POINT */
      pvalue->u.bOILING_POINT
          = rtxMemAllocType (pctxt, PERIODIC_TABLE_aTOM_element_bOILING_POINT);

      if (pvalue->u.bOILING_POINT == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PERIODIC_TABLE_aTOM_element_bOILING_POINT (pvalue->
         u.bOILING_POINT);

      stat = XmlDec_PERIODIC_TABLE_aTOM_element_bOILING_POINT (pctxt, pvalue->
         u.bOILING_POINT);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 5: { /* MELTING_POINT */
      pvalue->u.mELTING_POINT
          = rtxMemAllocType (pctxt, PERIODIC_TABLE_aTOM_element_mELTING_POINT);

      if (pvalue->u.mELTING_POINT == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PERIODIC_TABLE_aTOM_element_mELTING_POINT (pvalue->
         u.mELTING_POINT);

      stat = XmlDec_PERIODIC_TABLE_aTOM_element_mELTING_POINT (pctxt, pvalue->
         u.mELTING_POINT);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 6: { /* SYMBOL */
      stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->u.sYMBOL);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 7: { /* DENSITY */
      pvalue->u.dENSITY
          = rtxMemAllocType (pctxt, PERIODIC_TABLE_aTOM_element_dENSITY);

      if (pvalue->u.dENSITY == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PERIODIC_TABLE_aTOM_element_dENSITY (pvalue->u.dENSITY);

      stat = XmlDec_PERIODIC_TABLE_aTOM_element_dENSITY (pctxt, pvalue->
         u.dENSITY);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 8: { /* ELECTRON_CONFIGURATION */
      stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->u.eLECTRON_CONFIGURATION);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 9: { /* COVALENT_RADIUS */
      pvalue->u.cOVALENT_RADIUS
          = rtxMemAllocType (pctxt, PERIODIC_TABLE_aTOM_element_cOVALENT_RADIUS);

      if (pvalue->u.cOVALENT_RADIUS == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PERIODIC_TABLE_aTOM_element_cOVALENT_RADIUS (pvalue->
         u.cOVALENT_RADIUS);

      stat = XmlDec_PERIODIC_TABLE_aTOM_element_cOVALENT_RADIUS (pctxt, pvalue
         ->u.cOVALENT_RADIUS);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 10: { /* ELECTRONEGATIVITY */
      stat = rtXmlpDecDouble (pctxt, &pvalue->u.eLECTRONEGATIVITY, -1, -1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 11: { /* ATOMIC_RADIUS */
      pvalue->u.aTOMIC_RADIUS
          = rtxMemAllocType (pctxt, PERIODIC_TABLE_aTOM_element_aTOMIC_RADIUS);

      if (pvalue->u.aTOMIC_RADIUS == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PERIODIC_TABLE_aTOM_element_aTOMIC_RADIUS (pvalue->
         u.aTOMIC_RADIUS);

      stat = XmlDec_PERIODIC_TABLE_aTOM_element_aTOMIC_RADIUS (pctxt, pvalue->
         u.aTOMIC_RADIUS);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 12: { /* HEAT_OF_VAPORIZATION */
      pvalue->u.hEAT_OF_VAPORIZATION
          = rtxMemAllocType (pctxt, PERIODIC_TABLE_aTOM_element_hEAT_OF_VAPORIZATION);

      if (pvalue->u.hEAT_OF_VAPORIZATION == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PERIODIC_TABLE_aTOM_element_hEAT_OF_VAPORIZATION (pvalue->
         u.hEAT_OF_VAPORIZATION);

      stat = XmlDec_PERIODIC_TABLE_aTOM_element_hEAT_OF_VAPORIZATION (pctxt, 
         pvalue->u.hEAT_OF_VAPORIZATION);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 13: { /* ATOMIC_VOLUME */
      pvalue->u.aTOMIC_VOLUME
          = rtxMemAllocType (pctxt, PERIODIC_TABLE_aTOM_element_aTOMIC_VOLUME);

      if (pvalue->u.aTOMIC_VOLUME == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PERIODIC_TABLE_aTOM_element_aTOMIC_VOLUME (pvalue->
         u.aTOMIC_VOLUME);

      stat = XmlDec_PERIODIC_TABLE_aTOM_element_aTOMIC_VOLUME (pctxt, pvalue->
         u.aTOMIC_VOLUME);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 14: { /* HEAT_OF_FUSION */
      pvalue->u.hEAT_OF_FUSION
          = rtxMemAllocType (pctxt, PERIODIC_TABLE_aTOM_element_hEAT_OF_FUSION);

      if (pvalue->u.hEAT_OF_FUSION == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PERIODIC_TABLE_aTOM_element_hEAT_OF_FUSION (pvalue->
         u.hEAT_OF_FUSION);

      stat = XmlDec_PERIODIC_TABLE_aTOM_element_hEAT_OF_FUSION (pctxt, pvalue->
         u.hEAT_OF_FUSION);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 15: { /* SPECIFIC_HEAT_CAPACITY */
      pvalue->u.sPECIFIC_HEAT_CAPACITY
          = rtxMemAllocType (pctxt, PERIODIC_TABLE_aTOM_element_sPECIFIC_HEAT_CAPACITY);

      if (pvalue->u.sPECIFIC_HEAT_CAPACITY == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PERIODIC_TABLE_aTOM_element_sPECIFIC_HEAT_CAPACITY (pvalue->
         u.sPECIFIC_HEAT_CAPACITY);

      stat = XmlDec_PERIODIC_TABLE_aTOM_element_sPECIFIC_HEAT_CAPACITY (pctxt, 
         pvalue->u.sPECIFIC_HEAT_CAPACITY);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 16: { /* IONIZATION_POTENTIAL */
      stat = rtXmlpDecDouble (pctxt, &pvalue->u.iONIZATION_POTENTIAL, -1, -1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   case 17: { /* THERMAL_CONDUCTIVITY */
      pvalue->u.tHERMAL_CONDUCTIVITY
          = rtxMemAllocType (pctxt, PERIODIC_TABLE_aTOM_element_tHERMAL_CONDUCTIVITY);

      if (pvalue->u.tHERMAL_CONDUCTIVITY == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PERIODIC_TABLE_aTOM_element_tHERMAL_CONDUCTIVITY (pvalue->
         u.tHERMAL_CONDUCTIVITY);

      stat = XmlDec_PERIODIC_TABLE_aTOM_element_tHERMAL_CONDUCTIVITY (pctxt, 
         pvalue->u.tHERMAL_CONDUCTIVITY);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = rtXmlpMatchEndTag (pctxt, -1);
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PERIODIC_TABLE_aTOM                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PERIODIC_TABLE_aTOM (OSCTXT* pctxt, 
   PERIODIC_TABLE_aTOM *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode sTATE */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->sTATE, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sTATEPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode choice_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               PERIODIC_TABLE_aTOM_element* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->choice_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, PERIODIC_TABLE_aTOM_element, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_PERIODIC_TABLE_aTOM_element (pdata2);

                  stat = asn1D_PERIODIC_TABLE_aTOM_element (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->choice_list, pnode);
               }

               if (!(pvalue->choice_list.count >= 1U)) {
                  rtxErrAddStrParm (pctxt, "PERIODIC_TABLE_aTOM.choice_list.count");
                  rtxErrAddIntParm (pctxt, (int)pvalue->choice_list.count);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PERIODIC_TABLE_aTOM (OSCTXT* pctxt, PERIODIC_TABLE_aTOM* pvalue)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode attributes */
   if (rtXmlpHasAttributes (pctxt)) {
      static const OSXMLAttrDescr attrNames[] = {
         { {OSUTF8("STATE"), 5}, 0 }
      } ;
      OSUINT32 attrPresent[1];
      size_t i, nAttrs = 0;
      OSXMLNameFragments attrName;
      int tabidx;

      memset (attrPresent, 0, sizeof(attrPresent));

      stat = rtXmlpGetAttributeCount (pctxt);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
      else nAttrs = (size_t)stat;

      for (i = 0; i < nAttrs; i++) {
         if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
         tabidx = rtXmlpGetAttributeID (pctxt, 
            &attrName.mLocalName, 1, attrNames, attrPresent);

         switch (tabidx) {
         case 0: /* STATE */
            stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->sTATE);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->m.sTATEPresent = TRUE;
            break;

         default:
            stat = rtXmlpDecXSIAttr (pctxt, &attrName);
            if (stat != 0) {
               rtxErrAddStrParm (pctxt, "PERIODIC_TABLE_aTOM");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_INVATTR);
               stat = 0;
            }
         }
         if (stat < 0) {
            rtxErrAddStrParm (pctxt, "PERIODIC_TABLE_aTOM");
            rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
               attrName.mQName.length);
            LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
            stat = 0;
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("NAME"), 4}, 0}, 0 },
      {{{OSUTF8("ATOMIC_WEIGHT"), 13}, 0}, 0 },
      {{{OSUTF8("ATOMIC_NUMBER"), 13}, 0}, 0 },
      {{{OSUTF8("OXIDATION_STATES"), 16}, 0}, 0 },
      {{{OSUTF8("BOILING_POINT"), 13}, 0}, 0 },
      {{{OSUTF8("MELTING_POINT"), 13}, 0}, 0 },
      {{{OSUTF8("SYMBOL"), 6}, 0}, 0 },
      {{{OSUTF8("DENSITY"), 7}, 0}, 0 },
      {{{OSUTF8("ELECTRON_CONFIGURATION"), 22}, 0}, 0 },
      {{{OSUTF8("COVALENT_RADIUS"), 15}, 0}, 0 },
      {{{OSUTF8("ELECTRONEGATIVITY"), 17}, 0}, 0 },
      {{{OSUTF8("ATOMIC_RADIUS"), 13}, 0}, 0 },
      {{{OSUTF8("HEAT_OF_VAPORIZATION"), 20}, 0}, 0 },
      {{{OSUTF8("ATOMIC_VOLUME"), 13}, 0}, 0 },
      {{{OSUTF8("HEAT_OF_FUSION"), 14}, 0}, 0 },
      {{{OSUTF8("SPECIFIC_HEAT_CAPACITY"), 22}, 0}, 0 },
      {{{OSUTF8("IONIZATION_POTENTIAL"), 20}, 0}, 0 },
      {{{OSUTF8("THERMAL_CONDUCTIVITY"), 20}, 0}, 0 }
   } ;
   static const struct {
      int row;
      int num;
      int anyCase;
   } groupDesc[] = { {0, 18, -1}};

   int group = 0;
   int i;
   for (i = 0; i < 1; i++) {
      int fromrow = groupDesc[group].row;
      int rows = groupDesc[group].num;
      int anyCase = groupDesc[group].anyCase;

      elemID = rtXmlpGetNextElemID (pctxt, 
         elemtab + fromrow, rows, -1, FALSE);
      if (elemID == RTERR_UNEXPELEM && anyCase >= 0 && i == anyCase)
         elemID = anyCase;
      else if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;
      else if (elemID == elemtab[fromrow + rows - 1].id) group++;

      switch (elemID) {
      case 0: {
         PERIODIC_TABLE_aTOM_element* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, PERIODIC_TABLE_aTOM_element);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PERIODIC_TABLE_aTOM_element (pdata1);

            rtXmlpMarkLastEventActive (pctxt);

            stat = XmlDec_PERIODIC_TABLE_aTOM_element (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab + 0, 18, -1, FALSE);
            if (stat < 0 && stat != RTERR_UNEXPELEM)
               return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
      i = elemID;
   }
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PERIODIC_TABLE                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PERIODIC_TABLE (OSCTXT* pctxt, PERIODIC_TABLE *pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   PERIODIC_TABLE_aTOM* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (XD_PEEKTAG (pctxt, 0x30)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_UNIV|TM_CONS|16));

   if (XD_PEEKTAG (pctxt, 0xa0)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_CTXT|TM_CONS|0));

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      rtxDListAllocNodeAndData (pctxt, PERIODIC_TABLE_aTOM, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PERIODIC_TABLE_aTOM (pdata1);

      stat = asn1D_PERIODIC_TABLE_aTOM (pctxt, 
         pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "PERIODIC_TABLE.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

int XmlDec_PERIODIC_TABLE (OSCTXT* pctxt, PERIODIC_TABLE* pvalue)
{
   int stat = 0;

   { int elemID;
   PERIODIC_TABLE_aTOM* pdata1;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("ATOM"), 4}, 0}, 0 }
   } ;

   rtxDListInit (pvalue);
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 1, -1, FALSE);
      if (elemID < 0 || elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: /* ATOM */
         pdata1 = rtxMemAllocType (pctxt, PERIODIC_TABLE_aTOM);

         if (pdata1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PERIODIC_TABLE_aTOM (pdata1);

         stat = XmlDec_PERIODIC_TABLE_aTOM (pctxt, pdata1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         break;

      }
   }

   if (elemID == RTERR_UNEXPELEM || elemID == XML_OK_EOB) {
      stat = 0;
   }
   else return LOG_RTERR (pctxt, elemID);
   }

   return (stat);
}

int XmlDec_PERIODIC_TABLE_PDU (OSCTXT* pctxt, PERIODIC_TABLE* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   asn1Init_PERIODIC_TABLE (pvalue);

   stat = rtXmlpMatchStartTag (pctxt, OSUTF8("PERIODIC_TABLE"), 0);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   stat = XmlDec_PERIODIC_TABLE (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
