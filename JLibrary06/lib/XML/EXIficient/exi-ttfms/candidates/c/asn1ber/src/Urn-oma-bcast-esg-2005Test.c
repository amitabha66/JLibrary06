/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 19-Sep-2006.
 */
#include "Urn-oma-bcast-esg-2005.h"
#include "libxml/parser.h"
#include "rtxmlsrc/osrtxml.h"
#include "rtxsrc/rtxCommon.h"

int DOMTest_TargetUserProfileType (OSCTXT* pctxt, 
   TargetUserProfileType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("ProfileAttributeName"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->profileAttributeName = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("ProfileAttributeValue"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->profileAttributeValue = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_PreviewDataIDRefType (OSCTXT* pctxt, PreviewDataIDRefType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("usage"))) {
            pvalue->m.usagePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->usage = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }

   return 0;
}

int DOMTest_Broadcast_areaType_target_area (OSCTXT* pctxt, 
   Broadcast_areaType_target_area* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("shape"))) {
            pvalue->m.shapePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->shape = pXmlNode->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("cc"))) {
            pvalue->m.ccPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->cc = pXmlNode->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("name_area"))) {
            pvalue->m.name_areaPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->name_area = pXmlNode->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("zip_code"))) {
            pvalue->m.zip_codePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->zip_code = atoi ((const char*)pXmlNode->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Cell_ID"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->cell_ID_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Cell_Group_ID"))) {
            pvalue->m.cell_Group_IDPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->cell_Group_ID = pXmlNode->children->content;
            }
         }
      }
   }

   return 0;
}

int DOMTest_Broadcast_areaType (OSCTXT* pctxt, Broadcast_areaType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("polarity"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->polarity);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("target_area"))) {
            { Broadcast_areaType_target_area* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Broadcast_areaType_target_area);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Broadcast_areaType_target_area (pdata2);
            DOMTest_Broadcast_areaType_target_area (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->target_area_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("hor_ac"))) {
            { OSXSDAny* pdata2;
            pdata2 = rtxMemAllocTypeZ (pctxt, OSXSDAny);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            if (0 != pXmlNode->children) {
               pdata2->t = OSXSDAny_xmlText;
               pdata2->u.xmlText = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->hor_ac_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_ServiceType (OSCTXT* pctxt, ServiceType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("ServiceBaseCID"))) {
            pvalue->m.serviceBaseCIDPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->serviceBaseCID = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("ServiceProtection"))) {
            pvalue->m.serviceProtectionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->serviceProtection);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Weight"))) {
            pvalue->m.weightPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->weight = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->type = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("validFrom"))) {
            pvalue->m.validFromPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->validFrom = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("validTo"))) {
            pvalue->m.validToPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->validTo = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->version = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ExtensionURL"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->extensionURL_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("GlobalServiceID"))) {
            pvalue->m.globalServiceIDPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->globalServiceID = pXmlNode->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Name"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->name_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Description"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->description_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ParentalRating"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->parentalRating_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TargetUserProfile"))) {
            { TargetUserProfileType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TargetUserProfileType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TargetUserProfileType (pdata2);
            DOMTest_TargetUserProfileType (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->targetUserProfile_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Genre"))) {
            { GenreElementType pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->genre_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UserRating"))) {
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PreviewDataIDRef"))) {
            { PreviewDataIDRefType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, PreviewDataIDRefType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PreviewDataIDRefType (pdata2);
            DOMTest_PreviewDataIDRefType (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->previewDataIDRef_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("broadcast_area"))) {
            pvalue->m.broadcast_areaPresent = 1;
            DOMTest_Broadcast_areaType (pctxt, &pvalue->broadcast_area, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_Distribution_WindowType_repeatType (OSCTXT* pctxt, 
   Distribution_WindowType_repeatType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Num"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->num = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Unit"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->unit = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_Distribution_WindowType (OSCTXT* pctxt, 
   Distribution_WindowType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("DWid"))) {
            pvalue->m.dWidPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->dWid = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Distribution_End_Time"))) {
            pvalue->m.distribution_End_TimePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->distribution_End_Time = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Distribution_Start_Time"))) {
            pvalue->m.distribution_Start_TimePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->distribution_Start_Time = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Duration"))) {
            pvalue->m.durationPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->duration = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("RepeatType"))) {
            pvalue->m.repeatTypePresent = 1;
            DOMTest_Distribution_WindowType_repeatType (pctxt, &pvalue->repeatType, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_ScheduleType_interactivityDataIDRef (OSCTXT* pctxt, 
   ScheduleType_interactivityDataIDRef* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("AutoStart"))) {
            pvalue->m.autoStartPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->autoStart);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("idRef"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->idRef = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Distribution_Window"))) {
            { Distribution_WindowType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Distribution_WindowType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Distribution_WindowType (pdata2);
            DOMTest_Distribution_WindowType (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->distribution_Window_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_Presentation_WindowType_repeatType (OSCTXT* pctxt, 
   Presentation_WindowType_repeatType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Num"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->num = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Unit"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->unit = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_Presentation_WindowType (OSCTXT* pctxt, 
   Presentation_WindowType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Duration"))) {
            pvalue->m.durationPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->duration = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("PWid"))) {
            pvalue->m.pWidPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->pWid = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Presentation_End_Time"))) {
            pvalue->m.presentation_End_TimePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->presentation_End_Time = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Presentation_Start_Time"))) {
            pvalue->m.presentation_Start_TimePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->presentation_Start_Time = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("RepeatType"))) {
            pvalue->m.repeatTypePresent = 1;
            DOMTest_Presentation_WindowType_repeatType (pctxt, &pvalue->repeatType, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_ScheduleType_contentIDRef (OSCTXT* pctxt, 
   ScheduleType_contentIDRef* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("AutoStart"))) {
            pvalue->m.autoStartPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->autoStart);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("RepeatPlayback"))) {
            pvalue->m.repeatPlaybackPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->repeatPlayback);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("idRef"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->idRef = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Distribution_Window"))) {
            { Distribution_WindowType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Distribution_WindowType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Distribution_WindowType (pdata2);
            DOMTest_Distribution_WindowType (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->distribution_Window_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Presentation_Window"))) {
            { Presentation_WindowType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Presentation_WindowType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Presentation_WindowType (pdata2);
            DOMTest_Presentation_WindowType (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->presentation_Window_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_ScheduleType (OSCTXT* pctxt, ScheduleType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("ServiceIDRef"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->serviceIDRef = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("validFrom"))) {
            pvalue->m.validFromPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->validFrom = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("validTo"))) {
            pvalue->m.validToPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->validTo = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->version = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("InteractivityDataIDRef"))) {
            { ScheduleType_interactivityDataIDRef* pdata2;
            pdata2
                = rtxMemAllocType (pctxt, ScheduleType_interactivityDataIDRef);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ScheduleType_interactivityDataIDRef (pdata2);
            DOMTest_ScheduleType_interactivityDataIDRef (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->interactivityDataIDRef_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ContentIDRef"))) {
            { ScheduleType_contentIDRef* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ScheduleType_contentIDRef);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ScheduleType_contentIDRef (pdata2);
            DOMTest_ScheduleType_contentIDRef (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->contentIDRef_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ExtensionURL"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->extensionURL_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Name"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->name_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Description"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->description_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PreviewDataIDRef"))) {
            { PreviewDataIDRefType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, PreviewDataIDRefType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PreviewDataIDRefType (pdata2);
            DOMTest_PreviewDataIDRefType (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->previewDataIDRef_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_FileType (OSCTXT* pctxt, FileType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Content-Encoding"))) {
            pvalue->m.content_EncodingPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->content_Encoding = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Content-Length"))) {
            pvalue->m.content_LengthPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->content_Length = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Content-Location"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->content_Location = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Content-MD5"))) {
            pvalue->m.content_MD5Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecDynBase64Str (pctxt, &pvalue->content_MD5);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Content-Type"))) {
            pvalue->m.content_TypePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->content_Type = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("FEC-OTI-Encoding-Symbol-Length"))) {
            pvalue->m.fEC_OTI_Encoding_Symbol_LengthPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->fEC_OTI_Encoding_Symbol_Length = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("FEC-OTI-FEC-Instance-ID"))) {
            pvalue->m.fEC_OTI_FEC_Instance_IDPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->fEC_OTI_FEC_Instance_ID = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("FEC-OTI-Max-Number-of-Encoding-Symbols"))) {
            pvalue->m.fEC_OTI_Max_Number_of_Encoding_SymbolsPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->fEC_OTI_Max_Number_of_Encoding_Symbols = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("FEC-OTI-Maximum-Source-Block-Length"))) {
            pvalue->m.fEC_OTI_Maximum_Source_Block_LengthPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->fEC_OTI_Maximum_Source_Block_Length = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("TOI"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->tOI = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Transfer-Length"))) {
            pvalue->m.transfer_LengthPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->transfer_Length = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_FileDescriptionType (OSCTXT* pctxt, FileDescriptionType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Content-Encoding"))) {
            pvalue->m.content_EncodingPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->content_Encoding = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Content-Length"))) {
            pvalue->m.content_LengthPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->content_Length = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Content-MD5"))) {
            pvalue->m.content_MD5Present = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecDynBase64Str (pctxt, &pvalue->content_MD5);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Content-Type"))) {
            pvalue->m.content_TypePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->content_Type = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("FEC-OTI-Encoding-Symbol-Length"))) {
            pvalue->m.fEC_OTI_Encoding_Symbol_LengthPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->fEC_OTI_Encoding_Symbol_Length = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("FEC-OTI-FEC-Instance-ID"))) {
            pvalue->m.fEC_OTI_FEC_Instance_IDPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->fEC_OTI_FEC_Instance_ID = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("FEC-OTI-Max-Number-of-Encoding-Symbols"))) {
            pvalue->m.fEC_OTI_Max_Number_of_Encoding_SymbolsPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->fEC_OTI_Max_Number_of_Encoding_Symbols = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("FEC-OTI-Maximum-Source-Block-Length"))) {
            pvalue->m.fEC_OTI_Maximum_Source_Block_LengthPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->fEC_OTI_Maximum_Source_Block_Length = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Transfer-Length"))) {
            pvalue->m.transfer_LengthPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->transfer_Length = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("File"))) {
            { FileType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, FileType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FileType (pdata2);
            DOMTest_FileType (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->file_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_ContentType (OSCTXT* pctxt, ContentType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("ContentType"))) {
            pvalue->m.contentTypePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->contentType = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("ServiceIDRef"))) {
            pvalue->m.serviceIDRefPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->serviceIDRef = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("validFrom"))) {
            pvalue->m.validFromPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->validFrom = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("validTo"))) {
            pvalue->m.validToPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->validTo = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->version = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ExtensionURL"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->extensionURL_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Name"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->name_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Description"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->description_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ParentalRating"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->parentalRating_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TargetUserProfile"))) {
            pvalue->m.targetUserProfilePresent = 1;
            DOMTest_TargetUserProfileType (pctxt, &pvalue->targetUserProfile, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Genre"))) {
            { GenreElementType pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->genre_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UserRating"))) {
            pvalue->m.userRatingPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->userRating = atoi ((const char*)pXmlNode->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PreviewDataIDRef"))) {
            { PreviewDataIDRefType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, PreviewDataIDRefType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PreviewDataIDRefType (pdata2);
            DOMTest_PreviewDataIDRefType (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->previewDataIDRef_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("broadcast_area"))) {
            pvalue->m.broadcast_areaPresent = 1;
            DOMTest_Broadcast_areaType (pctxt, &pvalue->broadcast_area, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("FileDescription"))) {
            pvalue->m.fileDescriptionPresent = 1;
            DOMTest_FileDescriptionType (pctxt, &pvalue->fileDescription, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_AccessTypeType_broadcastTransmission_sessionDescriptionReference (OSCTXT* pctxt, 
   AccessTypeType_broadcastTransmission_sessionDescriptionReference* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Type"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->type = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("URI"))) {
            pvalue->m.uRIPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->uRI = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("idRef"))) {
            pvalue->m.idRefPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->idRef = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_AccessTypeType_broadcastTransmission (OSCTXT* pctxt, 
   AccessTypeType_broadcastTransmission* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("IPAddress"))) {
            pvalue->m.iPAddressPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->iPAddress = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SessionDescriptionReference"))) {
            { AccessTypeType_broadcastTransmission_sessionDescriptionReference* pdata2;
            pdata2
                = rtxMemAllocType (pctxt, AccessTypeType_broadcastTransmission_sessionDescriptionReference);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AccessTypeType_broadcastTransmission_sessionDescriptionReference (pdata2);
            DOMTest_AccessTypeType_broadcastTransmission_sessionDescriptionReference (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->sessionDescriptionReference_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SDP"))) {
            pvalue->m.sDPPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->sDP = pXmlNode->children->content;
            }
         }
      }
   }

   return 0;
}

int DOMTest_AccessTypeType_interactiveTransmissionScheme (OSCTXT* pctxt, 
   AccessTypeType_interactiveTransmissionScheme* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("TransmissionSchemeType"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->transmissionSchemeType = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AccessServerIPAddress"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->accessServerIPAddress_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AccessServerURL"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->accessServerURL_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AccessServerPhoneNumber"))) {
         }
      }
   }

   return 0;
}

int DOMTest_AccessTypeType (OSCTXT* pctxt, AccessTypeType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("TransmissionMedia"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->transmissionMedia = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("BroadcastTransmission"))) {
            pvalue->m.broadcastTransmissionPresent = 1;
            DOMTest_AccessTypeType_broadcastTransmission (pctxt, &pvalue->broadcastTransmission, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("InteractiveTransmissionScheme"))) {
            pvalue->m.interactiveTransmissionSchemePresent = 1;
            DOMTest_AccessTypeType_interactiveTransmissionScheme (pctxt, &pvalue->interactiveTransmissionScheme, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_KMSType (OSCTXT* pctxt, KMSType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("RightsIssuerURI"))) {
            pvalue->m.rightsIssuerURIPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->rightsIssuerURI = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("protectionType"))) {
            pvalue->m.protectionTypePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->protectionType = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }

   return 0;
}

int DOMTest_AccessType_scheduleIDRef (OSCTXT* pctxt, 
   AccessType_scheduleIDRef* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("DistributionWindowID"))) {
            pvalue->m.distributionWindowIDPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->distributionWindowID = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }

   return 0;
}

int DOMTest_AccessType_choice (OSCTXT* pctxt, AccessType_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ServiceIDRef"))) {
            pvalue->t = 1;
            pvalue->u.serviceIDRef_list = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.serviceIDRef_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.serviceIDRef_list);
            {
            ServiceIDType pdata2 = 0;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ServiceIDRef"))) {
                     if (0 != pXmlNode->children) {
                        pdata2 = pXmlNode->children->content;
                     }
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, pvalue->u.serviceIDRef_list, (void*)pdata2);
                  }
               }
            }
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ScheduleIDRef"))) {
            pvalue->t = 2;
            pvalue->u.scheduleIDRef_list = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.scheduleIDRef_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.scheduleIDRef_list);
            {
            AccessType_scheduleIDRef* pdata2;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ScheduleIDRef"))) {
                     pdata2
                         = rtxMemAllocType (pctxt, AccessType_scheduleIDRef);

                     if (pdata2 == NULL)
                        return LOG_RTERR (pctxt, RTERR_NOMEM);

                     asn1Init_AccessType_scheduleIDRef (pdata2);
                     DOMTest_AccessType_scheduleIDRef (pctxt, pdata2, pXmlNode, TRUE);
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, pvalue->u.scheduleIDRef_list, (void*)pdata2);
                  }
               }
            }
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_TerminalCapabilityRequirementType_video_bitrate (OSCTXT* pctxt, 
   TerminalCapabilityRequirementType_video_bitrate* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("average"))) {
            pvalue->m.averagePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->average = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("maximum"))) {
            pvalue->m.maximumPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->maximum = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_TerminalCapabilityRequirementType_video_resolution (OSCTXT* pctxt, 
   TerminalCapabilityRequirementType_video_resolution* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("horizontal"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->horizontal = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("vertical"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->vertical = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_TerminalCapabilityRequirementType_video (OSCTXT* pctxt, 
   TerminalCapabilityRequirementType_video* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Match explicit XML element tag */
   pXmlNode = pXmlNode->children;
   if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Complexity"))) {
      /* Populate elements */
      if (setChild)
         pXmlNode = pXmlNode->children;

      for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
         if (pXmlNode->type == XML_ELEMENT_NODE) {
            if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Bitrate"))) {
               pvalue->m.bitratePresent = 1;
               DOMTest_TerminalCapabilityRequirementType_video_bitrate (pctxt, &pvalue->bitrate, pXmlNode, TRUE);
            }
            else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Resolution"))) {
               pvalue->m.resolutionPresent = 1;
               DOMTest_TerminalCapabilityRequirementType_video_resolution (pctxt, &pvalue->resolution, pXmlNode, TRUE);
            }
            else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MinimumBufferSize"))) {
               pvalue->m.minimumBufferSizePresent = 1;
               if (0 != pXmlNode->children) {
                  pvalue->minimumBufferSize = atoi ((const char*)pXmlNode->children->content);
               }
            }
         }
      }
   } /* explicit tag match */

   return 0;
}

int DOMTest_TerminalCapabilityRequirementType_audio_bitrate (OSCTXT* pctxt, 
   TerminalCapabilityRequirementType_audio_bitrate* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("average"))) {
            pvalue->m.averagePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->average = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("maximum"))) {
            pvalue->m.maximumPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->maximum = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_TerminalCapabilityRequirementType_audio (OSCTXT* pctxt, 
   TerminalCapabilityRequirementType_audio* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Match explicit XML element tag */
   pXmlNode = pXmlNode->children;
   if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Complexity"))) {
      /* Populate elements */
      if (setChild)
         pXmlNode = pXmlNode->children;

      for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
         if (pXmlNode->type == XML_ELEMENT_NODE) {
            if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Bitrate"))) {
               pvalue->m.bitratePresent = 1;
               DOMTest_TerminalCapabilityRequirementType_audio_bitrate (pctxt, &pvalue->bitrate, pXmlNode, TRUE);
            }
            else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MinimumBufferSize"))) {
               pvalue->m.minimumBufferSizePresent = 1;
               if (0 != pXmlNode->children) {
                  pvalue->minimumBufferSize = atoi ((const char*)pXmlNode->children->content);
               }
            }
         }
      }
   } /* explicit tag match */

   return 0;
}

int DOMTest_TerminalCapabilityRequirementType (OSCTXT* pctxt, 
   TerminalCapabilityRequirementType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Video"))) {
            pvalue->m.videoPresent = 1;
            DOMTest_TerminalCapabilityRequirementType_video (pctxt, &pvalue->video, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Audio"))) {
            pvalue->m.audioPresent = 1;
            DOMTest_TerminalCapabilityRequirementType_audio (pctxt, &pvalue->audio, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("DownloadFile"))) {
            pvalue->m.downloadFilePresent = 1;
            { OSRTDList* pdata2;
            pdata2 = rtxMemAllocType (pctxt, OSRTDList);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pdata2);
            {
            const OSUTF8CHAR* pdata3 = 0;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Type"))) {
                     if (0 != pXmlNode->children) {
                        pdata3 = pXmlNode->children->content;
                     }
                     if (0 != pdata3)
                        rtxDListAppend (pctxt, pdata2, (void*)pdata3);
                  }
               }
            }
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->downloadFile, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_NotificationReceptionType (OSCTXT* pctxt, 
   NotificationReceptionType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("NotificationAddress"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->notificationAddress = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("NotificationPort"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->notificationPort = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_AccessType (OSCTXT* pctxt, AccessType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("AudioLanguage"))) {
            pvalue->m.audioLanguagePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->audioLanguage = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("ServiceProtection"))) {
            pvalue->m.serviceProtectionPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->serviceProtection);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("validFrom"))) {
            pvalue->m.validFromPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->validFrom = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("validTo"))) {
            pvalue->m.validToPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->validTo = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->version = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AccessType"))) {
            DOMTest_AccessTypeType (pctxt, &pvalue->accessType, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("KeyManagementSystem"))) {
            { KMSType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, KMSType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_KMSType (pdata2);
            DOMTest_KMSType (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->keyManagementSystem_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ExtensionURL"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->extensionURL_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ServiceIDRef")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ScheduleIDRef"))) {
            pvalue->m.choicePresent = 1;
            DOMTest_AccessType_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UsageInfo"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->usageInfo_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AlternativeAccessURL"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->alternativeAccessURL_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("TerminalCapabilityRequirement"))) {
            pvalue->m.terminalCapabilityRequirementPresent = 1;
            DOMTest_TerminalCapabilityRequirementType (pctxt, &pvalue->terminalCapabilityRequirement, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("BandwidthRequirement"))) {
            pvalue->m.bandwidthRequirementPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->bandwidthRequirement = atoi ((const char*)pXmlNode->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ServiceClass"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->serviceClass_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PreviewDataIDRef"))) {
            { PreviewDataIDRefType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, PreviewDataIDRefType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PreviewDataIDRefType (pdata2);
            DOMTest_PreviewDataIDRefType (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->previewDataIDRef_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("NotificationReception"))) {
            pvalue->m.notificationReceptionPresent = 1;
            DOMTest_NotificationReceptionType (pctxt, &pvalue->notificationReception, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_PictureType (OSCTXT* pctxt, PictureType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PictureURI"))) {
            pvalue->m.pictureURIPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->pictureURI = pXmlNode->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PictureData"))) {
            pvalue->m.pictureDataPresent = 1;
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecDynBase64Str (pctxt, &pvalue->pictureData);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Codec"))) {
            pvalue->m.codecPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->codec = atoi ((const char*)pXmlNode->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AlternativeText"))) {
            pvalue->m.alternativeTextPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->alternativeText = pXmlNode->children->content;
            }
         }
      }
   }

   return 0;
}

int DOMTest_VideoType (OSCTXT* pctxt, VideoType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("VideoURI"))) {
            if (0 != pXmlNode->children) {
               pvalue->videoURI = pXmlNode->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Codec"))) {
            pvalue->m.codecPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->codec = atoi ((const char*)pXmlNode->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AlternativeText"))) {
            pvalue->m.alternativeTextPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->alternativeText = pXmlNode->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AlternativePicture"))) {
            pvalue->m.alternativePicturePresent = 1;
            DOMTest_PictureType (pctxt, &pvalue->alternativePicture, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_AudioType (OSCTXT* pctxt, AudioType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AudioURI"))) {
            if (0 != pXmlNode->children) {
               pvalue->audioURI = pXmlNode->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Codec"))) {
            pvalue->m.codecPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->codec = atoi ((const char*)pXmlNode->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AlternativeText"))) {
            pvalue->m.alternativeTextPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->alternativeText = pXmlNode->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AlternativePicture"))) {
            pvalue->m.alternativePicturePresent = 1;
            DOMTest_PictureType (pctxt, &pvalue->alternativePicture, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_PreviewDataType (OSCTXT* pctxt, PreviewDataType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("validFrom"))) {
            pvalue->m.validFromPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->validFrom = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("validTo"))) {
            pvalue->m.validToPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->validTo = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->version = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SMIL"))) {
            pvalue->m.sMILPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->sMIL = pXmlNode->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Video"))) {
            pvalue->m.videoPresent = 1;
            DOMTest_VideoType (pctxt, &pvalue->video, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Audio"))) {
            pvalue->m.audioPresent = 1;
            DOMTest_AudioType (pctxt, &pvalue->audio, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Picture"))) {
            pvalue->m.picturePresent = 1;
            DOMTest_PictureType (pctxt, &pvalue->picture, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Text"))) {
            pvalue->m.textPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->text = pXmlNode->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AccessIDRef"))) {
            pvalue->m.accessIDRefPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->accessIDRef = pXmlNode->children->content;
            }
         }
      }
   }

   return 0;
}

int DOMTest_PurchaseItemType (OSCTXT* pctxt, PurchaseItemType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Weight"))) {
            pvalue->m.weightPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->weight = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("validFrom"))) {
            pvalue->m.validFromPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->validFrom = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("validTo"))) {
            pvalue->m.validToPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->validTo = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->version = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ExtensionURL"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->extensionURL_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ServiceIDRef"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->serviceIDRef_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ScheduleIDRef"))) {
            { ScheduleIDType pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->scheduleIDRef_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ContentIDRef"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->contentIDRef_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Name"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->name_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Description"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->description_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ParentalRating"))) {
            pvalue->m.parentalRatingPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->parentalRating = atoi ((const char*)pXmlNode->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PurchaseDataIDRef"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->purchaseDataIDRef_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_PurchaseDataType_priceInfo_subscriptionUnit (OSCTXT* pctxt, 
   PurchaseDataType_priceInfo_subscriptionUnit* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Type"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->type = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Unit"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->unit = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Value"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->value = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_PurchaseDataType_priceInfo_price (OSCTXT* pctxt, 
   PurchaseDataType_priceInfo_price* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Currency"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->currency = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Value"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->value = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_PurchaseDataType_priceInfo (OSCTXT* pctxt, 
   PurchaseDataType_priceInfo* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SubscriptionUnit"))) {
            DOMTest_PurchaseDataType_priceInfo_subscriptionUnit (pctxt, &pvalue->subscriptionUnit, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UnitText"))) {
            if (0 != pXmlNode->children) {
               pvalue->unitText = pXmlNode->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Price"))) {
            { PurchaseDataType_priceInfo_price* pdata2;
            pdata2
                = rtxMemAllocType (pctxt, PurchaseDataType_priceInfo_price);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PurchaseDataType_priceInfo_price (pdata2);
            DOMTest_PurchaseDataType_priceInfo_price (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->price_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_PurchaseDataType_mediaInformation (OSCTXT* pctxt, 
   PurchaseDataType_mediaInformation* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("idRef"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->idRef = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("usage"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->usage = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_PurchaseDataType_promotionInfo (OSCTXT* pctxt, 
   PurchaseDataType_promotionInfo* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("validFrom"))) {
            pvalue->m.validFromPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->validFrom = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("validTo"))) {
            pvalue->m.validToPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->validTo = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Title"))) {
            if (0 != pXmlNode->children) {
               pvalue->title = pXmlNode->children->content;
            }
         }
         pvalue->m.targetUserProfilePresent = 1;
         if (0 != pXmlNode->children) {
            pvalue->targetUserProfile.t = OSXSDAny_xmlText;
            pvalue->targetUserProfile.u.xmlText = pXmlNode->children->content;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Description"))) {
            pvalue->m.descriptionPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->description = pXmlNode->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("URL"))) {
            pvalue->m.uRLPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->uRL = pXmlNode->children->content;
            }
         }
      }
   }

   return 0;
}

int DOMTest_PurchaseDataType (OSCTXT* pctxt, PurchaseDataType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("validFrom"))) {
            pvalue->m.validFromPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->validFrom = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("validTo"))) {
            pvalue->m.validToPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->validTo = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->version = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ExtensionURL"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->extensionURL_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Description"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->description_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PurchaseItemIDRef"))) {
            if (0 != pXmlNode->children) {
               pvalue->purchaseItemIDRef = pXmlNode->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PurchaseChannelIDRef"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->purchaseChannelIDRef_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PriceInfo"))) {
            { PurchaseDataType_priceInfo* pdata2;
            pdata2 = rtxMemAllocType (pctxt, PurchaseDataType_priceInfo);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PurchaseDataType_priceInfo (pdata2);
            DOMTest_PurchaseDataType_priceInfo (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->priceInfo_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MediaInformation"))) {
            { PurchaseDataType_mediaInformation* pdata2;
            pdata2
                = rtxMemAllocType (pctxt, PurchaseDataType_mediaInformation);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PurchaseDataType_mediaInformation (pdata2);
            DOMTest_PurchaseDataType_mediaInformation (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->mediaInformation_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PromotionInfo"))) {
            { PurchaseDataType_promotionInfo* pdata2;
            pdata2 = rtxMemAllocType (pctxt, PurchaseDataType_promotionInfo);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PurchaseDataType_promotionInfo (pdata2);
            DOMTest_PurchaseDataType_promotionInfo (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->promotionInfo_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_PurchaseChannelType_selector (OSCTXT* pctxt, 
   PurchaseChannelType_selector* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Type"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->type = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }

   return 0;
}

int DOMTest_PurchaseChannelType_connection_purchaseURL (OSCTXT* pctxt, 
   PurchaseChannelType_connection_purchaseURL* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Bearer"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->bearer = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      pvalue->base = pXmlNode->children->content;
   }

   return 0;
}

int DOMTest_PurchaseChannelType (OSCTXT* pctxt, PurchaseChannelType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("RightsIssuerURI"))) {
            pvalue->m.rightsIssuerURIPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->rightsIssuerURI = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("localflag"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->localflag);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("validFrom"))) {
            pvalue->m.validFromPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->validFrom = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("validTo"))) {
            pvalue->m.validToPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->validTo = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->version = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Selector"))) {
            DOMTest_PurchaseChannelType_selector (pctxt, &pvalue->selector, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ExtensionURL"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->extensionURL_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Name"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->name_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PortalURL"))) {
            pvalue->m.portalURLPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->portalURL = pXmlNode->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Description"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->description_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Connection"))) {
            { OSRTDList* pdata2;
            pdata2 = rtxMemAllocType (pctxt, OSRTDList);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pdata2);
            {
            PurchaseChannelType_connection_purchaseURL* pdata3;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PurchaseURL"))) {
                     pdata3
                         = rtxMemAllocType (pctxt, PurchaseChannelType_connection_purchaseURL);

                     if (pdata3 == NULL)
                        return LOG_RTERR (pctxt, RTERR_NOMEM);

                     asn1Init_PurchaseChannelType_connection_purchaseURL (pdata3);
                     DOMTest_PurchaseChannelType_connection_purchaseURL (pctxt, pdata3, pXmlNode, TRUE);
                     if (0 != pdata3)
                        rtxDListAppend (pctxt, pdata2, (void*)pdata3);
                  }
               }
            }
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->connection_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ContactInfo"))) {
            pvalue->m.contactInfoPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->contactInfo = pXmlNode->children->content;
            }
         }
      }
   }

   return 0;
}

int DOMTest_ScheduleReferenceType (OSCTXT* pctxt, 
   ScheduleReferenceType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("idRef"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->idRef = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PresentationWindowID"))) {
         }
      }
   }

   return 0;
}

int DOMTest_InteractivityWindowType (OSCTXT* pctxt, 
   InteractivityWindowType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("InteractivityWindowEndTime"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->interactivityWindowEndTime = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("InteractivityWindowStartTime"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->interactivityWindowStartTime = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_InteractivityDataType (OSCTXT* pctxt, 
   InteractivityDataType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("InteractivityMediaDocumentPointer"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->interactivityMediaDocumentPointer = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("PrelistenIndicator"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->prelistenIndicator);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("id"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("validFrom"))) {
            pvalue->m.validFromPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->validFrom = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("validTo"))) {
            pvalue->m.validToPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->validTo = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("version"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->version = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ServiceIDRed"))) {
            { ServiceIDType pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->serviceIDRed_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ContentIDRef"))) {
            { ContentIDType pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->contentIDRef_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ScheduleReference"))) {
            { ScheduleReferenceType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ScheduleReferenceType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ScheduleReferenceType (pdata2);
            DOMTest_ScheduleReferenceType (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->scheduleReference_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("InteractivityWindow"))) {
            { InteractivityWindowType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, InteractivityWindowType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InteractivityWindowType (pdata2);
            DOMTest_InteractivityWindowType (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->interactivityWindow_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ExtensionURL"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->extensionURL_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_ESGMainBCAST (OSCTXT* pctxt, ESGMainBCAST* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Service"))) {
            { ServiceType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ServiceType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ServiceType (pdata2);
            DOMTest_ServiceType (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->service_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Schedule"))) {
            { ScheduleType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ScheduleType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ScheduleType (pdata2);
            DOMTest_ScheduleType (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->schedule_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Content"))) {
            { ContentType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ContentType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ContentType (pdata2);
            DOMTest_ContentType (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->content_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Access"))) {
            { AccessType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, AccessType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AccessType (pdata2);
            DOMTest_AccessType (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->access_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PreviewData"))) {
            { PreviewDataType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, PreviewDataType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PreviewDataType (pdata2);
            DOMTest_PreviewDataType (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->previewData_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PurchaseItem"))) {
            { PurchaseItemType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, PurchaseItemType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PurchaseItemType (pdata2);
            DOMTest_PurchaseItemType (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->purchaseItem_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PurchaseData"))) {
            { PurchaseDataType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, PurchaseDataType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PurchaseDataType (pdata2);
            DOMTest_PurchaseDataType (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->purchaseData_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PurchaseChannel"))) {
            { PurchaseChannelType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, PurchaseChannelType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PurchaseChannelType (pdata2);
            DOMTest_PurchaseChannelType (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->purchaseChannel_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("InteractivityData"))) {
            { InteractivityDataType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, InteractivityDataType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InteractivityDataType (pdata2);
            DOMTest_InteractivityDataType (pctxt, pdata2, pXmlNode, TRUE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->interactivityData_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

