/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 18-Oct-2006.
 */
#include "Soap-1-1.h"
#include "rtxsrc/rtxCommon.h"

/**************************************************************/
/*                                                            */
/*  MustUnderstand                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MustUnderstand (OSCTXT* pctxt,
   MustUnderstand *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_boolean (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_MustUnderstand (OSCTXT* pctxt, MustUnderstand value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncBool (pctxt, value, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Actor                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Actor (OSCTXT* pctxt,
   Actor pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_utf8str (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Actor (OSCTXT* pctxt, Actor value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt, value, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EncodingStyle_1                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EncodingStyle_1 (OSCTXT* pctxt,
   EncodingStyle_1 *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   pnode = pvalue->tail;
   while (0 != pnode) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode = pnode->prev;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_EncodingStyle_1 (OSCTXT* pctxt, EncodingStyle_1* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://schemas.xmlsoap.org/soap/envelope/"));

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8(""), 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      OSRTSAFEPUTCHAR (pctxt, ' ');
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  EncodingStyle                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_EncodingStyle (OSCTXT* pctxt,
   EncodingStyle *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_EncodingStyle_1 (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_EncodingStyle (OSCTXT* pctxt, EncodingStyle* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_EncodingStyle_1 (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Header                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Header (OSCTXT* pctxt,
   Header *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode elem_list */

   pnode2 = pvalue->elem_list.tail;
   while (0 != pnode2) {
      switch (((OSXSDAny*)pnode2->data)->t) {
      case OSXSDAny_binary:
         ll = xe_OpenType (pctxt, ((OSXSDAny*)pnode2->data)->u.binary->data, 
            ((OSXSDAny*)pnode2->data)->u.binary->numocts);
         break;
      case OSXSDAny_xmlText:
         ll = xe_utf8str (pctxt, ((OSXSDAny*)pnode2->data)->
            u.xmlText, ASN1EXPL);
         break;
      }
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      else ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode attr */

   pnode2 = pvalue->attr.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Header (OSCTXT* pctxt, Header* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */
   { OSRTDListNode* pnode = pvalue->attr.head;
   size_t len;
   while (0 != pnode) {
      len = rtxUTF8LenBytes (pnode->data);

      stat = rtxCheckBuffer (pctxt, len + 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTPUTCHAR (pctxt, ' ');
      OSRTMEMCPY (pctxt, pnode->data, len);

      pnode = pnode->next;
   }}

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://schemas.xmlsoap.org/soap/envelope/"));

   /* encode elem_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://schemas.xmlsoap.org/soap/envelope/"));

   { OSRTDListNode* pnode = pvalue->elem_list.head;
   while (0 != pnode) {
      if (((OSXSDAny*)pnode->data)->t == OSXSDAny_xmlText) {
         stat = rtXmlEncAnyStr (pctxt, ((OSXSDAny*)pnode->data)->u.xmlText
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         char buf[40];
         os_snprintf (buf, 40, "%d", ((OSXSDAny*)pnode->data)->t);
         rtxErrAddStrParm (pctxt, buf);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Body                                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Body (OSCTXT* pctxt,
   Body *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode elem_list */

   pnode2 = pvalue->elem_list.tail;
   while (0 != pnode2) {
      switch (((OSXSDAny*)pnode2->data)->t) {
      case OSXSDAny_binary:
         ll = xe_OpenType (pctxt, ((OSXSDAny*)pnode2->data)->u.binary->data, 
            ((OSXSDAny*)pnode2->data)->u.binary->numocts);
         break;
      case OSXSDAny_xmlText:
         ll = xe_utf8str (pctxt, ((OSXSDAny*)pnode2->data)->
            u.xmlText, ASN1EXPL);
         break;
      }
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      else ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode attr */

   pnode2 = pvalue->attr.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Body (OSCTXT* pctxt, Body* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */
   { OSRTDListNode* pnode = pvalue->attr.head;
   size_t len;
   while (0 != pnode) {
      len = rtxUTF8LenBytes (pnode->data);

      stat = rtxCheckBuffer (pctxt, len + 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTPUTCHAR (pctxt, ' ');
      OSRTMEMCPY (pctxt, pnode->data, len);

      pnode = pnode->next;
   }}

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://schemas.xmlsoap.org/soap/envelope/"));

   /* encode elem_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://schemas.xmlsoap.org/soap/envelope/"));

   { OSRTDListNode* pnode = pvalue->elem_list.head;
   while (0 != pnode) {
      if (((OSXSDAny*)pnode->data)->t == OSXSDAny_xmlText) {
         stat = rtXmlEncAnyStr (pctxt, ((OSXSDAny*)pnode->data)->u.xmlText
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         char buf[40];
         os_snprintf (buf, 40, "%d", ((OSXSDAny*)pnode->data)->t);
         rtxErrAddStrParm (pctxt, buf);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Envelope                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Envelope (OSCTXT* pctxt,
   Envelope *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode elem_list */

   pnode2 = pvalue->elem_list.tail;
   while (0 != pnode2) {
      switch (((OSXSDAny*)pnode2->data)->t) {
      case OSXSDAny_binary:
         ll = xe_OpenType (pctxt, ((OSXSDAny*)pnode2->data)->u.binary->data, 
            ((OSXSDAny*)pnode2->data)->u.binary->numocts);
         break;
      case OSXSDAny_xmlText:
         ll = xe_utf8str (pctxt, ((OSXSDAny*)pnode2->data)->
            u.xmlText, ASN1EXPL);
         break;
      }
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      else ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode body */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
      asn1E_Body (pctxt, &pvalue->body, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode header */

   if (pvalue->m.headerPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Header (pctxt, &pvalue->header, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode attr */

   pnode2 = pvalue->attr.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode encodingStyle */

   if (pvalue->m.encodingStylePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_EncodingStyle (pctxt, &pvalue->encodingStyle, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Envelope (OSCTXT* pctxt, Envelope* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.encodingStylePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" tns:encodingStyle=\""), 20);

      stat = XmlEnc_EncodingStyle (pctxt, &pvalue->encodingStyle, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '"');
   }
   { OSRTDListNode* pnode = pvalue->attr.head;
   size_t len;
   while (0 != pnode) {
      len = rtxUTF8LenBytes (pnode->data);

      stat = rtxCheckBuffer (pctxt, len + 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTPUTCHAR (pctxt, ' ');
      OSRTMEMCPY (pctxt, pnode->data, len);

      pnode = pnode->next;
   }}

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://schemas.xmlsoap.org/soap/envelope/"));

   /* encode header */

   if (pvalue->m.headerPresent) {
      stat = XmlEnc_Header (pctxt, &pvalue->header
         , OSUTF8("Header"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode body */

   stat = XmlEnc_Body (pctxt, &pvalue->body, OSUTF8("Body"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode elem_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://schemas.xmlsoap.org/soap/envelope/"));

   { OSRTDListNode* pnode = pvalue->elem_list.head;
   while (0 != pnode) {
      if (((OSXSDAny*)pnode->data)->t == OSXSDAny_xmlText) {
         stat = rtXmlEncAnyStr (pctxt, ((OSXSDAny*)pnode->data)->u.xmlText
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         char buf[40];
         os_snprintf (buf, 40, "%d", ((OSXSDAny*)pnode->data)->t);
         rtxErrAddStrParm (pctxt, buf);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Detail                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Detail (OSCTXT* pctxt,
   Detail *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode elem_list */

   pnode2 = pvalue->elem_list.tail;
   while (0 != pnode2) {
      switch (((OSXSDAny*)pnode2->data)->t) {
      case OSXSDAny_binary:
         ll = xe_OpenType (pctxt, ((OSXSDAny*)pnode2->data)->u.binary->data, 
            ((OSXSDAny*)pnode2->data)->u.binary->numocts);
         break;
      case OSXSDAny_xmlText:
         ll = xe_utf8str (pctxt, ((OSXSDAny*)pnode2->data)->
            u.xmlText, ASN1EXPL);
         break;
      }
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      else ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode attr */

   pnode2 = pvalue->attr.tail;
   while (0 != pnode2) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Detail (OSCTXT* pctxt, Detail* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */
   { OSRTDListNode* pnode = pvalue->attr.head;
   size_t len;
   while (0 != pnode) {
      len = rtxUTF8LenBytes (pnode->data);

      stat = rtxCheckBuffer (pctxt, len + 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTPUTCHAR (pctxt, ' ');
      OSRTMEMCPY (pctxt, pnode->data, len);

      pnode = pnode->next;
   }}

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://schemas.xmlsoap.org/soap/envelope/"));

   /* encode elem_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://schemas.xmlsoap.org/soap/envelope/"));

   { OSRTDListNode* pnode = pvalue->elem_list.head;
   while (0 != pnode) {
      if (((OSXSDAny*)pnode->data)->t == OSXSDAny_xmlText) {
         stat = rtXmlEncAnyStr (pctxt, ((OSXSDAny*)pnode->data)->u.xmlText
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         char buf[40];
         os_snprintf (buf, 40, "%d", ((OSXSDAny*)pnode->data)->t);
         rtxErrAddStrParm (pctxt, buf);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Fault                                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Fault (OSCTXT* pctxt,
   Fault *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode detail */

   if (pvalue->m.detailPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Detail (pctxt, &pvalue->detail, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode faultactor */

   if (pvalue->m.faultactorPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->faultactor, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode faultstring */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->faultstring, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode faultcode */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_XSD_QName (pctxt, &pvalue->faultcode, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_Fault (OSCTXT* pctxt, Fault* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://schemas.xmlsoap.org/soap/envelope/"));

   /* encode faultcode */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->faultcode.
      name, OSUTF8("faultcode"), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode faultstring */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->faultstring
      , OSUTF8("faultstring"), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode faultactor */

   if (pvalue->m.faultactorPresent) {
      stat = rtXmlEncUTF8Str (pctxt, pvalue->faultactor
         , OSUTF8("faultactor"), 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode detail */

   if (pvalue->m.detailPresent) {
      stat = XmlEnc_Detail (pctxt, &pvalue->detail, OSUTF8("detail"), 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlEnc_MustUnderstand_PDU (OSCTXT* pctxt, MustUnderstand value)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   rtXmlNSSetNamespace (pctxt, OSUTF8("tns"), 
      OSUTF8("http://schemas.xmlsoap.org/soap/envelope/"), FALSE);

   nsPrefix = rtXmlNSGetPrefix (pctxt, 
      OSUTF8("http://schemas.xmlsoap.org/soap/envelope/"));

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("mustUnderstand"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_MustUnderstand (pctxt, value, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("mustUnderstand"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_Actor_PDU (OSCTXT* pctxt, Actor value)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   rtXmlNSSetNamespace (pctxt, OSUTF8("tns"), 
      OSUTF8("http://schemas.xmlsoap.org/soap/envelope/"), FALSE);

   nsPrefix = rtXmlNSGetPrefix (pctxt, 
      OSUTF8("http://schemas.xmlsoap.org/soap/envelope/"));

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("actor"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_Actor (pctxt, value, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("actor"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_Envelope_PDU (OSCTXT* pctxt, Envelope* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   rtXmlNSSetNamespace (pctxt, OSUTF8("tns"), 
      OSUTF8("http://schemas.xmlsoap.org/soap/envelope/"), FALSE);

   nsPrefix = rtXmlNSGetPrefix (pctxt, 
      OSUTF8("http://schemas.xmlsoap.org/soap/envelope/"));

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("Envelope"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_Envelope (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("Envelope"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_Fault_PDU (OSCTXT* pctxt, Fault* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   rtXmlNSSetNamespace (pctxt, OSUTF8("tns"), 
      OSUTF8("http://schemas.xmlsoap.org/soap/envelope/"), FALSE);

   nsPrefix = rtXmlNSGetPrefix (pctxt, 
      OSUTF8("http://schemas.xmlsoap.org/soap/envelope/"));

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("Fault"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_Fault (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("Fault"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
