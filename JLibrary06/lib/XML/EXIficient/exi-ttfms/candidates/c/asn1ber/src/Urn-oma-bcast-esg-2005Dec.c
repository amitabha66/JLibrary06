/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 19-Sep-2006.
 */
#include "Urn-oma-bcast-esg-2005.h"
#include "rtxsrc/rtxCommon.h"

/**************************************************************/
/*                                                            */
/*  GenreElementType                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_GenreElementType (OSCTXT* pctxt,
   GenreElementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_GenreElementType (OSCTXT* pctxt, GenreElementType* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   if (elemLName != 0 && *elemLName != 0) {
      stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PreviewDataIDType                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PreviewDataIDType (OSCTXT* pctxt,
   PreviewDataIDType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_PreviewDataIDType (OSCTXT* pctxt, PreviewDataIDType* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   if (elemLName != 0 && *elemLName != 0) {
      stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RelativeDateType                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_RelativeDateType (OSCTXT* pctxt,
   RelativeDateType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_unsigned (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_RelativeDateType (OSCTXT* pctxt, RelativeDateType* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   if (elemLName != 0 && *elemLName != 0) {
      stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
   }

   stat = rtXmlpDecUInt (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ContentIDType                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ContentIDType (OSCTXT* pctxt,
   ContentIDType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_ContentIDType (OSCTXT* pctxt, ContentIDType* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   if (elemLName != 0 && *elemLName != 0) {
      stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ScheduleIDType                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ScheduleIDType (OSCTXT* pctxt,
   ScheduleIDType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_ScheduleIDType (OSCTXT* pctxt, ScheduleIDType* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   if (elemLName != 0 && *elemLName != 0) {
      stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ServiceIDType                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ServiceIDType (OSCTXT* pctxt,
   ServiceIDType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_ServiceIDType (OSCTXT* pctxt, ServiceIDType* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   if (elemLName != 0 && *elemLName != 0) {
      stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AccessIDType                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AccessIDType (OSCTXT* pctxt,
   AccessIDType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_AccessIDType (OSCTXT* pctxt, AccessIDType* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   if (elemLName != 0 && *elemLName != 0) {
      stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TextType                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TextType (OSCTXT* pctxt,
   TextType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_TextType (OSCTXT* pctxt, TextType* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   if (elemLName != 0 && *elemLName != 0) {
      stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InteractivityDataIDType                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_InteractivityDataIDType (OSCTXT* pctxt,
   InteractivityDataIDType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_InteractivityDataIDType (OSCTXT* pctxt, 
   InteractivityDataIDType* pvalue, const OSUTF8CHAR* elemLName, 
   const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   if (elemLName != 0 && *elemLName != 0) {
      stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InteractivityMediaIDType                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_InteractivityMediaIDType (OSCTXT* pctxt,
   InteractivityMediaIDType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_utf8str (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_InteractivityMediaIDType (OSCTXT* pctxt, 
   InteractivityMediaIDType* pvalue, const OSUTF8CHAR* elemLName, 
   const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   if (elemLName != 0 && *elemLName != 0) {
      stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TargetUserProfileType                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TargetUserProfileType (OSCTXT* pctxt,
   TargetUserProfileType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode profileAttributeName */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->profileAttributeName, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode profileAttributeValue */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->profileAttributeValue, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_TargetUserProfileType (OSCTXT* pctxt, 
   TargetUserProfileType* pvalue, const OSUTF8CHAR* elemLName, 
   const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("ProfileAttributeName"), 20}, 0 },
            { {OSUTF8("ProfileAttributeValue"), 21}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 2, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* ProfileAttributeName */
               stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->profileAttributeName
                  );
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            case 1: /* ProfileAttributeValue */
               stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->
                  profileAttributeValue);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "TargetUserProfileType");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "TargetUserProfileType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PreviewDataIDRefType                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PreviewDataIDRefType (OSCTXT* pctxt,
   PreviewDataIDRefType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode usage */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_int8 (pctxt, &pvalue->usage, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.usagePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PreviewDataIDRefType (OSCTXT* pctxt, PreviewDataIDRefType* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("usage"), 5}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 1, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* usage */
               stat = rtXmlpDecInt8 (pctxt, &pvalue->usage);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.usagePresent = TRUE;
               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "PreviewDataIDRefType");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "PreviewDataIDRefType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->base);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Broadcast_areaType_target_area                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Broadcast_areaType_target_area (OSCTXT* pctxt,
   Broadcast_areaType_target_area *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode shape */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->shape, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.shapePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode cc */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->cc, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.ccPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode name_area */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->name_area, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.name_areaPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode zip_code */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->zip_code, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.zip_codePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode cell_ID_list */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->cell_ID_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->cell_ID_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode cell_Group_ID */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->cell_Group_ID, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.cell_Group_IDPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Broadcast_areaType_target_area (OSCTXT* pctxt, 
   Broadcast_areaType_target_area* pvalue, const OSUTF8CHAR* elemLName, 
   const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0 && *elemLName != 0) {
      stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("shape"), 5}, 0}, 0 },
      {{{OSUTF8("cc"), 2}, 0}, 1 },
      {{{OSUTF8("name_area"), 9}, 0}, 2 },
      {{{OSUTF8("zip_code"), 8}, 0}, 3 },
      {{{OSUTF8("Cell_ID"), 7}, 0}, 4 },
      {{{OSUTF8("Cell_Group_ID"), 13}, 0}, 5 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 6, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: { /* shape */
         stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->shape);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.shapePresent = TRUE;
         break;
      }
      case 1: { /* cc */
         stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->cc);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.ccPresent = TRUE;
         break;
      }
      case 2: { /* name_area */
         stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->name_area);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.name_areaPresent = TRUE;
         break;
      }
      case 3: { /* zip_code */
         stat = rtXmlpDecInt (pctxt, &pvalue->zip_code);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.zip_codePresent = TRUE;
         break;
      }
      case 4: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->cell_ID_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 6, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 4);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 5: { /* Cell_Group_ID */
         stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->cell_Group_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.cell_Group_IDPresent = TRUE;
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Broadcast_areaType                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Broadcast_areaType (OSCTXT* pctxt,
   Broadcast_areaType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode polarity */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->polarity, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode target_area_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Broadcast_areaType_target_area* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->target_area_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Broadcast_areaType_target_area, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Broadcast_areaType_target_area (pdata2);

                  stat = asn1D_Broadcast_areaType_target_area (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->target_area_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode hor_ac_list */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               OSXSDAny* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->hor_ac_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, OSXSDAny, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  pdata2->u.binary = rtxMemAllocType (pctxt, OSOpenType);
                  stat = xd_OpenType (pctxt, &pdata2->u.binary->data,
                  &pdata2->u.binary->numocts);

                  pdata2->t = OSXSDAny_binary;
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->hor_ac_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Broadcast_areaType (OSCTXT* pctxt, Broadcast_areaType* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("polarity"), 8}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 1, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* polarity */
               stat = rtXmlpDecBool (pctxt, &pvalue->polarity);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "Broadcast_areaType");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "Broadcast_areaType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("target_area"), 11}, 0}, 0 },
      {{{OSUTF8("hor_ac"), 6}, 0}, 1 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: {
         Broadcast_areaType_target_area* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Broadcast_areaType_target_area);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Broadcast_areaType_target_area (pdata1);

            stat = XmlDec_Broadcast_areaType_target_area (pctxt, pdata1
               , OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->target_area_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 1: {
         OSXSDAny* pdata1;
         do {
            pdata1 = rtxMemAllocTypeZ (pctxt, OSXSDAny);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            /* decode xsd:any element as XML text */
               stat = rtXmlpDecAny (pctxt, &pdata1->u.xmlText);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            pdata1->
            t = OSXSDAny_xmlText;

            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->hor_ac_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ServiceType                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ServiceType (OSCTXT* pctxt,
   ServiceType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode serviceBaseCID */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->serviceBaseCID, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.serviceBaseCIDPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode serviceProtection */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->serviceProtection, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.serviceProtectionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode weight */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->weight, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.weightPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_int8 (pctxt, &pvalue->type, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode validFrom */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->validFrom, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.validFromPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode validTo */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->validTo, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.validToPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode version */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->version, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 8:
         /* decode extensionURL_list */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->extensionURL_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->extensionURL_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 9:
         /* decode globalServiceID */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->globalServiceID, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.globalServiceIDPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode name_list */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->name_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->name_list, pnode);
               }

               if (!(pvalue->name_list.count >= 1)) {
                  rtxErrAddStrParm (pctxt, "ServiceType.name_list.count");
                  rtxErrAddIntParm (pctxt, (int)pvalue->name_list.count);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 11:
         /* decode description_list */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->description_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->description_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 12:
         /* decode parentalRating_list */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->parentalRating_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->parentalRating_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 13:
         /* decode targetUserProfile_list */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               TargetUserProfileType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->targetUserProfile_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, TargetUserProfileType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_TargetUserProfileType (pdata2);

                  stat = asn1D_TargetUserProfileType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->targetUserProfile_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 14:
         /* decode genre_list */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               GenreElementType pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->genre_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = asn1D_GenreElementType (pctxt, 
                     &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->genre_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 15:
         /* decode userRating_list */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               int count;
               int xx2;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               stat = xd_count (pctxt, length, &count);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->userRating_list.n = count;
               ALLOC_ASN1ARRAY (pctxt, &pvalue->userRating_list, OSINT32);

               xx2 = 0;
               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  stat = xd_integer (pctxt, &pvalue->userRating_list.elem[xx2], ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  xx2++;
               }
               pvalue->userRating_list.n = xx2;

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 16:
         /* decode previewDataIDRef_list */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               PreviewDataIDRefType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->previewDataIDRef_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, PreviewDataIDRefType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_PreviewDataIDRefType (pdata2);

                  stat = asn1D_PreviewDataIDRefType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->previewDataIDRef_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 17:
         /* decode broadcast_area */
         if (XD_PEEKTAG (pctxt, 0x91)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Broadcast_areaType (pctxt, 
               &pvalue->broadcast_area, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.broadcast_areaPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_CONS|17):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 11) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_ServiceType (OSCTXT* pctxt, ServiceType* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("ServiceBaseCID"), 14}, 0 },
            { {OSUTF8("ServiceProtection"), 17}, 0 },
            { {OSUTF8("Weight"), 6}, 0 },
            { {OSUTF8("id"), 2}, 0 },
            { {OSUTF8("type"), 4}, 0 },
            { {OSUTF8("validFrom"), 9}, 0 },
            { {OSUTF8("validTo"), 7}, 0 },
            { {OSUTF8("version"), 7}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 8, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* ServiceBaseCID */
               stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->serviceBaseCID);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.serviceBaseCIDPresent = TRUE;
               break;

            case 1: /* ServiceProtection */
               stat = rtXmlpDecBool (pctxt, &pvalue->serviceProtection);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.serviceProtectionPresent = TRUE;
               break;

            case 2: /* Weight */
               stat = rtXmlpDecUInt (pctxt, &pvalue->weight);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.weightPresent = TRUE;
               break;

            case 3: /* id */
               stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            case 4: /* type */
               stat = rtXmlpDecInt8 (pctxt, &pvalue->type);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            case 5: /* validFrom */
               stat = rtXmlpDecUInt (pctxt, &pvalue->validFrom);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.validFromPresent = TRUE;
               break;

            case 6: /* validTo */
               stat = rtXmlpDecUInt (pctxt, &pvalue->validTo);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.validToPresent = TRUE;
               break;

            case 7: /* version */
               stat = rtXmlpDecUInt (pctxt, &pvalue->version);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "ServiceType");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "ServiceType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("ExtensionURL"), 12}, 0}, 0 },
      {{{OSUTF8("GlobalServiceID"), 15}, 0}, 1 },
      {{{OSUTF8("Name"), 4}, 0}, 2 },
      {{{OSUTF8("Description"), 11}, 0}, 3 },
      {{{OSUTF8("ParentalRating"), 14}, 0}, 4 },
      {{{OSUTF8("TargetUserProfile"), 17}, 0}, 5 },
      {{{OSUTF8("Genre"), 5}, 0}, 6 },
      {{{OSUTF8("UserRating"), 10}, 0}, 7 },
      {{{OSUTF8("PreviewDataIDRef"), 16}, 0}, 8 },
      {{{OSUTF8("broadcast_area"), 14}, 0}, 9 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 10, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->extensionURL_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 10, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 1: { /* GlobalServiceID */
         stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->globalServiceID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.globalServiceIDPresent = TRUE;
         break;
      }
      case 2: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->name_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 10, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 3: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->description_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 10, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 3);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 4: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->parentalRating_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 10, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 4);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 5: {
         TargetUserProfileType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, TargetUserProfileType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TargetUserProfileType (pdata1);

            stat = XmlDec_TargetUserProfileType (pctxt, pdata1
               , OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->targetUserProfile_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 10, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 5);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 6: {
         GenreElementType pdata1;
         do {
            stat = XmlDec_GenreElementType (pctxt, &pdata1, OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->genre_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 10, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 6);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 7: {
         OSRTDList tmplist;
         OSINT32* pdata1;
         rtxDListInit (&tmplist);
         do {
            pdata1 = rtxMemAllocTypeZ (pctxt, OSINT32);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            stat = rtXmlpDecInt (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &tmplist, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 10, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 7);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;

         /* Convert list to array */
         { OSUINT32 i = 0;
         OSRTDListNode* pnode = tmplist.head;
         pvalue->userRating_list.n = tmplist.count;
         pvalue->userRating_list.elem =
            rtxMemAllocArray (pctxt, tmplist.count, OSINT32);
         while (0 != pnode) {
            pdata1 = (OSINT32*)pnode->data;
            pvalue->userRating_list.elem[i++] = *pdata1;
            pnode = pnode->next;
         }}
         rtxDListFreeAll (pctxt, &tmplist);
         break;
      }
      case 8: {
         PreviewDataIDRefType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, PreviewDataIDRefType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PreviewDataIDRefType (pdata1);

            stat = XmlDec_PreviewDataIDRefType (pctxt, pdata1, OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->previewDataIDRef_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 10, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 8);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 9: { /* broadcast_area */
         stat = XmlDec_Broadcast_areaType (pctxt, &pvalue->broadcast_area
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.broadcast_areaPresent = TRUE;
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Distribution_WindowType_repeatType                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Distribution_WindowType_repeatType (OSCTXT* pctxt,
   Distribution_WindowType_repeatType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode num */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->num, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode unit */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->unit, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Distribution_WindowType_repeatType (OSCTXT* pctxt, 
   Distribution_WindowType_repeatType* pvalue, const OSUTF8CHAR* elemLName, 
   const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("Num"), 3}, 0 },
            { {OSUTF8("Unit"), 4}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 2, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* Num */
               stat = rtXmlpDecInt (pctxt, &pvalue->num);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            case 1: /* Unit */
               stat = rtXmlpDecInt (pctxt, &pvalue->unit);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "Distribution_WindowType_repeatType");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "Distribution_WindowType_repeatType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Distribution_WindowType                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Distribution_WindowType (OSCTXT* pctxt,
   Distribution_WindowType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode dWid */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->dWid, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.dWidPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode distribution_End_Time */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->distribution_End_Time, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.distribution_End_TimePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode distribution_Start_Time */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->distribution_Start_Time, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.distribution_Start_TimePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode duration */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->duration, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.durationPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode repeatType */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Distribution_WindowType_repeatType (pctxt, 
               &pvalue->repeatType, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.repeatTypePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Distribution_WindowType (OSCTXT* pctxt, 
   Distribution_WindowType* pvalue, const OSUTF8CHAR* elemLName, 
   const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("DWid"), 4}, 0 },
            { {OSUTF8("Distribution_End_Time"), 21}, 0 },
            { {OSUTF8("Distribution_Start_Time"), 23}, 0 },
            { {OSUTF8("Duration"), 8}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 4, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* DWid */
               stat = rtXmlpDecInt (pctxt, &pvalue->dWid);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.dWidPresent = TRUE;
               break;

            case 1: /* Distribution_End_Time */
               stat = rtXmlpDecUInt (pctxt, &pvalue->distribution_End_Time);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.distribution_End_TimePresent = TRUE;
               break;

            case 2: /* Distribution_Start_Time */
               stat = rtXmlpDecUInt (pctxt, &pvalue->distribution_Start_Time);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.distribution_Start_TimePresent = TRUE;
               break;

            case 3: /* Duration */
               stat = rtXmlpDecInt (pctxt, &pvalue->duration);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.durationPresent = TRUE;
               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "Distribution_WindowType");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "Distribution_WindowType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("RepeatType"), 10}, 0}, 0 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 1, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: { /* RepeatType */
         stat = XmlDec_Distribution_WindowType_repeatType (pctxt, &pvalue->
            repeatType, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.repeatTypePresent = TRUE;
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ScheduleType_interactivityDataIDRef                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ScheduleType_interactivityDataIDRef (OSCTXT* pctxt,
   ScheduleType_interactivityDataIDRef *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode autoStart */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->autoStart, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.autoStartPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode idRef */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->idRef, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode distribution_Window_list */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Distribution_WindowType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->distribution_Window_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Distribution_WindowType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Distribution_WindowType (pdata2);

                  stat = asn1D_Distribution_WindowType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->distribution_Window_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_ScheduleType_interactivityDataIDRef (OSCTXT* pctxt, 
   ScheduleType_interactivityDataIDRef* pvalue, const OSUTF8CHAR* elemLName, 
   const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("AutoStart"), 9}, 0 },
            { {OSUTF8("idRef"), 5}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 2, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* AutoStart */
               stat = rtXmlpDecBool (pctxt, &pvalue->autoStart);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.autoStartPresent = TRUE;
               break;

            case 1: /* idRef */
               stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->idRef);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "ScheduleType_interactivityDataIDRef");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "ScheduleType_interactivityDataIDRef");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Distribution_Window"), 19}, 0}, 0 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 1, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: {
         Distribution_WindowType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Distribution_WindowType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Distribution_WindowType (pdata1);

            stat = XmlDec_Distribution_WindowType (pctxt, pdata1
               , OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->distribution_Window_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 1, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Presentation_WindowType_repeatType                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Presentation_WindowType_repeatType (OSCTXT* pctxt,
   Presentation_WindowType_repeatType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode num */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->num, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode unit */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->unit, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Presentation_WindowType_repeatType (OSCTXT* pctxt, 
   Presentation_WindowType_repeatType* pvalue, const OSUTF8CHAR* elemLName, 
   const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("Num"), 3}, 0 },
            { {OSUTF8("Unit"), 4}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 2, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* Num */
               stat = rtXmlpDecInt (pctxt, &pvalue->num);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            case 1: /* Unit */
               stat = rtXmlpDecInt (pctxt, &pvalue->unit);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "Presentation_WindowType_repeatType");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "Presentation_WindowType_repeatType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Presentation_WindowType                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_Presentation_WindowType (OSCTXT* pctxt,
   Presentation_WindowType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode duration */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->duration, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.durationPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode pWid */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->pWid, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.pWidPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode presentation_End_Time */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_RelativeDateType (pctxt, 
               &pvalue->presentation_End_Time, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.presentation_End_TimePresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode presentation_Start_Time */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_RelativeDateType (pctxt, 
               &pvalue->presentation_Start_Time, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.presentation_Start_TimePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode repeatType */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Presentation_WindowType_repeatType (pctxt, 
               &pvalue->repeatType, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.repeatTypePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_Presentation_WindowType (OSCTXT* pctxt, 
   Presentation_WindowType* pvalue, const OSUTF8CHAR* elemLName, 
   const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("Duration"), 8}, 0 },
            { {OSUTF8("PWid"), 4}, 0 },
            { {OSUTF8("Presentation_End_Time"), 21}, 0 },
            { {OSUTF8("Presentation_Start_Time"), 23}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 4, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* Duration */
               stat = rtXmlpDecInt (pctxt, &pvalue->duration);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.durationPresent = TRUE;
               break;

            case 1: /* PWid */
               stat = rtXmlpDecInt (pctxt, &pvalue->pWid);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.pWidPresent = TRUE;
               break;

            case 2: /* Presentation_End_Time */
               stat = XmlDec_RelativeDateType (pctxt, &pvalue->
                  presentation_End_Time, OSUTF8(""), 0);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.presentation_End_TimePresent = TRUE;
               break;

            case 3: /* Presentation_Start_Time */
               stat = XmlDec_RelativeDateType (pctxt, &pvalue->
                  presentation_Start_Time, OSUTF8(""), 0);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.presentation_Start_TimePresent = TRUE;
               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "Presentation_WindowType");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "Presentation_WindowType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("RepeatType"), 10}, 0}, 0 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 1, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: { /* RepeatType */
         stat = XmlDec_Presentation_WindowType_repeatType (pctxt, &pvalue->
            repeatType, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.repeatTypePresent = TRUE;
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ScheduleType_contentIDRef                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ScheduleType_contentIDRef (OSCTXT* pctxt,
   ScheduleType_contentIDRef *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode autoStart */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->autoStart, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.autoStartPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode repeatPlayback */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->repeatPlayback, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.repeatPlaybackPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode idRef */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_ContentIDType (pctxt, 
               &pvalue->idRef, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode distribution_Window_list */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Distribution_WindowType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->distribution_Window_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Distribution_WindowType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Distribution_WindowType (pdata2);

                  stat = asn1D_Distribution_WindowType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->distribution_Window_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode presentation_Window_list */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               Presentation_WindowType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->presentation_Window_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, Presentation_WindowType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_Presentation_WindowType (pdata2);

                  stat = asn1D_Presentation_WindowType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->presentation_Window_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_ScheduleType_contentIDRef (OSCTXT* pctxt, 
   ScheduleType_contentIDRef* pvalue, const OSUTF8CHAR* elemLName, 
   const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("AutoStart"), 9}, 0 },
            { {OSUTF8("RepeatPlayback"), 14}, 0 },
            { {OSUTF8("idRef"), 5}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 3, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* AutoStart */
               stat = rtXmlpDecBool (pctxt, &pvalue->autoStart);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.autoStartPresent = TRUE;
               break;

            case 1: /* RepeatPlayback */
               stat = rtXmlpDecBool (pctxt, &pvalue->repeatPlayback);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.repeatPlaybackPresent = TRUE;
               break;

            case 2: /* idRef */
               stat = XmlDec_ContentIDType (pctxt, &pvalue->idRef
                  , OSUTF8(""), 0);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "ScheduleType_contentIDRef");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "ScheduleType_contentIDRef");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Distribution_Window"), 19}, 0}, 0 },
      {{{OSUTF8("Presentation_Window"), 19}, 0}, 1 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: {
         Distribution_WindowType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Distribution_WindowType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Distribution_WindowType (pdata1);

            stat = XmlDec_Distribution_WindowType (pctxt, pdata1
               , OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->distribution_Window_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 1: {
         Presentation_WindowType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, Presentation_WindowType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Presentation_WindowType (pdata1);

            stat = XmlDec_Presentation_WindowType (pctxt, pdata1
               , OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->presentation_Window_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ScheduleType                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ScheduleType (OSCTXT* pctxt,
   ScheduleType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode serviceIDRef */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_ServiceIDType (pctxt, 
               &pvalue->serviceIDRef, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_ScheduleIDType (pctxt, 
               &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode validFrom */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->validFrom, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.validFromPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode validTo */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->validTo, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.validToPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode version */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->version, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode interactivityDataIDRef_list */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               ScheduleType_interactivityDataIDRef* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->interactivityDataIDRef_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, ScheduleType_interactivityDataIDRef, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_ScheduleType_interactivityDataIDRef (pdata2);

                  stat = asn1D_ScheduleType_interactivityDataIDRef (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->interactivityDataIDRef_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode contentIDRef_list */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               ScheduleType_contentIDRef* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->contentIDRef_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, ScheduleType_contentIDRef, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_ScheduleType_contentIDRef (pdata2);

                  stat = asn1D_ScheduleType_contentIDRef (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->contentIDRef_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode extensionURL_list */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->extensionURL_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->extensionURL_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 8:
         /* decode name_list */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->name_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->name_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 9:
         /* decode description_list */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->description_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->description_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 10:
         /* decode previewDataIDRef_list */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               PreviewDataIDRefType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->previewDataIDRef_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, PreviewDataIDRefType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_PreviewDataIDRefType (pdata2);

                  stat = asn1D_PreviewDataIDRefType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->previewDataIDRef_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 9) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_ScheduleType (OSCTXT* pctxt, ScheduleType* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("ServiceIDRef"), 12}, 0 },
            { {OSUTF8("id"), 2}, 0 },
            { {OSUTF8("validFrom"), 9}, 0 },
            { {OSUTF8("validTo"), 7}, 0 },
            { {OSUTF8("version"), 7}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 5, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* ServiceIDRef */
               stat = XmlDec_ServiceIDType (pctxt, &pvalue->serviceIDRef
                  , OSUTF8(""), 0);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            case 1: /* id */
               stat = XmlDec_ScheduleIDType (pctxt, &pvalue->id
                  , OSUTF8(""), 0);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            case 2: /* validFrom */
               stat = rtXmlpDecUInt (pctxt, &pvalue->validFrom);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.validFromPresent = TRUE;
               break;

            case 3: /* validTo */
               stat = rtXmlpDecUInt (pctxt, &pvalue->validTo);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.validToPresent = TRUE;
               break;

            case 4: /* version */
               stat = rtXmlpDecUInt (pctxt, &pvalue->version);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "ScheduleType");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "ScheduleType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("InteractivityDataIDRef"), 22}, 0}, 0 },
      {{{OSUTF8("ContentIDRef"), 12}, 0}, 1 },
      {{{OSUTF8("ExtensionURL"), 12}, 0}, 2 },
      {{{OSUTF8("Name"), 4}, 0}, 3 },
      {{{OSUTF8("Description"), 11}, 0}, 4 },
      {{{OSUTF8("PreviewDataIDRef"), 16}, 0}, 5 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 6, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: {
         ScheduleType_interactivityDataIDRef* pdata1;
         do {
            pdata1
                = rtxMemAllocType (pctxt, ScheduleType_interactivityDataIDRef);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ScheduleType_interactivityDataIDRef (pdata1);

            stat = XmlDec_ScheduleType_interactivityDataIDRef (pctxt, pdata1
               , OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->interactivityDataIDRef_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 6, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 1: {
         ScheduleType_contentIDRef* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, ScheduleType_contentIDRef);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ScheduleType_contentIDRef (pdata1);

            stat = XmlDec_ScheduleType_contentIDRef (pctxt, pdata1
               , OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->contentIDRef_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 6, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 2: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->extensionURL_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 6, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 3: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->name_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 6, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 3);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 4: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->description_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 6, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 4);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 5: {
         PreviewDataIDRefType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, PreviewDataIDRefType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PreviewDataIDRefType (pdata1);

            stat = XmlDec_PreviewDataIDRefType (pctxt, pdata1, OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->previewDataIDRef_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 6, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 5);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FileType                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_FileType (OSCTXT* pctxt,
   FileType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode content_Encoding */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->content_Encoding, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.content_EncodingPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode content_Length */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_uint64 (pctxt, &pvalue->content_Length, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.content_LengthPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode content_Location */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->content_Location, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode content_MD5 */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_octstr (pctxt, &pvalue->content_MD5.data, &pvalue->content_MD5.numocts, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.content_MD5Present = TRUE;
            }
         }
         break;

      case 4:
         /* decode content_Type */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->content_Type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.content_TypePresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode fEC_OTI_Encoding_Symbol_Length */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_uint64 (pctxt, &pvalue->fEC_OTI_Encoding_Symbol_Length, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fEC_OTI_Encoding_Symbol_LengthPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode fEC_OTI_FEC_Instance_ID */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_uint64 (pctxt, &pvalue->fEC_OTI_FEC_Instance_ID, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fEC_OTI_FEC_Instance_IDPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode fEC_OTI_Max_Number_of_Encoding_Symbols */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_uint64 (pctxt, &pvalue->fEC_OTI_Max_Number_of_Encoding_Symbols, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fEC_OTI_Max_Number_of_Encoding_SymbolsPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode fEC_OTI_Maximum_Source_Block_Length */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_uint64 (pctxt, &pvalue->fEC_OTI_Maximum_Source_Block_Length, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fEC_OTI_Maximum_Source_Block_LengthPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode tOI */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->tOI, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 10:
         /* decode transfer_Length */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_uint64 (pctxt, &pvalue->transfer_Length, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.transfer_LengthPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_PRIM|10):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_FileType (OSCTXT* pctxt, FileType* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("Content-Encoding"), 16}, 0 },
            { {OSUTF8("Content-Length"), 14}, 0 },
            { {OSUTF8("Content-Location"), 16}, 0 },
            { {OSUTF8("Content-MD5"), 11}, 0 },
            { {OSUTF8("Content-Type"), 12}, 0 },
            { {OSUTF8("FEC-OTI-Encoding-Symbol-Length"), 30}, 0 },
            { {OSUTF8("FEC-OTI-FEC-Instance-ID"), 23}, 0 },
            { {OSUTF8("FEC-OTI-Max-Number-of-Encoding-Symbols"), 38}, 0 },
            { {OSUTF8("FEC-OTI-Maximum-Source-Block-Length"), 35}, 0 },
            { {OSUTF8("TOI"), 3}, 0 },
            { {OSUTF8("Transfer-Length"), 15}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 11, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* Content-Encoding */
               stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->content_Encoding);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.content_EncodingPresent = TRUE;
               break;

            case 1: /* Content-Length */
               stat = rtXmlpDecUInt64 (pctxt, &pvalue->content_Length);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.content_LengthPresent = TRUE;
               break;

            case 2: /* Content-Location */
               stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->content_Location);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            case 3: /* Content-MD5 */
               stat = rtXmlpDecDynBase64Str (pctxt, &pvalue->content_MD5);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.content_MD5Present = TRUE;
               break;

            case 4: /* Content-Type */
               stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->content_Type);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.content_TypePresent = TRUE;
               break;

            case 5: /* FEC-OTI-Encoding-Symbol-Length */
               stat = rtXmlpDecUInt64 (pctxt, &pvalue->
                  fEC_OTI_Encoding_Symbol_Length);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.fEC_OTI_Encoding_Symbol_LengthPresent = TRUE;
               break;

            case 6: /* FEC-OTI-FEC-Instance-ID */
               stat = rtXmlpDecUInt64 (pctxt, &pvalue->fEC_OTI_FEC_Instance_ID
                  );
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.fEC_OTI_FEC_Instance_IDPresent = TRUE;
               break;

            case 7: /* FEC-OTI-Max-Number-of-Encoding-Symbols */
               stat = rtXmlpDecUInt64 (pctxt, &pvalue->
                  fEC_OTI_Max_Number_of_Encoding_Symbols);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.fEC_OTI_Max_Number_of_Encoding_SymbolsPresent = TRUE;
               break;

            case 8: /* FEC-OTI-Maximum-Source-Block-Length */
               stat = rtXmlpDecUInt64 (pctxt, &pvalue->
                  fEC_OTI_Maximum_Source_Block_Length);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.fEC_OTI_Maximum_Source_Block_LengthPresent = TRUE;
               break;

            case 9: /* TOI */
               stat = rtXmlpDecUInt (pctxt, &pvalue->tOI);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            case 10: /* Transfer-Length */
               stat = rtXmlpDecUInt64 (pctxt, &pvalue->transfer_Length);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.transfer_LengthPresent = TRUE;
               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "FileType");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "FileType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  FileDescriptionType                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_FileDescriptionType (OSCTXT* pctxt,
   FileDescriptionType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode content_Encoding */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->content_Encoding, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.content_EncodingPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode content_Length */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_uint64 (pctxt, &pvalue->content_Length, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.content_LengthPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode content_MD5 */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_octstr (pctxt, &pvalue->content_MD5.data, &pvalue->content_MD5.numocts, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.content_MD5Present = TRUE;
            }
         }
         break;

      case 3:
         /* decode content_Type */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->content_Type, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.content_TypePresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode fEC_OTI_Encoding_Symbol_Length */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_uint64 (pctxt, &pvalue->fEC_OTI_Encoding_Symbol_Length, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fEC_OTI_Encoding_Symbol_LengthPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode fEC_OTI_FEC_Instance_ID */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_uint64 (pctxt, &pvalue->fEC_OTI_FEC_Instance_ID, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fEC_OTI_FEC_Instance_IDPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode fEC_OTI_Max_Number_of_Encoding_Symbols */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_uint64 (pctxt, &pvalue->fEC_OTI_Max_Number_of_Encoding_Symbols, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fEC_OTI_Max_Number_of_Encoding_SymbolsPresent = TRUE;
            }
         }
         break;

      case 7:
         /* decode fEC_OTI_Maximum_Source_Block_Length */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_uint64 (pctxt, &pvalue->fEC_OTI_Maximum_Source_Block_Length, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fEC_OTI_Maximum_Source_Block_LengthPresent = TRUE;
            }
         }
         break;

      case 8:
         /* decode transfer_Length */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_uint64 (pctxt, &pvalue->transfer_Length, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.transfer_LengthPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode file_list */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               FileType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->file_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, FileType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_FileType (pdata2);

                  stat = asn1D_FileType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->file_list, pnode);
               }

               if (!(pvalue->file_list.count >= 1)) {
                  rtxErrAddStrParm (pctxt, "FileDescriptionType.file_list.count");
                  rtxErrAddIntParm (pctxt, (int)pvalue->file_list.count);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|9):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_FileDescriptionType (OSCTXT* pctxt, FileDescriptionType* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("Content-Encoding"), 16}, 0 },
            { {OSUTF8("Content-Length"), 14}, 0 },
            { {OSUTF8("Content-MD5"), 11}, 0 },
            { {OSUTF8("Content-Type"), 12}, 0 },
            { {OSUTF8("FEC-OTI-Encoding-Symbol-Length"), 30}, 0 },
            { {OSUTF8("FEC-OTI-FEC-Instance-ID"), 23}, 0 },
            { {OSUTF8("FEC-OTI-Max-Number-of-Encoding-Symbols"), 38}, 0 },
            { {OSUTF8("FEC-OTI-Maximum-Source-Block-Length"), 35}, 0 },
            { {OSUTF8("Transfer-Length"), 15}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 9, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* Content-Encoding */
               stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->content_Encoding);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.content_EncodingPresent = TRUE;
               break;

            case 1: /* Content-Length */
               stat = rtXmlpDecUInt64 (pctxt, &pvalue->content_Length);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.content_LengthPresent = TRUE;
               break;

            case 2: /* Content-MD5 */
               stat = rtXmlpDecDynBase64Str (pctxt, &pvalue->content_MD5);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.content_MD5Present = TRUE;
               break;

            case 3: /* Content-Type */
               stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->content_Type);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.content_TypePresent = TRUE;
               break;

            case 4: /* FEC-OTI-Encoding-Symbol-Length */
               stat = rtXmlpDecUInt64 (pctxt, &pvalue->
                  fEC_OTI_Encoding_Symbol_Length);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.fEC_OTI_Encoding_Symbol_LengthPresent = TRUE;
               break;

            case 5: /* FEC-OTI-FEC-Instance-ID */
               stat = rtXmlpDecUInt64 (pctxt, &pvalue->fEC_OTI_FEC_Instance_ID
                  );
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.fEC_OTI_FEC_Instance_IDPresent = TRUE;
               break;

            case 6: /* FEC-OTI-Max-Number-of-Encoding-Symbols */
               stat = rtXmlpDecUInt64 (pctxt, &pvalue->
                  fEC_OTI_Max_Number_of_Encoding_Symbols);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.fEC_OTI_Max_Number_of_Encoding_SymbolsPresent = TRUE;
               break;

            case 7: /* FEC-OTI-Maximum-Source-Block-Length */
               stat = rtXmlpDecUInt64 (pctxt, &pvalue->
                  fEC_OTI_Maximum_Source_Block_Length);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.fEC_OTI_Maximum_Source_Block_LengthPresent = TRUE;
               break;

            case 8: /* Transfer-Length */
               stat = rtXmlpDecUInt64 (pctxt, &pvalue->transfer_Length);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.transfer_LengthPresent = TRUE;
               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "FileDescriptionType");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "FileDescriptionType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("File"), 4}, 0}, 0 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 1, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: {
         FileType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, FileType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_FileType (pdata1);

            stat = XmlDec_FileType (pctxt, pdata1, OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->file_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 1, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ContentType                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ContentType (OSCTXT* pctxt,
   ContentType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode contentType */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->contentType, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.contentTypePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode serviceIDRef */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_ServiceIDType (pctxt, 
               &pvalue->serviceIDRef, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.serviceIDRefPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_ContentIDType (pctxt, 
               &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode validFrom */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->validFrom, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.validFromPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode validTo */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->validTo, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.validToPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode version */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->version, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode extensionURL_list */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->extensionURL_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->extensionURL_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode name_list */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->name_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->name_list, pnode);
               }

               if (!(pvalue->name_list.count >= 1)) {
                  rtxErrAddStrParm (pctxt, "ContentType.name_list.count");
                  rtxErrAddIntParm (pctxt, (int)pvalue->name_list.count);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 8:
         /* decode description_list */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->description_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->description_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 9:
         /* decode parentalRating_list */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->parentalRating_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->parentalRating_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 10:
         /* decode targetUserProfile */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_TargetUserProfileType (pctxt, 
               &pvalue->targetUserProfile, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.targetUserProfilePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 11:
         /* decode genre_list */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               GenreElementType pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->genre_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = asn1D_GenreElementType (pctxt, 
                     &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->genre_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 12:
         /* decode userRating */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->userRating, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.userRatingPresent = TRUE;
            }
         }
         break;

      case 13:
         /* decode previewDataIDRef_list */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               PreviewDataIDRefType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->previewDataIDRef_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, PreviewDataIDRefType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_PreviewDataIDRefType (pdata2);

                  stat = asn1D_PreviewDataIDRefType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->previewDataIDRef_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 14:
         /* decode broadcast_area */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_Broadcast_areaType (pctxt, 
               &pvalue->broadcast_area, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.broadcast_areaPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 15:
         /* decode fileDescription */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_FileDescriptionType (pctxt, 
               &pvalue->fileDescription, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.fileDescriptionPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_CONS|15):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 8) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_ContentType (OSCTXT* pctxt, ContentType* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("ContentType"), 11}, 0 },
            { {OSUTF8("ServiceIDRef"), 12}, 0 },
            { {OSUTF8("id"), 2}, 0 },
            { {OSUTF8("validFrom"), 9}, 0 },
            { {OSUTF8("validTo"), 7}, 0 },
            { {OSUTF8("version"), 7}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 6, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* ContentType */
               stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->contentType);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.contentTypePresent = TRUE;
               break;

            case 1: /* ServiceIDRef */
               stat = XmlDec_ServiceIDType (pctxt, &pvalue->serviceIDRef
                  , OSUTF8(""), 0);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.serviceIDRefPresent = TRUE;
               break;

            case 2: /* id */
               stat = XmlDec_ContentIDType (pctxt, &pvalue->id
                  , OSUTF8(""), 0);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            case 3: /* validFrom */
               stat = rtXmlpDecUInt (pctxt, &pvalue->validFrom);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.validFromPresent = TRUE;
               break;

            case 4: /* validTo */
               stat = rtXmlpDecUInt (pctxt, &pvalue->validTo);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.validToPresent = TRUE;
               break;

            case 5: /* version */
               stat = rtXmlpDecUInt (pctxt, &pvalue->version);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "ContentType");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "ContentType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("ExtensionURL"), 12}, 0}, 0 },
      {{{OSUTF8("Name"), 4}, 0}, 1 },
      {{{OSUTF8("Description"), 11}, 0}, 2 },
      {{{OSUTF8("ParentalRating"), 14}, 0}, 3 },
      {{{OSUTF8("TargetUserProfile"), 17}, 0}, 4 },
      {{{OSUTF8("Genre"), 5}, 0}, 5 },
      {{{OSUTF8("UserRating"), 10}, 0}, 6 },
      {{{OSUTF8("PreviewDataIDRef"), 16}, 0}, 7 },
      {{{OSUTF8("broadcast_area"), 14}, 0}, 8 },
      {{{OSUTF8("FileDescription"), 15}, 0}, 9 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 10, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->extensionURL_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 10, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 1: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->name_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 10, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 2: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->description_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 10, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 3: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->parentalRating_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 10, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 3);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 4: { /* TargetUserProfile */
         stat = XmlDec_TargetUserProfileType (pctxt, &pvalue->targetUserProfile
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.targetUserProfilePresent = TRUE;
         break;
      }
      case 5: {
         GenreElementType pdata1;
         do {
            stat = XmlDec_GenreElementType (pctxt, &pdata1, OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->genre_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 10, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 5);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 6: { /* UserRating */
         stat = rtXmlpDecInt (pctxt, &pvalue->userRating);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.userRatingPresent = TRUE;
         break;
      }
      case 7: {
         PreviewDataIDRefType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, PreviewDataIDRefType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PreviewDataIDRefType (pdata1);

            stat = XmlDec_PreviewDataIDRefType (pctxt, pdata1, OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->previewDataIDRef_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 10, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 7);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 8: { /* broadcast_area */
         stat = XmlDec_Broadcast_areaType (pctxt, &pvalue->broadcast_area
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.broadcast_areaPresent = TRUE;
         break;
      }
      case 9: { /* FileDescription */
         stat = XmlDec_FileDescriptionType (pctxt, &pvalue->fileDescription
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.fileDescriptionPresent = TRUE;
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AccessTypeType_broadcastTransmission_sessionDescriptionR  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AccessTypeType_broadcastTransmission_sessionDescriptionReference (OSCTXT* pctxt,
   AccessTypeType_broadcastTransmission_sessionDescriptionReference *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->type, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode uRI */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uRI, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uRIPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode idRef */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->idRef, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.idRefPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_AccessTypeType_broadcastTransmission_sessionDescriptionReference 
   (OSCTXT* pctxt, 
   AccessTypeType_broadcastTransmission_sessionDescriptionReference* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("Type"), 4}, 0 },
            { {OSUTF8("URI"), 3}, 0 },
            { {OSUTF8("idRef"), 5}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 3, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* Type */
               stat = rtXmlpDecInt (pctxt, &pvalue->type);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            case 1: /* URI */
               stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uRI);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.uRIPresent = TRUE;
               break;

            case 2: /* idRef */
               stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->idRef);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.idRefPresent = TRUE;
               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "AccessTypeType_broadcastTransmission_sessionDescriptionReference");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "AccessTypeType_broadcastTransmission_sessionDescriptionReference");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AccessTypeType_broadcastTransmission                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AccessTypeType_broadcastTransmission (OSCTXT* pctxt,
   AccessTypeType_broadcastTransmission *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode iPAddress */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->iPAddress, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.iPAddressPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode sessionDescriptionReference_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               AccessTypeType_broadcastTransmission_sessionDescriptionReference* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->sessionDescriptionReference_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, AccessTypeType_broadcastTransmission_sessionDescriptionReference, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_AccessTypeType_broadcastTransmission_sessionDescriptionReference (pdata2);

                  stat = asn1D_AccessTypeType_broadcastTransmission_sessionDescriptionReference (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->sessionDescriptionReference_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode sDP */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->sDP, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sDPPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_AccessTypeType_broadcastTransmission (OSCTXT* pctxt, 
   AccessTypeType_broadcastTransmission* pvalue, const OSUTF8CHAR* elemLName, 
   const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("IPAddress"), 9}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 1, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* IPAddress */
               stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->iPAddress);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.iPAddressPresent = TRUE;
               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "AccessTypeType_broadcastTransmission");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "AccessTypeType_broadcastTransmission");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("SessionDescriptionReference"), 27}, 0}, 0 },
      {{{OSUTF8("SDP"), 3}, 0}, 1 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: {
         AccessTypeType_broadcastTransmission_sessionDescriptionReference* pdata1;
         do {
            pdata1
                = rtxMemAllocType (pctxt, AccessTypeType_broadcastTransmission_sessionDescriptionReference);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AccessTypeType_broadcastTransmission_sessionDescriptionReference (
               pdata1);

            stat = XmlDec_AccessTypeType_broadcastTransmission_sessionDescriptionReference 
               (pctxt, pdata1, OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->sessionDescriptionReference_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 1: { /* SDP */
         stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->sDP);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.sDPPresent = TRUE;
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AccessTypeType_interactiveTransmissionScheme              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AccessTypeType_interactiveTransmissionScheme (OSCTXT* pctxt,
   AccessTypeType_interactiveTransmissionScheme *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode transmissionSchemeType */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->transmissionSchemeType, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode accessServerIPAddress_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->accessServerIPAddress_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->accessServerIPAddress_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode accessServerURL_list */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->accessServerURL_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->accessServerURL_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode accessServerPhoneNumber_list */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               int count;
               int xx2;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               stat = xd_count (pctxt, length, &count);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->accessServerPhoneNumber_list.n = count;
               ALLOC_ASN1ARRAY (pctxt, &pvalue->accessServerPhoneNumber_list, OSINT32);

               xx2 = 0;
               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  stat = xd_integer (pctxt, &pvalue->accessServerPhoneNumber_list.elem[xx2], ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  xx2++;
               }
               pvalue->accessServerPhoneNumber_list.n = xx2;

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 4) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_AccessTypeType_interactiveTransmissionScheme (OSCTXT* pctxt, 
   AccessTypeType_interactiveTransmissionScheme* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("TransmissionSchemeType"), 22}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 1, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* TransmissionSchemeType */
               stat = rtXmlpDecInt (pctxt, &pvalue->transmissionSchemeType);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "AccessTypeType_interactiveTransmissionScheme");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "AccessTypeType_interactiveTransmissionScheme");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("AccessServerIPAddress"), 21}, 0}, 0 },
      {{{OSUTF8("AccessServerURL"), 15}, 0}, 1 },
      {{{OSUTF8("AccessServerPhoneNumber"), 23}, 0}, 2 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->accessServerIPAddress_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 1: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->accessServerURL_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 2: {
         OSRTDList tmplist;
         OSINT32* pdata1;
         rtxDListInit (&tmplist);
         do {
            pdata1 = rtxMemAllocTypeZ (pctxt, OSINT32);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            stat = rtXmlpDecInt (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &tmplist, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;

         /* Convert list to array */
         { OSUINT32 i = 0;
         OSRTDListNode* pnode = tmplist.head;
         pvalue->accessServerPhoneNumber_list.n = tmplist.count;
         pvalue->accessServerPhoneNumber_list.elem =
            rtxMemAllocArray (pctxt, tmplist.count, OSINT32);
         while (0 != pnode) {
            pdata1 = (OSINT32*)pnode->data;
            pvalue->accessServerPhoneNumber_list.elem[i++] = *pdata1;
            pnode = pnode->next;
         }}
         rtxDListFreeAll (pctxt, &tmplist);
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AccessTypeType                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AccessTypeType (OSCTXT* pctxt,
   AccessTypeType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode transmissionMedia */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->transmissionMedia, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode broadcastTransmission */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AccessTypeType_broadcastTransmission (pctxt, 
               &pvalue->broadcastTransmission, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.broadcastTransmissionPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode interactiveTransmissionScheme */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AccessTypeType_interactiveTransmissionScheme (pctxt, 
               &pvalue->interactiveTransmissionScheme, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.interactiveTransmissionSchemePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_AccessTypeType (OSCTXT* pctxt, AccessTypeType* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("TransmissionMedia"), 17}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 1, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* TransmissionMedia */
               stat = rtXmlpDecInt (pctxt, &pvalue->transmissionMedia);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "AccessTypeType");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "AccessTypeType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("BroadcastTransmission"), 21}, 0}, 0 },
      {{{OSUTF8("InteractiveTransmissionScheme"), 29}, 0}, 1 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: { /* BroadcastTransmission */
         stat = XmlDec_AccessTypeType_broadcastTransmission (pctxt, &pvalue->
            broadcastTransmission, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.broadcastTransmissionPresent = TRUE;
         break;
      }
      case 1: { /* InteractiveTransmissionScheme */
         stat = XmlDec_AccessTypeType_interactiveTransmissionScheme (pctxt, &
            pvalue->interactiveTransmissionScheme, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.interactiveTransmissionSchemePresent = TRUE;
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  KMSType                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_KMSType (OSCTXT* pctxt,
   KMSType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode rightsIssuerURI */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->rightsIssuerURI, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.rightsIssuerURIPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode protectionType */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->protectionType, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.protectionTypePresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_KMSType (OSCTXT* pctxt, KMSType* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("RightsIssuerURI"), 15}, 0 },
            { {OSUTF8("protectionType"), 14}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 2, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* RightsIssuerURI */
               stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->rightsIssuerURI);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.rightsIssuerURIPresent = TRUE;
               break;

            case 1: /* protectionType */
               stat = rtXmlpDecInt (pctxt, &pvalue->protectionType);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.protectionTypePresent = TRUE;
               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "KMSType");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "KMSType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->base);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AccessType_scheduleIDRef                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AccessType_scheduleIDRef (OSCTXT* pctxt,
   AccessType_scheduleIDRef *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode distributionWindowID */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->distributionWindowID, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.distributionWindowIDPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_AccessType_scheduleIDRef (OSCTXT* pctxt, 
   AccessType_scheduleIDRef* pvalue, const OSUTF8CHAR* elemLName, 
   const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("DistributionWindowID"), 20}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 1, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* DistributionWindowID */
               stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->distributionWindowID
                  );
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.distributionWindowIDPresent = TRUE;
               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "AccessType_scheduleIDRef");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "AccessType_scheduleIDRef");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->base);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AccessType_choice                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AccessType_choice (OSCTXT* pctxt,
   AccessType_choice *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         pvalue->u.serviceIDRef_list = rtxMemAllocType (pctxt, OSRTDList);

         if (pvalue->u.serviceIDRef_list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         rtxDListFastInit (pvalue->u.serviceIDRef_list);
         /* decode inline SEQUENCE OF type */
         {
            int stat = 0;
            ServiceIDType pdata2;
            OSRTDListNode* pnode;
            ASN1CCB ccb;

            /* decode SEQUENCE OF or SET OF */

            rtxDListInit (pvalue->u.serviceIDRef_list);

            ccb.len = length;
            ccb.ptr = OSRTBUFPTR(pctxt);

            while (!XD_CHKEND (pctxt, &ccb))
            {
               pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

               if (pnode == NULL)
                  return LOG_RTERR (pctxt, RTERR_NOMEM);

               stat = asn1D_ServiceIDType (pctxt, 
                  &pdata2, ASN1EXPL, length);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pnode->data = (void*)pdata2;
               rtxDListAppendNode (pvalue->u.serviceIDRef_list, pnode);
            }

         }
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 1;
         break;

      case (TM_CTXT|TM_CONS|1):
         pvalue->u.scheduleIDRef_list = rtxMemAllocType (pctxt, OSRTDList);

         if (pvalue->u.scheduleIDRef_list == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         rtxDListFastInit (pvalue->u.scheduleIDRef_list);
         /* decode inline SEQUENCE OF type */
         {
            int stat = 0;
            AccessType_scheduleIDRef* pdata2;
            OSRTDListNode* pnode;
            ASN1CCB ccb;

            /* decode SEQUENCE OF or SET OF */

            rtxDListInit (pvalue->u.scheduleIDRef_list);

            ccb.len = length;
            ccb.ptr = OSRTBUFPTR(pctxt);

            while (!XD_CHKEND (pctxt, &ccb))
            {
               rtxDListAllocNodeAndData (pctxt, AccessType_scheduleIDRef, &pnode, &pdata2);

               if (pnode == NULL)
                  return LOG_RTERR (pctxt, RTERR_NOMEM);

               asn1Init_AccessType_scheduleIDRef (pdata2);

               stat = asn1D_AccessType_scheduleIDRef (pctxt, 
                  pdata2, ASN1EXPL, length);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               rtxDListAppendNode (pvalue->u.scheduleIDRef_list, pnode);
            }

         }
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->t = 2;
         break;

      default:
         xu_addTagErrParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }

   return (stat);
}

int XmlDec_AccessType_choice (OSCTXT* pctxt, AccessType_choice* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   if (elemLName != 0 && *elemLName != 0) {
      stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("ServiceIDRef"), 12}, 0}, 0 },
      {{{OSUTF8("ScheduleIDRef"), 13}, 0}, 1 }
   } ;
   pvalue->t = 0;
   elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
   if (elemID < 0) return LOG_RTERR (pctxt, elemID);

   switch (elemID) {
   case 0: {
      ServiceIDType pdata1;

      pvalue->u.serviceIDRef_list = rtxMemAllocType (pctxt, OSRTDList);
      rtxDListInit (pvalue->u.serviceIDRef_list);

      do {
         stat = XmlDec_ServiceIDType (pctxt, &pdata1, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, pvalue->u.serviceIDRef_list, (void*)pdata1);

         stat = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }
      while (stat == 0);

      rtXmlpMarkLastEventActive (pctxt);
      stat = 0;
      break;
   }
   case 1: {
      AccessType_scheduleIDRef* pdata1;

      pvalue->u.scheduleIDRef_list = rtxMemAllocType (pctxt, OSRTDList);
      rtxDListInit (pvalue->u.scheduleIDRef_list);

      do {
         pdata1 = rtxMemAllocType (pctxt, AccessType_scheduleIDRef);

         if (pdata1 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_AccessType_scheduleIDRef (pdata1);

         stat = XmlDec_AccessType_scheduleIDRef (pctxt, pdata1
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         rtxDListAppend (pctxt, pvalue->u.scheduleIDRef_list, (void*)pdata1);

         stat = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }
      while (stat == 1);

      rtXmlpMarkLastEventActive (pctxt);
      stat = 0;
      break;
   }
   }
   if (elemID == XML_OK_EOB) return LOG_RTERR (pctxt, RTERR_INVOPT);
   else pvalue->t = elemID + 1;
   }

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminalCapabilityRequirementType_video_bitrate           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TerminalCapabilityRequirementType_video_bitrate (OSCTXT* pctxt,
   TerminalCapabilityRequirementType_video_bitrate *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode average */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_uint16 (pctxt, &pvalue->average, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.averagePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode maximum */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_uint16 (pctxt, &pvalue->maximum, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.maximumPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_TerminalCapabilityRequirementType_video_bitrate (OSCTXT* pctxt, 
   TerminalCapabilityRequirementType_video_bitrate* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("average"), 7}, 0 },
            { {OSUTF8("maximum"), 7}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 2, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* average */
               stat = rtXmlpDecUInt16 (pctxt, &pvalue->average);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.averagePresent = TRUE;
               break;

            case 1: /* maximum */
               stat = rtXmlpDecUInt16 (pctxt, &pvalue->maximum);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.maximumPresent = TRUE;
               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "TerminalCapabilityRequirementType_video_bitrate");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "TerminalCapabilityRequirementType_video_bitrate");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminalCapabilityRequirementType_video_resolution        */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TerminalCapabilityRequirementType_video_resolution (OSCTXT* pctxt,
   TerminalCapabilityRequirementType_video_resolution *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode horizontal */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_uint16 (pctxt, &pvalue->horizontal, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode vertical */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_uint16 (pctxt, &pvalue->vertical, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_TerminalCapabilityRequirementType_video_resolution (OSCTXT* pctxt, 
   TerminalCapabilityRequirementType_video_resolution* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("horizontal"), 10}, 0 },
            { {OSUTF8("vertical"), 8}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 2, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* horizontal */
               stat = rtXmlpDecUInt16 (pctxt, &pvalue->horizontal);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            case 1: /* vertical */
               stat = rtXmlpDecUInt16 (pctxt, &pvalue->vertical);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "TerminalCapabilityRequirementType_video_resolution");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "TerminalCapabilityRequirementType_video_resolution");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminalCapabilityRequirementType_video                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TerminalCapabilityRequirementType_video (OSCTXT* pctxt,
   TerminalCapabilityRequirementType_video *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (XD_PEEKTAG (pctxt, 0xa0)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_CTXT|TM_CONS|0));

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bitrate */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_TerminalCapabilityRequirementType_video_bitrate (pctxt, 
               &pvalue->bitrate, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bitratePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode resolution */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_TerminalCapabilityRequirementType_video_resolution (pctxt, 
               &pvalue->resolution, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.resolutionPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode minimumBufferSize */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->minimumBufferSize, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.minimumBufferSizePresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_TerminalCapabilityRequirementType_video (OSCTXT* pctxt, 
   TerminalCapabilityRequirementType_video* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0 && *elemLName != 0) {
      stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Bitrate"), 7}, 0}, 0 },
      {{{OSUTF8("Resolution"), 10}, 0}, 1 },
      {{{OSUTF8("MinimumBufferSize"), 17}, 0}, 2 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: { /* Bitrate */
         stat = XmlDec_TerminalCapabilityRequirementType_video_bitrate (pctxt, 
            &pvalue->bitrate, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.bitratePresent = TRUE;
         break;
      }
      case 1: { /* Resolution */
         stat = XmlDec_TerminalCapabilityRequirementType_video_resolution 
            (pctxt, &pvalue->resolution, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.resolutionPresent = TRUE;
         break;
      }
      case 2: { /* MinimumBufferSize */
         stat = rtXmlpDecUInt (pctxt, &pvalue->minimumBufferSize);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.minimumBufferSizePresent = TRUE;
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminalCapabilityRequirementType_audio_bitrate           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TerminalCapabilityRequirementType_audio_bitrate (OSCTXT* pctxt,
   TerminalCapabilityRequirementType_audio_bitrate *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode average */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_uint16 (pctxt, &pvalue->average, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.averagePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode maximum */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_uint16 (pctxt, &pvalue->maximum, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.maximumPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_TerminalCapabilityRequirementType_audio_bitrate (OSCTXT* pctxt, 
   TerminalCapabilityRequirementType_audio_bitrate* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("average"), 7}, 0 },
            { {OSUTF8("maximum"), 7}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 2, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* average */
               stat = rtXmlpDecUInt16 (pctxt, &pvalue->average);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.averagePresent = TRUE;
               break;

            case 1: /* maximum */
               stat = rtXmlpDecUInt16 (pctxt, &pvalue->maximum);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.maximumPresent = TRUE;
               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "TerminalCapabilityRequirementType_audio_bitrate");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "TerminalCapabilityRequirementType_audio_bitrate");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminalCapabilityRequirementType_audio                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TerminalCapabilityRequirementType_audio (OSCTXT* pctxt,
   TerminalCapabilityRequirementType_audio *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   if (XD_PEEKTAG (pctxt, 0xa0)) {
      stat = xd_Tag1AndLen (pctxt, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else return LOG_RTERR (pctxt,
      berErrUnexpTag(pctxt, TM_CTXT|TM_CONS|0));

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bitrate */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_TerminalCapabilityRequirementType_audio_bitrate (pctxt, 
               &pvalue->bitrate, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bitratePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode minimumBufferSize */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->minimumBufferSize, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.minimumBufferSizePresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_TerminalCapabilityRequirementType_audio (OSCTXT* pctxt, 
   TerminalCapabilityRequirementType_audio* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0 && *elemLName != 0) {
      stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Bitrate"), 7}, 0}, 0 },
      {{{OSUTF8("MinimumBufferSize"), 17}, 0}, 1 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 2, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: { /* Bitrate */
         stat = XmlDec_TerminalCapabilityRequirementType_audio_bitrate (pctxt, 
            &pvalue->bitrate, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.bitratePresent = TRUE;
         break;
      }
      case 1: { /* MinimumBufferSize */
         stat = rtXmlpDecUInt (pctxt, &pvalue->minimumBufferSize);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.minimumBufferSizePresent = TRUE;
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TerminalCapabilityRequirementType                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_TerminalCapabilityRequirementType (OSCTXT* pctxt,
   TerminalCapabilityRequirementType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode video */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_TerminalCapabilityRequirementType_video (pctxt, 
               &pvalue->video, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.videoPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 1:
         /* decode audio */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_TerminalCapabilityRequirementType_audio (pctxt, 
               &pvalue->audio, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.audioPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 2:
         /* decode downloadFile */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            { int ilcnt = 0, length;
            tagging = ASN1IMPL;
            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               OSRTDList* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               if (XD_PEEKTAG (pctxt, 0xa0)) {
                  stat = xd_Tag1AndLen (pctxt, &length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);
               }
               else return LOG_RTERR (pctxt,
                  berErrUnexpTag(pctxt, TM_CTXT|TM_CONS|0));

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->downloadFile);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  { int ilcnt = 0, length;
                  tagging = ASN1IMPL;
                  rtxDListAllocNodeAndData (pctxt, OSRTDList, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  rtxDListFastInit (pdata2);

                  /* decode inline SEQUENCE OF type */
                  {
                     int stat = 0;
                     const OSUTF8CHAR* pdata3;
                     OSRTDListNode* pnode;
                     ASN1CCB ccb;

                     if (XD_PEEKTAG (pctxt, 0x30)) {
                        stat = xd_Tag1AndLen (pctxt, &length);
                        if (stat != 0) return LOG_RTERR (pctxt, stat);
                     }
                     else return LOG_RTERR (pctxt,
                        berErrUnexpTag(pctxt, TM_UNIV|TM_CONS|16));

                     if (XD_PEEKTAG (pctxt, 0xa0)) {
                        stat = xd_Tag1AndLen (pctxt, &length);
                        if (stat != 0) return LOG_RTERR (pctxt, stat);
                     }
                     else return LOG_RTERR (pctxt,
                        berErrUnexpTag(pctxt, TM_CTXT|TM_CONS|0));

                     /* decode SEQUENCE OF or SET OF */

                     rtxDListInit (pdata2);

                     ccb.len = length;
                     ccb.ptr = OSRTBUFPTR(pctxt);

                     while (!XD_CHKEND (pctxt, &ccb))
                     {
                        pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                        if (pnode == NULL)
                           return LOG_RTERR (pctxt, RTERR_NOMEM);

                        stat = xd_utf8str (pctxt, &pdata3, ASN1EXPL, length);
                        if (stat != 0) return LOG_RTERR (pctxt, stat);

                        pnode->data = (void*)pdata3;
                        rtxDListAppendNode (pdata2, pnode);
                     }

                  }
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  while (ilcnt-- > 0) {
                     if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                     else return LOG_RTERR (pctxt, ASN_E_INVLEN);
                  }}
                  rtxDListAppendNode (&pvalue->downloadFile, pnode);
               }

            }
            if (stat == 0) {
               pvalue->m.downloadFilePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }

            while (ilcnt-- > 0) {
               if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
               else return LOG_RTERR (pctxt, ASN_E_INVLEN);
            }}
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_TerminalCapabilityRequirementType (OSCTXT* pctxt, 
   TerminalCapabilityRequirementType* pvalue, const OSUTF8CHAR* elemLName, 
   const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0 && *elemLName != 0) {
      stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Video"), 5}, 0}, 0 },
      {{{OSUTF8("Audio"), 5}, 0}, 1 },
      {{{OSUTF8("DownloadFile"), 12}, 0}, 2 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: { /* Video */
         stat = XmlDec_TerminalCapabilityRequirementType_video (pctxt, &pvalue
            ->video, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.videoPresent = TRUE;
         break;
      }
      case 1: { /* Audio */
         stat = XmlDec_TerminalCapabilityRequirementType_audio (pctxt, &pvalue
            ->audio, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.audioPresent = TRUE;
         break;
      }
      case 2: { /* DownloadFile */
         { int elemID;
         OSRTDList* pdata1;

         static const OSXMLElemIDRec elemtab[] = {
            {{{OSUTF8("MIMETypeSet"), 11}, 0}, 0 }
         } ;
         rtxDListInit (&pvalue->downloadFile);
         for (;;) {
            elemID = rtXmlpGetNextElemID (pctxt, elemtab, 1, -1, FALSE);
            if (elemID < 0 || elemID == XML_OK_EOB) break;

            switch (elemID) {
            case 0: /* MIMETypeSet */
               pdata1 = rtxMemAllocType (pctxt, OSRTDList);

               if (pdata1 == NULL)
                  return LOG_RTERR (pctxt, RTERR_NOMEM);

               rtxDListFastInit (pdata1);

               { int elemID;
               const OSUTF8CHAR* pdata2;

               static const OSXMLElemIDRec elemtab[] = {
                  {{{OSUTF8("Type"), 4}, 0}, 0 }
               } ;
               rtxDListInit (pdata1);
               for (;;) {
                  elemID = rtXmlpGetNextElemID (pctxt, elemtab, 1, -1, FALSE);
                  if (elemID < 0 || elemID == XML_OK_EOB) break;

                  switch (elemID) {
                  case 0: /* Type */
                     stat = rtXmlpDecDynUTF8Str (pctxt, &pdata2);
                     if (stat != 0) return LOG_RTERR (pctxt, stat);

                     rtxDListAppend (pctxt, pdata1, (void*)pdata2);
                     break;

                  }
               }

               if (elemID == RTERR_UNEXPELEM || elemID == XML_OK_EOB) {
                  stat = 0;
               }
               else return LOG_RTERR (pctxt, elemID);
               }

               stat = rtXmlpMatchEndTag (pctxt, -1);
               if (stat < 0) return LOG_RTERR (pctxt, stat);
               rtxDListAppend (pctxt, &pvalue->downloadFile, (void*)pdata1);
               break;

            }
         }

         if (elemID == RTERR_UNEXPELEM || elemID == XML_OK_EOB) {
            stat = 0;
         }
         else return LOG_RTERR (pctxt, elemID);
         }

         stat = rtXmlpMatchEndTag (pctxt, -1);
         if (stat < 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.downloadFilePresent = TRUE;
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  NotificationReceptionType                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_NotificationReceptionType (OSCTXT* pctxt,
   NotificationReceptionType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode notificationAddress */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->notificationAddress, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode notificationPort */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->notificationPort, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_NotificationReceptionType (OSCTXT* pctxt, 
   NotificationReceptionType* pvalue, const OSUTF8CHAR* elemLName, 
   const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("NotificationAddress"), 19}, 0 },
            { {OSUTF8("NotificationPort"), 16}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 2, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* NotificationAddress */
               stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->notificationAddress
                  );
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            case 1: /* NotificationPort */
               stat = rtXmlpDecInt (pctxt, &pvalue->notificationPort);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "NotificationReceptionType");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "NotificationReceptionType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AccessType                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AccessType (OSCTXT* pctxt,
   AccessType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode audioLanguage */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->audioLanguage, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.audioLanguagePresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode serviceProtection */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->serviceProtection, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.serviceProtectionPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AccessIDType (pctxt, 
               &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode validFrom */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->validFrom, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.validFromPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode validTo */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->validTo, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.validToPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode version */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->version, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode accessType */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AccessTypeType (pctxt, 
               &pvalue->accessType, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode keyManagementSystem_list */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               KMSType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->keyManagementSystem_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, KMSType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_KMSType (pdata2);

                  stat = asn1D_KMSType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->keyManagementSystem_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 8:
         /* decode extensionURL_list */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->extensionURL_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->extensionURL_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 9:
         /* decode choice */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AccessType_choice (pctxt, 
               &pvalue->choice, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.choicePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 10:
         /* decode usageInfo_list */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->usageInfo_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->usageInfo_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 11:
         /* decode alternativeAccessURL_list */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->alternativeAccessURL_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->alternativeAccessURL_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 12:
         /* decode terminalCapabilityRequirement */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_TerminalCapabilityRequirementType (pctxt, 
               &pvalue->terminalCapabilityRequirement, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.terminalCapabilityRequirementPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 13:
         /* decode bandwidthRequirement */
         if (XD_PEEKTAG (pctxt, 0x8d)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->bandwidthRequirement, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.bandwidthRequirementPresent = TRUE;
            }
         }
         break;

      case 14:
         /* decode serviceClass_list */
         if (XD_PEEKTAG (pctxt, 0x8e)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->serviceClass_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->serviceClass_list, pnode);
               }

               if (!(pvalue->serviceClass_list.count >= 1)) {
                  rtxErrAddStrParm (pctxt, "AccessType.serviceClass_list.count");
                  rtxErrAddIntParm (pctxt, (int)pvalue->serviceClass_list.count);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 15:
         /* decode previewDataIDRef_list */
         if (XD_PEEKTAG (pctxt, 0x8f)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               PreviewDataIDRefType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->previewDataIDRef_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, PreviewDataIDRefType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_PreviewDataIDRefType (pdata2);

                  stat = asn1D_PreviewDataIDRefType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->previewDataIDRef_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 16:
         /* decode notificationReception */
         if (XD_PEEKTAG (pctxt, 0x90)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_NotificationReceptionType (pctxt, 
               &pvalue->notificationReception, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.notificationReceptionPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_PRIM|13):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 9) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_AccessType (OSCTXT* pctxt, AccessType* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("AudioLanguage"), 13}, 0 },
            { {OSUTF8("ServiceProtection"), 17}, 0 },
            { {OSUTF8("id"), 2}, 0 },
            { {OSUTF8("validFrom"), 9}, 0 },
            { {OSUTF8("validTo"), 7}, 0 },
            { {OSUTF8("version"), 7}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 6, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* AudioLanguage */
               stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->audioLanguage);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.audioLanguagePresent = TRUE;
               break;

            case 1: /* ServiceProtection */
               stat = rtXmlpDecBool (pctxt, &pvalue->serviceProtection);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.serviceProtectionPresent = TRUE;
               break;

            case 2: /* id */
               stat = XmlDec_AccessIDType (pctxt, &pvalue->id, OSUTF8(""), 0);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            case 3: /* validFrom */
               stat = rtXmlpDecUInt (pctxt, &pvalue->validFrom);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.validFromPresent = TRUE;
               break;

            case 4: /* validTo */
               stat = rtXmlpDecUInt (pctxt, &pvalue->validTo);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.validToPresent = TRUE;
               break;

            case 5: /* version */
               stat = rtXmlpDecUInt (pctxt, &pvalue->version);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "AccessType");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "AccessType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("AccessType"), 10}, 0}, 0 },
      {{{OSUTF8("KeyManagementSystem"), 19}, 0}, 1 },
      {{{OSUTF8("ExtensionURL"), 12}, 0}, 2 },
      {{{OSUTF8("ServiceIDRef"), 12}, 0}, 3 },
      {{{OSUTF8("ScheduleIDRef"), 13}, 0}, 3 },
      {{{OSUTF8("UsageInfo"), 9}, 0}, 4 },
      {{{OSUTF8("AlternativeAccessURL"), 20}, 0}, 5 },
      {{{OSUTF8("TerminalCapabilityRequirement"), 29}, 0}, 6 },
      {{{OSUTF8("BandwidthRequirement"), 20}, 0}, 7 },
      {{{OSUTF8("ServiceClass"), 12}, 0}, 8 },
      {{{OSUTF8("PreviewDataIDRef"), 16}, 0}, 9 },
      {{{OSUTF8("NotificationReception"), 21}, 0}, 10 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 12, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: { /* AccessType */
         stat = XmlDec_AccessTypeType (pctxt, &pvalue->accessType
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: {
         KMSType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, KMSType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_KMSType (pdata1);

            stat = XmlDec_KMSType (pctxt, pdata1, OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->keyManagementSystem_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 12, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 2: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->extensionURL_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 12, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 3: { /*  */
         rtXmlpMarkLastEventActive (pctxt);

         stat = XmlDec_AccessType_choice (pctxt, &pvalue->choice
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.choicePresent = TRUE;
         break;
      }
      case 4: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->usageInfo_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 12, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 4);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 5: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->alternativeAccessURL_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 12, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 5);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 6: { /* TerminalCapabilityRequirement */
         stat = XmlDec_TerminalCapabilityRequirementType (pctxt, &pvalue->
            terminalCapabilityRequirement, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.terminalCapabilityRequirementPresent = TRUE;
         break;
      }
      case 7: { /* BandwidthRequirement */
         stat = rtXmlpDecInt (pctxt, &pvalue->bandwidthRequirement);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.bandwidthRequirementPresent = TRUE;
         break;
      }
      case 8: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->serviceClass_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 12, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 8);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 9: {
         PreviewDataIDRefType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, PreviewDataIDRefType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PreviewDataIDRefType (pdata1);

            stat = XmlDec_PreviewDataIDRefType (pctxt, pdata1, OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->previewDataIDRef_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 12, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 9);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 10: { /* NotificationReception */
         stat = XmlDec_NotificationReceptionType (pctxt, &pvalue->
            notificationReception, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.notificationReceptionPresent = TRUE;
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PictureType                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PictureType (OSCTXT* pctxt,
   PictureType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode pictureURI */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->pictureURI, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.pictureURIPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode pictureData */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_octstr (pctxt, &pvalue->pictureData.data, &pvalue->pictureData.numocts, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.pictureDataPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode codec */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->codec, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.codecPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode alternativeText */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_TextType (pctxt, 
               &pvalue->alternativeText, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.alternativeTextPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PictureType (OSCTXT* pctxt, PictureType* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0 && *elemLName != 0) {
      stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("PictureURI"), 10}, 0}, 0 },
      {{{OSUTF8("PictureData"), 11}, 0}, 1 },
      {{{OSUTF8("Codec"), 5}, 0}, 2 },
      {{{OSUTF8("AlternativeText"), 15}, 0}, 3 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 4, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: { /* PictureURI */
         stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->pictureURI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.pictureURIPresent = TRUE;
         break;
      }
      case 1: { /* PictureData */
         stat = rtXmlpDecDynBase64Str (pctxt, &pvalue->pictureData);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.pictureDataPresent = TRUE;
         break;
      }
      case 2: { /* Codec */
         stat = rtXmlpDecInt (pctxt, &pvalue->codec);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.codecPresent = TRUE;
         break;
      }
      case 3: { /* AlternativeText */
         stat = XmlDec_TextType (pctxt, &pvalue->alternativeText
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.alternativeTextPresent = TRUE;
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  VideoType                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_VideoType (OSCTXT* pctxt,
   VideoType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode videoURI */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->videoURI, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode codec */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->codec, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.codecPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode alternativeText */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_TextType (pctxt, 
               &pvalue->alternativeText, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.alternativeTextPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode alternativePicture */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PictureType (pctxt, 
               &pvalue->alternativePicture, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.alternativePicturePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_VideoType (OSCTXT* pctxt, VideoType* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0 && *elemLName != 0) {
      stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("VideoURI"), 8}, 0}, 0 },
      {{{OSUTF8("Codec"), 5}, 0}, 1 },
      {{{OSUTF8("AlternativeText"), 15}, 0}, 2 },
      {{{OSUTF8("AlternativePicture"), 18}, 0}, 3 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 4, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: { /* VideoURI */
         stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->videoURI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* Codec */
         stat = rtXmlpDecInt (pctxt, &pvalue->codec);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.codecPresent = TRUE;
         break;
      }
      case 2: { /* AlternativeText */
         stat = XmlDec_TextType (pctxt, &pvalue->alternativeText
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.alternativeTextPresent = TRUE;
         break;
      }
      case 3: { /* AlternativePicture */
         stat = XmlDec_PictureType (pctxt, &pvalue->alternativePicture
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.alternativePicturePresent = TRUE;
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  AudioType                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_AudioType (OSCTXT* pctxt,
   AudioType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode audioURI */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->audioURI, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode codec */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->codec, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.codecPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode alternativeText */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_TextType (pctxt, 
               &pvalue->alternativeText, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.alternativeTextPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode alternativePicture */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PictureType (pctxt, 
               &pvalue->alternativePicture, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.alternativePicturePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_AudioType (OSCTXT* pctxt, AudioType* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0 && *elemLName != 0) {
      stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("AudioURI"), 8}, 0}, 0 },
      {{{OSUTF8("Codec"), 5}, 0}, 1 },
      {{{OSUTF8("AlternativeText"), 15}, 0}, 2 },
      {{{OSUTF8("AlternativePicture"), 18}, 0}, 3 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 4, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: { /* AudioURI */
         stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->audioURI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* Codec */
         stat = rtXmlpDecInt (pctxt, &pvalue->codec);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.codecPresent = TRUE;
         break;
      }
      case 2: { /* AlternativeText */
         stat = XmlDec_TextType (pctxt, &pvalue->alternativeText
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.alternativeTextPresent = TRUE;
         break;
      }
      case 3: { /* AlternativePicture */
         stat = XmlDec_PictureType (pctxt, &pvalue->alternativePicture
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.alternativePicturePresent = TRUE;
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PreviewDataType                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PreviewDataType (OSCTXT* pctxt,
   PreviewDataType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PreviewDataIDType (pctxt, 
               &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode validFrom */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->validFrom, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.validFromPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode validTo */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->validTo, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.validToPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode version */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->version, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode sMIL */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->sMIL, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.sMILPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode video */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_VideoType (pctxt, 
               &pvalue->video, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.videoPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 6:
         /* decode audio */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AudioType (pctxt, 
               &pvalue->audio, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.audioPresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 7:
         /* decode picture */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PictureType (pctxt, 
               &pvalue->picture, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.picturePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 8:
         /* decode text */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_TextType (pctxt, 
               &pvalue->text, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.textPresent = TRUE;
            }
         }
         break;

      case 9:
         /* decode accessIDRef */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_AccessIDType (pctxt, 
               &pvalue->accessIDRef, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.accessIDRefPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PreviewDataType (OSCTXT* pctxt, PreviewDataType* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("id"), 2}, 0 },
            { {OSUTF8("validFrom"), 9}, 0 },
            { {OSUTF8("validTo"), 7}, 0 },
            { {OSUTF8("version"), 7}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 4, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* id */
               stat = XmlDec_PreviewDataIDType (pctxt, &pvalue->id
                  , OSUTF8(""), 0);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            case 1: /* validFrom */
               stat = rtXmlpDecInt (pctxt, &pvalue->validFrom);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.validFromPresent = TRUE;
               break;

            case 2: /* validTo */
               stat = rtXmlpDecInt (pctxt, &pvalue->validTo);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.validToPresent = TRUE;
               break;

            case 3: /* version */
               stat = rtXmlpDecUInt (pctxt, &pvalue->version);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "PreviewDataType");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "PreviewDataType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("SMIL"), 4}, 0}, 0 },
      {{{OSUTF8("Video"), 5}, 0}, 1 },
      {{{OSUTF8("Audio"), 5}, 0}, 2 },
      {{{OSUTF8("Picture"), 7}, 0}, 3 },
      {{{OSUTF8("Text"), 4}, 0}, 4 },
      {{{OSUTF8("AccessIDRef"), 11}, 0}, 5 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 6, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: { /* SMIL */
         stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->sMIL);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.sMILPresent = TRUE;
         break;
      }
      case 1: { /* Video */
         stat = XmlDec_VideoType (pctxt, &pvalue->video, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.videoPresent = TRUE;
         break;
      }
      case 2: { /* Audio */
         stat = XmlDec_AudioType (pctxt, &pvalue->audio, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.audioPresent = TRUE;
         break;
      }
      case 3: { /* Picture */
         stat = XmlDec_PictureType (pctxt, &pvalue->picture, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.picturePresent = TRUE;
         break;
      }
      case 4: { /* Text */
         stat = XmlDec_TextType (pctxt, &pvalue->text, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.textPresent = TRUE;
         break;
      }
      case 5: { /* AccessIDRef */
         stat = XmlDec_AccessIDType (pctxt, &pvalue->accessIDRef
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.accessIDRefPresent = TRUE;
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseItemType                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PurchaseItemType (OSCTXT* pctxt,
   PurchaseItemType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode weight */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->weight, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.weightPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode validFrom */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->validFrom, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.validFromPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode validTo */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->validTo, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.validToPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode version */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->version, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode extensionURL_list */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->extensionURL_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->extensionURL_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode serviceIDRef_list */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->serviceIDRef_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->serviceIDRef_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode scheduleIDRef_list */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               ScheduleIDType pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->scheduleIDRef_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = asn1D_ScheduleIDType (pctxt, 
                     &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->scheduleIDRef_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 8:
         /* decode contentIDRef_list */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->contentIDRef_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->contentIDRef_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 9:
         /* decode name_list */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->name_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->name_list, pnode);
               }

               if (!(pvalue->name_list.count >= 1)) {
                  rtxErrAddStrParm (pctxt, "PurchaseItemType.name_list.count");
                  rtxErrAddIntParm (pctxt, (int)pvalue->name_list.count);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 10:
         /* decode description_list */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->description_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->description_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 11:
         /* decode parentalRating */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->parentalRating, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.parentalRatingPresent = TRUE;
            }
         }
         break;

      case 12:
         /* decode purchaseDataIDRef_list */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->purchaseDataIDRef_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->purchaseDataIDRef_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_PRIM|11):
         case (TM_CTXT|TM_CONS|12):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 9) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PurchaseItemType (OSCTXT* pctxt, PurchaseItemType* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("Weight"), 6}, 0 },
            { {OSUTF8("id"), 2}, 0 },
            { {OSUTF8("validFrom"), 9}, 0 },
            { {OSUTF8("validTo"), 7}, 0 },
            { {OSUTF8("version"), 7}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 5, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* Weight */
               stat = rtXmlpDecUInt (pctxt, &pvalue->weight);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.weightPresent = TRUE;
               break;

            case 1: /* id */
               stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            case 2: /* validFrom */
               stat = rtXmlpDecUInt (pctxt, &pvalue->validFrom);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.validFromPresent = TRUE;
               break;

            case 3: /* validTo */
               stat = rtXmlpDecUInt (pctxt, &pvalue->validTo);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.validToPresent = TRUE;
               break;

            case 4: /* version */
               stat = rtXmlpDecUInt (pctxt, &pvalue->version);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "PurchaseItemType");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "PurchaseItemType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("ExtensionURL"), 12}, 0}, 0 },
      {{{OSUTF8("ServiceIDRef"), 12}, 0}, 1 },
      {{{OSUTF8("ScheduleIDRef"), 13}, 0}, 2 },
      {{{OSUTF8("ContentIDRef"), 12}, 0}, 3 },
      {{{OSUTF8("Name"), 4}, 0}, 4 },
      {{{OSUTF8("Description"), 11}, 0}, 5 },
      {{{OSUTF8("ParentalRating"), 14}, 0}, 6 },
      {{{OSUTF8("PurchaseDataIDRef"), 17}, 0}, 7 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 8, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->extensionURL_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 8, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 1: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->serviceIDRef_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 8, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 2: {
         ScheduleIDType pdata1;
         do {
            stat = XmlDec_ScheduleIDType (pctxt, &pdata1, OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->scheduleIDRef_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 8, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 3: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->contentIDRef_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 8, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 3);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 4: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->name_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 8, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 4);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 5: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->description_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 8, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 5);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 6: { /* ParentalRating */
         stat = rtXmlpDecInt (pctxt, &pvalue->parentalRating);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.parentalRatingPresent = TRUE;
         break;
      }
      case 7: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->purchaseDataIDRef_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 8, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 7);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseDataType_priceInfo_subscriptionUnit               */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PurchaseDataType_priceInfo_subscriptionUnit (OSCTXT* pctxt,
   PurchaseDataType_priceInfo_subscriptionUnit *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->type, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode unit */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->unit, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PurchaseDataType_priceInfo_subscriptionUnit (OSCTXT* pctxt, 
   PurchaseDataType_priceInfo_subscriptionUnit* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("Type"), 4}, 0 },
            { {OSUTF8("Unit"), 4}, 0 },
            { {OSUTF8("Value"), 5}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 3, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* Type */
               stat = rtXmlpDecInt (pctxt, &pvalue->type);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            case 1: /* Unit */
               stat = rtXmlpDecInt (pctxt, &pvalue->unit);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            case 2: /* Value */
               stat = rtXmlpDecInt (pctxt, &pvalue->value);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "PurchaseDataType_priceInfo_subscriptionUnit");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "PurchaseDataType_priceInfo_subscriptionUnit");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseDataType_priceInfo_price                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PurchaseDataType_priceInfo_price (OSCTXT* pctxt,
   PurchaseDataType_priceInfo_price *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode currency */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->currency, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->value, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PurchaseDataType_priceInfo_price (OSCTXT* pctxt, 
   PurchaseDataType_priceInfo_price* pvalue, const OSUTF8CHAR* elemLName, 
   const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("Currency"), 8}, 0 },
            { {OSUTF8("Value"), 5}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 2, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* Currency */
               stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->currency);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            case 1: /* Value */
               stat = rtXmlpDecInt (pctxt, &pvalue->value);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "PurchaseDataType_priceInfo_price");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "PurchaseDataType_priceInfo_price");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseDataType_priceInfo                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PurchaseDataType_priceInfo (OSCTXT* pctxt,
   PurchaseDataType_priceInfo *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode subscriptionUnit */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PurchaseDataType_priceInfo_subscriptionUnit (pctxt, 
               &pvalue->subscriptionUnit, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode unitText */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->unitText, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode price_list */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               PurchaseDataType_priceInfo_price* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->price_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, PurchaseDataType_priceInfo_price, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_PurchaseDataType_priceInfo_price (pdata2);

                  stat = asn1D_PurchaseDataType_priceInfo_price (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->price_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PurchaseDataType_priceInfo (OSCTXT* pctxt, 
   PurchaseDataType_priceInfo* pvalue, const OSUTF8CHAR* elemLName, 
   const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   if (elemLName != 0 && *elemLName != 0) {
      stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("SubscriptionUnit"), 16}, 0}, 0 },
      {{{OSUTF8("UnitText"), 8}, 0}, 1 },
      {{{OSUTF8("Price"), 5}, 0}, 2 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: { /* SubscriptionUnit */
         stat = XmlDec_PurchaseDataType_priceInfo_subscriptionUnit (pctxt, &
            pvalue->subscriptionUnit, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /* UnitText */
         stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->unitText);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 2: {
         PurchaseDataType_priceInfo_price* pdata1;
         do {
            pdata1
                = rtxMemAllocType (pctxt, PurchaseDataType_priceInfo_price);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PurchaseDataType_priceInfo_price (pdata1);

            stat = XmlDec_PurchaseDataType_priceInfo_price (pctxt, pdata1
               , OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->price_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseDataType_mediaInformation                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PurchaseDataType_mediaInformation (OSCTXT* pctxt,
   PurchaseDataType_mediaInformation *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode idRef */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->idRef, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode usage */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->usage, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PurchaseDataType_mediaInformation (OSCTXT* pctxt, 
   PurchaseDataType_mediaInformation* pvalue, const OSUTF8CHAR* elemLName, 
   const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("idRef"), 5}, 0 },
            { {OSUTF8("usage"), 5}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 2, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* idRef */
               stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->idRef);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            case 1: /* usage */
               stat = rtXmlpDecInt (pctxt, &pvalue->usage);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "PurchaseDataType_mediaInformation");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "PurchaseDataType_mediaInformation");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseDataType_promotionInfo                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PurchaseDataType_promotionInfo (OSCTXT* pctxt,
   PurchaseDataType_promotionInfo *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode validFrom */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->validFrom, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.validFromPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode validTo */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->validTo, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.validToPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode title */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->title, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode targetUserProfile */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            pvalue->targetUserProfile.u.binary = rtxMemAllocType (pctxt, OSOpenType);
            stat = xd_OpenType (pctxt, &pvalue->targetUserProfile.
               u.binary->data,
            &pvalue->targetUserProfile.u.binary->numocts);

            pvalue->targetUserProfile.t = OSXSDAny_binary;
            if (stat == 0) {
               pvalue->m.targetUserProfilePresent = TRUE;
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
         }
         break;

      case 5:
         /* decode description */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->description, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.descriptionPresent = TRUE;
            }
         }
         break;

      case 6:
         /* decode uRL */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->uRL, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.uRLPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PurchaseDataType_promotionInfo (OSCTXT* pctxt, 
   PurchaseDataType_promotionInfo* pvalue, const OSUTF8CHAR* elemLName, 
   const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("id"), 2}, 0 },
            { {OSUTF8("validFrom"), 9}, 0 },
            { {OSUTF8("validTo"), 7}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 3, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* id */
               stat = rtXmlpDecUInt (pctxt, &pvalue->id);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            case 1: /* validFrom */
               stat = rtXmlpDecUInt (pctxt, &pvalue->validFrom);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.validFromPresent = TRUE;
               break;

            case 2: /* validTo */
               stat = rtXmlpDecUInt (pctxt, &pvalue->validTo);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.validToPresent = TRUE;
               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "PurchaseDataType_promotionInfo");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "PurchaseDataType_promotionInfo");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Title"), 5}, 0}, 0 },
      {{{OSUTF8("Description"), 11}, 0}, 1 },
      {{{OSUTF8("URL"), 3}, 0}, 2 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 3, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: { /* Title */
         stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->title);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: { /*  */
         /* decode xsd:any element as XML text */stat = rtXmlpDecAny (pctxt, &
            pvalue->targetUserProfile.u.xmlText);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         pvalue->targetUserProfile.
         t = OSXSDAny_xmlText;

         pvalue->m.targetUserProfilePresent = TRUE;
         break;
      }
      case 2: { /* Description */
         stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->description);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.descriptionPresent = TRUE;
         break;
      }
      case 3: { /* URL */
         stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->uRL);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.uRLPresent = TRUE;
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseDataType                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PurchaseDataType (OSCTXT* pctxt,
   PurchaseDataType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode validFrom */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->validFrom, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.validFromPresent = TRUE;
            }
         }
         break;

      case 2:
         /* decode validTo */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->validTo, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.validToPresent = TRUE;
            }
         }
         break;

      case 3:
         /* decode version */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->version, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode extensionURL_list */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->extensionURL_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->extensionURL_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode description_list */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->description_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->description_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode purchaseItemIDRef */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->purchaseItemIDRef, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode purchaseChannelIDRef_list */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->purchaseChannelIDRef_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->purchaseChannelIDRef_list, pnode);
               }

               if (!(pvalue->purchaseChannelIDRef_list.count >= 1)) {
                  rtxErrAddStrParm (pctxt, "PurchaseDataType.purchaseChannelIDRef_list.count");
                  rtxErrAddIntParm (pctxt, (int)pvalue->purchaseChannelIDRef_list.count);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 8:
         /* decode priceInfo_list */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               PurchaseDataType_priceInfo* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->priceInfo_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, PurchaseDataType_priceInfo, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_PurchaseDataType_priceInfo (pdata2);

                  stat = asn1D_PurchaseDataType_priceInfo (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->priceInfo_list, pnode);
               }

               if (!(pvalue->priceInfo_list.count >= 1)) {
                  rtxErrAddStrParm (pctxt, "PurchaseDataType.priceInfo_list.count");
                  rtxErrAddIntParm (pctxt, (int)pvalue->priceInfo_list.count);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 9:
         /* decode mediaInformation_list */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               PurchaseDataType_mediaInformation* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->mediaInformation_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, PurchaseDataType_mediaInformation, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_PurchaseDataType_mediaInformation (pdata2);

                  stat = asn1D_PurchaseDataType_mediaInformation (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->mediaInformation_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 10:
         /* decode promotionInfo_list */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               PurchaseDataType_promotionInfo* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->promotionInfo_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, PurchaseDataType_promotionInfo, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_PurchaseDataType_promotionInfo (pdata2);

                  stat = asn1D_PurchaseDataType_promotionInfo (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->promotionInfo_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 9) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PurchaseDataType (OSCTXT* pctxt, PurchaseDataType* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("id"), 2}, 0 },
            { {OSUTF8("validFrom"), 9}, 0 },
            { {OSUTF8("validTo"), 7}, 0 },
            { {OSUTF8("version"), 7}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 4, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* id */
               stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            case 1: /* validFrom */
               stat = rtXmlpDecUInt (pctxt, &pvalue->validFrom);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.validFromPresent = TRUE;
               break;

            case 2: /* validTo */
               stat = rtXmlpDecUInt (pctxt, &pvalue->validTo);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.validToPresent = TRUE;
               break;

            case 3: /* version */
               stat = rtXmlpDecUInt (pctxt, &pvalue->version);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "PurchaseDataType");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "PurchaseDataType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("ExtensionURL"), 12}, 0}, 0 },
      {{{OSUTF8("Description"), 11}, 0}, 1 },
      {{{OSUTF8("PurchaseItemIDRef"), 17}, 0}, 2 },
      {{{OSUTF8("PurchaseChannelIDRef"), 20}, 0}, 3 },
      {{{OSUTF8("PriceInfo"), 9}, 0}, 4 },
      {{{OSUTF8("MediaInformation"), 16}, 0}, 5 },
      {{{OSUTF8("PromotionInfo"), 13}, 0}, 6 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 7, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->extensionURL_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 7, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 1: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->description_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 7, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 2: { /* PurchaseItemIDRef */
         stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->purchaseItemIDRef);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 3: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->purchaseChannelIDRef_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 7, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 3);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 4: {
         PurchaseDataType_priceInfo* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, PurchaseDataType_priceInfo);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PurchaseDataType_priceInfo (pdata1);

            stat = XmlDec_PurchaseDataType_priceInfo (pctxt, pdata1
               , OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->priceInfo_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 7, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 4);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 5: {
         PurchaseDataType_mediaInformation* pdata1;
         do {
            pdata1
                = rtxMemAllocType (pctxt, PurchaseDataType_mediaInformation);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PurchaseDataType_mediaInformation (pdata1);

            stat = XmlDec_PurchaseDataType_mediaInformation (pctxt, pdata1
               , OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->mediaInformation_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 7, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 5);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 6: {
         PurchaseDataType_promotionInfo* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, PurchaseDataType_promotionInfo);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PurchaseDataType_promotionInfo (pdata1);

            stat = XmlDec_PurchaseDataType_promotionInfo (pctxt, pdata1
               , OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->promotionInfo_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 7, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 6);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseChannelType_selector                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PurchaseChannelType_selector (OSCTXT* pctxt,
   PurchaseChannelType_selector *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->type, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PurchaseChannelType_selector (OSCTXT* pctxt, 
   PurchaseChannelType_selector* pvalue, const OSUTF8CHAR* elemLName, 
   const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("Type"), 4}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 1, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* Type */
               stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->type);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "PurchaseChannelType_selector");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "PurchaseChannelType_selector");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->base);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseChannelType_connection_purchaseURL                */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PurchaseChannelType_connection_purchaseURL (OSCTXT* pctxt,
   PurchaseChannelType_connection_purchaseURL *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode bearer */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_integer (pctxt, &pvalue->bearer, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode base */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->base, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PurchaseChannelType_connection_purchaseURL (OSCTXT* pctxt, 
   PurchaseChannelType_connection_purchaseURL* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("Bearer"), 6}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 1, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* Bearer */
               stat = rtXmlpDecInt (pctxt, &pvalue->bearer);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "PurchaseChannelType_connection_purchaseURL");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "PurchaseChannelType_connection_purchaseURL");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->base);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PurchaseChannelType                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_PurchaseChannelType (OSCTXT* pctxt,
   PurchaseChannelType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode rightsIssuerURI */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->rightsIssuerURI, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.rightsIssuerURIPresent = TRUE;
            }
         }
         break;

      case 1:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode localflag */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->localflag, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode validFrom */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->validFrom, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.validFromPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode validTo */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->validTo, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.validToPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode version */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->version, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode selector */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_PurchaseChannelType_selector (pctxt, 
               &pvalue->selector, ASN1IMPL, length);
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode extensionURL_list */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->extensionURL_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->extensionURL_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 8:
         /* decode name_list */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->name_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->name_list, pnode);
               }

               if (!(pvalue->name_list.count >= 1)) {
                  rtxErrAddStrParm (pctxt, "PurchaseChannelType.name_list.count");
                  rtxErrAddIntParm (pctxt, (int)pvalue->name_list.count);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 9:
         /* decode portalURL */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->portalURL, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.portalURLPresent = TRUE;
            }
         }
         break;

      case 10:
         /* decode description_list */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->description_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->description_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 11:
         /* decode connection_list */
         if (XD_PEEKTAG (pctxt, 0x8b)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               OSRTDList* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->connection_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  { int ilcnt = 0, length;
                  tagging = ASN1IMPL;
                  rtxDListAllocNodeAndData (pctxt, OSRTDList, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  rtxDListFastInit (pdata2);

                  /* decode inline SEQUENCE OF type */
                  {
                     int stat = 0;
                     PurchaseChannelType_connection_purchaseURL* pdata3;
                     OSRTDListNode* pnode;
                     ASN1CCB ccb;

                     if (XD_PEEKTAG (pctxt, 0x30)) {
                        stat = xd_Tag1AndLen (pctxt, &length);
                        if (stat != 0) return LOG_RTERR (pctxt, stat);
                     }
                     else return LOG_RTERR (pctxt,
                        berErrUnexpTag(pctxt, TM_UNIV|TM_CONS|16));

                     if (XD_PEEKTAG (pctxt, 0xa0)) {
                        stat = xd_Tag1AndLen (pctxt, &length);
                        if (stat != 0) return LOG_RTERR (pctxt, stat);
                     }
                     else return LOG_RTERR (pctxt,
                        berErrUnexpTag(pctxt, TM_CTXT|TM_CONS|0));

                     /* decode SEQUENCE OF or SET OF */

                     rtxDListInit (pdata2);

                     ccb.len = length;
                     ccb.ptr = OSRTBUFPTR(pctxt);

                     while (!XD_CHKEND (pctxt, &ccb))
                     {
                        rtxDListAllocNodeAndData (pctxt, PurchaseChannelType_connection_purchaseURL, &pnode, &pdata3);

                        if (pnode == NULL)
                           return LOG_RTERR (pctxt, RTERR_NOMEM);

                        asn1Init_PurchaseChannelType_connection_purchaseURL (pdata3);

                        stat = asn1D_PurchaseChannelType_connection_purchaseURL (pctxt, 
                           pdata3, ASN1EXPL, length);
                        if (stat != 0) return LOG_RTERR (pctxt, stat);

                        rtxDListAppendNode (pdata2, pnode);
                     }

                     if (!(pdata2->count >= 1)) {
                        rtxErrAddStrParm (pctxt, "<unknown>.count");
                        rtxErrAddIntParm (pctxt, (int)pdata2->count);
                        return LOG_RTERR (pctxt, RTERR_CONSVIO);
                     }

                  }
                  if (stat == 0) {
                  }
                  else return LOG_RTERR (pctxt, stat);

                  while (ilcnt-- > 0) {
                     if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                     else return LOG_RTERR (pctxt, ASN_E_INVLEN);
                  }}
                  rtxDListAppendNode (&pvalue->connection_list, pnode);
               }

               if (!(pvalue->connection_list.count >= 1)) {
                  rtxErrAddStrParm (pctxt, "PurchaseChannelType.connection_list.count");
                  rtxErrAddIntParm (pctxt, (int)pvalue->connection_list.count);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 12:
         /* decode contactInfo */
         if (XD_PEEKTAG (pctxt, 0x8c)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_utf8str (pctxt, &pvalue->contactInfo, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.contactInfoPresent = TRUE;
            }
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_PRIM|9):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_PRIM|12):
         case (TM_CTXT|TM_CONS|12):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 8) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_PurchaseChannelType (OSCTXT* pctxt, PurchaseChannelType* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("RightsIssuerURI"), 15}, 0 },
            { {OSUTF8("id"), 2}, 0 },
            { {OSUTF8("localflag"), 9}, 0 },
            { {OSUTF8("validFrom"), 9}, 0 },
            { {OSUTF8("validTo"), 7}, 0 },
            { {OSUTF8("version"), 7}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 6, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* RightsIssuerURI */
               stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->rightsIssuerURI);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.rightsIssuerURIPresent = TRUE;
               break;

            case 1: /* id */
               stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->id);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            case 2: /* localflag */
               stat = rtXmlpDecBool (pctxt, &pvalue->localflag);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            case 3: /* validFrom */
               stat = rtXmlpDecUInt (pctxt, &pvalue->validFrom);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.validFromPresent = TRUE;
               break;

            case 4: /* validTo */
               stat = rtXmlpDecUInt (pctxt, &pvalue->validTo);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.validToPresent = TRUE;
               break;

            case 5: /* version */
               stat = rtXmlpDecUInt (pctxt, &pvalue->version);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "PurchaseChannelType");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "PurchaseChannelType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Selector"), 8}, 0}, 0 },
      {{{OSUTF8("ExtensionURL"), 12}, 0}, 1 },
      {{{OSUTF8("Name"), 4}, 0}, 2 },
      {{{OSUTF8("PortalURL"), 9}, 0}, 3 },
      {{{OSUTF8("Description"), 11}, 0}, 4 },
      {{{OSUTF8("Connection"), 10}, 0}, 5 },
      {{{OSUTF8("ContactInfo"), 11}, 0}, 6 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 7, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: { /* Selector */
         stat = XmlDec_PurchaseChannelType_selector (pctxt, &pvalue->selector
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;
      }
      case 1: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->extensionURL_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 7, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 2: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->name_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 7, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 3: { /* PortalURL */
         stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->portalURL);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.portalURLPresent = TRUE;
         break;
      }
      case 4: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->description_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 7, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 4);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 5: {
         OSRTDList* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, OSRTDList);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pdata1);

            { int elemID;
            PurchaseChannelType_connection_purchaseURL* pdata2;

            static const OSXMLElemIDRec elemtab[] = {
               {{{OSUTF8("PurchaseURL"), 11}, 0}, 0 }
            } ;
            rtxDListInit (pdata1);
            for (;;) {
               elemID = rtXmlpGetNextElemID (pctxt, elemtab, 1, -1, FALSE);
               if (elemID < 0 || elemID == XML_OK_EOB) break;

               switch (elemID) {
               case 0: /* PurchaseURL */
                  pdata2
                      = rtxMemAllocType (pctxt, PurchaseChannelType_connection_purchaseURL);

                  if (pdata2 == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_PurchaseChannelType_connection_purchaseURL (pdata2
                     );

                  stat = XmlDec_PurchaseChannelType_connection_purchaseURL 
                     (pctxt, pdata2, OSUTF8(""), 0);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppend (pctxt, pdata1, (void*)pdata2);
                  break;

               }
            }

            if (elemID == RTERR_UNEXPELEM || elemID == XML_OK_EOB) {
               stat = 0;
            }
            else return LOG_RTERR (pctxt, elemID);
            }

            stat = rtXmlpMatchEndTag (pctxt, -1);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
            rtxDListAppend (pctxt, &pvalue->connection_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 7, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 5);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 6: { /* ContactInfo */
         stat = rtXmlpDecDynUTF8Str (pctxt, &pvalue->contactInfo);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         pvalue->m.contactInfoPresent = TRUE;
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ScheduleReferenceType                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ScheduleReferenceType (OSCTXT* pctxt,
   ScheduleReferenceType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode idRef */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_ScheduleIDType (pctxt, 
               &pvalue->idRef, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode presentationWindowID_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               int count;
               int xx2;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               stat = xd_count (pctxt, length, &count);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->presentationWindowID_list.n = count;
               ALLOC_ASN1ARRAY (pctxt, &pvalue->presentationWindowID_list, OSINT32);

               xx2 = 0;
               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  stat = xd_integer (pctxt, &pvalue->presentationWindowID_list.elem[xx2], ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  xx2++;
               }
               pvalue->presentationWindowID_list.n = xx2;

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_ScheduleReferenceType (OSCTXT* pctxt, 
   ScheduleReferenceType* pvalue, const OSUTF8CHAR* elemLName, 
   const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("idRef"), 5}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 1, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* idRef */
               stat = XmlDec_ScheduleIDType (pctxt, &pvalue->idRef
                  , OSUTF8(""), 0);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "ScheduleReferenceType");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "ScheduleReferenceType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("PresentationWindowID"), 20}, 0}, 0 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 1, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: {
         OSRTDList tmplist;
         OSINT32* pdata1;
         rtxDListInit (&tmplist);
         do {
            pdata1 = rtxMemAllocTypeZ (pctxt, OSINT32);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            stat = rtXmlpDecInt (pctxt, pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &tmplist, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 1, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;

         /* Convert list to array */
         { OSUINT32 i = 0;
         OSRTDListNode* pnode = tmplist.head;
         pvalue->presentationWindowID_list.n = tmplist.count;
         pvalue->presentationWindowID_list.elem =
            rtxMemAllocArray (pctxt, tmplist.count, OSINT32);
         while (0 != pnode) {
            pdata1 = (OSINT32*)pnode->data;
            pvalue->presentationWindowID_list.elem[i++] = *pdata1;
            pnode = pnode->next;
         }}
         rtxDListFreeAll (pctxt, &tmplist);
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InteractivityWindowType                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_InteractivityWindowType (OSCTXT* pctxt,
   InteractivityWindowType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode interactivityWindowEndTime */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_RelativeDateType (pctxt, 
               &pvalue->interactivityWindowEndTime, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode interactivityWindowStartTime */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_RelativeDateType (pctxt, 
               &pvalue->interactivityWindowStartTime, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_InteractivityWindowType (OSCTXT* pctxt, 
   InteractivityWindowType* pvalue, const OSUTF8CHAR* elemLName, 
   const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("InteractivityWindowEndTime"), 26}, 0 },
            { {OSUTF8("InteractivityWindowStartTime"), 28}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 2, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* InteractivityWindowEndTime */
               stat = XmlDec_RelativeDateType (pctxt, &pvalue->
                  interactivityWindowEndTime, OSUTF8(""), 0);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            case 1: /* InteractivityWindowStartTime */
               stat = XmlDec_RelativeDateType (pctxt, &pvalue->
                  interactivityWindowStartTime, OSUTF8(""), 0);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "InteractivityWindowType");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "InteractivityWindowType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  InteractivityDataType                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_InteractivityDataType (OSCTXT* pctxt,
   InteractivityDataType *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode interactivityMediaDocumentPointer */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_InteractivityMediaIDType (pctxt, 
               &pvalue->interactivityMediaDocumentPointer, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode prelistenIndicator */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_boolean (pctxt, &pvalue->prelistenIndicator, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode id */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = asn1D_InteractivityDataIDType (pctxt, 
               &pvalue->id, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode validFrom */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->validFrom, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.validFromPresent = TRUE;
            }
         }
         break;

      case 4:
         /* decode validTo */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->validTo, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.validToPresent = TRUE;
            }
         }
         break;

      case 5:
         /* decode version */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            stat = xd_unsigned (pctxt, &pvalue->version, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode serviceIDRed_list */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               ServiceIDType pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->serviceIDRed_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = asn1D_ServiceIDType (pctxt, 
                     &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->serviceIDRed_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode contentIDRef_list */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               ContentIDType pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->contentIDRef_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = asn1D_ContentIDType (pctxt, 
                     &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->contentIDRef_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 8:
         /* decode scheduleReference_list */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               ScheduleReferenceType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->scheduleReference_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, ScheduleReferenceType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_ScheduleReferenceType (pdata2);

                  stat = asn1D_ScheduleReferenceType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->scheduleReference_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 9:
         /* decode interactivityWindow_list */
         if (XD_PEEKTAG (pctxt, 0x89)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               InteractivityWindowType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->interactivityWindow_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, InteractivityWindowType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_InteractivityWindowType (pdata2);

                  stat = asn1D_InteractivityWindowType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->interactivityWindow_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 10:
         /* decode extensionURL_list */
         if (XD_PEEKTAG (pctxt, 0x8a)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               const OSUTF8CHAR* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->extensionURL_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  stat = xd_utf8str (pctxt, &pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  pnode->data = (void*)pdata2;
                  rtxDListAppendNode (&pvalue->extensionURL_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 9) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_InteractivityDataType (OSCTXT* pctxt, 
   InteractivityDataType* pvalue, const OSUTF8CHAR* elemLName, 
   const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   memset (&pvalue->m, 0, sizeof(pvalue->m));

   if (elemLName != 0) {
      if (*elemLName != 0) {
         stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
         if (stat < 0) return LOG_RTERR (pctxt, stat);
      }

      /* decode attributes */
      if (rtXmlpHasAttributes (pctxt)) {
         static const OSXMLAttrDescr attrNames[] = {
            { {OSUTF8("InteractivityMediaDocumentPointer"), 33}, 0 },
            { {OSUTF8("PrelistenIndicator"), 18}, 0 },
            { {OSUTF8("id"), 2}, 0 },
            { {OSUTF8("validFrom"), 9}, 0 },
            { {OSUTF8("validTo"), 7}, 0 },
            { {OSUTF8("version"), 7}, 0 }
         } ;
         OSUINT32 attrPresent[1];
         size_t i, nAttrs = rtXmlpGetAttributeCount (pctxt);
         OSXMLNameFragments attrName;
         int tabidx;

         memset (attrPresent, 0, sizeof(attrPresent));

         for (i = 0; i < nAttrs; i++) {
            if (rtXmlpSelectAttribute (pctxt, &attrName, i) != 0) continue;
            tabidx = rtXmlpGetAttributeID (pctxt, 
               &attrName.mLocalName, 6, attrNames, attrPresent);

            switch (tabidx) {
            case 0: /* InteractivityMediaDocumentPointer */
               stat = XmlDec_InteractivityMediaIDType (pctxt, &pvalue->
                  interactivityMediaDocumentPointer, OSUTF8(""), 0);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            case 1: /* PrelistenIndicator */
               stat = rtXmlpDecBool (pctxt, &pvalue->prelistenIndicator);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            case 2: /* id */
               stat = XmlDec_InteractivityDataIDType (pctxt, &pvalue->id
                  , OSUTF8(""), 0);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            case 3: /* validFrom */
               stat = rtXmlpDecUInt (pctxt, &pvalue->validFrom);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.validFromPresent = TRUE;
               break;

            case 4: /* validTo */
               stat = rtXmlpDecUInt (pctxt, &pvalue->validTo);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               pvalue->m.validToPresent = TRUE;
               break;

            case 5: /* version */
               stat = rtXmlpDecUInt (pctxt, &pvalue->version);
               if (stat != 0) return LOG_RTERR (pctxt, stat);

               break;

            default:
               stat = rtXmlpDecXSIAttr (pctxt, &attrName);
               if (stat != 0) {
                  rtxErrAddStrParm (pctxt, "InteractivityDataType");
                  rtxErrAddStrnParm (pctxt, 
                     (const char*)attrName.mQName.value, 
                     attrName.mQName.length);
                  LOG_RTERRNEW (pctxt, RTERR_INVATTR);
                  stat = 0;
               }
            }
            if (stat < 0) {
               rtxErrAddStrParm (pctxt, "InteractivityDataType");
               rtxErrAddStrnParm (pctxt, (const char*)attrName.mQName.value, 
                  attrName.mQName.length);
               LOG_RTERRNEW (pctxt, RTERR_DECATTRFAIL);
               stat = 0;
            }
         }
      }
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("ServiceIDRed"), 12}, 0}, 0 },
      {{{OSUTF8("ContentIDRef"), 12}, 0}, 1 },
      {{{OSUTF8("ScheduleReference"), 17}, 0}, 2 },
      {{{OSUTF8("InteractivityWindow"), 19}, 0}, 3 },
      {{{OSUTF8("ExtensionURL"), 12}, 0}, 4 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 5, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: {
         ServiceIDType pdata1;
         do {
            stat = XmlDec_ServiceIDType (pctxt, &pdata1, OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->serviceIDRed_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 5, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 1: {
         ContentIDType pdata1;
         do {
            stat = XmlDec_ContentIDType (pctxt, &pdata1, OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->contentIDRef_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 5, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 2: {
         ScheduleReferenceType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, ScheduleReferenceType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ScheduleReferenceType (pdata1);

            stat = XmlDec_ScheduleReferenceType (pctxt, pdata1
               , OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->scheduleReference_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 5, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 3: {
         InteractivityWindowType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, InteractivityWindowType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InteractivityWindowType (pdata1);

            stat = XmlDec_InteractivityWindowType (pctxt, pdata1
               , OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->interactivityWindow_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 5, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 3);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 4: {
         const OSUTF8CHAR* pdata1;
         do {
            stat = rtXmlpDecDynUTF8Str (pctxt, &pdata1);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->extensionURL_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 5, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 4);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ESGMainBCAST                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1D_ESGMainBCAST (OSCTXT* pctxt,
   ESGMainBCAST *pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode service_list */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               ServiceType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->service_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, ServiceType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_ServiceType (pdata2);

                  stat = asn1D_ServiceType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->service_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 1:
         /* decode schedule_list */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               ScheduleType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->schedule_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, ScheduleType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_ScheduleType (pdata2);

                  stat = asn1D_ScheduleType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->schedule_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 2:
         /* decode content_list */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               ContentType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->content_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, ContentType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_ContentType (pdata2);

                  stat = asn1D_ContentType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->content_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 3:
         /* decode access_list */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               AccessType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->access_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, AccessType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_AccessType (pdata2);

                  stat = asn1D_AccessType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->access_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 4:
         /* decode previewData_list */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               PreviewDataType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->previewData_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, PreviewDataType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_PreviewDataType (pdata2);

                  stat = asn1D_PreviewDataType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->previewData_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 5:
         /* decode purchaseItem_list */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               PurchaseItemType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->purchaseItem_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, PurchaseItemType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_PurchaseItemType (pdata2);

                  stat = asn1D_PurchaseItemType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->purchaseItem_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 6:
         /* decode purchaseData_list */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               PurchaseDataType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->purchaseData_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, PurchaseDataType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_PurchaseDataType (pdata2);

                  stat = asn1D_PurchaseDataType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->purchaseData_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 7:
         /* decode purchaseChannel_list */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               PurchaseChannelType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->purchaseChannel_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, PurchaseChannelType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_PurchaseChannelType (pdata2);

                  stat = asn1D_PurchaseChannelType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->purchaseChannel_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      case 8:
         /* decode interactivityData_list */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            /* decode inline SEQUENCE OF type */
            {
               int stat = 0;
               InteractivityDataType* pdata2;
               OSRTDListNode* pnode;
               ASN1CCB ccb;

               /* decode SEQUENCE OF or SET OF */

               rtxDListInit (&pvalue->interactivityData_list);

               ccb.len = length;
               ccb.ptr = OSRTBUFPTR(pctxt);

               while (!XD_CHKEND (pctxt, &ccb))
               {
                  rtxDListAllocNodeAndData (pctxt, InteractivityDataType, &pnode, &pdata2);

                  if (pnode == NULL)
                     return LOG_RTERR (pctxt, RTERR_NOMEM);

                  asn1Init_InteractivityDataType (pdata2);

                  stat = asn1D_InteractivityDataType (pctxt, 
                     pdata2, ASN1EXPL, length);
                  if (stat != 0) return LOG_RTERR (pctxt, stat);

                  rtxDListAppendNode (&pvalue->interactivityData_list, pnode);
               }

            }
            if (stat == 0) {
               if (length == ASN_K_INDEFLEN) {
                  if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
                  else return LOG_RTERR (pctxt, ASN_E_INVLEN);
               }
            }
            else return LOG_RTERR (pctxt, stat);

            reqcnt++;
         }
         break;

      default:
         { ASN1TAG tag;
         int len;
         stat = xd_tag_len (pctxt, &tag, &len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
            stat = RTERR_SEQORDER;
            break;
         default:
            stat = RTERR_SEQOVFLW;
            break;
         }}
      }

      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 9) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   if (tagging == ASN1EXPL && ccb.len == ASN_K_INDEFLEN) {
      if (XD_MATCHEOC (pctxt)) XD_BUMPIDX (pctxt, 2);
      else return LOG_RTERR (pctxt, ASN_E_INVLEN);
   }
   return (stat);
}

int XmlDec_ESGMainBCAST (OSCTXT* pctxt, ESGMainBCAST* pvalue, 
   const OSUTF8CHAR* elemLName, const OSUTF8CHAR* elemURI)
{
   int stat = 0;

   if (elemLName != 0 && *elemLName != 0) {
      stat = rtXmlpMatchStartTag (pctxt, elemLName, elemURI);
      if (stat < 0) return LOG_RTERR (pctxt, stat);
   }

   { int elemID;

   static const OSXMLElemIDRec elemtab[] = {
      {{{OSUTF8("Service"), 7}, 0}, 0 },
      {{{OSUTF8("Schedule"), 8}, 0}, 1 },
      {{{OSUTF8("Content"), 7}, 0}, 2 },
      {{{OSUTF8("Access"), 6}, 0}, 3 },
      {{{OSUTF8("PreviewData"), 11}, 0}, 4 },
      {{{OSUTF8("PurchaseItem"), 12}, 0}, 5 },
      {{{OSUTF8("PurchaseData"), 12}, 0}, 6 },
      {{{OSUTF8("PurchaseChannel"), 15}, 0}, 7 },
      {{{OSUTF8("InteractivityData"), 17}, 0}, 8 }
   } ;
   for (;;) {
      elemID = rtXmlpGetNextElemID (pctxt, elemtab, 9, -1, TRUE);
      if (elemID < 0) return LOG_RTERR (pctxt, elemID);
      else if (elemID == XML_OK_EOB) break;

      switch (elemID) {
      case 0: {
         ServiceType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, ServiceType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ServiceType (pdata1);

            stat = XmlDec_ServiceType (pctxt, pdata1, OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->service_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 9, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 0);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 1: {
         ScheduleType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, ScheduleType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ScheduleType (pdata1);

            stat = XmlDec_ScheduleType (pctxt, pdata1, OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->schedule_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 9, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 1);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 2: {
         ContentType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, ContentType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ContentType (pdata1);

            stat = XmlDec_ContentType (pctxt, pdata1, OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->content_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 9, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 2);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 3: {
         AccessType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, AccessType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_AccessType (pdata1);

            stat = XmlDec_AccessType (pctxt, pdata1, OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->access_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 9, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 3);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 4: {
         PreviewDataType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, PreviewDataType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PreviewDataType (pdata1);

            stat = XmlDec_PreviewDataType (pctxt, pdata1, OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->previewData_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 9, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 4);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 5: {
         PurchaseItemType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, PurchaseItemType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PurchaseItemType (pdata1);

            stat = XmlDec_PurchaseItemType (pctxt, pdata1, OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->purchaseItem_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 9, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 5);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 6: {
         PurchaseDataType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, PurchaseDataType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PurchaseDataType (pdata1);

            stat = XmlDec_PurchaseDataType (pctxt, pdata1, OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->purchaseData_list, (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 9, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 6);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 7: {
         PurchaseChannelType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, PurchaseChannelType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PurchaseChannelType (pdata1);

            stat = XmlDec_PurchaseChannelType (pctxt, pdata1, OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->purchaseChannel_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 9, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 7);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      case 8: {
         InteractivityDataType* pdata1;
         do {
            pdata1 = rtxMemAllocType (pctxt, InteractivityDataType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_InteractivityDataType (pdata1);

            stat = XmlDec_InteractivityDataType (pctxt, pdata1
               , OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            rtxDListAppend (pctxt, &pvalue->interactivityData_list
               , (void*)pdata1);

            stat = rtXmlpGetNextElemID (pctxt, elemtab, 9, -1, TRUE);
            if (stat < 0) return LOG_RTERR (pctxt, stat);
         }
         while (stat == 8);

         rtXmlpMarkLastEventActive (pctxt);
         stat = 0;
         break;
      }
      }
   }
   }

   stat = rtXmlpMatchEndTag (pctxt, -1);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlDec_ESGMainBCAST_PDU (OSCTXT* pctxt, ESGMainBCAST* pvalue)
{
   int stat;

   rtXmlpCreateReader (pctxt);

   asn1Init_ESGMainBCAST (pvalue);

   stat = XmlDec_ESGMainBCAST (pctxt, pvalue, OSUTF8("ESGMainBCAST"), 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
