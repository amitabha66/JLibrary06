/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 18-Oct-2006.
 */
#include "Xmldsig.h"
#include "libxml/parser.h"
#include "rtxmlsrc/osrtxml.h"
#include "rtxsrc/rtxCommon.h"

int DOMTest_CanonicalizationMethodType (OSCTXT* pctxt, 
   CanonicalizationMethodType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Algorithm"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->algorithm = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->algorithm = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         { OSXSDAny* pdata2;
         pdata2 = rtxMemAllocTypeZ (pctxt, OSXSDAny);

         if (pdata2 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         if (0 != pXmlNode->children) {
            pdata2->t = OSXSDAny_xmlText;
            pdata2->u.xmlText = pXmlNode->children->content;
         }
         if (0 != pdata2)
            rtxDListAppend (pctxt, &pvalue->elem_list, (void*)pdata2);
         }
      }
   }

   return 0;
}

int DOMTest_CanonicalizationMethod (OSCTXT* pctxt, 
   CanonicalizationMethod* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_CanonicalizationMethodType (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_SignatureMethodType (OSCTXT* pctxt, SignatureMethodType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Algorithm"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->algorithm = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->algorithm = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("HMACOutputLength"))) {
            pvalue->m.hMACOutputLengthPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->hMACOutputLength = atoi ((const char*)pXmlNode->children->content);
            }
         }
         { OSXSDAny* pdata2;
         pdata2 = rtxMemAllocTypeZ (pctxt, OSXSDAny);

         if (pdata2 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         if (0 != pXmlNode->children) {
            pdata2->t = OSXSDAny_xmlText;
            pdata2->u.xmlText = pXmlNode->children->content;
         }
         if (0 != pdata2)
            rtxDListAppend (pctxt, &pvalue->elem_list, (void*)pdata2);
         }
      }
   }

   return 0;
}

int DOMTest_SignatureMethod (OSCTXT* pctxt, SignatureMethod* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_SignatureMethodType (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_TransformType_element (OSCTXT* pctxt, 
   TransformType_element* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("XPath"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               pvalue->u.xPath = pXmlNode->children->content;
            }
            else {
               pvalue->u.xPath = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else {
            printf ("TODO: add logic to populate xsd:any element\n");
         }
      }
   }

   return 0;
}

int DOMTest_TransformType (OSCTXT* pctxt, TransformType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Algorithm"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->algorithm = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->algorithm = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("XPath"))) {
            { TransformType_element* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TransformType_element);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TransformType_element (pdata2);
            DOMTest_TransformType_element (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_Transform (OSCTXT* pctxt, Transform* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_TransformType (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_TransformsType (OSCTXT* pctxt, TransformsType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Transform"))) {
            { Transform* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Transform);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Transform (pdata2);
            DOMTest_Transform (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->transform_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_Transforms (OSCTXT* pctxt, Transforms* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_TransformsType (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_DigestMethodType (OSCTXT* pctxt, DigestMethodType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Algorithm"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->algorithm = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->algorithm = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         { OSXSDAny* pdata2;
         pdata2 = rtxMemAllocTypeZ (pctxt, OSXSDAny);

         if (pdata2 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         if (0 != pXmlNode->children) {
            pdata2->t = OSXSDAny_xmlText;
            pdata2->u.xmlText = pXmlNode->children->content;
         }
         if (0 != pdata2)
            rtxDListAppend (pctxt, &pvalue->elem_list, (void*)pdata2);
         }
      }
   }

   return 0;
}

int DOMTest_DigestMethod (OSCTXT* pctxt, DigestMethod* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_DigestMethodType (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_ReferenceType (OSCTXT* pctxt, ReferenceType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Type"))) {
            pvalue->m.typePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->type = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->type = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("URI"))) {
            pvalue->m.uRIPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->uRI = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->uRI = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Transforms"))) {
            pvalue->m.transformsPresent = 1;
            DOMTest_Transforms (pctxt, &pvalue->transforms, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("DigestMethod"))) {
            DOMTest_DigestMethod (pctxt, &pvalue->digestMethod, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("DigestValue"))) {
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecDynBase64Str (pctxt, &pvalue->digestValue);
            }
         }
      }
   }

   return 0;
}

int DOMTest_Reference (OSCTXT* pctxt, Reference* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_ReferenceType (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_SignedInfoType (OSCTXT* pctxt, SignedInfoType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("CanonicalizationMethod"))) {
            DOMTest_CanonicalizationMethod (pctxt, &pvalue->canonicalizationMethod, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SignatureMethod"))) {
            DOMTest_SignatureMethod (pctxt, &pvalue->signatureMethod, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Reference"))) {
            { Reference* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Reference);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Reference (pdata2);
            DOMTest_Reference (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->reference_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_SignedInfo (OSCTXT* pctxt, SignedInfo* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_SignedInfoType (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_SignatureValueType (OSCTXT* pctxt, SignatureValueType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      OSUTF8CHAR* pcontent = pXmlNode->children->content;
      rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
      rtXmlDecDynBase64Str (pctxt, &pvalue->base);
   }

   return 0;
}

int DOMTest_SignatureValue (OSCTXT* pctxt, SignatureValue* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_SignatureValueType (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_KeyValueType_embed_values (OSCTXT* pctxt, 
   KeyValueType_embed_values* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* pdata1 = 0;
   if (0 != pXmlNode->children) {
      pdata1 = pXmlNode->children->content;
   }
   else {
      pdata1 = (const OSUTF8CHAR*)"";
   }
   if (0 != pdata1)
      rtxDListAppend (pctxt, pvalue, (void*)pdata1);

   return 0;
}

int DOMTest_DSAKeyValueType_sequence (OSCTXT* pctxt, 
   DSAKeyValueType_sequence* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("P"))) {
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecDynBase64Str (pctxt, &pvalue->p);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Q"))) {
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecDynBase64Str (pctxt, &pvalue->q);
            }
         }
      }
   }

   return 0;
}

int DOMTest_DSAKeyValueType_sequence_1 (OSCTXT* pctxt, 
   DSAKeyValueType_sequence_1* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Seed"))) {
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecDynBase64Str (pctxt, &pvalue->seed);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PgenCounter"))) {
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecDynBase64Str (pctxt, &pvalue->pgenCounter);
            }
         }
      }
   }

   return 0;
}

int DOMTest_DSAKeyValueType (OSCTXT* pctxt, DSAKeyValueType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("P"))) {
            pvalue->m.sequencePresent = 1;
            DOMTest_DSAKeyValueType_sequence (pctxt, &pvalue->sequence, pXmlNode, FALSE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("G"))) {
            pvalue->m.gPresent = 1;
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecDynBase64Str (pctxt, &pvalue->g);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Y"))) {
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecDynBase64Str (pctxt, &pvalue->y);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("J"))) {
            pvalue->m.jPresent = 1;
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecDynBase64Str (pctxt, &pvalue->j);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Seed"))) {
            pvalue->m.sequence_1Present = 1;
            DOMTest_DSAKeyValueType_sequence_1 (pctxt, &pvalue->sequence_1, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_DSAKeyValue (OSCTXT* pctxt, DSAKeyValue* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_DSAKeyValueType (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_RSAKeyValueType (OSCTXT* pctxt, RSAKeyValueType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Modulus"))) {
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecDynBase64Str (pctxt, &pvalue->modulus);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Exponent"))) {
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecDynBase64Str (pctxt, &pvalue->exponent);
            }
         }
      }
   }

   return 0;
}

int DOMTest_RSAKeyValue (OSCTXT* pctxt, RSAKeyValue* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_RSAKeyValueType (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_KeyValueType_choice (OSCTXT* pctxt, KeyValueType_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("DSAKeyValue"))) {
            pvalue->t = 1;
            pvalue->u.dSAKeyValue = rtxMemAllocType (pctxt, DSAKeyValue);

            if (pvalue->u.dSAKeyValue == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_DSAKeyValue (pvalue->u.dSAKeyValue);
            DOMTest_DSAKeyValue (pctxt, pvalue->u.dSAKeyValue, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("RSAKeyValue"))) {
            pvalue->t = 2;
            pvalue->u.rSAKeyValue = rtxMemAllocType (pctxt, RSAKeyValue);

            if (pvalue->u.rSAKeyValue == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RSAKeyValue (pvalue->u.rSAKeyValue);
            DOMTest_RSAKeyValue (pctxt, pvalue->u.rSAKeyValue, pXmlNode, TRUE);
            break;
         }
         else {
            printf ("TODO: add logic to populate xsd:any element\n");
         }
      }
   }

   return 0;
}

int DOMTest_KeyValueType (OSCTXT* pctxt, KeyValueType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("DSAKeyValue")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("RSAKeyValue"))) {
            DOMTest_KeyValueType_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_KeyValue (OSCTXT* pctxt, KeyValue* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_KeyValueType (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_RetrievalMethodType (OSCTXT* pctxt, RetrievalMethodType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Type"))) {
            pvalue->m.typePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->type = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->type = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("URI"))) {
            pvalue->m.uRIPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->uRI = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->uRI = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Transforms"))) {
            pvalue->m.transformsPresent = 1;
            DOMTest_Transforms (pctxt, &pvalue->transforms, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_RetrievalMethod (OSCTXT* pctxt, RetrievalMethod* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_RetrievalMethodType (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_X509IssuerSerialType (OSCTXT* pctxt, X509IssuerSerialType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("X509IssuerName"))) {
            if (0 != pXmlNode->children) {
               pvalue->x509IssuerName = pXmlNode->children->content;
            }
            else {
               pvalue->x509IssuerName = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("X509SerialNumber"))) {
            if (0 != pXmlNode->children) {
               pvalue->x509SerialNumber = atoi ((const char*)pXmlNode->children->content);
            }
         }
      }
   }

   return 0;
}

int DOMTest_X509DataType__choice1 (OSCTXT* pctxt, 
   X509DataType__choice1* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("X509IssuerSerial"))) {
            pvalue->t = 1;
            pvalue->u.x509IssuerSerial
                = rtxMemAllocType (pctxt, X509IssuerSerialType);

            if (pvalue->u.x509IssuerSerial == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_X509IssuerSerialType (pvalue->u.x509IssuerSerial);
            DOMTest_X509IssuerSerialType (pctxt, pvalue->u.x509IssuerSerial, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("X509SKI"))) {
            pvalue->t = 2;
            pvalue->u.x509SKI = rtxMemAllocType (pctxt, ASN1DynOctStr);

            if (pvalue->u.x509SKI == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            pvalue->u.x509SKI->numocts = 0;
            pvalue->u.x509SKI->data = 0;
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecDynBase64Str (pctxt, pvalue->u.x509SKI);
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("X509SubjectName"))) {
            pvalue->t = 3;
            if (0 != pXmlNode->children) {
               pvalue->u.x509SubjectName = pXmlNode->children->content;
            }
            else {
               pvalue->u.x509SubjectName = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("X509Certificate"))) {
            pvalue->t = 4;
            pvalue->u.x509Certificate
                = rtxMemAllocType (pctxt, ASN1DynOctStr);

            if (pvalue->u.x509Certificate == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            pvalue->u.x509Certificate->numocts = 0;
            pvalue->u.x509Certificate->data = 0;
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecDynBase64Str (pctxt, pvalue->u.x509Certificate);
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("X509CRL"))) {
            pvalue->t = 5;
            pvalue->u.x509CRL = rtxMemAllocType (pctxt, ASN1DynOctStr);

            if (pvalue->u.x509CRL == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            pvalue->u.x509CRL->numocts = 0;
            pvalue->u.x509CRL->data = 0;
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecDynBase64Str (pctxt, pvalue->u.x509CRL);
            }
            break;
         }
         else {
            printf ("TODO: add logic to populate xsd:any element\n");
         }
      }
   }

   return 0;
}

int DOMTest_X509DataType (OSCTXT* pctxt, X509DataType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   X509DataType__choice1* pdata1;
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("_choice1"))) {
            pdata1 = rtxMemAllocType (pctxt, X509DataType__choice1);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_X509DataType__choice1 (pdata1);
            DOMTest_X509DataType__choice1 (pctxt, pdata1, pXmlNode, TRUE);
            if (0 != pdata1)
               rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         }
      }
   }

   return 0;
}

int DOMTest_X509Data (OSCTXT* pctxt, X509Data* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_X509DataType (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_PGPDataType_sequence (OSCTXT* pctxt, PGPDataType_sequence* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PGPKeyID"))) {
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecDynBase64Str (pctxt, &pvalue->pGPKeyID);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PGPKeyPacket"))) {
            pvalue->m.pGPKeyPacketPresent = 1;
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecDynBase64Str (pctxt, &pvalue->pGPKeyPacket);
            }
         }
         { OSXSDAny* pdata2;
         pdata2 = rtxMemAllocTypeZ (pctxt, OSXSDAny);

         if (pdata2 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         if (0 != pXmlNode->children) {
            pdata2->t = OSXSDAny_xmlText;
            pdata2->u.xmlText = pXmlNode->children->content;
         }
         if (0 != pdata2)
            rtxDListAppend (pctxt, &pvalue->elem_list, (void*)pdata2);
         }
      }
   }

   return 0;
}

int DOMTest_PGPDataType_sequence_1 (OSCTXT* pctxt, 
   PGPDataType_sequence_1* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PGPKeyPacket"))) {
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecDynBase64Str (pctxt, &pvalue->pGPKeyPacket);
            }
         }
         { OSXSDAny* pdata2;
         pdata2 = rtxMemAllocTypeZ (pctxt, OSXSDAny);

         if (pdata2 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         if (0 != pXmlNode->children) {
            pdata2->t = OSXSDAny_xmlText;
            pdata2->u.xmlText = pXmlNode->children->content;
         }
         if (0 != pdata2)
            rtxDListAppend (pctxt, &pvalue->elem_list, (void*)pdata2);
         }
      }
   }

   return 0;
}

int DOMTest_PGPDataType (OSCTXT* pctxt, PGPDataType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PGPKeyID"))) {
            pvalue->t = 1;
            pvalue->u.sequence
                = rtxMemAllocType (pctxt, PGPDataType_sequence);

            if (pvalue->u.sequence == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PGPDataType_sequence (pvalue->u.sequence);
            DOMTest_PGPDataType_sequence (pctxt, pvalue->u.sequence, pXmlNode, FALSE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PGPKeyPacket"))) {
            pvalue->t = 2;
            pvalue->u.sequence_1
                = rtxMemAllocType (pctxt, PGPDataType_sequence_1);

            if (pvalue->u.sequence_1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PGPDataType_sequence_1 (pvalue->u.sequence_1);
            DOMTest_PGPDataType_sequence_1 (pctxt, pvalue->u.sequence_1, pXmlNode, FALSE);
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_PGPData (OSCTXT* pctxt, PGPData* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_PGPDataType (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_SPKIDataType_element (OSCTXT* pctxt, SPKIDataType_element* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SPKISexp"))) {
            if (0 != pXmlNode->children) {
               OSUTF8CHAR* pcontent = pXmlNode->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecDynBase64Str (pctxt, &pvalue->sPKISexp);
            }
         }
         pvalue->m.elemPresent = 1;
         if (0 != pXmlNode->children) {
            pvalue->elem.t = OSXSDAny_xmlText;
            pvalue->elem.u.xmlText = pXmlNode->children->content;
         }
      }
   }

   return 0;
}

int DOMTest_SPKIDataType (OSCTXT* pctxt, SPKIDataType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   SPKIDataType_element* pdata1 = rtxMemAllocTypeZ (pctxt, SPKIDataType_element);
   DOMTest_SPKIDataType_element (pctxt, pdata1, pXmlNode, setChild);
   if (0 != pdata1)
      rtxDListAppend (pctxt, pvalue, (void*)pdata1);

   return 0;
}

int DOMTest_SPKIData (OSCTXT* pctxt, SPKIData* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_SPKIDataType (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_KeyInfoType_element (OSCTXT* pctxt, KeyInfoType_element* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("KeyName"))) {
            pvalue->t = 1;
            if (0 != pXmlNode->children) {
               pvalue->u.keyName = pXmlNode->children->content;
            }
            else {
               pvalue->u.keyName = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("KeyValue"))) {
            pvalue->t = 2;
            pvalue->u.keyValue = rtxMemAllocType (pctxt, KeyValue);

            if (pvalue->u.keyValue == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_KeyValue (pvalue->u.keyValue);
            DOMTest_KeyValue (pctxt, pvalue->u.keyValue, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("RetrievalMethod"))) {
            pvalue->t = 3;
            pvalue->u.retrievalMethod
                = rtxMemAllocType (pctxt, RetrievalMethod);

            if (pvalue->u.retrievalMethod == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_RetrievalMethod (pvalue->u.retrievalMethod);
            DOMTest_RetrievalMethod (pctxt, pvalue->u.retrievalMethod, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("X509Data"))) {
            pvalue->t = 4;
            pvalue->u.x509Data = rtxMemAllocType (pctxt, X509Data);

            if (pvalue->u.x509Data == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_X509Data (pvalue->u.x509Data);
            DOMTest_X509Data (pctxt, pvalue->u.x509Data, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PGPData"))) {
            pvalue->t = 5;
            pvalue->u.pGPData = rtxMemAllocType (pctxt, PGPData);

            if (pvalue->u.pGPData == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_PGPData (pvalue->u.pGPData);
            DOMTest_PGPData (pctxt, pvalue->u.pGPData, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SPKIData"))) {
            pvalue->t = 6;
            pvalue->u.sPKIData = rtxMemAllocType (pctxt, SPKIData);

            if (pvalue->u.sPKIData == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SPKIData (pvalue->u.sPKIData);
            DOMTest_SPKIData (pctxt, pvalue->u.sPKIData, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MgmtData"))) {
            pvalue->t = 7;
            if (0 != pXmlNode->children) {
               pvalue->u.mgmtData = pXmlNode->children->content;
            }
            else {
               pvalue->u.mgmtData = (const OSUTF8CHAR*)"";
            }
            break;
         }
         else {
            printf ("TODO: add logic to populate xsd:any element\n");
         }
      }
   }

   return 0;
}

int DOMTest_KeyInfoType (OSCTXT* pctxt, KeyInfoType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("KeyName")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("KeyValue")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("RetrievalMethod")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("X509Data")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PGPData")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SPKIData")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MgmtData"))) {
            { KeyInfoType_element* pdata2;
            pdata2 = rtxMemAllocType (pctxt, KeyInfoType_element);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_KeyInfoType_element (pdata2);
            DOMTest_KeyInfoType_element (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_KeyInfo (OSCTXT* pctxt, KeyInfo* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_KeyInfoType (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_ObjectType (OSCTXT* pctxt, ObjectType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Encoding"))) {
            pvalue->m.encodingPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->encoding = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->encoding = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("MimeType"))) {
            pvalue->m.mimeTypePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->mimeType = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->mimeType = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         { OSXSDAny* pdata2;
         pdata2 = rtxMemAllocTypeZ (pctxt, OSXSDAny);

         if (pdata2 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         if (0 != pXmlNode->children) {
            pdata2->t = OSXSDAny_xmlText;
            pdata2->u.xmlText = pXmlNode->children->content;
         }
         if (0 != pdata2)
            rtxDListAppend (pctxt, &pvalue->sequence_list, (void*)pdata2);
         }
      }
   }

   return 0;
}

int DOMTest_Object (OSCTXT* pctxt, Object* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_ObjectType (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_SignatureType (OSCTXT* pctxt, SignatureType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SignedInfo"))) {
            DOMTest_SignedInfo (pctxt, &pvalue->signedInfo, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SignatureValue"))) {
            DOMTest_SignatureValue (pctxt, &pvalue->signatureValue, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("KeyInfo"))) {
            pvalue->m.keyInfoPresent = 1;
            DOMTest_KeyInfo (pctxt, &pvalue->keyInfo, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Object"))) {
            { Object* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Object);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Object (pdata2);
            DOMTest_Object (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->object_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_Signature (OSCTXT* pctxt, Signature* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_SignatureType (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_ManifestType (OSCTXT* pctxt, ManifestType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Reference"))) {
            { Reference* pdata2;
            pdata2 = rtxMemAllocType (pctxt, Reference);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_Reference (pdata2);
            DOMTest_Reference (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->reference_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_Manifest (OSCTXT* pctxt, Manifest* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_ManifestType (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_SignaturePropertyType_element (OSCTXT* pctxt, 
   SignaturePropertyType_element* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         printf ("TODO: add logic to populate xsd:any element\n");
      }
   }

   return 0;
}

int DOMTest_SignaturePropertyType (OSCTXT* pctxt, 
   SignaturePropertyType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Target"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->target = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->target = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         { SignaturePropertyType_element* pdata2;
         pdata2 = rtxMemAllocType (pctxt, SignaturePropertyType_element);

         if (pdata2 == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_SignaturePropertyType_element (pdata2);
         DOMTest_SignaturePropertyType_element (pctxt, pdata2, pXmlNode, FALSE);
         if (0 != pdata2)
            rtxDListAppend (pctxt, &pvalue->choice_list, (void*)pdata2);
         }
      }
   }

   return 0;
}

int DOMTest_SignatureProperty (OSCTXT* pctxt, SignatureProperty* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_SignaturePropertyType (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_SignaturePropertiesType (OSCTXT* pctxt, 
   SignaturePropertiesType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("Id"))) {
            pvalue->m.idPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->id = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->id = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SignatureProperty"))) {
            { SignatureProperty* pdata2;
            pdata2 = rtxMemAllocType (pctxt, SignatureProperty);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignatureProperty (pdata2);
            DOMTest_SignatureProperty (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->signatureProperty_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_SignatureProperties (OSCTXT* pctxt, SignatureProperties* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_SignaturePropertiesType (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

