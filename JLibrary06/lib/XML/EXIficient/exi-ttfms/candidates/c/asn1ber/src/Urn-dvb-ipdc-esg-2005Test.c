/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 18-Oct-2006.
 */
#include "Urn-dvb-ipdc-esg-2005.h"
#include "Urn-tva-metadata-2005.h"
#include "Urn-mpeg-mpeg7-schema-2001.h"
#include "libxml/parser.h"
#include "rtxmlsrc/osrtxml.h"
#include "rtxsrc/rtxCommon.h"

int DOMTest_CBMS_ESGIDRefType (OSCTXT* pctxt, CBMS_ESGIDRefType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("IDRef"))) {
            pvalue->m.iDRefPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->iDRef = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->iDRef = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_CBMS_AcquisitionRefType (OSCTXT* pctxt, 
   CBMS_AcquisitionRefType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("IDRef"))) {
            pvalue->m.iDRefPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->iDRef = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->iDRef = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Label"))) {
            { TextualType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TextualType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TextualType (pdata2);
            DOMTest_TextualType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->label_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_ServiceRefType (OSCTXT* pctxt, CBMS_ServiceRefType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("IDRef"))) {
            pvalue->m.iDRefPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->iDRef = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->iDRef = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("serviceNumber"))) {
            pvalue->m.serviceNumberPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->serviceNumber = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_CBMS_ESGIDRefType_derivations (OSCTXT* pctxt, 
   CBMS_ESGIDRefType_derivations* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      xsiType = OSUTF8("ESGIDRefType");
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("ESGIDRefType")))
   {
      pvalue->t = 1;
      pvalue->u.eSGIDRefType = rtxMemAllocType (pctxt, CBMS_ESGIDRefType);

      if (pvalue->u.eSGIDRefType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CBMS_ESGIDRefType (pvalue->u.eSGIDRefType);
      DOMTest_CBMS_ESGIDRefType (pctxt, pvalue->u.eSGIDRefType, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("AcquisitionRefType")))
   {
      pvalue->t = 2;
      pvalue->u.acquisitionRefType
          = rtxMemAllocType (pctxt, CBMS_AcquisitionRefType);

      if (pvalue->u.acquisitionRefType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CBMS_AcquisitionRefType (pvalue->u.acquisitionRefType);
      DOMTest_CBMS_AcquisitionRefType (pctxt, pvalue->u.acquisitionRefType, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("ServiceRefType")))
   {
      pvalue->t = 3;
      pvalue->u.serviceRefType = rtxMemAllocType (pctxt, CBMS_ServiceRefType);

      if (pvalue->u.serviceRefType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CBMS_ServiceRefType (pvalue->u.serviceRefType);
      DOMTest_CBMS_ServiceRefType (pctxt, pvalue->u.serviceRefType, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_CBMS_RelatedMaterialType (OSCTXT* pctxt, 
   CBMS_RelatedMaterialType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("HowRelated"))) {
            pvalue->m.howRelatedPresent = 1;
            DOMTest_ControlledTermType_derivations (pctxt, &pvalue->howRelated, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MediaLocator"))) {
            DOMTest_MediaLocatorType_derivations (pctxt, &pvalue->mediaLocator, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PromotionalText"))) {
            { TextualType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TextualType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TextualType (pdata2);
            DOMTest_TextualType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->promotionalText_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PromotionalMedia"))) {
            { TitleMediaType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TitleMediaType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TitleMediaType (pdata2);
            DOMTest_TitleMediaType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->promotionalMedia_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_PrivateDataType (OSCTXT* pctxt, CBMS_PrivateDataType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_CBMS_ContentType (OSCTXT* pctxt, CBMS_ContentType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("contentID"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->contentID = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->contentID = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Title"))) {
            { TitleType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TitleType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TitleType (pdata2);
            DOMTest_TitleType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->title_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MediaTitle"))) {
            { TitleMediaType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TitleMediaType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TitleMediaType (pdata2);
            DOMTest_TitleMediaType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->mediaTitle_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ServiceRef"))) {
            { CBMS_ESGIDRefType_derivations* pdata2;
            pdata2 = rtxMemAllocType (pctxt, CBMS_ESGIDRefType_derivations);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CBMS_ESGIDRefType_derivations (pdata2);
            DOMTest_CBMS_ESGIDRefType_derivations (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->serviceRef_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Synopsis"))) {
            { SynopsisType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, SynopsisType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SynopsisType (pdata2);
            DOMTest_SynopsisType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->synopsis_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Keyword"))) {
            { KeywordType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, KeywordType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_KeywordType (pdata2);
            DOMTest_KeywordType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->keyword_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Genre"))) {
            { GenreType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, GenreType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_GenreType (pdata2);
            DOMTest_GenreType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->genre_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ContentType"))) {
            { ControlledTermType_derivations* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ControlledTermType_derivations);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ControlledTermType_derivations (pdata2);
            DOMTest_ControlledTermType_derivations (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->contentType_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ParentalGuidance"))) {
            { ParentalGuidanceType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ParentalGuidanceType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ParentalGuidanceType (pdata2);
            DOMTest_ParentalGuidanceType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->parentalGuidance_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Language"))) {
            { ExtendedLanguageType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ExtendedLanguageType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ExtendedLanguageType (pdata2);
            DOMTest_ExtendedLanguageType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->language_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("CaptionLanguage"))) {
            { CaptionLanguageType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, CaptionLanguageType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CaptionLanguageType (pdata2);
            DOMTest_CaptionLanguageType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->captionLanguage_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SignLanguage"))) {
            { SignLanguageType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, SignLanguageType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SignLanguageType (pdata2);
            DOMTest_SignLanguageType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->signLanguage_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("CreditsList"))) {
            pvalue->m.creditsListPresent = 1;
            DOMTest_CreditsListType (pctxt, &pvalue->creditsList, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("RelatedMaterial"))) {
            { CBMS_RelatedMaterialType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, CBMS_RelatedMaterialType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CBMS_RelatedMaterialType (pdata2);
            DOMTest_CBMS_RelatedMaterialType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->relatedMaterial_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Duration"))) {
            pvalue->m.durationPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->duration = pXmlNode->children->content;
            }
            else {
               pvalue->duration = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PrivateData"))) {
            { CBMS_PrivateDataType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, CBMS_PrivateDataType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CBMS_PrivateDataType (pdata2);
            DOMTest_CBMS_PrivateDataType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->privateData_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_ContentTableType (OSCTXT* pctxt, 
   CBMS_ContentTableType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   CBMS_ContentType* pdata1;
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Content"))) {
            pdata1 = rtxMemAllocType (pctxt, CBMS_ContentType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CBMS_ContentType (pdata1);
            DOMTest_CBMS_ContentType (pctxt, pdata1, pXmlNode, TRUE);
            if (0 != pdata1)
               rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_ScheduleEventType_element_element (OSCTXT* pctxt, 
   CBMS_ScheduleEventType_element_element* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AcquisitionRef"))) {
            pvalue->m.acquisitionRefPresent = 1;
            DOMTest_CBMS_AcquisitionRefType (pctxt, &pvalue->acquisitionRef, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ContentLocation"))) {
            pvalue->m.contentLocationPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->contentLocation = pXmlNode->children->content;
            }
            else {
               pvalue->contentLocation = (const OSUTF8CHAR*)"";
            }
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_ScheduleEventType_element (OSCTXT* pctxt, 
   CBMS_ScheduleEventType_element* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ContentFragmentRef"))) {
            pvalue->m.contentFragmentRefPresent = 1;
            DOMTest_CBMS_ESGIDRefType_derivations (pctxt, &pvalue->contentFragmentRef, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AcquisitionRef")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ContentLocation"))) {
            pvalue->m.sequence_listPresent = 1;
            { CBMS_ScheduleEventType_element_element* pdata2;
            pdata2
                = rtxMemAllocType (pctxt, CBMS_ScheduleEventType_element_element);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CBMS_ScheduleEventType_element_element (pdata2);
            DOMTest_CBMS_ScheduleEventType_element_element (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->sequence_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_ScheduleEventType (OSCTXT* pctxt, 
   CBMS_ScheduleEventType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("clearToAir"))) {
            pvalue->m.clearToAirPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->clearToAir);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("freeToAir"))) {
            pvalue->m.freeToAirPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->freeToAir);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("live"))) {
            pvalue->m.livePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->live);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("repeat"))) {
            pvalue->m.repeatPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->repeat);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("scheduleId"))) {
            pvalue->m.scheduleIdPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->scheduleId = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->scheduleId = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PublishedStartTime"))) {
            pvalue->m.publishedStartTimePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->publishedStartTime = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->publishedStartTime = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PublishedEndTime"))) {
            pvalue->m.publishedEndTimePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->publishedEndTime = (const char*)pXmlNode->children->content;
            }
            else {
               pvalue->publishedEndTime = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ServiceRef"))) {
            DOMTest_CBMS_ESGIDRefType_derivations (pctxt, &pvalue->serviceRef, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ContentFragmentRef")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AcquisitionRef")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ContentLocation"))) {
            pvalue->m.sequence_listPresent = 1;
            { CBMS_ScheduleEventType_element* pdata2;
            pdata2 = rtxMemAllocType (pctxt, CBMS_ScheduleEventType_element);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CBMS_ScheduleEventType_element (pdata2);
            DOMTest_CBMS_ScheduleEventType_element (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->sequence_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_ScheduleEventTableType (OSCTXT* pctxt, 
   CBMS_ScheduleEventTableType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   CBMS_ScheduleEventType* pdata1;
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ScheduleEvent"))) {
            pdata1 = rtxMemAllocType (pctxt, CBMS_ScheduleEventType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CBMS_ScheduleEventType (pdata1);
            DOMTest_CBMS_ScheduleEventType (pctxt, pdata1, pXmlNode, TRUE);
            if (0 != pdata1)
               rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_ProviderType (OSCTXT* pctxt, CBMS_ProviderType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ProviderURI"))) {
            pvalue->m.providerURIPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->providerURI = pXmlNode->children->content;
            }
            else {
               pvalue->providerURI = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ProviderName"))) {
            { TextualType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TextualType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TextualType (pdata2);
            DOMTest_TextualType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->providerName_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ProviderLogo"))) {
            pvalue->m.providerLogoPresent = 1;
            DOMTest_TitleMediaType (pctxt, &pvalue->providerLogo, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ProviderInformationURL"))) {
            pvalue->m.providerInformationURLPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->providerInformationURL = pXmlNode->children->content;
            }
            else {
               pvalue->providerInformationURL = (const OSUTF8CHAR*)"";
            }
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_ServiceType (OSCTXT* pctxt, CBMS_ServiceType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("clearToAir"))) {
            pvalue->m.clearToAirPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->clearToAir);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("freeToAir"))) {
            pvalue->m.freeToAirPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               OSUTF8CHAR* pcontent = ((xmlNodePtr)pXmlAttr)->children->content;
               rtxInitContextBuffer (pctxt, pcontent, rtxUTF8LenBytes(pcontent));
               rtXmlDecBool (pctxt, &pvalue->freeToAir);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("serviceID"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->serviceID = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->serviceID = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ServiceName"))) {
            { ServiceInformationNameType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ServiceInformationNameType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ServiceInformationNameType (pdata2);
            DOMTest_ServiceInformationNameType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->serviceName_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ServiceNumber"))) {
            pvalue->m.serviceNumberPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->serviceNumber = atoi ((const char*)pXmlNode->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ServiceLogo"))) {
            { TitleMediaType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TitleMediaType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TitleMediaType (pdata2);
            DOMTest_TitleMediaType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->serviceLogo_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ServiceDescription"))) {
            { SynopsisType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, SynopsisType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_SynopsisType (pdata2);
            DOMTest_SynopsisType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->serviceDescription_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ServiceGenre"))) {
            { GenreType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, GenreType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_GenreType (pdata2);
            DOMTest_GenreType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->serviceGenre_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ServiceType"))) {
            { ControlledTermType_derivations* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ControlledTermType_derivations);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ControlledTermType_derivations (pdata2);
            DOMTest_ControlledTermType_derivations (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->serviceType_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ParentalGuidance"))) {
            { ParentalGuidanceType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ParentalGuidanceType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ParentalGuidanceType (pdata2);
            DOMTest_ParentalGuidanceType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->parentalGuidance_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ServiceLanguage"))) {
            pvalue->m.serviceLanguagePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->serviceLanguage = pXmlNode->children->content;
            }
            else {
               pvalue->serviceLanguage = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ServiceProvider"))) {
            pvalue->m.serviceProviderPresent = 1;
            DOMTest_CBMS_ProviderType (pctxt, &pvalue->serviceProvider, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AcquisitionRef"))) {
            { CBMS_AcquisitionRefType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, CBMS_AcquisitionRefType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CBMS_AcquisitionRefType (pdata2);
            DOMTest_CBMS_AcquisitionRefType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->acquisitionRef_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("RelatedMaterial"))) {
            { CBMS_RelatedMaterialType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, CBMS_RelatedMaterialType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CBMS_RelatedMaterialType (pdata2);
            DOMTest_CBMS_RelatedMaterialType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->relatedMaterial_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PrivateData"))) {
            { CBMS_PrivateDataType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, CBMS_PrivateDataType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CBMS_PrivateDataType (pdata2);
            DOMTest_CBMS_PrivateDataType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->privateData_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_ServiceTableType (OSCTXT* pctxt, 
   CBMS_ServiceTableType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   CBMS_ServiceType* pdata1;
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Service"))) {
            pdata1 = rtxMemAllocType (pctxt, CBMS_ServiceType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CBMS_ServiceType (pdata1);
            DOMTest_CBMS_ServiceType (pctxt, pdata1, pXmlNode, TRUE);
            if (0 != pdata1)
               rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_ServiceBundleType (OSCTXT* pctxt, 
   CBMS_ServiceBundleType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("serviceBundleID"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->serviceBundleID = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->serviceBundleID = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ServiceBundleName"))) {
            { TextualType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TextualType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TextualType (pdata2);
            DOMTest_TextualType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->serviceBundleName_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ServiceBundleProvider"))) {
            pvalue->m.serviceBundleProviderPresent = 1;
            DOMTest_CBMS_ProviderType (pctxt, &pvalue->serviceBundleProvider, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ServiceBundleMediaTitle"))) {
            pvalue->m.serviceBundleMediaTitlePresent = 1;
            DOMTest_TitleMediaType (pctxt, &pvalue->serviceBundleMediaTitle, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ServiceBundleDescription"))) {
            { TextualType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TextualType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TextualType (pdata2);
            DOMTest_TextualType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->serviceBundleDescription_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ServiceBundleGenre"))) {
            { GenreType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, GenreType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_GenreType (pdata2);
            DOMTest_GenreType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->serviceBundleGenre_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ServiceRef"))) {
            { CBMS_ServiceRefType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, CBMS_ServiceRefType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CBMS_ServiceRefType (pdata2);
            DOMTest_CBMS_ServiceRefType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->serviceRef_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ParentalGuidance"))) {
            { ParentalGuidanceType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ParentalGuidanceType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ParentalGuidanceType (pdata2);
            DOMTest_ParentalGuidanceType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->parentalGuidance_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("RelatedMaterial"))) {
            { CBMS_RelatedMaterialType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, CBMS_RelatedMaterialType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CBMS_RelatedMaterialType (pdata2);
            DOMTest_CBMS_RelatedMaterialType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->relatedMaterial_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_ServiceBundleTableType (OSCTXT* pctxt, 
   CBMS_ServiceBundleTableType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   CBMS_ServiceBundleType* pdata1;
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ServiceBundle"))) {
            pdata1 = rtxMemAllocType (pctxt, CBMS_ServiceBundleType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CBMS_ServiceBundleType (pdata1);
            DOMTest_CBMS_ServiceBundleType (pctxt, pdata1, pXmlNode, TRUE);
            if (0 != pdata1)
               rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_PurchaseType_price (OSCTXT* pctxt, 
   CBMS_PurchaseType_price* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("currency"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->currency = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->currency = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (0 != pXmlNode->children) {
      rtxUTF8StrToDouble (pXmlNode->children->content, &pvalue->base);
   }

   return 0;
}

int DOMTest_CBMS_UsageConstraintsType_quantityRange (OSCTXT* pctxt, 
   CBMS_UsageConstraintsType_quantityRange* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("max"))) {
            pvalue->m.maxPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->max = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("min"))) {
            pvalue->m.minPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->min = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_CBMS_UsageConstraintsType (OSCTXT* pctxt, 
   CBMS_UsageConstraintsType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PurchaseType"))) {
            pvalue->m.purchaseTypePresent = 1;
            DOMTest_ControlledTermType_derivations (pctxt, &pvalue->purchaseType, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("QuantityUnit"))) {
            pvalue->m.quantityUnitPresent = 1;
            DOMTest_ControlledTermType_derivations (pctxt, &pvalue->quantityUnit, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("QuantityRange"))) {
            pvalue->m.quantityRangePresent = 1;
            DOMTest_CBMS_UsageConstraintsType_quantityRange (pctxt, &pvalue->quantityRange, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_PurchaseDataType (OSCTXT* pctxt, 
   CBMS_PurchaseDataType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Data"))) {
            if (0 != pXmlNode->children) {
               pvalue->data = pXmlNode->children->content;
            }
            else {
               pvalue->data = (const OSUTF8CHAR*)"";
            }
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_PurchaseDataBaseType_derivations (OSCTXT* pctxt, 
   CBMS_PurchaseDataBaseType_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      return LOG_RTERR1 (pctxt, RTERR_ATTRMISRQ,
         rtxErrAddStrParm (pctxt, "xsi:type"));
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("PurchaseDataType")))
   {
      pvalue->t = 1;
      pvalue->u.purchaseDataType
          = rtxMemAllocType (pctxt, CBMS_PurchaseDataType);

      if (pvalue->u.purchaseDataType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CBMS_PurchaseDataType (pvalue->u.purchaseDataType);
      DOMTest_CBMS_PurchaseDataType (pctxt, pvalue->u.purchaseDataType, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_CBMS_PurchaseRequestType (OSCTXT* pctxt, 
   CBMS_PurchaseRequestType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("DRMSystem"))) {
            if (0 != pXmlNode->children) {
               pvalue->dRMSystem = pXmlNode->children->content;
            }
            else {
               pvalue->dRMSystem = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PurchaseData"))) {
            pvalue->m.purchaseDataPresent = 1;
            DOMTest_CBMS_PurchaseDataBaseType_derivations (pctxt, &pvalue->purchaseData, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PurchaseChannelIDRef"))) {
            pvalue->m.purchaseChannelIDRefPresent = 1;
            DOMTest_CBMS_ESGIDRefType_derivations (pctxt, &pvalue->purchaseChannelIDRef, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_PurchaseType (OSCTXT* pctxt, CBMS_PurchaseType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("end"))) {
            pvalue->m.endPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->end = (const char*)((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->end = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("purchaseId"))) {
            pvalue->m.purchaseIdPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->purchaseId = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->purchaseId = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("start"))) {
            pvalue->m.startPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->start = (const char*)((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->start = "";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ServiceBundleRef"))) {
            pvalue->m.serviceBundleRefPresent = 1;
            DOMTest_CBMS_ESGIDRefType_derivations (pctxt, &pvalue->serviceBundleRef, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Price"))) {
            { CBMS_PurchaseType_price* pdata2;
            pdata2 = rtxMemAllocType (pctxt, CBMS_PurchaseType_price);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CBMS_PurchaseType_price (pdata2);
            DOMTest_CBMS_PurchaseType_price (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->price_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("UsageConstraints"))) {
            { CBMS_UsageConstraintsType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, CBMS_UsageConstraintsType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CBMS_UsageConstraintsType (pdata2);
            DOMTest_CBMS_UsageConstraintsType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->usageConstraints_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Description"))) {
            { TextualType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TextualType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TextualType (pdata2);
            DOMTest_TextualType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->description_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PurchaseRequest"))) {
            { CBMS_PurchaseRequestType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, CBMS_PurchaseRequestType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CBMS_PurchaseRequestType (pdata2);
            DOMTest_CBMS_PurchaseRequestType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->purchaseRequest_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MediaTitle"))) {
            { TitleMediaType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TitleMediaType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TitleMediaType (pdata2);
            DOMTest_TitleMediaType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->mediaTitle_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_PurchaseTableType (OSCTXT* pctxt, 
   CBMS_PurchaseTableType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   CBMS_PurchaseType* pdata1;
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Purchase"))) {
            pdata1 = rtxMemAllocType (pctxt, CBMS_PurchaseType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CBMS_PurchaseType (pdata1);
            DOMTest_CBMS_PurchaseType (pctxt, pdata1, pXmlNode, TRUE);
            if (0 != pdata1)
               rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_PurchaseChannelType (OSCTXT* pctxt, 
   CBMS_PurchaseChannelType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("purchaseChannelID"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->purchaseChannelID = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->purchaseChannelID = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Name"))) {
            { TextualType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TextualType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TextualType (pdata2);
            DOMTest_TextualType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->name_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Description"))) {
            { TextualType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TextualType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TextualType (pdata2);
            DOMTest_TextualType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->description_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PortalURL"))) {
            pvalue->m.portalURLPresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->portalURL = pXmlNode->children->content;
            }
            else {
               pvalue->portalURL = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ContactInfo"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            else {
               pdata2 = (const OSUTF8CHAR*)"";
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->contactInfo_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MediaTitle"))) {
            { TitleMediaType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, TitleMediaType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_TitleMediaType (pdata2);
            DOMTest_TitleMediaType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->mediaTitle_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PrivateData"))) {
            { CBMS_PrivateDataType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, CBMS_PrivateDataType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CBMS_PrivateDataType (pdata2);
            DOMTest_CBMS_PrivateDataType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->privateData_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_PurchaseChannelTableType (OSCTXT* pctxt, 
   CBMS_PurchaseChannelTableType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   CBMS_PurchaseChannelType* pdata1;
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PurchaseChannel"))) {
            pdata1 = rtxMemAllocType (pctxt, CBMS_PurchaseChannelType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CBMS_PurchaseChannelType (pdata1);
            DOMTest_CBMS_PurchaseChannelType (pctxt, pdata1, pXmlNode, TRUE);
            if (0 != pdata1)
               rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_VideoCodecCharacteristicType (OSCTXT* pctxt, 
   CBMS_VideoCodecCharacteristicType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Codec"))) {
            pvalue->m.codecPresent = 1;
            DOMTest_ControlledTermType_derivations (pctxt, &pvalue->codec, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ProfileLevelIndication"))) {
            pvalue->m.profileLevelIndicationPresent = 1;
            DOMTest_ControlledTermType_derivations (pctxt, &pvalue->profileLevelIndication, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_VideoComponentType (OSCTXT* pctxt, 
   CBMS_VideoComponentType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("purpose"))) {
            pvalue->m.purposePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->purpose = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->purpose = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Bandwidth"))) {
            pvalue->m.bandwidthPresent = 1;
            DOMTest_BitRateType (pctxt, &pvalue->bandwidth, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("CodecCharacteristic"))) {
            pvalue->m.codecCharacteristicPresent = 1;
            DOMTest_CBMS_VideoCodecCharacteristicType (pctxt, &pvalue->codecCharacteristic, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("FrameRate"))) {
            pvalue->m.frameRatePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->frameRate = pXmlNode->children->content;
            }
            else {
               pvalue->frameRate = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("OpenCaptionLanguage"))) {
            pvalue->m.openCaptionLanguagePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->openCaptionLanguage = pXmlNode->children->content;
            }
            else {
               pvalue->openCaptionLanguage = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SignLanguage"))) {
            pvalue->m.signLanguagePresent = 1;
            DOMTest_SignLanguageType (pctxt, &pvalue->signLanguage, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_AudioComponentType (OSCTXT* pctxt, 
   CBMS_AudioComponentType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("purpose"))) {
            pvalue->m.purposePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->purpose = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->purpose = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Bandwidth"))) {
            pvalue->m.bandwidthPresent = 1;
            DOMTest_BitRateType (pctxt, &pvalue->bandwidth, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Codec"))) {
            pvalue->m.codecPresent = 1;
            DOMTest_ControlledTermType_derivations (pctxt, &pvalue->codec, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Mode"))) {
            pvalue->m.modePresent = 1;
            DOMTest_ControlledTermType_derivations (pctxt, &pvalue->mode, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Language"))) {
            { ExtendedLanguageType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ExtendedLanguageType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ExtendedLanguageType (pdata2);
            DOMTest_ExtendedLanguageType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->language_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_FileDownloadComponentType (OSCTXT* pctxt, 
   CBMS_FileDownloadComponentType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("purpose"))) {
            pvalue->m.purposePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->purpose = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->purpose = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Bandwidth"))) {
            pvalue->m.bandwidthPresent = 1;
            DOMTest_BitRateType (pctxt, &pvalue->bandwidth, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("FileFormat"))) {
            { const OSUTF8CHAR* pdata2 = 0;
            if (0 != pXmlNode->children) {
               pdata2 = pXmlNode->children->content;
            }
            else {
               pdata2 = (const OSUTF8CHAR*)"";
            }
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->fileFormat_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Storage"))) {
            pvalue->m.storagePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->storage = atoi ((const char*)pXmlNode->children->content);
            }
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_ComponentCharacteristicType_derivations (OSCTXT* pctxt, 
   CBMS_ComponentCharacteristicType_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      return LOG_RTERR1 (pctxt, RTERR_ATTRMISRQ,
         rtxErrAddStrParm (pctxt, "xsi:type"));
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("VideoComponentType")))
   {
      pvalue->t = 1;
      pvalue->u.videoComponentType
          = rtxMemAllocType (pctxt, CBMS_VideoComponentType);

      if (pvalue->u.videoComponentType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CBMS_VideoComponentType (pvalue->u.videoComponentType);
      DOMTest_CBMS_VideoComponentType (pctxt, pvalue->u.videoComponentType, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("AudioComponentType")))
   {
      pvalue->t = 2;
      pvalue->u.audioComponentType
          = rtxMemAllocType (pctxt, CBMS_AudioComponentType);

      if (pvalue->u.audioComponentType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CBMS_AudioComponentType (pvalue->u.audioComponentType);
      DOMTest_CBMS_AudioComponentType (pctxt, pvalue->u.audioComponentType, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("FileDownloadComponentType")))
   {
      pvalue->t = 3;
      pvalue->u.fileDownloadComponentType
          = rtxMemAllocType (pctxt, CBMS_FileDownloadComponentType);

      if (pvalue->u.fileDownloadComponentType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CBMS_FileDownloadComponentType (pvalue->u.fileDownloadComponentType);
      DOMTest_CBMS_FileDownloadComponentType (pctxt, pvalue->u.fileDownloadComponentType, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_CBMS_InlinedSDPType (OSCTXT* pctxt, CBMS_InlinedSDPType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SDP"))) {
            if (0 != pXmlNode->children) {
               pvalue->sDP = pXmlNode->children->content;
            }
            else {
               pvalue->sDP = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AssociatedDeliveryProcedure"))) {
            pvalue->m.associatedDeliveryProcedurePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->associatedDeliveryProcedure = pXmlNode->children->content;
            }
            else {
               pvalue->associatedDeliveryProcedure = (const OSUTF8CHAR*)"";
            }
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_SDPRefType (OSCTXT* pctxt, CBMS_SDPRefType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SDPStream"))) {
            if (0 != pXmlNode->children) {
               pvalue->sDPStream = pXmlNode->children->content;
            }
            else {
               pvalue->sDPStream = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SDPURI"))) {
            if (0 != pXmlNode->children) {
               pvalue->sDPURI = pXmlNode->children->content;
            }
            else {
               pvalue->sDPURI = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AssociatedDeliveryProcedure"))) {
            pvalue->m.associatedDeliveryProcedurePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->associatedDeliveryProcedure = pXmlNode->children->content;
            }
            else {
               pvalue->associatedDeliveryProcedure = (const OSUTF8CHAR*)"";
            }
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_SessionDescriptionBaseType_derivations (OSCTXT* pctxt, 
   CBMS_SessionDescriptionBaseType_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      return LOG_RTERR1 (pctxt, RTERR_ATTRMISRQ,
         rtxErrAddStrParm (pctxt, "xsi:type"));
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("InlinedSDPType")))
   {
      pvalue->t = 1;
      pvalue->u.inlinedSDPType = rtxMemAllocType (pctxt, CBMS_InlinedSDPType);

      if (pvalue->u.inlinedSDPType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CBMS_InlinedSDPType (pvalue->u.inlinedSDPType);
      DOMTest_CBMS_InlinedSDPType (pctxt, pvalue->u.inlinedSDPType, pXmlNode, TRUE);
   }
   else if (rtxUTF8StrEqual (xsiType, OSUTF8("SDPRefType")))
   {
      pvalue->t = 2;
      pvalue->u.sDPRefType = rtxMemAllocType (pctxt, CBMS_SDPRefType);

      if (pvalue->u.sDPRefType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CBMS_SDPRefType (pvalue->u.sDPRefType);
      DOMTest_CBMS_SDPRefType (pctxt, pvalue->u.sDPRefType, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_CBMS_ComponentDescriptionType (OSCTXT* pctxt, 
   CBMS_ComponentDescriptionType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ComponentCharacteristic"))) {
            { CBMS_ComponentCharacteristicType_derivations* pdata2;
            pdata2
                = rtxMemAllocType (pctxt, CBMS_ComponentCharacteristicType_derivations);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CBMS_ComponentCharacteristicType_derivations (pdata2);
            DOMTest_CBMS_ComponentCharacteristicType_derivations (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->componentCharacteristic_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("SessionDescription"))) {
            DOMTest_CBMS_SessionDescriptionBaseType_derivations (pctxt, &pvalue->sessionDescription, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_ZappingSupportType_element_choice (OSCTXT* pctxt, 
   CBMS_ZappingSupportType_element_choice* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MediaLocator"))) {
            pvalue->t = 1;
            pvalue->u.mediaLocator
                = rtxMemAllocType (pctxt, MediaLocatorType_derivations);

            if (pvalue->u.mediaLocator == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_MediaLocatorType_derivations (pvalue->u.mediaLocator);
            DOMTest_MediaLocatorType_derivations (pctxt, pvalue->u.mediaLocator, pXmlNode, TRUE);
            break;
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ZappingSDP"))) {
            pvalue->t = 2;
            pvalue->u.zappingSDP_list = rtxMemAllocType (pctxt, OSRTDList);

            if (pvalue->u.zappingSDP_list == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            rtxDListFastInit (pvalue->u.zappingSDP_list);
            {
            CBMS_SessionDescriptionBaseType_derivations* pdata2;
            for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
               if (pXmlNode->type == XML_ELEMENT_NODE) {
                  if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ZappingSDP"))) {
                     pdata2
                         = rtxMemAllocType (pctxt, CBMS_SessionDescriptionBaseType_derivations);

                     if (pdata2 == NULL)
                        return LOG_RTERR (pctxt, RTERR_NOMEM);

                     asn1Init_CBMS_SessionDescriptionBaseType_derivations (pdata2);
                     DOMTest_CBMS_SessionDescriptionBaseType_derivations (pctxt, pdata2, pXmlNode, TRUE);
                     if (0 != pdata2)
                        rtxDListAppend (pctxt, pvalue->u.zappingSDP_list, (void*)pdata2);
                  }
               }
            }
            }
            break;
         }
         else {
            LOG_RTERR1 (pctxt, RTERR_INVOPT,
               rtxErrAddStrParm (pctxt, (const char*)pXmlNode->name));
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_ZappingSupportType_element (OSCTXT* pctxt, 
   CBMS_ZappingSupportType_element* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Type"))) {
            { ControlledTermType_derivations* pdata2;
            pdata2 = rtxMemAllocType (pctxt, ControlledTermType_derivations);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ControlledTermType_derivations (pdata2);
            DOMTest_ControlledTermType_derivations (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->type_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("MediaLocator")) ||
         rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ZappingSDP"))) {
            pvalue->m.choicePresent = 1;
            DOMTest_CBMS_ZappingSupportType_element_choice (pctxt, &pvalue->choice, pXmlNode, FALSE);
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_ZappingSupportType (OSCTXT* pctxt, 
   CBMS_ZappingSupportType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   CBMS_ZappingSupportType_element* pdata1 = rtxMemAllocTypeZ (pctxt, CBMS_ZappingSupportType_element);
   DOMTest_CBMS_ZappingSupportType_element (pctxt, pdata1, pXmlNode, setChild);
   if (0 != pdata1)
      rtxDListAppend (pctxt, pvalue, (void*)pdata1);

   return 0;
}

int DOMTest_CBMS_KeyStreamType (OSCTXT* pctxt, CBMS_KeyStreamType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("CBMSKMSId"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->cBMSKMSId = atoi ((const char*)((xmlNodePtr)pXmlAttr)->children->content);
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("IPDCOperatorID"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->iPDCOperatorID = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->iPDCOperatorID = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_CBMS_KeyStreamBaseType_derivations (OSCTXT* pctxt, 
   CBMS_KeyStreamBaseType_derivations* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   const OSUTF8CHAR* xsiType = 0;
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Find xsi:type attribute */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("type"))) {
            xmlChar* pPrefix;
            xsiType = xmlSplitQName2 (pXmlAttr->children->content, &pPrefix);
         }
      }
   }

   /* Call derived function based on type name */
   if (0 == xsiType) {
      return LOG_RTERR1 (pctxt, RTERR_ATTRMISRQ,
         rtxErrAddStrParm (pctxt, "xsi:type"));
   }
   if (rtxUTF8StrEqual (xsiType, OSUTF8("KeyStreamType")))
   {
      pvalue->t = 1;
      pvalue->u.keyStreamType = rtxMemAllocType (pctxt, CBMS_KeyStreamType);

      if (pvalue->u.keyStreamType == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CBMS_KeyStreamType (pvalue->u.keyStreamType);
      DOMTest_CBMS_KeyStreamType (pctxt, pvalue->u.keyStreamType, pXmlNode, TRUE);
   }
   else {
      printf ("unknown xsi type\n");
   }

   return 0;
}

int DOMTest_CBMS_AcquisitionType (OSCTXT* pctxt, CBMS_AcquisitionType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("acquisitionID"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->acquisitionID = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->acquisitionID = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("contentMimeType"))) {
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->contentMimeType = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->contentMimeType = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ComponentDescription"))) {
            { CBMS_ComponentDescriptionType* pdata2;
            pdata2 = rtxMemAllocType (pctxt, CBMS_ComponentDescriptionType);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CBMS_ComponentDescriptionType (pdata2);
            DOMTest_CBMS_ComponentDescriptionType (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->componentDescription_list, (void*)pdata2);
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ZappingSupport"))) {
            pvalue->m.zappingSupportPresent = 1;
            DOMTest_CBMS_ZappingSupportType (pctxt, &pvalue->zappingSupport, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("KeyStream"))) {
            { CBMS_KeyStreamBaseType_derivations* pdata2;
            pdata2
                = rtxMemAllocType (pctxt, CBMS_KeyStreamBaseType_derivations);

            if (pdata2 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CBMS_KeyStreamBaseType_derivations (pdata2);
            DOMTest_CBMS_KeyStreamBaseType_derivations (pctxt, pdata2, pXmlNode, FALSE);
            if (0 != pdata2)
               rtxDListAppend (pctxt, &pvalue->keyStream_list, (void*)pdata2);
            }
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_AcquisitionTableType (OSCTXT* pctxt, 
   CBMS_AcquisitionTableType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   CBMS_AcquisitionType* pdata1;
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Acquisition"))) {
            pdata1 = rtxMemAllocType (pctxt, CBMS_AcquisitionType);

            if (pdata1 == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_CBMS_AcquisitionType (pdata1);
            DOMTest_CBMS_AcquisitionType (pctxt, pdata1, pXmlNode, TRUE);
            if (0 != pdata1)
               rtxDListAppend (pctxt, pvalue, (void*)pdata1);
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_ESGType (OSCTXT* pctxt, CBMS_ESGType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ContentTable"))) {
            pvalue->m.contentTablePresent = 1;
            DOMTest_CBMS_ContentTableType (pctxt, &pvalue->contentTable, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ScheduleEventTable"))) {
            pvalue->m.scheduleEventTablePresent = 1;
            DOMTest_CBMS_ScheduleEventTableType (pctxt, &pvalue->scheduleEventTable, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ServiceTable"))) {
            pvalue->m.serviceTablePresent = 1;
            DOMTest_CBMS_ServiceTableType (pctxt, &pvalue->serviceTable, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ServiceBundleTable"))) {
            pvalue->m.serviceBundleTablePresent = 1;
            DOMTest_CBMS_ServiceBundleTableType (pctxt, &pvalue->serviceBundleTable, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PurchaseTable"))) {
            pvalue->m.purchaseTablePresent = 1;
            DOMTest_CBMS_PurchaseTableType (pctxt, &pvalue->purchaseTable, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("PurchaseChannelTable"))) {
            pvalue->m.purchaseChannelTablePresent = 1;
            DOMTest_CBMS_PurchaseChannelTableType (pctxt, &pvalue->purchaseChannelTable, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("AcquisitionTable"))) {
            pvalue->m.acquisitionTablePresent = 1;
            DOMTest_CBMS_AcquisitionTableType (pctxt, &pvalue->acquisitionTable, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_ESGMainType (OSCTXT* pctxt, CBMS_ESGMainType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("publicationTime"))) {
            pvalue->m.publicationTimePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->publicationTime = (const char*)((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->publicationTime = "";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("publisher"))) {
            pvalue->m.publisherPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->publisher = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->publisher = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("rightsOwner"))) {
            pvalue->m.rightsOwnerPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->rightsOwner = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->rightsOwner = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("lang"))) {
            pvalue->m.langPresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->lang = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->lang = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("CopyrightNotice"))) {
            pvalue->m.copyrightNoticePresent = 1;
            if (0 != pXmlNode->children) {
               pvalue->copyrightNotice = pXmlNode->children->content;
            }
            else {
               pvalue->copyrightNotice = (const OSUTF8CHAR*)"";
            }
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ClassificationSchemeTable"))) {
            pvalue->m.classificationSchemeTablePresent = 1;
            DOMTest_ClassificationSchemeTableType (pctxt, &pvalue->classificationSchemeTable, pXmlNode, TRUE);
         }
         else if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("ESG"))) {
            pvalue->m.eSGPresent = 1;
            DOMTest_CBMS_ESGType (pctxt, &pvalue->eSG, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_ESGMain (OSCTXT* pctxt, CBMS_ESGMain* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   DOMTest_CBMS_ESGMainType (pctxt, pvalue, pXmlNode, TRUE);

   return 0;
}

int DOMTest_CBMS_PurchaseDataBaseType (OSCTXT* pctxt, 
   CBMS_PurchaseDataBaseType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_CBMS_ComponentCharacteristicType (OSCTXT* pctxt, 
   CBMS_ComponentCharacteristicType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   xmlAttrPtr pXmlAttr = pXmlNode->properties;

   /* Populate attributes */
   for ( ; 0 != pXmlAttr; pXmlAttr = pXmlAttr->next) {
      if (pXmlAttr->type == XML_ATTRIBUTE_NODE) {
         if (rtxUTF8StrEqual (pXmlAttr->name, OSUTF8("purpose"))) {
            pvalue->m.purposePresent = 1;
            if (0 != ((xmlNodePtr)pXmlAttr)->children) {
               pvalue->purpose = ((xmlNodePtr)pXmlAttr)->children->content;
            }
            else {
               pvalue->purpose = (const OSUTF8CHAR*)"";
            }
         }
      }
   }
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
         if (rtxUTF8StrEqual (pXmlNode->name, OSUTF8("Bandwidth"))) {
            pvalue->m.bandwidthPresent = 1;
            DOMTest_BitRateType (pctxt, &pvalue->bandwidth, pXmlNode, TRUE);
         }
      }
   }

   return 0;
}

int DOMTest_CBMS_SessionDescriptionBaseType (OSCTXT* pctxt, 
   CBMS_SessionDescriptionBaseType* pvalue, 
   xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

int DOMTest_CBMS_KeyStreamBaseType (OSCTXT* pctxt, 
   CBMS_KeyStreamBaseType* pvalue, xmlNodePtr pXmlNode, OSBOOL setChild)
{
   /* Populate elements */
   if (setChild)
      pXmlNode = pXmlNode->children;

   for ( ; 0 != pXmlNode; pXmlNode = pXmlNode->next) {
      if (pXmlNode->type == XML_ELEMENT_NODE) {
      }
   }

   return 0;
}

