/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.0B, Date: 18-Oct-2006.
 */
#include "Xmldsig.h"
#include "rtxsrc/rtxCommon.h"

/**************************************************************/
/*                                                            */
/*  CanonicalizationMethodType                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CanonicalizationMethodType (OSCTXT* pctxt,
   CanonicalizationMethodType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode elem_list */

   pnode2 = pvalue->elem_list.tail;
   while (0 != pnode2) {
      switch (((OSXSDAny*)pnode2->data)->t) {
      case OSXSDAny_binary:
         ll = xe_OpenType (pctxt, ((OSXSDAny*)pnode2->data)->u.binary->data, 
            ((OSXSDAny*)pnode2->data)->u.binary->numocts);
         break;
      case OSXSDAny_xmlText:
         ll = xe_utf8str (pctxt, ((OSXSDAny*)pnode2->data)->
            u.xmlText, ASN1EXPL);
         break;
      }
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      else ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode algorithm */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->algorithm, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_CanonicalizationMethodType (OSCTXT* pctxt, 
   CanonicalizationMethodType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" Algorithm=\""), 12);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->algorithm, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   /* encode elem_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   { OSRTDListNode* pnode = pvalue->elem_list.head;
   while (0 != pnode) {
      if (((OSXSDAny*)pnode->data)->t == OSXSDAny_xmlText) {
         stat = rtXmlEncAnyStr (pctxt, ((OSXSDAny*)pnode->data)->u.xmlText
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         char buf[40];
         os_snprintf (buf, 40, "%d", ((OSXSDAny*)pnode->data)->t);
         rtxErrAddStrParm (pctxt, buf);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CanonicalizationMethod                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CanonicalizationMethod (OSCTXT* pctxt,
   CanonicalizationMethod *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_CanonicalizationMethodType (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_CanonicalizationMethod (OSCTXT* pctxt, 
   CanonicalizationMethod* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_CanonicalizationMethodType (pctxt, pvalue
      , elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  HMACOutputLengthType                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_HMACOutputLengthType (OSCTXT* pctxt,
   HMACOutputLengthType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_integer (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_HMACOutputLengthType (OSCTXT* pctxt, HMACOutputLengthType value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncInt (pctxt, value, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SignatureMethodType                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SignatureMethodType (OSCTXT* pctxt,
   SignatureMethodType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode elem_list */

   pnode2 = pvalue->elem_list.tail;
   while (0 != pnode2) {
      switch (((OSXSDAny*)pnode2->data)->t) {
      case OSXSDAny_binary:
         ll = xe_OpenType (pctxt, ((OSXSDAny*)pnode2->data)->u.binary->data, 
            ((OSXSDAny*)pnode2->data)->u.binary->numocts);
         break;
      case OSXSDAny_xmlText:
         ll = xe_utf8str (pctxt, ((OSXSDAny*)pnode2->data)->
            u.xmlText, ASN1EXPL);
         break;
      }
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      else ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode hMACOutputLength */

   if (pvalue->m.hMACOutputLengthPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         asn1E_HMACOutputLengthType (pctxt, &pvalue->hMACOutputLength, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode algorithm */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->algorithm, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SignatureMethodType (OSCTXT* pctxt, SignatureMethodType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" Algorithm=\""), 12);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->algorithm, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   /* encode hMACOutputLength */

   if (pvalue->m.hMACOutputLengthPresent) {
      stat = XmlEnc_HMACOutputLengthType (pctxt, pvalue->hMACOutputLength
         , OSUTF8("HMACOutputLength"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode elem_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   { OSRTDListNode* pnode = pvalue->elem_list.head;
   while (0 != pnode) {
      if (((OSXSDAny*)pnode->data)->t == OSXSDAny_xmlText) {
         stat = rtXmlEncAnyStr (pctxt, ((OSXSDAny*)pnode->data)->u.xmlText
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         char buf[40];
         os_snprintf (buf, 40, "%d", ((OSXSDAny*)pnode->data)->t);
         rtxErrAddStrParm (pctxt, buf);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SignatureMethod                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SignatureMethod (OSCTXT* pctxt,
   SignatureMethod *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_SignatureMethodType (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_SignatureMethod (OSCTXT* pctxt, SignatureMethod* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_SignatureMethodType (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransformType_element                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TransformType_element (OSCTXT* pctxt,
   TransformType_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         switch (pvalue->u.elem.t) {
         case OSXSDAny_binary:
            ll = xe_OpenType (pctxt, pvalue->u.elem.u.binary->data, pvalue->
               u.elem.u.binary->numocts);
            break;
         case OSXSDAny_xmlText:
            ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
               xe_utf8str (pctxt, pvalue->u.elem.u.xmlText, ASN1IMPL));
            break;
         }
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
            xe_utf8str (pctxt, pvalue->u.xPath, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_TransformType_element (OSCTXT* pctxt, 
   TransformType_element* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   switch (pvalue->t)
   {
      case 1:
         /* encode elem */

         if (pvalue->u.elem.t == OSXSDAny_xmlText) {
            stat = rtXmlEncAnyStr (pctxt, pvalue->u.elem.u.xmlText
               , OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
         }
         else {
            char buf[40];
            os_snprintf (buf, 40, "%d", pvalue->u.elem.t);
            rtxErrAddStrParm (pctxt, buf);
            return LOG_RTERR (pctxt, RTERR_INVOPT);
         }

         break;

      case 2:
         /* encode xPath */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->u.xPath
            , OSUTF8("XPath"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransformType                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TransformType (OSCTXT* pctxt,
   TransformType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode choice_list */

   pnode2 = pvalue->choice_list.tail;
   while (0 != pnode2) {
      ll = asn1E_TransformType_element (pctxt, ((TransformType_element*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode algorithm */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->algorithm, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TransformType (OSCTXT* pctxt, TransformType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" Algorithm=\""), 12);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->algorithm, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   /* encode choice_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   { OSRTDListNode* pnode = pvalue->choice_list.head;
   while (0 != pnode) {
      stat = XmlEnc_TransformType_element (pctxt, 
         ((TransformType_element*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Transform                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Transform (OSCTXT* pctxt,
   Transform *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_TransformType (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Transform (OSCTXT* pctxt, Transform* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_TransformType (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  TransformsType                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_TransformsType (OSCTXT* pctxt,
   TransformsType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode transform_list */

   if (!(pvalue->transform_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TransformsType.transform_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->transform_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->transform_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Transform (pctxt, ((Transform*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_TransformsType (OSCTXT* pctxt, TransformsType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   /* encode transform_list */

   if (!(pvalue->transform_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "TransformsType.transform_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->transform_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   { OSRTDListNode* pnode = pvalue->transform_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Transform (pctxt, ((Transform*)pnode->data)
         , OSUTF8("Transform"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Transforms                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Transforms (OSCTXT* pctxt,
   Transforms *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_TransformsType (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Transforms (OSCTXT* pctxt, Transforms* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_TransformsType (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DigestMethodType                                          */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DigestMethodType (OSCTXT* pctxt,
   DigestMethodType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode elem_list */

   pnode2 = pvalue->elem_list.tail;
   while (0 != pnode2) {
      switch (((OSXSDAny*)pnode2->data)->t) {
      case OSXSDAny_binary:
         ll = xe_OpenType (pctxt, ((OSXSDAny*)pnode2->data)->u.binary->data, 
            ((OSXSDAny*)pnode2->data)->u.binary->numocts);
         break;
      case OSXSDAny_xmlText:
         ll = xe_utf8str (pctxt, ((OSXSDAny*)pnode2->data)->
            u.xmlText, ASN1EXPL);
         break;
      }
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      else ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode algorithm */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->algorithm, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DigestMethodType (OSCTXT* pctxt, DigestMethodType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" Algorithm=\""), 12);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->algorithm, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   /* encode elem_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   { OSRTDListNode* pnode = pvalue->elem_list.head;
   while (0 != pnode) {
      if (((OSXSDAny*)pnode->data)->t == OSXSDAny_xmlText) {
         stat = rtXmlEncAnyStr (pctxt, ((OSXSDAny*)pnode->data)->u.xmlText
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         char buf[40];
         os_snprintf (buf, 40, "%d", ((OSXSDAny*)pnode->data)->t);
         rtxErrAddStrParm (pctxt, buf);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DigestMethod                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DigestMethod (OSCTXT* pctxt,
   DigestMethod *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_DigestMethodType (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_DigestMethod (OSCTXT* pctxt, DigestMethod* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_DigestMethodType (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DigestValueType                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DigestValueType (OSCTXT* pctxt,
   DigestValueType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_octstr (pctxt, pvalue->data, pvalue->numocts, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_DigestValueType (OSCTXT* pctxt, DigestValueType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncBase64Binary
      (pctxt, pvalue->numocts, pvalue->data, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DigestValue                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DigestValue (OSCTXT* pctxt,
   DigestValue *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_DigestValueType (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_DigestValue (OSCTXT* pctxt, DigestValue* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_DigestValueType (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ReferenceType                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ReferenceType (OSCTXT* pctxt,
   ReferenceType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode digestValue */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
      asn1E_DigestValue (pctxt, &pvalue->digestValue, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode digestMethod */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
      asn1E_DigestMethod (pctxt, &pvalue->digestMethod, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode transforms */

   if (pvalue->m.transformsPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_Transforms (pctxt, &pvalue->transforms, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode uRI */

   if (pvalue->m.uRIPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->uRI, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode type */

   if (pvalue->m.typePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->type, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ReferenceType (OSCTXT* pctxt, ReferenceType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" Id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.typePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" Type=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->type, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.uRIPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" URI=\""), 6);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->uRI, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   /* encode transforms */

   if (pvalue->m.transformsPresent) {
      stat = XmlEnc_Transforms (pctxt, &pvalue->transforms
         , OSUTF8("Transforms"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode digestMethod */

   stat = XmlEnc_DigestMethod (pctxt, &pvalue->digestMethod
      , OSUTF8("DigestMethod"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode digestValue */

   stat = XmlEnc_DigestValue (pctxt, &pvalue->digestValue
      , OSUTF8("DigestValue"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Reference                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Reference (OSCTXT* pctxt,
   Reference *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_ReferenceType (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Reference (OSCTXT* pctxt, Reference* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_ReferenceType (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SignedInfoType                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SignedInfoType (OSCTXT* pctxt,
   SignedInfoType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode reference_list */

   if (!(pvalue->reference_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SignedInfoType.reference_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->reference_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->reference_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Reference (pctxt, ((Reference*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode signatureMethod */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_SignatureMethod (pctxt, &pvalue->signatureMethod, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode canonicalizationMethod */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_CanonicalizationMethod (pctxt, &pvalue->canonicalizationMethod, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SignedInfoType (OSCTXT* pctxt, SignedInfoType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" Id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   /* encode canonicalizationMethod */

   stat = XmlEnc_CanonicalizationMethod (pctxt, &pvalue->canonicalizationMethod
      , OSUTF8("CanonicalizationMethod"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode signatureMethod */

   stat = XmlEnc_SignatureMethod (pctxt, &pvalue->signatureMethod
      , OSUTF8("SignatureMethod"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode reference_list */

   if (!(pvalue->reference_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SignedInfoType.reference_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->reference_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   { OSRTDListNode* pnode = pvalue->reference_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Reference (pctxt, ((Reference*)pnode->data)
         , OSUTF8("Reference"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SignedInfo                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SignedInfo (OSCTXT* pctxt,
   SignedInfo *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_SignedInfoType (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_SignedInfo (OSCTXT* pctxt, SignedInfo* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_SignedInfoType (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SignatureValueType                                        */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SignatureValueType (OSCTXT* pctxt,
   SignatureValueType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode base */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_octstr (pctxt, pvalue->base.data, pvalue->base.numocts, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SignatureValueType (OSCTXT* pctxt, SignatureValueType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" Id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   /* encode base */

   stat = rtXmlEncBase64Binary
      (pctxt, pvalue->base.numocts, pvalue->base.data, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SignatureValue                                            */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SignatureValue (OSCTXT* pctxt,
   SignatureValue *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_SignatureValueType (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_SignatureValue (OSCTXT* pctxt, SignatureValue* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_SignatureValueType (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  KeyName                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_KeyName (OSCTXT* pctxt,
   KeyName pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_utf8str (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_KeyName (OSCTXT* pctxt, KeyName value, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt, value, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  KeyValueType_embed_values                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_KeyValueType_embed_values (OSCTXT* pctxt,
   KeyValueType_embed_values *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   pnode = pvalue->tail;
   while (0 != pnode) {
      ll = xe_utf8str (pctxt, ((const OSUTF8CHAR*)pnode->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode = pnode->prev;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_KeyValueType_embed_values (OSCTXT* pctxt, 
   KeyValueType_embed_values* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = rtXmlEncUTF8Str (pctxt, ((const OSUTF8CHAR*)pnode->data)
         , OSUTF8(""), 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  CryptoBinary                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_CryptoBinary (OSCTXT* pctxt,
   CryptoBinary *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_octstr (pctxt, pvalue->data, pvalue->numocts, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_CryptoBinary (OSCTXT* pctxt, CryptoBinary* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncBase64Binary
      (pctxt, pvalue->numocts, pvalue->data, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DSAKeyValueType_sequence                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DSAKeyValueType_sequence (OSCTXT* pctxt,
   DSAKeyValueType_sequence *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode q */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_CryptoBinary (pctxt, &pvalue->q, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode p */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_CryptoBinary (pctxt, &pvalue->p, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DSAKeyValueType_sequence (OSCTXT* pctxt, 
   DSAKeyValueType_sequence* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   /* encode p */

   stat = XmlEnc_CryptoBinary (pctxt, &pvalue->p, OSUTF8("P"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode q */

   stat = XmlEnc_CryptoBinary (pctxt, &pvalue->q, OSUTF8("Q"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DSAKeyValueType_sequence_1                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DSAKeyValueType_sequence_1 (OSCTXT* pctxt,
   DSAKeyValueType_sequence_1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode pgenCounter */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_CryptoBinary (pctxt, &pvalue->pgenCounter, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode seed */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_CryptoBinary (pctxt, &pvalue->seed, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DSAKeyValueType_sequence_1 (OSCTXT* pctxt, 
   DSAKeyValueType_sequence_1* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   /* encode seed */

   stat = XmlEnc_CryptoBinary (pctxt, &pvalue->seed
      , OSUTF8("Seed"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode pgenCounter */

   stat = XmlEnc_CryptoBinary (pctxt, &pvalue->pgenCounter
      , OSUTF8("PgenCounter"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DSAKeyValueType                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DSAKeyValueType (OSCTXT* pctxt,
   DSAKeyValueType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode sequence_1 */

   if (pvalue->m.sequence_1Present) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_DSAKeyValueType_sequence_1 (pctxt, &pvalue->sequence_1, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode j */

   if (pvalue->m.jPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         asn1E_CryptoBinary (pctxt, &pvalue->j, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode y */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
      asn1E_CryptoBinary (pctxt, &pvalue->y, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode g */

   if (pvalue->m.gPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         asn1E_CryptoBinary (pctxt, &pvalue->g, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode sequence */

   if (pvalue->m.sequencePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_DSAKeyValueType_sequence (pctxt, &pvalue->sequence, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_DSAKeyValueType (OSCTXT* pctxt, DSAKeyValueType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   /* encode sequence */

   if (pvalue->m.sequencePresent) {
      stat = XmlEnc_DSAKeyValueType_sequence (pctxt, &pvalue->sequence
         , OSUTF8(""), 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode g */

   if (pvalue->m.gPresent) {
      stat = XmlEnc_CryptoBinary (pctxt, &pvalue->g, OSUTF8("G"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode y */

   stat = XmlEnc_CryptoBinary (pctxt, &pvalue->y, OSUTF8("Y"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode j */

   if (pvalue->m.jPresent) {
      stat = XmlEnc_CryptoBinary (pctxt, &pvalue->j, OSUTF8("J"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode sequence_1 */

   if (pvalue->m.sequence_1Present) {
      stat = XmlEnc_DSAKeyValueType_sequence_1 (pctxt, &pvalue->sequence_1
         , OSUTF8(""), 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  DSAKeyValue                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_DSAKeyValue (OSCTXT* pctxt,
   DSAKeyValue *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_DSAKeyValueType (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_DSAKeyValue (OSCTXT* pctxt, DSAKeyValue* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_DSAKeyValueType (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RSAKeyValueType                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RSAKeyValueType (OSCTXT* pctxt,
   RSAKeyValueType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode exponent */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      asn1E_CryptoBinary (pctxt, &pvalue->exponent, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode modulus */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      asn1E_CryptoBinary (pctxt, &pvalue->modulus, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_RSAKeyValueType (OSCTXT* pctxt, RSAKeyValueType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   /* encode modulus */

   stat = XmlEnc_CryptoBinary (pctxt, &pvalue->modulus
      , OSUTF8("Modulus"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode exponent */

   stat = XmlEnc_CryptoBinary (pctxt, &pvalue->exponent
      , OSUTF8("Exponent"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RSAKeyValue                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RSAKeyValue (OSCTXT* pctxt,
   RSAKeyValue *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_RSAKeyValueType (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_RSAKeyValue (OSCTXT* pctxt, RSAKeyValue* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_RSAKeyValueType (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  KeyValueType_choice                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_KeyValueType_choice (OSCTXT* pctxt,
   KeyValueType_choice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_DSAKeyValue (pctxt, pvalue->u.dSAKeyValue, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_RSAKeyValue (pctxt, pvalue->u.rSAKeyValue, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         switch (pvalue->u.elem.t) {
         case OSXSDAny_binary:
            ll = xe_OpenType (pctxt, pvalue->u.elem.u.binary->data, pvalue->
               u.elem.u.binary->numocts);
            break;
         case OSXSDAny_xmlText:
            ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
               xe_utf8str (pctxt, pvalue->u.elem.u.xmlText, ASN1IMPL));
            break;
         }
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_KeyValueType_choice (OSCTXT* pctxt, KeyValueType_choice* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   switch (pvalue->t)
   {
      case 1:
         /* encode dSAKeyValue */

         stat = XmlEnc_DSAKeyValue (pctxt, pvalue->u.dSAKeyValue
            , OSUTF8("DSAKeyValue"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode rSAKeyValue */

         stat = XmlEnc_RSAKeyValue (pctxt, pvalue->u.rSAKeyValue
            , OSUTF8("RSAKeyValue"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode elem */

         if (pvalue->u.elem.t == OSXSDAny_xmlText) {
            stat = rtXmlEncAnyStr (pctxt, pvalue->u.elem.u.xmlText
               , OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
         }
         else {
            char buf[40];
            os_snprintf (buf, 40, "%d", pvalue->u.elem.t);
            rtxErrAddStrParm (pctxt, buf);
            return LOG_RTERR (pctxt, RTERR_INVOPT);
         }

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  KeyValueType                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_KeyValueType (OSCTXT* pctxt,
   KeyValueType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode choice */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_KeyValueType_choice (pctxt, &pvalue->choice, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode embed_values */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      asn1E_KeyValueType_embed_values (pctxt, &pvalue->embed_values, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_KeyValueType (OSCTXT* pctxt, KeyValueType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   /* encode embed_values */

   stat = XmlEnc_KeyValueType_embed_values (pctxt, &pvalue->embed_values
      , 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode choice */

   stat = XmlEnc_KeyValueType_choice (pctxt, &pvalue->choice, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  KeyValue                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_KeyValue (OSCTXT* pctxt,
   KeyValue *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_KeyValueType (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_KeyValue (OSCTXT* pctxt, KeyValue* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_KeyValueType (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RetrievalMethodType                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RetrievalMethodType (OSCTXT* pctxt,
   RetrievalMethodType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode transforms */

   if (pvalue->m.transformsPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_Transforms (pctxt, &pvalue->transforms, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode uRI */

   if (pvalue->m.uRIPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->uRI, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode type */

   if (pvalue->m.typePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->type, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_RetrievalMethodType (OSCTXT* pctxt, RetrievalMethodType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.typePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" Type=\""), 7);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->type, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.uRIPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" URI=\""), 6);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->uRI, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   /* encode transforms */

   if (pvalue->m.transformsPresent) {
      stat = XmlEnc_Transforms (pctxt, &pvalue->transforms
         , OSUTF8("Transforms"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  RetrievalMethod                                           */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_RetrievalMethod (OSCTXT* pctxt,
   RetrievalMethod *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_RetrievalMethodType (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_RetrievalMethod (OSCTXT* pctxt, RetrievalMethod* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_RetrievalMethodType (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  X509IssuerSerialType                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_X509IssuerSerialType (OSCTXT* pctxt,
   X509IssuerSerialType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode x509SerialNumber */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_integer (pctxt, &pvalue->x509SerialNumber, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode x509IssuerName */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_utf8str (pctxt, pvalue->x509IssuerName, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_X509IssuerSerialType (OSCTXT* pctxt, X509IssuerSerialType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   /* encode x509IssuerName */

   stat = rtXmlEncUTF8Str (pctxt, pvalue->x509IssuerName
      , OSUTF8("X509IssuerName"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode x509SerialNumber */

   stat = rtXmlEncInt (pctxt, pvalue->x509SerialNumber
      , OSUTF8("X509SerialNumber"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  X509DataType__choice1                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_X509DataType__choice1 (OSCTXT* pctxt,
   X509DataType__choice1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_X509IssuerSerialType (pctxt, pvalue->u.x509IssuerSerial, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
            xe_octstr (pctxt, pvalue->u.x509SKI->data, pvalue->u.x509SKI->numocts, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
            xe_utf8str (pctxt, pvalue->u.x509SubjectName, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 4:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
            xe_octstr (pctxt, pvalue->u.x509Certificate->data, pvalue->u.x509Certificate->numocts, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 5:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
            xe_octstr (pctxt, pvalue->u.x509CRL->data, pvalue->u.x509CRL->numocts, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 6:
         switch (pvalue->u.elem.t) {
         case OSXSDAny_binary:
            ll = xe_OpenType (pctxt, pvalue->u.elem.u.binary->data, pvalue->
               u.elem.u.binary->numocts);
            break;
         case OSXSDAny_xmlText:
            ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
               xe_utf8str (pctxt, pvalue->u.elem.u.xmlText, ASN1IMPL));
            break;
         }
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   if (tagging == ASN1EXPL) {
      ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
      if (ll1 < 0) return LOG_RTERR (pctxt, ll1);
   }

   ll0 += ll1;

   return (ll0);
}

int XmlEnc_X509DataType__choice1 (OSCTXT* pctxt, 
   X509DataType__choice1* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   switch (pvalue->t)
   {
      case 1:
         /* encode x509IssuerSerial */

         stat = XmlEnc_X509IssuerSerialType (pctxt, pvalue->u.x509IssuerSerial
            , OSUTF8("X509IssuerSerial"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode x509SKI */

         stat = rtXmlEncBase64Binary
            (pctxt, pvalue->u.x509SKI->numocts, pvalue->u.x509SKI->data, 
               OSUTF8("X509SKI"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode x509SubjectName */

         stat = rtXmlEncUTF8Str (pctxt, pvalue->u.x509SubjectName
            , OSUTF8("X509SubjectName"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 4:
         /* encode x509Certificate */

         stat = rtXmlEncBase64Binary
            (pctxt, pvalue->u.x509Certificate->numocts, pvalue->
               u.x509Certificate->data, OSUTF8("X509Certificate"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 5:
         /* encode x509CRL */

         stat = rtXmlEncBase64Binary
            (pctxt, pvalue->u.x509CRL->numocts, pvalue->u.x509CRL->data, 
               OSUTF8("X509CRL"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 6:
         /* encode elem */

         if (pvalue->u.elem.t == OSXSDAny_xmlText) {
            stat = rtXmlEncAnyStr (pctxt, pvalue->u.elem.u.xmlText
               , OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
         }
         else {
            char buf[40];
            os_snprintf (buf, 40, "%d", pvalue->u.elem.t);
            rtxErrAddStrParm (pctxt, buf);
            return LOG_RTERR (pctxt, RTERR_INVOPT);
         }

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  X509DataType                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_X509DataType (OSCTXT* pctxt,
   X509DataType *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "X509DataType.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_X509DataType__choice1 (pctxt, ((X509DataType__choice1*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_X509DataType (OSCTXT* pctxt, X509DataType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "X509DataType.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_X509DataType__choice1 (pctxt, 
         ((X509DataType__choice1*)pnode->data), OSUTF8("_choice1"), 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  X509Data                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_X509Data (OSCTXT* pctxt,
   X509Data *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_X509DataType (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_X509Data (OSCTXT* pctxt, X509Data* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_X509DataType (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PGPDataType_sequence                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PGPDataType_sequence (OSCTXT* pctxt,
   PGPDataType_sequence *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode elem_list */

   pnode2 = pvalue->elem_list.tail;
   while (0 != pnode2) {
      switch (((OSXSDAny*)pnode2->data)->t) {
      case OSXSDAny_binary:
         ll = xe_OpenType (pctxt, ((OSXSDAny*)pnode2->data)->u.binary->data, 
            ((OSXSDAny*)pnode2->data)->u.binary->numocts);
         break;
      case OSXSDAny_xmlText:
         ll = xe_utf8str (pctxt, ((OSXSDAny*)pnode2->data)->
            u.xmlText, ASN1EXPL);
         break;
      }
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      else ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode pGPKeyPacket */

   if (pvalue->m.pGPKeyPacketPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_octstr (pctxt, pvalue->pGPKeyPacket.data, pvalue->pGPKeyPacket.numocts, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode pGPKeyID */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_octstr (pctxt, pvalue->pGPKeyID.data, pvalue->pGPKeyID.numocts, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PGPDataType_sequence (OSCTXT* pctxt, PGPDataType_sequence* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   /* encode pGPKeyID */

   stat = rtXmlEncBase64Binary
      (pctxt, pvalue->pGPKeyID.numocts, pvalue->pGPKeyID.data, 
         OSUTF8("PGPKeyID"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode pGPKeyPacket */

   if (pvalue->m.pGPKeyPacketPresent) {
      stat = rtXmlEncBase64Binary
         (pctxt, pvalue->pGPKeyPacket.numocts, pvalue->pGPKeyPacket.data, 
            OSUTF8("PGPKeyPacket"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode elem_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   { OSRTDListNode* pnode = pvalue->elem_list.head;
   while (0 != pnode) {
      if (((OSXSDAny*)pnode->data)->t == OSXSDAny_xmlText) {
         stat = rtXmlEncAnyStr (pctxt, ((OSXSDAny*)pnode->data)->u.xmlText
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         char buf[40];
         os_snprintf (buf, 40, "%d", ((OSXSDAny*)pnode->data)->t);
         rtxErrAddStrParm (pctxt, buf);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PGPDataType_sequence_1                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PGPDataType_sequence_1 (OSCTXT* pctxt,
   PGPDataType_sequence_1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode elem_list */

   pnode2 = pvalue->elem_list.tail;
   while (0 != pnode2) {
      switch (((OSXSDAny*)pnode2->data)->t) {
      case OSXSDAny_binary:
         ll = xe_OpenType (pctxt, ((OSXSDAny*)pnode2->data)->u.binary->data, 
            ((OSXSDAny*)pnode2->data)->u.binary->numocts);
         break;
      case OSXSDAny_xmlText:
         ll = xe_utf8str (pctxt, ((OSXSDAny*)pnode2->data)->
            u.xmlText, ASN1EXPL);
         break;
      }
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      else ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode pGPKeyPacket */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_octstr (pctxt, pvalue->pGPKeyPacket.data, pvalue->pGPKeyPacket.numocts, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_PGPDataType_sequence_1 (OSCTXT* pctxt, 
   PGPDataType_sequence_1* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   /* encode pGPKeyPacket */

   stat = rtXmlEncBase64Binary
      (pctxt, pvalue->pGPKeyPacket.numocts, pvalue->pGPKeyPacket.data, 
         OSUTF8("PGPKeyPacket"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode elem_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   { OSRTDListNode* pnode = pvalue->elem_list.head;
   while (0 != pnode) {
      if (((OSXSDAny*)pnode->data)->t == OSXSDAny_xmlText) {
         stat = rtXmlEncAnyStr (pctxt, ((OSXSDAny*)pnode->data)->u.xmlText
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         char buf[40];
         os_snprintf (buf, 40, "%d", ((OSXSDAny*)pnode->data)->t);
         rtxErrAddStrParm (pctxt, buf);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PGPDataType                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PGPDataType (OSCTXT* pctxt,
   PGPDataType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_PGPDataType_sequence (pctxt, pvalue->u.sequence, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_PGPDataType_sequence_1 (pctxt, pvalue->u.sequence_1, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   if (tagging == ASN1EXPL) {
      ll1 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll1);
      if (ll1 < 0) return LOG_RTERR (pctxt, ll1);
   }

   ll0 += ll1;

   return (ll0);
}

int XmlEnc_PGPDataType (OSCTXT* pctxt, PGPDataType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   switch (pvalue->t)
   {
      case 1:
         /* encode sequence */

         stat = XmlEnc_PGPDataType_sequence (pctxt, pvalue->u.sequence
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode sequence_1 */

         stat = XmlEnc_PGPDataType_sequence_1 (pctxt, pvalue->u.sequence_1
            , OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  PGPData                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_PGPData (OSCTXT* pctxt,
   PGPData *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_PGPDataType (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_PGPData (OSCTXT* pctxt, PGPData* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_PGPDataType (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SPKIDataType_element                                      */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SPKIDataType_element (OSCTXT* pctxt,
   SPKIDataType_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode elem */

   if (pvalue->m.elemPresent) {
      switch (pvalue->elem.t) {
      case OSXSDAny_binary:
         ll = xe_OpenType (pctxt, pvalue->elem.u.binary->data, pvalue->elem.
            u.binary->numocts);
         break;
      case OSXSDAny_xmlText:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
            xe_utf8str (pctxt, pvalue->elem.u.xmlText, ASN1IMPL));
         break;
      }
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      else ll1 += ll;
   }
   /* encode sPKISexp */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_octstr (pctxt, pvalue->sPKISexp.data, pvalue->sPKISexp.numocts, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SPKIDataType_element (OSCTXT* pctxt, SPKIDataType_element* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   /* encode sPKISexp */

   stat = rtXmlEncBase64Binary
      (pctxt, pvalue->sPKISexp.numocts, pvalue->sPKISexp.data, 
         OSUTF8("SPKISexp"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode elem */

   if (pvalue->m.elemPresent) {
      if (pvalue->elem.t == OSXSDAny_xmlText) {
         stat = rtXmlEncAnyStr (pctxt, pvalue->elem.u.xmlText, OSUTF8(""), 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->elem.t);
         rtxErrAddStrParm (pctxt, buf);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SPKIDataType                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SPKIDataType (OSCTXT* pctxt,
   SPKIDataType *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SPKIDataType.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode1 = pvalue->tail;
   while (0 != pnode1) {
      ll = asn1E_SPKIDataType_element (pctxt, ((SPKIDataType_element*)pnode1->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      pnode1 = pnode1->prev;
   }
   ll1 = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0, ll1);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SPKIDataType (OSCTXT* pctxt, SPKIDataType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (!(pvalue->count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SPKIDataType.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   if (elemName != 0) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   { OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      stat = XmlEnc_SPKIDataType_element (pctxt, 
         ((SPKIDataType_element*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SPKIData                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SPKIData (OSCTXT* pctxt,
   SPKIData *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_SPKIDataType (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_SPKIData (OSCTXT* pctxt, SPKIData* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_SPKIDataType (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  MgmtData                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_MgmtData (OSCTXT* pctxt,
   MgmtData pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_utf8str (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_MgmtData (OSCTXT* pctxt, MgmtData value, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = rtXmlEncUTF8Str (pctxt, value, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  KeyInfoType_element                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_KeyInfoType_element (OSCTXT* pctxt,
   KeyInfoType_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            asn1E_KeyName (pctxt, pvalue->u.keyName, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 2:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_KeyValue (pctxt, pvalue->u.keyValue, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 3:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_RetrievalMethod (pctxt, pvalue->u.retrievalMethod, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 4:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
            asn1E_X509Data (pctxt, pvalue->u.x509Data, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 5:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
            asn1E_PGPData (pctxt, pvalue->u.pGPData, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 6:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
            asn1E_SPKIData (pctxt, pvalue->u.sPKIData, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 7:
         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
            asn1E_MgmtData (pctxt, pvalue->u.mgmtData, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;
         break;

      case 8:
         switch (pvalue->u.elem.t) {
         case OSXSDAny_binary:
            ll = xe_OpenType (pctxt, pvalue->u.elem.u.binary->data, pvalue->
               u.elem.u.binary->numocts);
            break;
         case OSXSDAny_xmlText:
            ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
               xe_utf8str (pctxt, pvalue->u.elem.u.xmlText, ASN1IMPL));
            break;
         }
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_KeyInfoType_element (OSCTXT* pctxt, KeyInfoType_element* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   switch (pvalue->t)
   {
      case 1:
         /* encode keyName */

         stat = XmlEnc_KeyName (pctxt, pvalue->u.keyName
            , OSUTF8("KeyName"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 2:
         /* encode keyValue */

         stat = XmlEnc_KeyValue (pctxt, pvalue->u.keyValue
            , OSUTF8("KeyValue"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 3:
         /* encode retrievalMethod */

         stat = XmlEnc_RetrievalMethod (pctxt, pvalue->u.retrievalMethod
            , OSUTF8("RetrievalMethod"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 4:
         /* encode x509Data */

         stat = XmlEnc_X509Data (pctxt, pvalue->u.x509Data
            , OSUTF8("X509Data"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 5:
         /* encode pGPData */

         stat = XmlEnc_PGPData (pctxt, pvalue->u.pGPData
            , OSUTF8("PGPData"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 6:
         /* encode sPKIData */

         stat = XmlEnc_SPKIData (pctxt, pvalue->u.sPKIData
            , OSUTF8("SPKIData"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 7:
         /* encode mgmtData */

         stat = XmlEnc_MgmtData (pctxt, pvalue->u.mgmtData
            , OSUTF8("MgmtData"), nsPrefix);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         break;

      case 8:
         /* encode elem */

         if (pvalue->u.elem.t == OSXSDAny_xmlText) {
            stat = rtXmlEncAnyStr (pctxt, pvalue->u.elem.u.xmlText
               , OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
         }
         else {
            char buf[40];
            os_snprintf (buf, 40, "%d", pvalue->u.elem.t);
            rtxErrAddStrParm (pctxt, buf);
            return LOG_RTERR (pctxt, RTERR_INVOPT);
         }

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  KeyInfoType                                               */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_KeyInfoType (OSCTXT* pctxt,
   KeyInfoType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode choice_list */

   if (!(pvalue->choice_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "KeyInfoType.choice_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->choice_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->choice_list.tail;
   while (0 != pnode2) {
      ll = asn1E_KeyInfoType_element (pctxt, ((KeyInfoType_element*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_KeyInfoType (OSCTXT* pctxt, KeyInfoType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" Id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   /* encode choice_list */

   if (!(pvalue->choice_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "KeyInfoType.choice_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->choice_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   { OSRTDListNode* pnode = pvalue->choice_list.head;
   while (0 != pnode) {
      stat = XmlEnc_KeyInfoType_element (pctxt, 
         ((KeyInfoType_element*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  KeyInfo                                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_KeyInfo (OSCTXT* pctxt,
   KeyInfo *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_KeyInfoType (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_KeyInfo (OSCTXT* pctxt, KeyInfo* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_KeyInfoType (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ObjectType                                                */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ObjectType (OSCTXT* pctxt,
   ObjectType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode sequence_list */

   pnode2 = pvalue->sequence_list.tail;
   while (0 != pnode2) {
      switch (((OSXSDAny*)pnode2->data)->t) {
      case OSXSDAny_binary:
         ll = xe_OpenType (pctxt, ((OSXSDAny*)pnode2->data)->u.binary->data, 
            ((OSXSDAny*)pnode2->data)->u.binary->numocts);
         break;
      case OSXSDAny_xmlText:
         ll = xe_utf8str (pctxt, ((OSXSDAny*)pnode2->data)->
            u.xmlText, ASN1EXPL);

         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0, ll);
         if (ll < 0) return LOG_RTERR (pctxt, ll);

         ll = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         break;
      }
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      else ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode mimeType */

   if (pvalue->m.mimeTypePresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_utf8str (pctxt, pvalue->mimeType, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode encoding */

   if (pvalue->m.encodingPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->encoding, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ObjectType (OSCTXT* pctxt, ObjectType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.encodingPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" Encoding=\""), 11);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->encoding, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" Id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   if (pvalue->m.mimeTypePresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" MimeType=\""), 11);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->mimeType, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   /* encode sequence_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   { OSRTDListNode* pnode = pvalue->sequence_list.head;
   while (0 != pnode) {
      if (((OSXSDAny*)pnode->data)->t == OSXSDAny_xmlText) {
         stat = rtXmlEncAnyStr (pctxt, ((OSXSDAny*)pnode->data)->u.xmlText
            , 0, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         char buf[40];
         os_snprintf (buf, 40, "%d", ((OSXSDAny*)pnode->data)->t);
         rtxErrAddStrParm (pctxt, buf);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Object                                                    */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Object (OSCTXT* pctxt,
   Object *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_ObjectType (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Object (OSCTXT* pctxt, Object* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_ObjectType (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SignatureType                                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SignatureType (OSCTXT* pctxt,
   SignatureType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode object_list */

   pnode2 = pvalue->object_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Object (pctxt, ((Object*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode keyInfo */

   if (pvalue->m.keyInfoPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_KeyInfo (pctxt, &pvalue->keyInfo, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   /* encode signatureValue */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
      asn1E_SignatureValue (pctxt, &pvalue->signatureValue, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode signedInfo */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_SignedInfo (pctxt, &pvalue->signedInfo, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SignatureType (OSCTXT* pctxt, SignatureType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" Id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   /* encode signedInfo */

   stat = XmlEnc_SignedInfo (pctxt, &pvalue->signedInfo
      , OSUTF8("SignedInfo"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode signatureValue */

   stat = XmlEnc_SignatureValue (pctxt, &pvalue->signatureValue
      , OSUTF8("SignatureValue"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode keyInfo */

   if (pvalue->m.keyInfoPresent) {
      stat = XmlEnc_KeyInfo (pctxt, &pvalue->keyInfo
         , OSUTF8("KeyInfo"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   /* encode object_list */

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   { OSRTDListNode* pnode = pvalue->object_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Object (pctxt, ((Object*)pnode->data)
         , OSUTF8("Object"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Signature                                                 */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Signature (OSCTXT* pctxt,
   Signature *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_SignatureType (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Signature (OSCTXT* pctxt, Signature* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_SignatureType (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  ManifestType                                              */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_ManifestType (OSCTXT* pctxt,
   ManifestType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode reference_list */

   if (!(pvalue->reference_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ManifestType.reference_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->reference_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->reference_list.tail;
   while (0 != pnode2) {
      ll = asn1E_Reference (pctxt, ((Reference*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_ManifestType (OSCTXT* pctxt, ManifestType* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" Id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   /* encode reference_list */

   if (!(pvalue->reference_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "ManifestType.reference_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->reference_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   { OSRTDListNode* pnode = pvalue->reference_list.head;
   while (0 != pnode) {
      stat = XmlEnc_Reference (pctxt, ((Reference*)pnode->data)
         , OSUTF8("Reference"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  Manifest                                                  */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_Manifest (OSCTXT* pctxt,
   Manifest *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_ManifestType (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_Manifest (OSCTXT* pctxt, Manifest* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_ManifestType (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SignaturePropertyType_element                             */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SignaturePropertyType_element (OSCTXT* pctxt,
   SignaturePropertyType_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         switch (pvalue->u.elem.t) {
         case OSXSDAny_binary:
            ll = xe_OpenType (pctxt, pvalue->u.elem.u.binary->data, pvalue->
               u.elem.u.binary->numocts);
            break;
         case OSXSDAny_xmlText:
            ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
               xe_utf8str (pctxt, pvalue->u.elem.u.xmlText, ASN1IMPL));
            break;
         }
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         else ll1 += ll;
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

int XmlEnc_SignaturePropertyType_element (OSCTXT* pctxt, 
   SignaturePropertyType_element* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, TRUE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   switch (pvalue->t)
   {
      case 1:
         /* encode elem */

         if (pvalue->u.elem.t == OSXSDAny_xmlText) {
            stat = rtXmlEncAnyStr (pctxt, pvalue->u.elem.u.xmlText
               , OSUTF8(""), 0);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
         }
         else {
            char buf[40];
            os_snprintf (buf, 40, "%d", pvalue->u.elem.t);
            rtxErrAddStrParm (pctxt, buf);
            return LOG_RTERR (pctxt, RTERR_INVOPT);
         }

         break;

      default: {
         char buf[40];
         os_snprintf (buf, 40, "%d", pvalue->t);
         return LOG_RTERRNEW1 (pctxt, RTERR_INVOPT, 
            rtxErrAddStrParm (pctxt, buf));
      }
   }
   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SignaturePropertyType                                     */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SignaturePropertyType (OSCTXT* pctxt,
   SignaturePropertyType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode choice_list */

   if (!(pvalue->choice_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SignaturePropertyType.choice_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->choice_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->choice_list.tail;
   while (0 != pnode2) {
      ll = asn1E_SignaturePropertyType_element (pctxt, ((SignaturePropertyType_element*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode target */

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
      xe_utf8str (pctxt, pvalue->target, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SignaturePropertyType (OSCTXT* pctxt, 
   SignaturePropertyType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" Id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEMEMCPY (pctxt, OSUTF8(" Target=\""), 9);

   stat = rtXmlEncUTF8Str (pctxt, pvalue->target, 0, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSRTSAFEPUTCHAR (pctxt, '\"');

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   /* encode choice_list */

   if (!(pvalue->choice_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SignaturePropertyType.choice_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->choice_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   { OSRTDListNode* pnode = pvalue->choice_list.head;
   while (0 != pnode) {
      stat = XmlEnc_SignaturePropertyType_element (pctxt, 
         ((SignaturePropertyType_element*)pnode->data), 0, nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SignatureProperty                                         */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SignatureProperty (OSCTXT* pctxt,
   SignatureProperty *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_SignaturePropertyType (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_SignatureProperty (OSCTXT* pctxt, SignatureProperty* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_SignaturePropertyType (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SignaturePropertiesType                                   */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SignaturePropertiesType (OSCTXT* pctxt,
   SignaturePropertiesType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OSRTDListNode* pnode2;
   int ll2 = 0;

   /* encode signatureProperty_list */

   if (!(pvalue->signatureProperty_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SignaturePropertiesType.signatureProperty_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->signatureProperty_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   pnode2 = pvalue->signatureProperty_list.tail;
   while (0 != pnode2) {
      ll = asn1E_SignatureProperty (pctxt, ((SignatureProperty*)pnode2->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll2 += ll;

      pnode2 = pnode2->prev;
   }
   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1, ll2);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   else { ll1 += ll; ll2 = 0; }

   /* encode id */

   if (pvalue->m.idPresent) {
      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         xe_utf8str (pctxt, pvalue->id, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

int XmlEnc_SignaturePropertiesType (OSCTXT* pctxt, 
   SignaturePropertiesType* pvalue, const OSUTF8CHAR* elemName, 
   const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   if (0 != elemName) {
      stat = rtXmlEncStartElement (pctxt, elemName, nsPrefix, FALSE);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* add attributes */

   if (pvalue->m.idPresent) {
      OSRTSAFEMEMCPY (pctxt, OSUTF8(" Id=\""), 5);

      stat = rtXmlEncUTF8Str (pctxt, pvalue->id, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      OSRTSAFEPUTCHAR (pctxt, '\"');
   }

   OSRTSAFEPUTCHAR (pctxt, '>');
   pctxt->flags &= ~OSTERMSTART;
   pctxt->state = OSXMLSTART;

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   /* encode signatureProperty_list */

   if (!(pvalue->signatureProperty_list.count >= 1U)) {
      rtxErrAddStrParm (pctxt, "SignaturePropertiesType.signatureProperty_list.count");
      rtxErrAddIntParm (pctxt, (int)pvalue->signatureProperty_list.count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   { const OSUTF8CHAR* savedPrefix = nsPrefix;
   nsPrefix = rtXmlNSGetPrefix (pctxt, OSUTF8(
      "http://www.w3.org/2000/09/xmldsig#"));

   { OSRTDListNode* pnode = pvalue->signatureProperty_list.head;
   while (0 != pnode) {
      stat = XmlEnc_SignatureProperty (pctxt, ((SignatureProperty*)pnode->data)
         , OSUTF8("SignatureProperty"), nsPrefix);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      pnode = pnode->next;
   }}
   nsPrefix = savedPrefix;
   }

   nsPrefix = savedPrefix;
   }

   stat = rtXmlEncEndElement (pctxt, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

/**************************************************************/
/*                                                            */
/*  SignatureProperties                                       */
/*                                                            */
/**************************************************************/

EXTERN int asn1E_SignatureProperties (OSCTXT* pctxt,
   SignatureProperties *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = asn1E_SignaturePropertiesType (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

int XmlEnc_SignatureProperties (OSCTXT* pctxt, SignatureProperties* pvalue, 
   const OSUTF8CHAR* elemName, const OSUTF8CHAR* nsPrefix)
{
   int stat = 0;

   stat = XmlEnc_SignaturePropertiesType (pctxt, pvalue, elemName, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int XmlEnc_Manifest_PDU (OSCTXT* pctxt, Manifest* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   rtXmlNSSetNamespace (pctxt, OSUTF8("ds"), 
      OSUTF8("http://www.w3.org/2000/09/xmldsig#"), FALSE);

   nsPrefix = rtXmlNSGetPrefix (pctxt, 
      OSUTF8("http://www.w3.org/2000/09/xmldsig#"));

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("Manifest"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_Manifest (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("Manifest"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
int XmlEnc_SignatureProperties_PDU (OSCTXT* pctxt, SignatureProperties* pvalue)
{
   int stat;
   const OSUTF8CHAR* nsPrefix = 0;

   rtXmlNSSetNamespace (pctxt, OSUTF8("ds"), 
      OSUTF8("http://www.w3.org/2000/09/xmldsig#"), FALSE);

   nsPrefix = rtXmlNSGetPrefix (pctxt, 
      OSUTF8("http://www.w3.org/2000/09/xmldsig#"));

   stat = rtXmlEncStartDocument (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncStartElement (pctxt, OSUTF8("SignatureProperties"), nsPrefix, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncNSAttrs (pctxt);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncXSIAttrs (pctxt, FALSE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = XmlEnc_SignatureProperties (pctxt, pvalue, 0, nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtXmlEncEndElement (pctxt, OSUTF8("SignatureProperties"), nsPrefix);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return stat;
}
